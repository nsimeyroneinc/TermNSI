{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Exercices sur les bases de donn\u00e9es \u2693\ufe0e Ce site propose diff\u00e9rents exercices sur les bases de donn\u00e9e et le langage SQL . Vous y trouverez diff\u00e9rents exercices sur les th\u00e8mes suivants : \ud83d\udd28 Cr\u00e9ation de base de donn\u00e9es et insertion de valeurs (hors du programme NSI mais n\u00e9anmoins int\u00e9ressant), \ud83d\udc2d Requ\u00eates sur une seule table , \ud83d\udc08 Requ\u00eates sur plusieurs tables , \ud83d\udc2f Exemples complets . Le site n'a pas vocation \u00e0 \u00eatre un cours sur les bases de donn\u00e9es ni sur le langage SQL . Il propose simplement des exercices de r\u00e9daction d'instructions SQL dans le cadre du programme de la sp\u00e9cialit\u00e9 NSI . Notez que dans chaque section sauf la derni\u00e8re, le premier exercice propos\u00e9 pr\u00e9sente les nouvelles instructions SQL utilis\u00e9es. La derni\u00e8re section propose des exercices reprenant l'ensemble des instructions pr\u00e9sent\u00e9es dans les pr\u00e9c\u00e9dentes. Les commandes de base de SQL sont rappel\u00e9es dans le memento SQL .","title":"\ud83c\udfe1 Accueil"},{"location":"#exercices-sur-les-bases-de-donnees","text":"Ce site propose diff\u00e9rents exercices sur les bases de donn\u00e9e et le langage SQL . Vous y trouverez diff\u00e9rents exercices sur les th\u00e8mes suivants : \ud83d\udd28 Cr\u00e9ation de base de donn\u00e9es et insertion de valeurs (hors du programme NSI mais n\u00e9anmoins int\u00e9ressant), \ud83d\udc2d Requ\u00eates sur une seule table , \ud83d\udc08 Requ\u00eates sur plusieurs tables , \ud83d\udc2f Exemples complets . Le site n'a pas vocation \u00e0 \u00eatre un cours sur les bases de donn\u00e9es ni sur le langage SQL . Il propose simplement des exercices de r\u00e9daction d'instructions SQL dans le cadre du programme de la sp\u00e9cialit\u00e9 NSI . Notez que dans chaque section sauf la derni\u00e8re, le premier exercice propos\u00e9 pr\u00e9sente les nouvelles instructions SQL utilis\u00e9es. La derni\u00e8re section propose des exercices reprenant l'ensemble des instructions pr\u00e9sent\u00e9es dans les pr\u00e9c\u00e9dentes. Les commandes de base de SQL sont rappel\u00e9es dans le memento SQL .","title":"Exercices sur les bases de donn\u00e9es"},{"location":"TD11_Corrige/","text":"Th\u00e8me 1 : Structure de Donn\u00e9es 07 Les Listes - Corrig\u00e9 \ud83d\udcd8 Le Programme en N.S.I en Terminale Notre objet d\u2019\u00e9tude aujourd\u2019hui est la structure de donn\u00e9es lin\u00e9aire liste. Les objectifs de ce travail sont : de d\u00e9finir la structure de donn\u00e9es liste. Pour cela nous allons nous concentrer sur ses m\u00e9thodes, de manipuler cette structure de donn\u00e9es, d\u2019appr\u00e9hender la notion de mutabilit\u00e9 des listes (elles peuvent changer), d\u2019appr\u00e9hender la complexit\u00e9 de la manipulation des listes, de comprendre que ce qui est appel\u00e9 \\textbf{List} en Python n\u2019est pas une liste au sens commun du terme. La structure de donn\u00e9e \u2693\ufe0e Vous connaissez d\u00e9j\u00e0 la structure de liste puisque vous l\u2019avez largement utilis\u00e9e dans les programmes Python que vous avez pu \u00e9crire pr\u00e9c\u00e9demment. Vous avez cr\u00e9\u00e9 des listes, ajout\u00e9 des \u00e9l\u00e9ments, acc\u00e9d\u00e9 \u00e0 sa longueur, acc\u00e9d\u00e9 \u00e0 un \u00e9l\u00e9ment, etc. Liste Python Python abuse du terme liste qu\u2019il utilise pour ce qui sont des tableaux dynamiques munis de m\u00e9thodes d\u2019acc\u00e8s typiques des listes. Nous nous int\u00e9ressons ici \u00e0 ce que les informaticiens appellent vraiment des listes. Qu\u2019est-ce qu\u2019une liste ? \u2693\ufe0e Intuitivement. Une liste est une collection finie d\u2019\u00e9l\u00e9ments qui se suivent. C\u2019est donc une structure de donn\u00e9es lin\u00e9aire. Une liste peut contenir un nombre quelconque d\u2019\u00e9l\u00e9ments y compris nul (la liste vide). Liste Une liste est une structure de donn\u00e9es permettant de regrouper des donn\u00e9es. C'est une collection finie et ordonn\u00e9e d'\u00e9l\u00e9ments, cela signifie que chaque \u00e9l\u00e9ment d'une liste est rep\u00e9r\u00e9 par son index (sa position). A la diff\u00e9rence d'un tableau qui est de taille fixe, une liste est extensible : on peut lui ajouter des \u00e9l\u00e9ments, on peut lui retirer des \u00e9l\u00e9ments; sa taille n'est donc pas fixe. Un peu d'histoire pour commencer \u2693\ufe0e Le langage LISP, invent\u00e9 par John Mac Carthy (photo) en 1958, est un des premiers \u00e0 utiliser la notion de liste (LISP vient de l'anglais list processing signifiant \u00ab traitement de listes \u00bb). Les listes du langage LISP sont compos\u00e9es de deux parties : une t\u00eate correspondant au premier \u00e9l\u00e9ment de la liste une queue correspondant au reste de la liste On pouvait alors construire une liste \u00e0 partir d'un premier \u00e9l\u00e9ment (sa t\u00eate) et d'une liste (sa queue). Obtenir une d\u00e9finition formelle \u2693\ufe0e Prenons une liste comme par exemple \\(L_1=[5,3,8]\\) . C\u2019est une liste \u00e0 trois \u00e9l\u00e9ments (ou de longueur trois) dont le premier est 5, le deuxi\u00e8me 3, et le dernier 8. Une fa\u00e7on de d\u00e9crire cette liste consiste \u00e0 dire que la liste \\(L_1\\) poss\u00e8de un premier \u00e9l\u00e9ment 5 qu\u2019on nommera \u00e9l\u00e9ment de t\u00eate, et que vient apr\u00e8s cet \u00e9l\u00e9ment de t\u00eate la liste \\(L_2=[3,8]\\) des \u00e9l\u00e9ments qui suivent, liste qu\u2019on nommera reste. Ce qu\u2019on vient de dire de la liste \\(L_1\\) peut \u00eatre r\u00e9p\u00e9t\u00e9 pour la liste \\(L_2\\) qui est donc constitu\u00e9e : d\u2019un \u00e9l\u00e9ment de t\u00eate : 3, et d\u2019un reste : \\(L_3=[8]\\) . \u00c0 nouveau on peut r\u00e9p\u00e9ter le m\u00eame discours pour la liste \\(L_3\\) qui est donc constitu\u00e9e : d\u2019un \u00e9l\u00e9ment de t\u00eate : 8, et d\u2019un reste : \\(L_4=[]\\) . La liste \\(L_4\\) \u00e9tant vide, elle ne poss\u00e8de pas d\u2019\u00e9l\u00e9ment de t\u00eate, et ne peut donc pas \u00eatre d\u00e9compos\u00e9e comme nous venons de le faire \u00e0 trois reprises. Si on convient d\u2019utiliser la notation \\((e,L)\\) pour d\u00e9signer le couple constitu\u00e9 de l\u2019\u00e9l\u00e9ment \\(e\\) de t\u00eate, et du reste \\(L\\) d\u2019une liste, on peut alors \u00e9crire : \\[L_1=(5,(3,(8,[])))\\] \u27a1 Repr\u00e9sentation sch\u00e9matique : Ce qui vient d\u2019\u00eatre fait pour la liste \\(L_1\\) peut \u00eatre reproduit pour n\u2019importe quelle liste. On peut conclure cette approche en donnant une d\u00e9finition abstraite et formelle des listes d\u2019\u00e9l\u00e9ments appartenant tous \u00e0 un ensemble E. Une liste d\u2019\u00e9l\u00e9ments d\u2019un ensemble E est * soit la liste vide * soit un couple \\((e,L)\\) constitu\u00e9 d\u2019un \u00e9l\u00e9ment \\(e \\in E\\) et d\u2019une liste \\(L\\) d\u2019\u00e9l\u00e9ments de E. Les listes peuvent donc \u00eatre vues comme des structures de donn\u00e9es r\u00e9cursives L'interface minimale du type abstrait Liste \u2693\ufe0e Le type abstrait Liste peut alors \u00eatre d\u00e9fini par l' interface suivante contenant 5 op\u00e9rations primitives : Des constructeurs : listevide() pour construire une liste vide construit(e,\\ L) pour construire une nouvelle liste contenant un premier \u00e9l\u00e9ment e (sa t\u00eate) et une suite L (sa queue, qui est une liste). Cet op\u00e9rateur est aussi souvent not\u00e9 cons . Des s\u00e9lecteurs : premier(L) pour acc\u00e9der au premier \u00e9l\u00e9ment de la liste L , sa t\u00eate. Cet op\u00e9rateur est aussi souvent not\u00e9 car . reste(L) pour acc\u00e9der au reste de la liste L c'est-\u00e0-dire sa queue. Cet op\u00e9rateur est aussi souvent not\u00e9 cdr . Un pr\u00e9dicat (une question dont la r\u00e9ponse est un bool\u00e9en (V/F)) : estvide(L) pour tester si une liste est vide. Ainsi, pour construire une liste form\u00e9e par les nombres 5, 3, 8 (dans cet ordre) on fait : maliste1 = construit(5, construit(3, construit(8, listevide()))) Dans ce cas, premier(maliste1) correspond \u00e0 sa t\u00eate, c'est-\u00e0-dire 5 reste(maliste1) correspondant \u00e0 sa queue, c'est-\u00e0-dire la liste correspondant \u00e0 construit(3, construit(8, listevide())) form\u00e9e des nombres 3 et 8. On sait depuis les travaux de Mac Carthy sur le langage LISP, qu'avec ces 5 op\u00e9rations on peut reconstruire toutes les op\u00e9rations sur les listes (acc\u00e9der \u00e0 un \u00e9l\u00e9ment, modifier un \u00e9l\u00e9ment, ajouter/supprimer un \u00e9l\u00e9ment, calculer la longueur, tester l'appartenance, etc.) Liste vs tableaux \u2693\ufe0e \u270f Qu\u2019est ce qui diff\u00e9rencie les listes des tableaux ? \u2693\ufe0e Tableau Sa taille est fixe, les \u00e9l\u00e8ments se suivent en m\u00e9roire. Acc\u00e9der \u00e0 son \u00e9l\u00e8ment par son indice est rapide. Liste Les \u00e9l\u00e8ments ne se suivent pas forc\u00e9ment en m\u00e9moire. La queue de la liste pointe vers une autre liste. Acc\u00e9der \u00e0 un \u00e9l\u00e8ment par son indice est lent (il faut suivre tous les liens) \u270f Insertion d'un \u00e9l\u00e8ment : \u2693\ufe0e Dans un tableau \u2693\ufe0e Tableau de taille 4 : Pour ns\u00e9rer un \u00e9l\u00e8ment il faut recr\u00e9er un tableau de taille sup\u00e9rieure Nouveau Tableau de taille 5 : Dans une liste : \u2693\ufe0e Pour ins\u00e9rer un \u00e9l\u00e8ment, c'est facile ! Liste 1. on casse le lien entre \"2\" et Liste(1,()) 2. On fait pointer la queue apr\u00e9s 5 sur Liste(1,()) 3. On fait pointer la queue apr\u00e9s 2 sur Liste(5,(1,())) C'est beaucoup plus rapide que pour les tableaux. Activit\u00e9 1 : Utiliser une interface \u2693\ufe0e On rappelle que le type abstrait Liste peut \u00eatre d\u00e9fini par l' interface suivante contenant 5 op\u00e9rations primitives : Des constructeurs : listevide() pour construire une liste vide construit(e, L) pour construire une nouvelle liste contenant un premier \u00e9l\u00e9ment e (sa t\u00eate) et une suite L (sa queue, qui est une liste). Cet op\u00e9rateur est aussi souvent not\u00e9 cons . Des s\u00e9lecteurs : premier(L) pour acc\u00e9der au premier \u00e9l\u00e9ment de la liste L , sa t\u00eate. Cet op\u00e9rateur est aussi souvent not\u00e9 car . reste(L) pour acc\u00e9der au reste de la liste L c'est-\u00e0-dire sa queue. Cet op\u00e9rateur est aussi souvent not\u00e9 cdr . Un pr\u00e9dicat : estvide(L) pour tester si une liste est vide. Question 1 : On consid\u00e8re la liste L1 suivante : L1=construit(1, contruit(3, construit(-2, construit(0, listecide())))) Quelle est la liste construite ? Que vaut chacune des variables suivantes ? \ud83d\udccb Texte e1=premier(L1) L2=reste(L1) L3=reste(reste(L1)) e2=premier(reste(reste(L1))) L4=construit(5, L3) Question 2 : \u00c9crivez les instructions permettant de : construire une liste maliste1 contenant les nombres 5, 2, 4, 7 dans cet ordre stocker dans une variable e1 le premier \u00e9l\u00e9ment de maliste1 stocker dans une variable e2 le deuxi\u00e8me \u00e9l\u00e9ment de maliste1 stocker dans une variable e3 le dernier \u00e9l\u00e9ment de maliste1 construire une liste vide appel\u00e9e maliste2 construire, \u00e0 partir de maliste1 , une liste maliste3 contenant uniquement les nombres 4 et 7. construire, uniquement \u00e0 partir des listes et variables pr\u00e9c\u00e9dentes, une liste maliste4 contenant les nombres 5, 2, 1, 4, 7 (on veut ins\u00e9rer 1 entre 2 et 4 dans liste de d\u00e9part). Impl\u00e9mentations possibles \u2693\ufe0e \u270f Une impl\u00e9mentation avec des couples en Python \u2693\ufe0e Cette premi\u00e8re impl\u00e9mentation est bas\u00e9e sur des paires (couples) qui comportent chacune un \u00e9l\u00e9ment et la suite de la liste, qui elle-m\u00eame peut \u00eatre une paire... Elle r\u00e9utilise le type tuple de Python. On d\u00e9finit ainsi notre structure de donn\u00e9es de mani\u00e8re r\u00e9cursive pour respecter la philosophie du langage LISP. Activit\u00e9 2 : \u00c9criture de quelques op\u00e9rations d\u00e9riv\u00e9es \u2693\ufe0e On consid\u00e8re toujours la m\u00eame interface (que dans l\u2019activit\u00e9 1) pour le type abstrait de donn\u00e9es Liste. Voici une impl\u00e9mentation utilisant des couples, \u00e0 compl\u00e9ter : \ud83d\udc0d Script Python def listevide (): return None # on utilise None pour une liste vide def construit ( e , L ): return ( e , L ) # renvoie un tuple de deux \u00e9l\u00e9ments def premier ( L ): return L [ 0 ] # acc\u00e8s au premier \u00e9l\u00e9ment du couple (la t\u00eate de L) def reste ( L ): return L [ 1 ] # acc\u00e8s au deuxi\u00e8me \u00e9l\u00e9ment du couple (la queue de L) def estvide ( L ): return L is None # L est \u00e9gal \u00e0 None ? On peut alors tester les instructions pr\u00e9c\u00e9dentes et en affichant le contenu de maliste1, on se rend compte de l\u2019impl\u00e9mentation choisie avec des paires imbriqu\u00e9es. \ud83d\udc0d Script Python maliste1 = construit ( 5 , construit ( 3 , construit ( 8 , listevide ()))) maliste1 \ud83d\udccb Texte (5, (3, (8, None))) On a donc logiquement : \ud83d\udc0d Script Python premier ( maliste1 ) \ud83d\udccb Texte 5 \ud83d\udc0d Script Python reste ( maliste1 ) \ud83d\udccb Texte (3, (8, None)) Avec cette impl\u00e9mentation, il est int\u00e9ressant de noter que la contruction de maliste1 avec l\u2019instruction \ud83d\udc0d Script Python construit ( 5 , construit ( 3 , construit ( 8 , listevide ()))) \ud83d\udccb Texte (5, (3, (8, None))) n\u00e9cessite la construction 3 paires interm\u00e9diaires qui sont construites de la plus imbriqu\u00e9e (liste vide) \u00e0 la moins imbriqu\u00e9e. On peut visualiser facilement cela avec Python tutor. \u270f Partie A : Utilisation des op\u00e9rations \u2693\ufe0e Question 1 : Utilisez cette impl\u00e9mentation pour v\u00e9rifier vos r\u00e9ponses \u00e0 l\u2019activit\u00e9 1. \ud83d\udc0d Script Python L1 = construit ( 1 , construit ( 3 , construit ( - 2 , construit ( 0 , listevide ())))) e1 = premier ( L1 ) print ( e1 ) L2 = reste ( L1 ) print ( L2 ) L3 = reste ( reste ( L1 )) print ( L3 ) e2 = premier ( reste ( reste ( L1 ))) print ( e2 ) L4 = construit ( 5 , L3 ) print ( L4 ) \ud83d\udccb Texte 1 (3, (-2, (0, None))) (-2, (0, None)) -2 (5, (-2, (0, None))) \u270f Partie B : Ecriture d\u2019op\u00e9rations d\u00e9riv\u00e9es \u2693\ufe0e On a vu dans le cours qu\u2019il est possible de construire toutes les op\u00e9rations \u00e0 partir des 5 op\u00e9rations primivites donn\u00e9es ci-dessus. Par exemple, pour obtenir le dernier \u00e9l\u00e9ment d\u2019une liste, on peut impl\u00e9menter l\u2019op\u00e9ration dernier(L) \u00e0 partir des autres : \ud83d\udc0d Script Python def dernier ( L ): \"\"\"Liste --> Element Pr\u00e9condition : L n\u2019est pas vide.\"\"\" assert estvide ( L ) != None L1 = L while L1 != None : dernier = premier ( L1 ) L1 = reste ( L1 ) return dernier \ud83d\udc0d Script Python L1 = construit ( 1 , construit ( 3 , construit ( - 2 , construit ( 0 , listevide ())))) dernier ( L1 ) \ud83d\udccb Texte 0 On rappelle que l\u2019on peut \u00e9crire un jeu de tests en utilisant la construction assert. \ud83d\udc0d Script Python liste1 = construit ( 2 , listevide ()) liste2 = construit ( 1 , construit ( 2 , construit ( 5 , listevide ()))) assert dernier ( liste1 ) == 2 assert dernier ( liste2 ) == 5 Question 2 : On souhaite impl\u00e9menter en une fonction l\u2019op\u00e9ration taille(L) qui renvoie le nombre d\u2019\u00e9l\u00e9ments contenus dans la liste L. 1. \u00c9crivez un jeu de tests de qualit\u00e9 pour cette fonction. 2. Proposez le code de cette fonction avec sa docstring (qui doit passer les tests avec succ\u00e8s). \ud83d\udc0d Script Python def taille ( L ): L1 = L if L1 == None : return 0 else : t = 0 while L1 != None : t += 1 L1 = reste ( L1 ) return t \ud83d\udc0d Script Python L1 = construit ( 1 , construit ( 3 , construit ( - 2 , construit ( 6 , listevide ())))) taille ( L1 ) assert taille ( L1 ) == 4 L2 = ( None ) assert taille ( L2 ) == 0 Question 3 : M\u00eames questions avec l\u2019op\u00e9ration lire(L, i) renvoie le i-\u00e8me \u00e9l\u00e9ment de la liste L. \ud83d\udc0d Script Python def lire ( L , i ): L1 = L if i > taille ( L1 ): return False else : t = 0 while t != i : t += 1 L1 = reste ( L1 ) rep = premier ( L1 ) return rep \ud83d\udc0d Script Python print ( L1 ) lire ( L1 , 2 ) lire ( L1 , 5 ) \ud83d\udccb Texte (1, (3, (-2, (6, None)))) False \u270f Une impl\u00e9mentation avec le type list de Python \u2693\ufe0e Il est possible d\u2019impl\u00e9menter les 5 op\u00e9rations d\u00e9finissant le type abstrait Liste en utilisant le type pr\u00e9- d\u00e9fini list de Python. Les fonctions sont tr\u00e8s ressemblantes \u00e0 celles utilisant les couples. Cela fait l\u2019objet des activit\u00e9s 3 et 4 qui proposent deux impl\u00e9mentations diff\u00e9rentes : - la premi\u00e8re avec copie des listes interm\u00e9diaires (comme l\u2019impl\u00e9mentation avec les couples) - la seconde avec modification de la liste en place. Activit\u00e9 3 : Une impl\u00e9mentation avec le type list de Python \u2693\ufe0e On veut maintenant impl\u00e9menter le type abstrait Liste en utilisant le type list de Python. Question 1 : Utilisez la documentation officielle pour compl\u00e9ter l\u2019impl\u00e9mentation du type Liste avec les possibilit\u00e9s offertes par le type list de Python. \ud83d\udc0d Script Python def listevide (): return [] # renvoie une liste vide def construit ( e , L ): # renvoie une liste qui est la concat\u00e9nation d\u2019une liste contenant e avec la liste L return [ e ] + L def premier ( L ): # renvoie le premier \u00e9l\u00e9ment de L return L [ 0 ] def reste ( L ): # renvoie une liste contenant les \u00e9l\u00e9ments de L \u00e0 partir de la position 1 return L [ 1 :] def dernier ( L ): return L [ - 1 ] def estvide ( L ): # renvoie True si L est vide, False sinon if L == []: return True else : return False Question 2 : V\u00e9rifiez qu\u2019en ex\u00e9cutant le code suivant, on obtient exactement le m\u00eame r\u00e9sultat qu\u2019avec la premi\u00e8re impl\u00e9mentation. L\u2019utilisateur curieux pourra cependant observer la structure des informa- tions m\u00e9moris\u00e9es en affichant les listes L1 (impl\u00e9ment\u00e9e par des couples) et L2 (impl\u00e9ment\u00e9e par le type list de Python). \ud83d\udc0d Script Python L2 = construit ( 1 , construit ( 3 , construit ( - 2 , construit ( - 3 , listevide ())))) #construction avec la nouvelle impl\u00e9mentation print ( L2 ) dernier ( L2 ) # renvoie le dernier \u00e9l\u00e9ment de la liste construite \ud83d\udccb Texte [1, 3, -2, -3] -3 Question 3 : Utilisez Python Tutor pour observer pas \u00e0 pas la construction de la liste L2 pr\u00e9c\u00e9dente. Combien de listes interm\u00e9diaires sont cr\u00e9\u00e9es pour construire la liste L2 avec cette impl\u00e9mentation ? \ud83d\udc0d Script Python","title":"TD - Les Listes - Corrig\u00e9"},{"location":"TD11_Les_Listes/","text":"TD n\u00b011 : Structures de donn\u00e9es - Listes Th\u00e8me 1 : Structures de donn\u00e9es COURS et EXERCICES \ud83d\udcd8 Le Programme en N.S.I en Terminale Notre objet d\u2019\u00e9tude aujourd\u2019hui est la structure de donn\u00e9es lin\u00e9aire liste. Les objectifs de ce travail sont : de d\u00e9finir la structure de donn\u00e9es liste. Pour cela nous allons nous concentrer sur ses m\u00e9thodes, de manipuler cette structure de donn\u00e9es, d\u2019appr\u00e9hender la notion de mutabilit\u00e9 des listes (elles peuvent changer), d\u2019appr\u00e9hender la complexit\u00e9 de la manipulation des listes, de comprendre que ce qui est appel\u00e9 \\textbf{List} en Python n\u2019est pas une liste au sens commun du terme. I. La structure de donn\u00e9e Vous connaissez d\u00e9j\u00e0 la structure de liste puisque vous l\u2019avez largement utilis\u00e9e dans les programmes Python que vous avez pu \u00e9crire pr\u00e9c\u00e9demment. Vous avez cr\u00e9\u00e9 des listes, ajout\u00e9 des \u00e9l\u00e9ments, acc\u00e9d\u00e9 \u00e0 sa longueur, acc\u00e9d\u00e9 \u00e0 un \u00e9l\u00e9ment, etc. Liste Python Python abuse du terme liste qu\u2019il utilise pour ce qui sont des tableaux dynamiques munis de m\u00e9thodes d\u2019acc\u00e8s typiques des listes. Nous nous int\u00e9ressons ici \u00e0 ce que les informaticiens appellent vraiment des listes. II. Qu\u2019est-ce qu\u2019une liste ? Intuitivement. Une liste est une collection finie d\u2019\u00e9l\u00e9ments qui se suivent. C\u2019est donc une structure de donn\u00e9es lin\u00e9aire. Une liste peut contenir un nombre quelconque d\u2019\u00e9l\u00e9ments y compris nul (la liste vide). Liste Une liste est une structure de donn\u00e9es permettant de regrouper des donn\u00e9es. C'est une collection finie et ordonn\u00e9e d'\u00e9l\u00e9ments, cela signifie que chaque \u00e9l\u00e9ment d'une liste est rep\u00e9r\u00e9 par son index (sa position). A la diff\u00e9rence d'un tableau qui est de taille fixe, une liste est extensible : on peut lui ajouter des \u00e9l\u00e9ments, on peut lui retirer des \u00e9l\u00e9ments; sa taille n'est donc pas fixe. III. Un peu d'histoire pour commencer Le langage LISP, invent\u00e9 par John Mac Carthy (photo) en 1958, est un des premiers \u00e0 utiliser la notion de liste (LISP vient de l'anglais list processing signifiant \u00ab traitement de listes \u00bb). Les listes du langage LISP sont compos\u00e9es de deux parties : une t\u00eate correspondant au premier \u00e9l\u00e9ment de la liste une queue correspondant au reste de la liste On pouvait alors construire une liste \u00e0 partir d'un premier \u00e9l\u00e9ment (sa t\u00eate) et d'une liste (sa queue). IV. Obtenir une d\u00e9finition formelle Prenons une liste comme par exemple \\(L_1=[5,3,8]\\) . C\u2019est une liste \u00e0 trois \u00e9l\u00e9ments (ou de longueur trois) dont le premier est 5, le deuxi\u00e8me 3, et le dernier 8. Une fa\u00e7on de d\u00e9crire cette liste consiste \u00e0 dire que la liste \\(L_1\\) poss\u00e8de un premier \u00e9l\u00e9ment 5 qu\u2019on nommera \u00e9l\u00e9ment de t\u00eate, et que vient apr\u00e8s cet \u00e9l\u00e9ment de t\u00eate la liste \\(L_2=[3,8]\\) des \u00e9l\u00e9ments qui suivent, liste qu\u2019on nommera reste. Ce qu\u2019on vient de dire de la liste \\(L_1\\) peut \u00eatre r\u00e9p\u00e9t\u00e9 pour la liste \\(L_2\\) qui est donc constitu\u00e9e : d\u2019un \u00e9l\u00e9ment de t\u00eate : 3, et d\u2019un reste : \\(L_3=[8]\\) . \u00c0 nouveau on peut r\u00e9p\u00e9ter le m\u00eame discours pour la liste \\(L_3\\) qui est donc constitu\u00e9e : d\u2019un \u00e9l\u00e9ment de t\u00eate : 8, et d\u2019un reste : \\(L_4=[]\\) . La liste \\(L_4\\) \u00e9tant vide, elle ne poss\u00e8de pas d\u2019\u00e9l\u00e9ment de t\u00eate, et ne peut donc pas \u00eatre d\u00e9compos\u00e9e comme nous venons de le faire \u00e0 trois reprises. Si on convient d\u2019utiliser la notation \\((e,L)\\) pour d\u00e9signer le couple constitu\u00e9 de l\u2019\u00e9l\u00e9ment \\(e\\) de t\u00eate, et du reste \\(L\\) d\u2019une liste, on peut alors \u00e9crire : \\[L_1=(5,(3,(8,[])))\\] \u27a1 Repr\u00e9sentation sch\u00e9matique : Ce qui vient d\u2019\u00eatre fait pour la liste \\(L_1\\) peut \u00eatre reproduit pour n\u2019importe quelle liste. On peut conclure cette approche en donnant une d\u00e9finition abstraite et formelle des listes d\u2019\u00e9l\u00e9ments appartenant tous \u00e0 un ensemble E. Une liste d\u2019\u00e9l\u00e9ments d\u2019un ensemble E est * soit la liste vide * soit un couple \\((e,L)\\) constitu\u00e9 d\u2019un \u00e9l\u00e9ment \\(e \\in E\\) et d\u2019une liste \\(L\\) d\u2019\u00e9l\u00e9ments de E. Les listes peuvent donc \u00eatre vues comme des structures de donn\u00e9es r\u00e9cursives V. L'interface minimale du type abstrait Liste Le type abstrait Liste peut alors \u00eatre d\u00e9fini par l' interface suivante contenant 5 op\u00e9rations primitives : Des constructeurs : listevide() pour construire une liste vide construit(e,\\ L) pour construire une nouvelle liste contenant un premier \u00e9l\u00e9ment e (sa t\u00eate) et une suite L (sa queue, qui est une liste). Cet op\u00e9rateur est aussi souvent not\u00e9 cons . Des s\u00e9lecteurs : premier(L) pour acc\u00e9der au premier \u00e9l\u00e9ment de la liste L , sa t\u00eate. Cet op\u00e9rateur est aussi souvent not\u00e9 car . reste(L) pour acc\u00e9der au reste de la liste L c'est-\u00e0-dire sa queue. Cet op\u00e9rateur est aussi souvent not\u00e9 cdr . Un pr\u00e9dicat (une question dont la r\u00e9ponse est un bool\u00e9en (V/F)) : estvide(L) pour tester si une liste est vide. Ainsi, pour construire une liste form\u00e9e par les nombres 5, 3, 8 (dans cet ordre) on fait : maliste1 = construit(5, construit(3, construit(8, listevide()))) Dans ce cas, premier(maliste1) correspond \u00e0 sa t\u00eate, c'est-\u00e0-dire 5 reste(maliste1) correspondant \u00e0 sa queue, c'est-\u00e0-dire la liste correspondant \u00e0 construit(3, construit(8, listevide())) form\u00e9e des nombres 3 et 8. On sait depuis les travaux de Mac Carthy sur le langage LISP, qu'avec ces 5 op\u00e9rations on peut reconstruire toutes les op\u00e9rations sur les listes (acc\u00e9der \u00e0 un \u00e9l\u00e9ment, modifier un \u00e9l\u00e9ment, ajouter/supprimer un \u00e9l\u00e9ment, calculer la longueur, tester l'appartenance, etc.) VI. Liste vs tableaux \u270f Qu\u2019est ce qui diff\u00e9rencie les listes des tableaux ? \u2693\ufe0e Tableau Sa taille est fixe, les \u00e9l\u00e8ments se suivent en m\u00e9roire. Acc\u00e9der \u00e0 son \u00e9l\u00e8ment par son indice est rapide. Liste Les \u00e9l\u00e8ments ne se suivent pas forc\u00e9ment en m\u00e9moire. La queue de la liste pointe vers une autre liste. Acc\u00e9der \u00e0 un \u00e9l\u00e8ment par son indice est lent (il faut suivre tous les liens) \u270f Insertion d'un \u00e9l\u00e8ment : \u2693\ufe0e Dans un tableau \u2693\ufe0e Tableau de taille 4 : Pour ns\u00e9rer un \u00e9l\u00e8ment il faut recr\u00e9er un tableau de taille sup\u00e9rieure Nouveau Tableau de taille 5 : Dans une liste : \u2693\ufe0e Pour ins\u00e9rer un \u00e9l\u00e8ment, c'est facile ! Liste 1. on casse le lien entre \"2\" et Liste(1,()) 2. On fait pointer la queue apr\u00e9s 5 sur Liste(1,()) 3. On fait pointer la queue apr\u00e9s 2 sur Liste(5,(1,())) C'est beaucoup plus rapide que pour les tableaux. Activit\u00e9 1 : Utiliser une interface On rappelle que le type abstrait Liste peut \u00eatre d\u00e9fini par l' interface suivante contenant 5 op\u00e9rations primitives : Des constructeurs : listevide() pour construire une liste vide construit(e, L) pour construire une nouvelle liste contenant un premier \u00e9l\u00e9ment e (sa t\u00eate) et une suite L (sa queue, qui est une liste). Cet op\u00e9rateur est aussi souvent not\u00e9 cons . Des s\u00e9lecteurs : premier(L) pour acc\u00e9der au premier \u00e9l\u00e9ment de la liste L , sa t\u00eate. Cet op\u00e9rateur est aussi souvent not\u00e9 car . reste(L) pour acc\u00e9der au reste de la liste L c'est-\u00e0-dire sa queue. Cet op\u00e9rateur est aussi souvent not\u00e9 cdr . Un pr\u00e9dicat : estvide(L) pour tester si une liste est vide. Question 1 : On consid\u00e8re la liste L1 suivante : L1=construit(1, contruit(3, construit(-2, construit(0, listecide())))) Quelle est la liste construite ? Que vaut chacune des variables suivantes ? \ud83d\udccb Texte e1=premier(L1) L2=reste(L1) L3=reste(reste(L1)) e2=premier(reste(reste(L1))) L4=construit(5, L3) Question 2 : \u00c9crivez les instructions permettant de : construire une liste maliste1 contenant les nombres 5, 2, 4, 7 dans cet ordre stocker dans une variable e1 le premier \u00e9l\u00e9ment de maliste1 stocker dans une variable e2 le deuxi\u00e8me \u00e9l\u00e9ment de maliste1 stocker dans une variable e3 le dernier \u00e9l\u00e9ment de maliste1 construire une liste vide appel\u00e9e maliste2 construire, \u00e0 partir de maliste1 , une liste maliste3 contenant uniquement les nombres 4 et 7. construire, uniquement \u00e0 partir des listes et variables pr\u00e9c\u00e9dentes, une liste maliste4 contenant les nombres 5, 2, 1, 4, 7 (on veut ins\u00e9rer 1 entre 2 et 4 dans liste de d\u00e9part). VII. Impl\u00e9mentations possibles \u270f VII.1. Une impl\u00e9mentation avec des couples en Python \u2693\ufe0e Cette premi\u00e8re impl\u00e9mentation est bas\u00e9e sur des paires (couples) qui comportent chacune un \u00e9l\u00e9ment et la suite de la liste, qui elle-m\u00eame peut \u00eatre une paire... Elle r\u00e9utilise le type tuple de Python. On d\u00e9finit ainsi notre structure de donn\u00e9es de mani\u00e8re r\u00e9cursive pour respecter la philosophie du langage LISP. Activit\u00e9 2 : \u00c9criture de quelques op\u00e9rations d\u00e9riv\u00e9es On consid\u00e8re toujours la m\u00eame interface (que dans l\u2019activit\u00e9 1) pour le type abstrait de donn\u00e9es Liste. Voici une impl\u00e9mentation utilisant des couples, \u00e0 compl\u00e9ter : \ud83d\udc0d Script Python def listevide (): return None # on utilise None pour une liste vide def construit ( e , L ): ... # renvoie un tuple de deux \u00e9l\u00e9ments def premier ( L ): ... # acc\u00e8s au premier \u00e9l\u00e9ment du couple (la t\u00eate de L) def reste ( L ): ... # acc\u00e8s au deuxi\u00e8me \u00e9l\u00e9ment du couple (la queue de L) def estvide ( L ): return L is None # L est \u00e9gal \u00e0 None ? On peut alors tester les instructions pr\u00e9c\u00e9dentes et en affichant le contenu de maliste1, on se rend compte de l\u2019impl\u00e9mentation choisie avec des paires imbriqu\u00e9es. \ud83d\udc0d Script Python maliste1 = construit ( 5 , construit ( 3 , construit ( 8 , listevide ()))) maliste1 On a donc logiquement : \ud83d\udc0d Script Python premier ( maliste1 ) \ud83d\udc0d Script Python reste ( maliste1 ) Avec cette impl\u00e9mentation, il est int\u00e9ressant de noter que la contruction de maliste1 avec l\u2019instruction \ud83d\udc0d Script Python construit ( 5 , construit ( 3 , construit ( 8 , listevide ()))) n\u00e9cessite la construction 3 paires interm\u00e9diaires qui sont construites de la plus imbriqu\u00e9e (liste vide) \u00e0 la moins imbriqu\u00e9e. On peut visualiser facilement cela avec Python tutor. \u270f Partie A : Utilisation des op\u00e9rations \u2693\ufe0e Question 1 : Utilisez cette impl\u00e9mentation pour v\u00e9rifier vos r\u00e9ponses \u00e0 l\u2019activit\u00e9 1. \ud83d\udc0d Script Python \u270f Partie B : Ecriture d\u2019op\u00e9rations d\u00e9riv\u00e9es \u2693\ufe0e On a vu dans le cours qu\u2019il est possible de construire toutes les op\u00e9rations \u00e0 partir des 5 op\u00e9rations primivites donn\u00e9es ci-dessus. Par exemple, pour obtenir le dernier \u00e9l\u00e9ment d\u2019une liste, on peut impl\u00e9menter l\u2019op\u00e9ration dernier(L) \u00e0 partir des autres : \ud83d\udc0d Script Python def dernier ( L ): \"\"\"Liste --> Element Pr\u00e9condition : L n\u2019est pas vide.\"\"\" ... \ud83d\udc0d Script Python L1 = construit ( 1 , construit ( 3 , construit ( - 2 , construit ( 0 , listevide ())))) dernier ( L1 ) On rappelle que l\u2019on peut \u00e9crire un jeu de tests en utilisant la construction assert. \ud83d\udc0d Script Python liste1 liste2 assert assert = construit ( 2 , listevide ()) = construit ( 1 , construit ( 2 , construit ( 5 , listevide ()))) dernier ( liste1 ) == 2 dernier ( liste2 ) == 5 Question 2 : On souhaite impl\u00e9menter en une fonction l\u2019op\u00e9ration taille(L) qui renvoie le nombre d\u2019\u00e9l\u00e9ments contenus dans la liste L. 1. \u00c9crivez un jeu de tests de qualit\u00e9 pour cette fonction. 2. Proposez le code de cette fonction avec sa docstring (qui doit passer les tests avec succ\u00e8s). \ud83d\udc0d Script Python Question 3 : M\u00eames questions avec l\u2019op\u00e9ration lire(L, i) renvoie le i-\u00e8me \u00e9l\u00e9ment de la liste L. \ud83d\udc0d Script Python \u270f VII.2. Une impl\u00e9mentation avec le type list de Python \u2693\ufe0e Il est possible d\u2019impl\u00e9menter les 5 op\u00e9rations d\u00e9finissant le type abstrait Liste en utilisant le type pr\u00e9- d\u00e9fini list de Python. Les fonctions sont tr\u00e8s ressemblantes \u00e0 celles utilisant les couples. Cela fait l\u2019objet des activit\u00e9s 3 et 4 qui proposent deux impl\u00e9mentations diff\u00e9rentes : - la premi\u00e8re avec copie des listes interm\u00e9diaires (comme l\u2019impl\u00e9mentation avec les couples) - la seconde avec modification de la liste en place. Activit\u00e9 3 : Une impl\u00e9mentation avec le type list de Python On veut maintenant impl\u00e9menter le type abstrait Liste en utilisant le type list de Python. Question 1 : Utilisez la documentation officielle pour compl\u00e9ter l\u2019impl\u00e9mentation du type Liste avec les possibilit\u00e9s offertes par le type list de Python. \ud83d\udc0d Script Python def listevide (): # renvoie une liste vide def construit ( e , L ): # renvoie une liste qui est la concat\u00e9nation d\u2019une liste contenant e avec la liste L def premier ( L ): # renvoie le premier \u00e9l\u00e9ment de L def reste ( L ): # renvoie une liste contenant les \u00e9l\u00e9ments de L \u00e0 partir de la position 1 def estvide ( L ): # renvoie True si L est vide, False sinon Question 2 : V\u00e9rifiez qu\u2019en ex\u00e9cutant le code suivant, on obtient exactement le m\u00eame r\u00e9sultat qu\u2019avec la premi\u00e8re impl\u00e9mentation. L\u2019utilisateur curieux pourra cependant observer la structure des informa- tions m\u00e9moris\u00e9es en affichant les listes L1 (impl\u00e9ment\u00e9e par des couples) et L2 (impl\u00e9ment\u00e9e par le type list de Python). \ud83d\udc0d Script Python L2 = construit ( 1 , construit ( 3 , construit ( - 2 , construit ( 0 , listevide ())))) #construction avec la nouvelle impl\u00e9mentation dernier ( L2 ) # renvoie le dernier \u00e9l\u00e9ment de la liste construite Question 3 : Utilisez Python Tutor pour observer pas \u00e0 pas la construction de la liste L2 pr\u00e9c\u00e9dente. Combien de listes interm\u00e9diaires sont cr\u00e9\u00e9es pour construire la liste L2 avec cette impl\u00e9mentation ? \ud83d\udc0d Script Python","title":"TD11 Les Listes"},{"location":"TD12_ListeChainee/","text":"TD n\u00b012 : Impl\u00e9mentation d'une *liste* par une liste cha\u00een\u00e9e Th\u00e8me 1 : Structures de donn\u00e9es EXERCICES On propose dans cette activit\u00e9 d'impl\u00e9menter le type abstrait liste par ce qu'on appelle une liste cha\u00een\u00e9e. Nous utiliserons le paradigme objet. Interface On rappelle que ce type abstrait est d\u00e9finie par les op\u00e9rations cr\u00e9ation d'une liste vide ajout d'un \u00e9l\u00e9ment en t\u00eate de liste acc\u00e8s \u00e0 la t\u00eate de la liste acc\u00e8s \u00e0 la queue de la liste test d'une liste vide On rappelle aussi qu'une liste cha\u00een\u00e9e est une repr\u00e9sentation non contigue des listes, avec des cellules (ou maillons ) comportant chacun un \u00e9l\u00e9ment (de la liste) et une r\u00e9f\u00e9rence au suivant. Ainsi, les \u00e9l\u00e9ments sont cha\u00een\u00e9s entre eux (d'o\u00f9 le nom) et on peut repr\u00e9senter une liste cha\u00een\u00e9e de la fa\u00e7on suivante : Chaque cellule contient deux informations : la valeur d'un \u00e9l\u00e9ment de la liste un lien vers la cellule suivante (son adresse m\u00e9moire) Dans l'exemple propos\u00e9, le premier \u00e9l\u00e9ment est 12, le second est 14, ..., le dernier est 22 car le lien vers la cellule suivante pointe vers None qui marque la fin de la liste. La classe Cellule \u2693\ufe0e Commen\u00e7ons par cr\u00e9er une cellule en utilisant la programmation objet. On doit donc cr\u00e9er une classe Cellule poss\u00e9dant deux attributs : valeur qui est la valeur de la cellule suivante qui est une r\u00e9f\u00e9rence vers la cellule suivante. \ud83d\udc0d Script Python class Cellule : def __init__ ( self , valeur , suivante ): self . valeur = valeur self . suivante = suivante On peut alors cr\u00e9er une cha\u00eene et acc\u00e9der \u00e0 ses \u00e9l\u00e9ments en consultant la valeur d'une cellule, ou la valeur de la suivante, etc. \ud83d\udc0d Script Python chaine1 = Cellule ( 1 , Cellule ( 2 , Cellule ( 3 , None ))) print ( \"premier \u00e9l\u00e9ment :\" , chaine1 . valeur ) print ( \"deuxi\u00e8me \u00e9l\u00e9ment :\" , chaine1 . suivante . valeur ) print ( \"troisi\u00e8me \u00e9l\u00e9ment :\" , chaine1 . suivante . suivante . valeur ) print ( \"quatri\u00e8me \u00e9l\u00e9ment ? :\" , chaine1 . suivante . suivante . suivante ) On peut visualiser la construction de la cha\u00eene avec Python tutor . Il est important de remarquer que : chaque \u00e9l\u00e9ment de la cha\u00eene est une instance (un objet) de la classe Cellule ; la variable chaine pointe vers la premi\u00e8re cellule de la cha\u00eene. Question 1 Construisez une liste appel\u00e9e chaine correspondant au sch\u00e9ma donn\u00e9 dans l'introduction. \ud83d\udc0d Script Python # \u00e0 compl\u00e9ter Remarque : Pour le moment on a utilis\u00e9 le terme chaine et non le terme liste car la classe Cellule ne permet pas de repr\u00e9senter une liste vide, qui serait une liste sans aucune cellule... On peut voir une chaine comme une liste non vide, c'est-\u00e0-dire comportant au moins une cellule. Eciture de quelques fonctions \u2693\ufe0e Longueur d'une chaine \u2693\ufe0e Pour d\u00e9terminer la longueur d'une chaine, il suffit de parcourir chaque cellule, jusqu'\u00e0 trouver une cellule dont l'attribut suivante pointe vers None . Si la chaine vaut None au d\u00e9part, elle repr\u00e9sente une liste vide qui a pour longueur 0. On peut d\u00e9finir la fonction longueur qui calcule la longueur d'une chaine : \ud83d\udc0d Script Python def longueur ( chaine ): n = 0 courante = chaine # la cellule courante pointe vers chaine qui pointe vers la premi\u00e8re cellule ou None while courante is not None : # tant que la cellule courante ne pointe par vers None courante = courante . suivante # on passe \u00e0 la cellule suivante n = n + 1 # la longueur augmente d'une unit\u00e9 return n chaine1 = Cellule ( 1 , Cellule ( 2 , Cellule ( 3 , None ))) print ( \"longueur :\" , longueur ( chaine1 )) print ( \"longueur d'une liste vide :\" , longueur ( None )) Question 2 V\u00e9rifiez la longueur renvoy\u00e9e pour la cha\u00eene chaine (question 1). \ud83d\udc0d Script Python # \u00e0 compl\u00e9ter Question 3 Proposez une version r\u00e9cursive de la fonction longueur ( puis v\u00e9rifiez ) \ud83d\udc0d Script Python # VERSION RECURSIVE # \u00e0 compl\u00e9ter El\u00e9ments d'une chaine \u2693\ufe0e Il peut \u00eatre int\u00e9ressant de pouvoir afficher ou renvoyer tous les \u00e9l\u00e9ments d'une chaine. Cela permet notamment de v\u00e9rifier des choses. Question 4 Ecrivez une fonction affiche(chaine) qui affiche tous les \u00e9l\u00e9ments d'une chaine (non vide). \ud83d\udc0d Script Python # \u00e0 compl\u00e9ter \ud83d\udc0d Script Python Question 5 Ecrivez une fonction liste_elements(chaine) qui renvoie la liste (au sens list de Python) des \u00e9l\u00e9ments d'une cha\u00eene. \ud83d\udc0d Script Python def liste_elements ( chaine ): \"\"\"Renvoie une list Python contenant tous les \u00e9l\u00e9ments de la liste cha\u00een\u00e9e L >>> liste_elements(Cellule(1, Cellule(2, Cellule(3, None)))) [1, 2, 3] >>> liste_elements(Cellule(12, Cellule(14, Cellule(8, Cellule(7, Cellule(19, Cellule(22, None))))))) [12, 14, 8, 7, 19, 22] \"\"\" # \u00e0 compl\u00e9ter \ud83d\udc0d Script Python import doctest doctest . testmod () # verbose = True pour plus de d\u00e9tails \ud83d\udccb Texte TestResults(failed=0, attempted=0) Acc\u00e8s au i-\u00e8me \u00e9l\u00e9ment d'une chaine \u2693\ufe0e On souhaite maintenant \u00e9crire une fonction ieme_element(chaine, i) permettant de renvoyer le i -\u00e8me \u00e9l\u00e9ment de la chaine . Pr\u00e9conditions : chaine est non vide (au moins une cellule) et i est compris entre 0 et longueur(chaine)-1 . Question 6 Proposez une fonction qui convient. On peut trouver le i-\u00e8me \u00e9l\u00e9ment avec une boucle ou par r\u00e9cursivit\u00e9. Voir si besoin les anciens chapitres. \ud83d\udc0d Script Python # \u00e0 compl\u00e9ter \ud83d\udc0d Script Python # VERSION ITERATIVE AVEC UNE BOUCLE WHILE La classe ListeChainee \u2693\ufe0e La classe Cellule ne permet pas d'impl\u00e9menter \u00e0 elle seule le type abstrait liste car rien n'est pr\u00e9vu pour repr\u00e9senter une liste vide. On va utiliser cette classe pour cr\u00e9er une classe ListeChainee qui impl\u00e9mente ce type abstrait. Il suffira de faire pointer la liste vers le premier \u00e9l\u00e9ment de la cha\u00eene (de cellules) ou vers None pour la liste vide. Les op\u00e9rations \u00e0 impl\u00e9menter dans la classe ListeChainee sont : cr\u00e9ation d'une liste vide ajout d'un \u00e9l\u00e9ment en t\u00eate de liste : ajouter_en_tete(self, element) test d'une liste vide : est_vide(self) acc\u00e8s \u00e0 la t\u00eate de la liste : premier(self) acc\u00e8s \u00e0 la queue de la liste : reste(self) Attributs \u2693\ufe0e On choisit de d\u00e9finir un seul attribut tete , qui peut \u00eatre soit une r\u00e9f\u00e9rence vers la premi\u00e8re Cellule d'une cha\u00eene (de cellules), soit la valeur particuli\u00e8re None pour repr\u00e9senter une liste vide. On d\u00e9finit ainsi une liste cha\u00een\u00e9e . M\u00e9thodes \u2693\ufe0e On veut impl\u00e9menter les 5 op\u00e9rations primitives d'une liste (donn\u00e9es en d\u00e9but de document). Impl\u00e9mentation \u2693\ufe0e La m\u00e9thode d'initialisation __init__ cr\u00e9e une liste vide en initialisant l'attribut tete \u00e0 None . La m\u00e9thode ajouter_en_tete permet d'ajouter un \u00e9lement en premi\u00e8re position. La m\u00e9thode est_vide permet de tester si une liste est vide ou non La m\u00e9thode premier permet d'acc\u00e9der au premier \u00e9l\u00e9ment d'une liste non vide (sa t\u00eate). On peut aussi l'attribut tete . La m\u00e9thode reste permet d'acc\u00e9der au reste des \u00e9l\u00e9ments d'une liste non vide (sa queue), qui est aussi une liste. Question 7 Etudiez attentivement l'impl\u00e9mentation propos\u00e9e. \ud83d\udc0d Script Python class ListeChainee : \"\"\"Manipulation de listes cha\u00een\u00e9es\"\"\" def __init__ ( self ): \"\"\"Initialise une liste vide.\"\"\" self . tete = None def ajouter_en_tete ( self , e ): \"\"\"Ins\u00e8re e en t\u00eate de liste en cr\u00e9ant une nouvelle cellule\"\"\" nouvelle_cellule = Cellule ( e , self . tete ) self . tete = nouvelle_cellule def est_vide ( self ): \"\"\"Renvoie True si la liste est vide, False sinon\"\"\" return self . tete is None def premier ( self ): \"\"\"Renvoie le premier \u00e9l\u00e9ment de la liste (sa t\u00eate) si cette derni\u00e8re est non vide\"\"\" assert self . premier is not None , \"une liste vide n'a pas de t\u00eate\" return self . tete . valeur def reste ( self ): \"\"\"Renvoie le reste de la liste (sa queue) si cette derni\u00e8re est non vide.\"\"\" assert self . tete is not None , \"une liste vide n'a pas de queue\" r = ListeChainee () r . tete = self . tete . suivante return r Explications : On s'attarde sur les m\u00e9thodes ajouter_en_tete et reste qui sont plus subtiles qu'il n'y para\u00eet. M\u00e9thode ajouter_en_tete : ligne 1 : on commence par cr\u00e9er une nouvelle cellule dont l'attribut valeur vaut l'\u00e9l\u00e9ment e \u00e0 ajouter \u00e0 la liste et dont l'attribut suivante vaut self.tete c'est-\u00e0-dire la r\u00e9f\u00e9rence vers la premi\u00e8re cellule de la liste. On construit ainsi une cellule avec la valeur \u00e0 ajout\u00e9 et qui pointe vers l'ancienne premi\u00e8re cellule de notre liste. ligne 2: il ne faut pas oublier de mettre \u00e0 jour l'attribut tete pour qu'il d\u00e9signe notre nouvelle premi\u00e8re cellule. M\u00e9thode reste : ligne 1 : on programme de mani\u00e8re plus s\u00fbre en commen\u00e7ant pas tester au moyen d' assert que la liste n'est pas vide. ligne 2, 3 et 4 : il ne suffit pas de renvoyer la deuxi\u00e8me cellule de notre liste ( self.tete.suivante ) car on renverrait alors un objet Cellule et non une ListeChainee comme souhait\u00e9. On commence donc par cr\u00e9er une liste vide r dont l'attribut tete d\u00e9signe la deuxi\u00e8me cellule (celle qui suit la t\u00eate) et on renvoie cette liste r qui pointe bien vers la deuxi\u00e8me cellule de d\u00e9part. On peut cr\u00e9er une liste vide, puis lui ajouter des \u00e9l\u00e9ments en t\u00eate. On acc\u00e8de aux diff\u00e9rents \u00e9l\u00e9ments gr\u00e2ce aux m\u00e9thodes premier et reste . \ud83d\udc0d Script Python L = ListeChainee () print ( L . est_vide ()) L . ajouter_en_tete ( 22 ) print ( L . est_vide ()) L . ajouter_en_tete ( 19 ) L . ajouter_en_tete ( 7 ) L . ajouter_en_tete ( 8 ) L . ajouter_en_tete ( 14 ) L . ajouter_en_tete ( 12 ) print ( \"le premier \u00e9l\u00e9ment est :\" , L . premier ()) print ( \"le deuxi\u00e8me \u00e9l\u00e9ment est :\" , L . reste () . premier ()) # le 2\u00e8me est le premier du reste print ( \"le troisi\u00e8me \u00e9l\u00e9ment est :\" , L . reste () . reste () . premier ()) # le 3\u00e8me est le premier du reste du reste Ajout de quelques m\u00e9thodes \u2693\ufe0e On souhaite maintenant utiliser les fonctions longueur , liste_elements et ieme_element pour d\u00e9finir trois nouvelles m\u00e9thodes \u00e0 notre classe ListeChainee . Pour ajouter une m\u00e9thode taille \u00e0 la classe, il suffit d'appeler notre fonction longueur \u00e9crite pr\u00e9c\u00e9demment : \ud83d\udc0d Script Python def taille ( self ): return longueur ( self . tete ) Il ne faut pas oublier que la fonction longueur d\u00e9j\u00e0 \u00e9crite s'applique \u00e0 une cha\u00eene d\u00e9sign\u00e9e par sa premi\u00e8re cellule et non \u00e0 un objet de la classe ListeChainee . Ainsi, il ne faut pas renvoyer longueur(self) mais bien longueur(self.tete) , o\u00f9 self.tete d\u00e9signe bien la premi\u00e8re cellule de la liste cha\u00een\u00e9e. Question 8 En utilisant les fonctions ieme_element et liste_elements et en vous inspirant de la m\u00e9thode taille(self) , \u00e9crivez les m\u00e9thodes lire(self, i) et __repr__(self) qui permettent respectivement de renvoyer le i -\u00e8me \u00e9l\u00e9ment d'un objet ListeChainee et de repr\u00e9senter un objet ListeChainee comme une list Python. Attention : la m\u00e9thode sp\u00e9ciale __repr__ doit renvoyer une cha\u00eene de caract\u00e8res, il faut penser \u00e0 utiliser la fonction str pour convertir la list Python. \ud83d\udc0d Script Python class ListeChainee : \"\"\"Manipulation de listes cha\u00een\u00e9es\"\"\" def __init__ ( self ): \"\"\"Initialise une liste vide.\"\"\" self . tete = None def ajouter_en_tete ( self , e ): \"\"\"Ins\u00e8re e en t\u00eate de liste en cr\u00e9ant une nouvelle cellule\"\"\" nouvelle_cellule = Cellule ( e , self . tete ) self . tete = nouvelle_cellule def est_vide ( self ): \"\"\"Renvoie True si la liste est vide, False sinon\"\"\" return self . tete is None def premier ( self ): \"\"\"Renvoie le premier \u00e9l\u00e9ment de la liste (sa t\u00eate) si cette derni\u00e8re est non vide\"\"\" assert self . premier is not None , \"une liste vide n'a pas de t\u00eate\" return self . tete . valeur def reste ( self ): \"\"\"Renvoie le reste de la liste (sa queue) si cette derni\u00e8re est non vide.\"\"\" assert self . tete is not None , \"une liste vide n'a pas de queue\" r = ListeChainee () r . tete = self . tete . suivante return r def longueur ( self ): return longueur ( self . tete ) def lire ( self , i ): # \u00e0 compl\u00e9ter def __repr__ ( self ): # compl\u00e9ter \ud83d\udc0d Script Python # ESSAIS L = ListeChainee () L . ajouter_en_tete ( 22 ) L . ajouter_en_tete ( 19 ) L . ajouter_en_tete ( 7 ) L . ajouter_en_tete ( 8 ) L . ajouter_en_tete ( 14 ) L . ajouter_en_tete ( 12 ) print ( L ) print ( \"longueur :\" , L . longueur ()) print ( \"premier \u00e9l\u00e9ment :\" , L . lire ( 0 )) print ( \"troisi\u00e8me \u00e9l\u00e9ment :\" , L . lire ( 2 )) Utilisation de m\u00e9thodes sp\u00e9ciales \u2693\ufe0e On peut utiliser les m\u00e9thodes sp\u00e9ciales __len__ et __getitem__ \u00e0 la place des m\u00e9thodes taille et lire afin d'utiliser la syntaxe habituelle de Python en \u00e9crivant : len(L) pour obtenir la longueur d'une liste L au lieu de L.taille() L[i] pour acc\u00e9der au i -\u00e8me \u00e9l\u00e9ment d'une liste L au lieu de L.lire(i) . Question 9 Remplacez les m\u00e9thodes taille et lire par les m\u00e9thodes __len__ et __getitem__ . V\u00e9rifiez ensuite si tout fonctionne comme avec des list Python. \ud83d\udc0d Script Python # \u00e0 compl\u00e9ter Supprimer en t\u00eate et ajouter en queue \u2693\ufe0e Nous terminons par l'\u00e9criture de deux m\u00e9thodes qui peuvent se r\u00e9v\u00e9ler utiles (pour la suite de l'ann\u00e9e). Il s'agit des m\u00e9thodes : supprimer_en_tete(self) qui permet de supprimer l'\u00e9l\u00e9ment de t\u00eate d'une liste ajouter_en_queue(self, e) qui permet d'ajouter l'\u00e9l\u00e9ment e en queue de liste Question 10 Expliquez, par des phrases et/ou un sch\u00e9ma, ce qu'il faut faire pour supprimer l'\u00e9l\u00e9ment de t\u00eate (la cellule de t\u00eate) d'une liste L . R\u00e9ponse : On doit faire pointer la t\u00eate de liste vers la deuxi\u00e8me cellule dont la r\u00e9f\u00e9rence se trouve dans l'attribut suivante de la premi\u00e8re cellule c'est-\u00e0-dire L.premier.suivante . Question 11 Expliquez, par des phrases et/ou un sch\u00e9ma, ce qu'il faut faire pour ajouter l'\u00e9l\u00e9ment e en queue d'une liste L . R\u00e9ponse : Il faut parcourir toutes les cellules jusqu'\u00e0 la derni\u00e8re, celle qui pointe vers None . On cr\u00e9e une nouvelle cellule . Il suffit de faire pointer cette derni\u00e8re cellule (en modifiant son attribut suivante vers une nouvelle cellule que l'on cr\u00e9e avec l'attribut valeur \u00e9gal \u00e0 e et l'attribut suivante qui pointe vers None . Question 12 Ajoutez ces deux m\u00e9thodes dans la classe Liste (l'ajout en queue est beaucoup plus difficile). \ud83d\udc0d Script Python # \u00e0 compl\u00e9ter class ListeChainee : \"\"\"Manipulation de listes cha\u00een\u00e9es\"\"\" # ---------- OPERATIONS PRIMITIVES ------------------ def __init__ ( self ): \"\"\"Initialise une liste vide.\"\"\" self . tete = None def ajouter_en_tete ( self , e ): \"\"\"Ins\u00e8re e en t\u00eate de liste en cr\u00e9ant une nouvelle cellule\"\"\" nouvelle_cellule = Cellule ( e , self . tete ) self . tete = nouvelle_cellule def est_vide ( self ): \"\"\"Renvoie True si la liste est vide, False sinon\"\"\" return self . tete is None def premier ( self ): \"\"\"Renvoie le premier \u00e9l\u00e9ment de la liste (sa t\u00eate) si cette derni\u00e8re est non vide\"\"\" assert self . premier is not None , \"une liste vide n'a pas de t\u00eate\" return self . tete . valeur def reste ( self ): \"\"\"Renvoie le reste de la liste (sa queue) si cette derni\u00e8re est non vide.\"\"\" assert self . tete is not None , \"une liste vide n'a pas de queue\" r = ListeChainee () r . tete = self . tete . suivante return r # ---------- AUTRES OPERATIONS ------------------ \ud83d\udc0d Script Python # ESSAIS L = ListeChainee () L . ajouter_en_tete ( 22 ) L . ajouter_en_tete ( 19 ) L . ajouter_en_tete ( 7 ) L . ajouter_en_tete ( 8 ) L . ajouter_en_tete ( 14 ) L . ajouter_en_tete ( 12 ) print ( L ) L . supprimer_en_tete () print ( L ) L . ajouter_en_queue ( 5 ) print ( L ) L . supprimer_en_tete () print ( L ) Cr\u00e9ation d'un module listechainee \u2693\ufe0e Cr\u00e9ez un module listechainee.py qui peut \u00eatre import\u00e9 dans un autre programme Python et qui permet de manipuler la classe ListeChainee ainsi cr\u00e9\u00e9e (avec toutes les m\u00e9thodes). Attention \u00e0 ne rien oublier, la classe ListeChainee fait appel \u00e0 des fonctions et classe externes. Bilan On a impl\u00e9ment\u00e9 une classe ListeChainee qui impl\u00e9mente le type abstrait liste avec des listes cha\u00een\u00e9es qui sont des cha\u00eenes de plusieurs cellules de la classe Cellule . Chaque cellule poss\u00e8de une valeur et une r\u00e9f\u00e9rence vers la cellule suivante. Les objets de la classe ListeChainee pointent vers la premi\u00e8re cellule d'une cha\u00eene, ou vers None pour d\u00e9signer une liste vide. L'int\u00e9r\u00eat d'une liste cha\u00een\u00e9e, par rapport \u00e0 une impl\u00e9mentation avec un tableau dynamique ( list Python), se trouve dans les op\u00e9rations d'ajout et suppression en d\u00e9but de liste (ajout, suppression) qui sont moins co\u00fbteuses car ne n\u00e9cessitent pas de d\u00e9caler tous les \u00e9l\u00e9ments qui suivent. La cr\u00e9ation du module listechainee permet de manipuler des listes (impl\u00e9ment\u00e9es par des listes cha\u00een\u00e9es) en important la classe ListeChainee du module. Une fois import\u00e9e, cette classe masque totalement l'impl\u00e9mentation avec des cellules formant des listes cha\u00een\u00e9es. N\u00e9anmoins, le savoir permet de privil\u00e9gier certaines op\u00e9rations moins co\u00fbteuses qu'avec une impl\u00e9mentation avec des tableaux redimensionnables ( list Python). Pour aller plus loin \u2693\ufe0e On pourrait programmer pour notre classe ListeChainee , les autres op\u00e9rations disponibles pour le type pr\u00e9d\u00e9fini list de Python. Par exemple : la suppression en queue l'ajout/la suppression en position i la concat\u00e9nation l'inversion etc. On se rapprocherait ainsi du type list de Python mais il faut garder en t\u00eate que le co\u00fbt de certaines op\u00e9rations n'est pas forc\u00e9ment le m\u00eame : rapide en fin de liste mais co\u00fbteux en d\u00e9but pour les list Python, alors que c'est le contraire pour les listes cha\u00een\u00e9es de notre classe ListeChainee .","title":"TD12 ListeChainee"},{"location":"TD12_ListeChainee/#la-classe-cellule","text":"Commen\u00e7ons par cr\u00e9er une cellule en utilisant la programmation objet. On doit donc cr\u00e9er une classe Cellule poss\u00e9dant deux attributs : valeur qui est la valeur de la cellule suivante qui est une r\u00e9f\u00e9rence vers la cellule suivante. \ud83d\udc0d Script Python class Cellule : def __init__ ( self , valeur , suivante ): self . valeur = valeur self . suivante = suivante On peut alors cr\u00e9er une cha\u00eene et acc\u00e9der \u00e0 ses \u00e9l\u00e9ments en consultant la valeur d'une cellule, ou la valeur de la suivante, etc. \ud83d\udc0d Script Python chaine1 = Cellule ( 1 , Cellule ( 2 , Cellule ( 3 , None ))) print ( \"premier \u00e9l\u00e9ment :\" , chaine1 . valeur ) print ( \"deuxi\u00e8me \u00e9l\u00e9ment :\" , chaine1 . suivante . valeur ) print ( \"troisi\u00e8me \u00e9l\u00e9ment :\" , chaine1 . suivante . suivante . valeur ) print ( \"quatri\u00e8me \u00e9l\u00e9ment ? :\" , chaine1 . suivante . suivante . suivante ) On peut visualiser la construction de la cha\u00eene avec Python tutor . Il est important de remarquer que : chaque \u00e9l\u00e9ment de la cha\u00eene est une instance (un objet) de la classe Cellule ; la variable chaine pointe vers la premi\u00e8re cellule de la cha\u00eene. Question 1 Construisez une liste appel\u00e9e chaine correspondant au sch\u00e9ma donn\u00e9 dans l'introduction. \ud83d\udc0d Script Python # \u00e0 compl\u00e9ter Remarque : Pour le moment on a utilis\u00e9 le terme chaine et non le terme liste car la classe Cellule ne permet pas de repr\u00e9senter une liste vide, qui serait une liste sans aucune cellule... On peut voir une chaine comme une liste non vide, c'est-\u00e0-dire comportant au moins une cellule.","title":"La classe Cellule"},{"location":"TD12_ListeChainee/#eciture-de-quelques-fonctions","text":"","title":"Eciture de quelques fonctions"},{"location":"TD12_ListeChainee/#la-classe-listechainee","text":"La classe Cellule ne permet pas d'impl\u00e9menter \u00e0 elle seule le type abstrait liste car rien n'est pr\u00e9vu pour repr\u00e9senter une liste vide. On va utiliser cette classe pour cr\u00e9er une classe ListeChainee qui impl\u00e9mente ce type abstrait. Il suffira de faire pointer la liste vers le premier \u00e9l\u00e9ment de la cha\u00eene (de cellules) ou vers None pour la liste vide. Les op\u00e9rations \u00e0 impl\u00e9menter dans la classe ListeChainee sont : cr\u00e9ation d'une liste vide ajout d'un \u00e9l\u00e9ment en t\u00eate de liste : ajouter_en_tete(self, element) test d'une liste vide : est_vide(self) acc\u00e8s \u00e0 la t\u00eate de la liste : premier(self) acc\u00e8s \u00e0 la queue de la liste : reste(self)","title":"La classe ListeChainee"},{"location":"TD12_ListeChainee/#creation-dun-module-listechainee","text":"Cr\u00e9ez un module listechainee.py qui peut \u00eatre import\u00e9 dans un autre programme Python et qui permet de manipuler la classe ListeChainee ainsi cr\u00e9\u00e9e (avec toutes les m\u00e9thodes). Attention \u00e0 ne rien oublier, la classe ListeChainee fait appel \u00e0 des fonctions et classe externes. Bilan On a impl\u00e9ment\u00e9 une classe ListeChainee qui impl\u00e9mente le type abstrait liste avec des listes cha\u00een\u00e9es qui sont des cha\u00eenes de plusieurs cellules de la classe Cellule . Chaque cellule poss\u00e8de une valeur et une r\u00e9f\u00e9rence vers la cellule suivante. Les objets de la classe ListeChainee pointent vers la premi\u00e8re cellule d'une cha\u00eene, ou vers None pour d\u00e9signer une liste vide. L'int\u00e9r\u00eat d'une liste cha\u00een\u00e9e, par rapport \u00e0 une impl\u00e9mentation avec un tableau dynamique ( list Python), se trouve dans les op\u00e9rations d'ajout et suppression en d\u00e9but de liste (ajout, suppression) qui sont moins co\u00fbteuses car ne n\u00e9cessitent pas de d\u00e9caler tous les \u00e9l\u00e9ments qui suivent. La cr\u00e9ation du module listechainee permet de manipuler des listes (impl\u00e9ment\u00e9es par des listes cha\u00een\u00e9es) en important la classe ListeChainee du module. Une fois import\u00e9e, cette classe masque totalement l'impl\u00e9mentation avec des cellules formant des listes cha\u00een\u00e9es. N\u00e9anmoins, le savoir permet de privil\u00e9gier certaines op\u00e9rations moins co\u00fbteuses qu'avec une impl\u00e9mentation avec des tableaux redimensionnables ( list Python).","title":"Cr\u00e9ation d'un module listechainee"},{"location":"TD12_ListeChainee/#pour-aller-plus-loin","text":"On pourrait programmer pour notre classe ListeChainee , les autres op\u00e9rations disponibles pour le type pr\u00e9d\u00e9fini list de Python. Par exemple : la suppression en queue l'ajout/la suppression en position i la concat\u00e9nation l'inversion etc. On se rapprocherait ainsi du type list de Python mais il faut garder en t\u00eate que le co\u00fbt de certaines op\u00e9rations n'est pas forc\u00e9ment le m\u00eame : rapide en fin de liste mais co\u00fbteux en d\u00e9but pour les list Python, alors que c'est le contraire pour les listes cha\u00een\u00e9es de notre classe ListeChainee .","title":"Pour aller plus loin"},{"location":"TD12_ListeChainee_Corrige/","text":"Th\u00e8me 1 : Structure de Donn\u00e9es 12 Impl\u00e9mentation d'une *liste* par une liste cha\u00een\u00e9e On propose dans cette activit\u00e9 d'impl\u00e9menter le type abstrait liste par ce qu'on appelle une liste cha\u00een\u00e9e. Nous utiliserons le paradigme objet. Interface On rappelle que ce type abstrait est d\u00e9finie par les op\u00e9rations cr\u00e9ation d'une liste vide ajout d'un \u00e9l\u00e9ment en t\u00eate de liste acc\u00e8s \u00e0 la t\u00eate de la liste acc\u00e8s \u00e0 la queue de la liste test d'une liste vide On rappelle aussi qu'une liste cha\u00een\u00e9e est une repr\u00e9sentation non contigue des listes, avec des cellules (ou maillons ) comportant chacun un \u00e9l\u00e9ment (de la liste) et une r\u00e9f\u00e9rence au suivant. Ainsi, les \u00e9l\u00e9ments sont cha\u00een\u00e9s entre eux (d'o\u00f9 le nom) et on peut repr\u00e9senter une liste cha\u00een\u00e9e de la fa\u00e7on suivante : Chaque cellule contient deux informations : - la valeur d'un \u00e9l\u00e9ment de la liste - un lien vers la cellule suivante (son adresse m\u00e9moire) Dans l'exemple propos\u00e9, le premier \u00e9l\u00e9ment est 12, le second est 14, ..., le dernier est 22 car le lien vers la cellule suivante pointe vers None qui marque la fin de la liste. \u27a1 La classe Cellule \u2693\ufe0e Commen\u00e7ons par cr\u00e9er une cellule en utilisant la programmation objet. On doit donc cr\u00e9er une classe Cellule poss\u00e9dant deux attributs : valeur qui est la valeur de la cellule suivante qui est une r\u00e9f\u00e9rence vers la cellule suivante. \ud83d\udc0d Script Python class Cellule : def __init__ ( self , valeur , suivante ): self . valeur = valeur self . suivante = suivante On peut alors cr\u00e9er une cha\u00eene et acc\u00e9der \u00e0 ses \u00e9l\u00e9ments en consultant la valeur d'une cellule, ou la valeur de la suivante, etc. \ud83d\udc0d Script Python chaine1 = Cellule ( 1 , Cellule ( 2 , Cellule ( 3 , None ))) print ( \"premier \u00e9l\u00e9ment :\" , chaine1 . valeur ) print ( \"deuxi\u00e8me \u00e9l\u00e9ment :\" , chaine1 . suivante . valeur ) print ( \"troisi\u00e8me \u00e9l\u00e9ment :\" , chaine1 . suivante . suivante . valeur ) print ( \"quatri\u00e8me \u00e9l\u00e9ment ? :\" , chaine1 . suivante . suivante . suivante ) On peut visualiser la construction de la cha\u00eene avec Python tutor . Il est important de remarquer que : chaque \u00e9l\u00e9ment de la cha\u00eene est une instance (un objet) de la classe Cellule ; la variable chaine pointe vers la premi\u00e8re cellule de la cha\u00eene. Question 1 Enonc\u00e9e Solution Construisez une liste appel\u00e9e chaine correspondant au sch\u00e9ma donn\u00e9 dans l'introduction. \ud83d\udc0d Script Python # \u00e0 compl\u00e9ter \ud83d\udc0d Script Python chaine = Cellule ( 12 , Cellule ( 14 , Cellule ( 8 , Cellule ( 7 , Cellule ( 19 , Cellule ( 22 , None )))))) print ( \"premier \u00e9l\u00e9ment :\" , chaine . valeur ) print ( \"deuxi\u00e8me \u00e9l\u00e9ment :\" , chaine . suivante . valeur ) print ( \"troisi\u00e8me \u00e9l\u00e9ment :\" , chaine . suivante . suivante . valeur ) print ( \"quatri\u00e8me \u00e9l\u00e9ment :\" , chaine . suivante . suivante . suivante . valeur ) Remarque : Pour le moment on a utilis\u00e9 le terme chaine et non le terme liste car la classe Cellule ne permet pas de repr\u00e9senter une liste vide, qui serait une liste sans aucune cellule... On peut voir une chaine comme une liste non vide, c'est-\u00e0-dire comportant au moins une cellule. \u27a1 Eciture de quelques fonctions \u2693\ufe0e Longueur d'une chaine \u2693\ufe0e Pour d\u00e9terminer la longueur d'une chaine, il suffit de parcourir chaque cellule, jusqu'\u00e0 trouver une cellule dont l'attribut suivante pointe vers None . Si la chaine vaut None au d\u00e9part, elle repr\u00e9sente une liste vide qui a pour longueur 0. On peut d\u00e9finir la fonction longueur qui calcule la longueur d'une chaine : \ud83d\udc0d Script Python def longueur ( chaine ): n = 0 courante = chaine # la cellule courante pointe vers chaine qui pointe vers la premi\u00e8re cellule ou None while courante is not None : # tant que la cellule courante ne pointe par vers None courante = courante . suivante # on passe \u00e0 la cellule suivante n = n + 1 # la longueur augmente d'une unit\u00e9 return n chaine1 = Cellule ( 1 , Cellule ( 2 , Cellule ( 3 , None ))) assert longueur ( chaine1 ) == 3 assert longueur ( None ) == 0 Question 2 Enonc\u00e9e Solution V\u00e9rifiez la longueur renvoy\u00e9e pour la cha\u00eene chaine (question 1). \ud83d\udc0d Script Python # \u00e0 compl\u00e9ter \ud83d\udc0d Script Python print ( \"longueur :\" , longueur ( chaine )) Question 3 Enonc\u00e9 Solution Proposez une version r\u00e9cursive de la fonction longueur ( puis v\u00e9rifiez ) \ud83d\udc0d Script Python # VERSION RECURSIVE \ud83d\udc0d Script Python # VERSION RECURSIVE # \u00e0 compl\u00e9ter def longueur ( chaine ) : courante = chaine if courante == None : return 0 else : return 1 + longueur ( courante . suivante ) \ud83d\udc0d Script Python print ( \"longueur :\" , longueur ( chaine )) El\u00e9ments d'une chaine \u2693\ufe0e Il peut \u00eatre int\u00e9ressant de pouvoir afficher ou renvoyer tous les \u00e9l\u00e9ments d'une chaine. Cela permet notamment de v\u00e9rifier des choses. Question 4 Enonc\u00e9 Solution it\u00e9rative Solution r\u00e9cursive Ecrivez une fonction affiche(chaine) qui affiche tous les \u00e9l\u00e9ments d'une chaine (non vide). \ud83d\udc0d Script Python # \u00e0 compl\u00e9ter \ud83d\udc0d Script Python def affiche ( chaine ): courante = chaine while courante is not None : print ( courante . valeur ) courante = courante . suivante \ud83d\udc0d Script Python def affiche ( chaine ): if chaine . suivante == None : return f \" { chaine . valeur } -> None\" else : return f \" { chaine . valeur } -> { affiche ( chaine . suivante ) } \" \ud83d\udc0d Script Python affiche ( chaine ) \ud83d\udc0d Script Python affiche2 ( chaine ) Question 5 Enonc\u00e9 Solution Ecrivez une fonction liste_elements(chaine) qui renvoie la liste (au sens list de Python) des \u00e9l\u00e9ments d'une cha\u00eene. \ud83d\udc0d Script Python def liste_elements ( chaine ): \"\"\"Renvoie une list Python contenant tous les \u00e9l\u00e9ments de la liste cha\u00een\u00e9e L >>> liste_elements(Cellule(1, Cellule(2, Cellule(3, None)))) [1, 2, 3] >>> liste_elements(Cellule(12, Cellule(14, Cellule(8, Cellule(7, Cellule(19, Cellule(22, None))))))) [12, 14, 8, 7, 19, 22] \"\"\" # \u00e0 compl\u00e9ter T = liste_elements ( Cellule ( 12 , Cellule ( 14 , Cellule ( 8 , Cellule ( 7 , Cellule ( 19 , Cellule ( 22 , None ))))))) print ( T ) \ud83d\udc0d Script Python def liste_elements ( chaine ): \"\"\"Renvoie une list Python contenant tous les \u00e9l\u00e9ments de la liste cha\u00een\u00e9e L >>> liste_elements(Cellule(1, Cellule(2, Cellule(3, None)))) [1, 2, 3] >>> liste_elements(Cellule(12, Cellule(14, Cellule(8, Cellule(7, Cellule(19, Cellule(22, None))))))) [12, 14, 8, 7, 19, 22] \"\"\" L = [] courante = chaine while courante is not None : L . append ( courante . valeur ) courante = courante . suivante return L # \u00e0 compl\u00e9ter T = liste_elements ( Cellule ( 12 , Cellule ( 14 , Cellule ( 8 , Cellule ( 7 , Cellule ( 19 , Cellule ( 22 , None ))))))) print ( T ) \ud83d\udc0d Script Python #Pour v\u00e9rification import doctest doctest . testmod () # verbose = True pour plus de d\u00e9tails Acc\u00e8s au i-\u00e8me \u00e9l\u00e9ment d'une chaine \u2693\ufe0e On souhaite maintenant \u00e9crire une fonction ieme_element(chaine, i) permettant de renvoyer le i -\u00e8me \u00e9l\u00e9ment de la chaine . Pr\u00e9conditions : chaine est non vide (au moins une cellule) et i est compris entre 0 et longueur(chaine)-1 . Question 6 Enonc\u00e9 Solution it\u00e9rative Solution r\u00e9cursive Proposez une fonction qui convient. On peut trouver le i-\u00e8me \u00e9l\u00e9ment avec une boucle ou par r\u00e9cursivit\u00e9. Voir si besoin les anciens chapitres. \ud83d\udc0d Script Python # \u00e0 compl\u00e9ter def ieme_element ( chaine , i ): pass \ud83d\udc0d Script Python # VERSION ITERATIVE AVEC UNE BOUCLE WHILE def ieme_element ( chaine , i ): assert chaine != None and 0 < i < longueur ( chaine ) - 1 ni = 0 courante = chaine while courante != None and ni != i : ni += 1 courante = courante . suivante if courante != None : return courante . valeur \ud83d\udc0d Script Python # VERSION RECURSIVE def niemeElement ( chaine , i ) : assert chaine != None if i == 0 : return chaine . valeur else : return niemeElement ( chaine . suivante , i - 1 ) \ud83d\udc0d Script Python ieme_element ( chaine , 2 ) \u27a1 La classe ListeChainee \u2693\ufe0e La classe Cellule ne permet pas d'impl\u00e9menter \u00e0 elle seule le type abstrait liste car rien n'est pr\u00e9vu pour repr\u00e9senter une liste vide. On va utiliser cette classe pour cr\u00e9er une classe ListeChainee qui impl\u00e9mente ce type abstrait. Il suffira de faire pointer la liste vers le premier \u00e9l\u00e9ment de la cha\u00eene (de cellules) ou vers None pour la liste vide. Les op\u00e9rations \u00e0 impl\u00e9menter dans la classe ListeChainee sont : cr\u00e9ation d'une liste vide ajout d'un \u00e9l\u00e9ment en t\u00eate de liste : ajouter_en_tete(self, element) test d'une liste vide : est_vide(self) acc\u00e8s \u00e0 la t\u00eate de la liste : premier(self) acc\u00e8s \u00e0 la queue de la liste : reste(self) Attributs \u2693\ufe0e On choisit de d\u00e9finir un seul attribut tete , qui peut \u00eatre soit une r\u00e9f\u00e9rence vers la premi\u00e8re Cellule d'une cha\u00eene (de cellules), soit la valeur particuli\u00e8re None pour repr\u00e9senter une liste vide. On d\u00e9finit ainsi une liste cha\u00een\u00e9e . M\u00e9thodes \u2693\ufe0e On veut impl\u00e9menter les 5 op\u00e9rations primitives d'une liste (donn\u00e9es en d\u00e9but de document). Impl\u00e9mentation \u2693\ufe0e La m\u00e9thode d'initialisation __init__ cr\u00e9e une liste vide en initialisant l'attribut tete \u00e0 None . La m\u00e9thode ajouter_en_tete permet d'ajouter un \u00e9lement en premi\u00e8re position. La m\u00e9thode est_vide permet de tester si une liste est vide ou non La m\u00e9thode premier permet d'acc\u00e9der au premier \u00e9l\u00e9ment d'une liste non vide (sa t\u00eate). On peut aussi l'attribut tete . La m\u00e9thode reste permet d'acc\u00e9der au reste des \u00e9l\u00e9ments d'une liste non vide (sa queue), qui est aussi une liste. Question Etudiez attentivement l'impl\u00e9mentation propos\u00e9e. \ud83d\udc0d Script Python class ListeChainee : \"\"\"Manipulation de listes cha\u00een\u00e9es\"\"\" def __init__ ( self ): \"\"\"Initialise une liste vide.\"\"\" self . tete = None def ajouter_en_tete ( self , e ): \"\"\"Ins\u00e8re e en t\u00eate de liste en cr\u00e9ant une nouvelle cellule\"\"\" nouvelle_cellule = Cellule ( e , self . tete ) self . tete = nouvelle_cellule def est_vide ( self ): \"\"\"Renvoie True si la liste est vide, False sinon\"\"\" return self . tete is None def premier ( self ): \"\"\"Renvoie le premier \u00e9l\u00e9ment de la liste (sa t\u00eate) si cette derni\u00e8re est non vide\"\"\" assert self . premier is not None , \"une liste vide n'a pas de t\u00eate\" return self . tete . valeur def reste ( self ): \"\"\"Renvoie le reste de la liste (sa queue) si cette derni\u00e8re est non vide.\"\"\" assert self . tete is not None , \"une liste vide n'a pas de queue\" r = ListeChainee () r . tete = self . tete . suivante return r Explications : On s'attarde sur les m\u00e9thodes ajouter_en_tete et reste qui sont plus subtiles qu'il n'y para\u00eet. M\u00e9thode ajouter_en_tete : ligne 1 : on commence par cr\u00e9er une nouvelle cellule dont l'attribut valeur vaut l'\u00e9l\u00e9ment e \u00e0 ajouter \u00e0 la liste et dont l'attribut suivante vaut self.tete c'est-\u00e0-dire la r\u00e9f\u00e9rence vers la premi\u00e8re cellule de la liste. On construit ainsi une cellule avec la valeur \u00e0 ajout\u00e9 et qui pointe vers l'ancienne premi\u00e8re cellule de notre liste. ligne 2: il ne faut pas oublier de mettre \u00e0 jour l'attribut tete pour qu'il d\u00e9signe notre nouvelle premi\u00e8re cellule. M\u00e9thode reste : ligne 1 : on programme de mani\u00e8re plus s\u00fbre en commen\u00e7ant pas tester au moyen d' assert que la liste n'est pas vide. ligne 2, 3 et 4 : il ne suffit pas de renvoyer la deuxi\u00e8me cellule de notre liste ( self.tete.suivante ) car on renverrait alors un objet Cellule et non une ListeChainee comme souhait\u00e9. On commence donc par cr\u00e9er une liste vide r dont l'attribut tete d\u00e9signe la deuxi\u00e8me cellule (celle qui suit la t\u00eate) et on renvoie cette liste r qui pointe bien vers la deuxi\u00e8me cellule de d\u00e9part. On peut cr\u00e9er une liste vide, puis lui ajouter des \u00e9l\u00e9ments en t\u00eate. On acc\u00e8de aux diff\u00e9rents \u00e9l\u00e9ments gr\u00e2ce aux m\u00e9thodes premier et reste . \ud83d\udc0d Script Python L = ListeChainee () print ( L . est_vide ()) L . ajouter_en_tete ( 22 ) print ( L . est_vide ()) L . ajouter_en_tete ( 19 ) L . ajouter_en_tete ( 7 ) L . ajouter_en_tete ( 8 ) L . ajouter_en_tete ( 14 ) L . ajouter_en_tete ( 12 ) print ( \"le premier \u00e9l\u00e9ment est :\" , L . premier ()) print ( \"le deuxi\u00e8me \u00e9l\u00e9ment est :\" , L . reste () . premier ()) # le 2\u00e8me est le premier du reste print ( \"le troisi\u00e8me \u00e9l\u00e9ment est :\" , L . reste () . reste () . premier ()) # le 3\u00e8me est le premier du reste du reste Ajout de quelques m\u00e9thodes \u2693\ufe0e On souhaite maintenant utiliser les fonctions longueur , liste_elements et ieme_element pour d\u00e9finir trois nouvelles m\u00e9thodes \u00e0 notre classe ListeChainee . Pour ajouter une m\u00e9thode taille \u00e0 la classe, il suffit d'appeler notre fonction longueur \u00e9crite pr\u00e9c\u00e9demment : \ud83d\udc0d Script Python def taille ( self ): return longueur ( self . tete ) Il ne faut pas oublier que la fonction longueur d\u00e9j\u00e0 \u00e9crite s'applique \u00e0 une cha\u00eene d\u00e9sign\u00e9e par sa premi\u00e8re cellule et non \u00e0 un objet de la classe ListeChainee . Ainsi, il ne faut pas renvoyer longueur(self) mais bien longueur(self.tete) , o\u00f9 self.tete d\u00e9signe bien la premi\u00e8re cellule de la liste cha\u00een\u00e9e. Question 7 Enonc\u00e9 Solution En utilisant les fonctions ieme_element et liste_elements et en vous inspirant de la m\u00e9thode taille(self) , \u00e9crivez les m\u00e9thodes lire(self, i) et __repr__(self) qui permettent respectivement de renvoyer le i -\u00e8me \u00e9l\u00e9ment d'un objet ListeChainee et de repr\u00e9senter un objet ListeChainee comme une list Python. Warning Attention : la m\u00e9thode sp\u00e9ciale __repr__ doit renvoyer une cha\u00eene de caract\u00e8res, il faut penser \u00e0 utiliser la fonction str pour convertir la list Python. \ud83d\udc0d Script Python class ListeChainee : \"\"\"Manipulation de listes cha\u00een\u00e9es\"\"\" def __init__ ( self ): \"\"\"Initialise une liste vide.\"\"\" self . tete = None def ajouter_en_tete ( self , e ): \"\"\"Ins\u00e8re e en t\u00eate de liste en cr\u00e9ant une nouvelle cellule\"\"\" nouvelle_cellule = Cellule ( e , self . tete ) self . tete = nouvelle_cellule def est_vide ( self ): \"\"\"Renvoie True si la liste est vide, False sinon\"\"\" return self . tete is None def premier ( self ): \"\"\"Renvoie le premier \u00e9l\u00e9ment de la liste (sa t\u00eate) si cette derni\u00e8re est non vide\"\"\" assert self . premier is not None , \"une liste vide n'a pas de t\u00eate\" return self . tete . valeur def reste ( self ): \"\"\"Renvoie le reste de la liste (sa queue) si cette derni\u00e8re est non vide.\"\"\" assert self . tete is not None , \"une liste vide n'a pas de queue\" r = ListeChainee () r . tete = self . tete . suivante return r def longueur ( self ): return longueur ( self . tete ) def taille ( self ): return longueur ( self . tete ) def lire ( self , i ): return niemeElement ( self . tete , i ) def __repr__ ( self ): return str ( liste_elements ( self . tete )) \ud83d\udc0d Script Python # ESSAIS L1 = ListeChainee () L1 . ajouter_en_tete ( 25 ) L1 . ajouter_en_tete ( 29 ) L1 . ajouter_en_tete ( 27 ) L1 . ajouter_en_tete ( 18 ) L1 . ajouter_en_tete ( 4 ) L1 . ajouter_en_tete ( 32 ) L1 . ajouter_en_tete ( 6 ) L1 . ajouter_en_tete ( 16 ) print ( L1 ) print ( L . reste ()) print ( \"longueur :\" , L1 . longueur ()) print ( \"premier \u00e9l\u00e9ment :\" , L1 . lire ( 0 )) print ( \"troisi\u00e8me \u00e9l\u00e9ment :\" , L1 . lire ( 2 )) print ( \"quatri\u00e8me \u00e9l\u00e9ment :\" , L1 . lire ( 3 )) Utilisation de m\u00e9thodes sp\u00e9ciales \u2693\ufe0e On peut utiliser les m\u00e9thodes sp\u00e9ciales __len__ et __getitem__ \u00e0 la place des m\u00e9thodes taille et lire afin d'utiliser la syntaxe habituelle de Python en \u00e9crivant : - len(L) pour obtenir la longueur d'une liste L au lieu de L.taille() - L[i] pour acc\u00e9der au i -\u00e8me \u00e9l\u00e9ment d'une liste L au lieu de L.lire(i) . Question 8 Enonc\u00e9e Solution Remplacez les m\u00e9thodes taille et lire par les m\u00e9thodes __len__ et __getitem__ . V\u00e9rifiez ensuite si tout fonctionne comme avec des list Python. \ud83d\udc0d Script Python # \u00e0 compl\u00e9ter class ListeChainee : \"\"\"Manipulation de listes cha\u00een\u00e9es\"\"\" def __init__ ( self ): \"\"\"Initialise une liste vide.\"\"\" self . tete = None def ajouter_en_tete ( self , e ): \"\"\"Ins\u00e8re e en t\u00eate de liste en cr\u00e9ant une nouvelle cellule\"\"\" nouvelle_cellule = Cellule ( e , self . tete ) self . tete = nouvelle_cellule def est_vide ( self ): \"\"\"Renvoie True si la liste est vide, False sinon\"\"\" return self . tete is None def premier ( self ): \"\"\"Renvoie le premier \u00e9l\u00e9ment de la liste (sa t\u00eate) si cette derni\u00e8re est non vide\"\"\" assert self . premier is not None , \"une liste vide n'a pas de t\u00eate\" return self . tete . valeur def reste ( self ): \"\"\"Renvoie le reste de la liste (sa queue) si cette derni\u00e8re est non vide.\"\"\" assert self . tete is not None , \"une liste vide n'a pas de queue\" r = ListeChainee () r . tete = self . tete . suivante return r def taille ( self ): return longueur ( self . tete ) def lire ( self , i ): return niemeElement ( self . tete , i ) \ud83d\udc0d Script Python # \u00e0 compl\u00e9ter class ListeChainee : \"\"\"Manipulation de listes cha\u00een\u00e9es\"\"\" def __init__ ( self ): \"\"\"Initialise une liste vide.\"\"\" self . tete = None def ajouter_en_tete ( self , e ): \"\"\"Ins\u00e8re e en t\u00eate de liste en cr\u00e9ant une nouvelle cellule\"\"\" nouvelle_cellule = Cellule ( e , self . tete ) self . tete = nouvelle_cellule def est_vide ( self ): \"\"\"Renvoie True si la liste est vide, False sinon\"\"\" return self . tete is None def premier ( self ): \"\"\"Renvoie le premier \u00e9l\u00e9ment de la liste (sa t\u00eate) si cette derni\u00e8re est non vide\"\"\" assert self . premier is not None , \"une liste vide n'a pas de t\u00eate\" return self . tete . valeur def reste ( self ): \"\"\"Renvoie le reste de la liste (sa queue) si cette derni\u00e8re est non vide.\"\"\" assert self . tete is not None , \"une liste vide n'a pas de queue\" r = ListeChainee () r . tete = self . tete . suivante return r def longueur ( self ): return longueur ( self . tete ) def taille ( self ): return longueur ( self . tete ) def lire ( self , i ): return niemeElement ( self . tete , i ) def __repr__ ( self ): return str ( liste_elements ( self . tete )) def __len__ ( self ): return self . taille () def __getitem__ ( self , i ): return self . lire ( i ) \ud83d\udc0d Script Python # ESSAIS L1 = ListeChainee () L1 . ajouter_en_tete ( 25 ) L1 . ajouter_en_tete ( 29 ) L1 . ajouter_en_tete ( 27 ) L1 . ajouter_en_tete ( 18 ) L1 . ajouter_en_tete ( 4 ) L1 . ajouter_en_tete ( 32 ) L1 . ajouter_en_tete ( 6 ) L1 . ajouter_en_tete ( 16 ) print ( L1 ) print ( \"taille :\" , L1 . taille ()) print ( len ( L1 )) print ( L1 [ 2 ]) Supprimer en t\u00eate et ajouter en queue \u2693\ufe0e Nous terminons par l'\u00e9criture de deux m\u00e9thodes qui peuvent se r\u00e9v\u00e9ler utiles (pour la suite de l'ann\u00e9e). Il s'agit des m\u00e9thodes : supprimer_en_tete(self) qui permet de supprimer l'\u00e9l\u00e9ment de t\u00eate d'une liste ajouter_en_queue(self, e) qui permet d'ajouter l'\u00e9l\u00e9ment e en queue de liste Question 9 Enonc\u00e9 Solution Expliquez, par des phrases et/ou un sch\u00e9ma, ce qu'il faut faire pour supprimer l'\u00e9l\u00e9ment de t\u00eate (la cellule de t\u00eate) d'une liste L . On doit faire pointer la t\u00eate de liste vers la deuxi\u00e8me cellule dont la r\u00e9f\u00e9rence se trouve dans l'attribut suivante de la premi\u00e8re cellule c'est-\u00e0-dire L.premier.suivante . Question 10 Enonc\u00e9 Solution Expliquez, par des phrases et/ou un sch\u00e9ma, ce qu'il faut faire pour ajouter l'\u00e9l\u00e9ment e en queue d'une liste L . Il faut parcourir toutes les cellules jusqu'\u00e0 la derni\u00e8re, celle qui pointe vers None . On cr\u00e9e une nouvelle cellule . Il suffit de faire pointer cette derni\u00e8re cellule (en modifiant son attribut suivante vers une nouvelle cellule que l'on cr\u00e9e avec l'attribut valeur \u00e9gal \u00e0 e et l'attribut suivante qui pointe vers None . Question 11 Enonc\u00e9 Solution Ajoutez ces deux m\u00e9thodes dans la classe Liste (l'ajout en queue est beaucoup plus difficile). \ud83d\udc0d Script Python #Code complet class Cellule : def __init__ ( self , valeur , suivante ): self . valeur = valeur self . suivante = suivante def longueur ( chaine ): n = 0 courante = chaine # la cellule courante pointe vers chaine qui pointe vers la premi\u00e8re cellule ou None while courante is not None : # tant que la cellule courante ne pointe par vers None courante = courante . suivante # on passe \u00e0 la cellule suivante n = n + 1 # la longueur augmente d'une unit\u00e9 return n def affiche ( chaine ): if chaine . suivante == None : return f \" { chaine . valeur } -> None\" else : return f \" { chaine . valeur } -> { affiche ( chaine . suivante ) } \" def liste_elements ( chaine ): \"\"\"Renvoie une list Python contenant tous les \u00e9l\u00e9ments de la liste cha\u00een\u00e9e L >>> liste_elements(Cellule(1, Cellule(2, Cellule(3, None)))) [1, 2, 3] >>> liste_elements(Cellule(12, Cellule(14, Cellule(8, Cellule(7, Cellule(19, Cellule(22, None))))))) [12, 14, 8, 7, 19, 22] \"\"\" L = [] courante = chaine while courante is not None : L . append ( courante . valeur ) courante = courante . suivante return L def niemeElement ( chaine , i ) : assert chaine != None if i == 0 : return chaine . valeur else : return niemeElement ( chaine . suivante , i - 1 ) class ListeChainee : \"\"\"Manipulation de listes cha\u00een\u00e9es\"\"\" # ---------- OPERATIONS PRIMITIVES ------------------ def __init__ ( self ): \"\"\"Initialise une liste vide.\"\"\" self . tete = None def ajouter_en_tete ( self , e ): \"\"\"Ins\u00e8re e en t\u00eate de liste en cr\u00e9ant une nouvelle cellule\"\"\" nouvelle_cellule = Cellule ( e , self . tete ) self . tete = nouvelle_cellule def est_vide ( self ): \"\"\"Renvoie True si la liste est vide, False sinon\"\"\" return self . tete is None def premier ( self ): \"\"\"Renvoie le premier \u00e9l\u00e9ment de la liste (sa t\u00eate) si cette derni\u00e8re est non vide\"\"\" assert self . premier is not None , \"une liste vide n'a pas de t\u00eate\" return self . tete . valeur def reste ( self ): \"\"\"Renvoie le reste de la liste (sa queue) si cette derni\u00e8re est non vide.\"\"\" assert self . tete is not None , \"une liste vide n'a pas de queue\" r = ListeChainee () r . tete = self . tete . suivante return r # ---------- AUTRES OPERATIONS ------------------ def longueur ( self ): return longueur ( self . tete ) def taille ( self ): return longueur ( self . tete ) def lire ( self , i ): return niemeElement ( self . tete , i ) #def __repr__(self): # return str(liste_elements(self.tete)) # Une autre repr\u00e9sentation possible def __repr__ ( self ): ch = \"\" courante = self . tete for k in range ( self . taille ()): ch = ch + \" -> \" + str ( courante . valeur ) courante = courante . suivante return ch [ 4 :] # pour enlever les 4 caract\u00e8res \" -> \" du d\u00e9but def __len__ ( self ): return self . taille () def __getitem__ ( self , i ): return self . lire ( i ) def supprimer_en_tete ( self ): \"\"\"Supprime l'\u00e9l\u00e9ment en t\u00eate de liste, celle-ci \u00e9tant non vide\"\"\" assert self . tete is not None , \"on ne peut pas supprimer d'\u00e9l\u00e9ment d'une liste vide\" self . tete = self . tete . suivante def ajouter_en_queue ( self , e ): \"\"\"Ajoute l'\u00e9l\u00e9ment e en queue de liste\"\"\" courante = self . tete if courante is None : # si la liste est vide self . ajouter_en_tete ( e ) # on ajoute e en t\u00eate else : while courante . suivante is not None : # sinon on parcourt la liste jusqu'au dernier \u00e9l\u00e9ment courante = courante . suivante derniere_cellule = Cellule ( e , None ) courante . suivante = derniere_cellule \ud83d\udc0d Script Python # ESSAIS L = ListeChainee () L . ajouter_en_tete ( 22 ) L . ajouter_en_tete ( 19 ) L . ajouter_en_tete ( 7 ) L . ajouter_en_tete ( 8 ) L . ajouter_en_tete ( 14 ) L . ajouter_en_tete ( 12 ) print ( L ) L . supprimer_en_tete () print ( L ) L . ajouter_en_queue ( 5 ) print ( L ) #L.supprimer_en_tete() #print(L) \ud83d\udccb Texte 12 -> 14 -> 8 -> 7 -> 19 -> 22 14 -> 8 -> 7 -> 19 -> 22 14 -> 8 -> 7 -> 19 -> 22 -> 5 \u27a1 Cr\u00e9ation d'un module listechainee \u2693\ufe0e Cr\u00e9ez un module listechainee.py qui peut \u00eatre import\u00e9 dans un autre programme Python et qui permet de manipuler la classe ListeChainee ainsi cr\u00e9\u00e9e (avec toutes les m\u00e9thodes). Attention \u00e0 ne rien oublier, la classe ListeChainee fait appel \u00e0 des fonctions et classe externes. \u27a1 Bilan \u2693\ufe0e BILAN On a impl\u00e9ment\u00e9 une classe ListeChainee qui impl\u00e9mente le type abstrait liste avec des listes cha\u00een\u00e9es qui sont des cha\u00eenes de plusieurs cellules de la classe Cellule . Chaque cellule poss\u00e8de une valeur et une r\u00e9f\u00e9rence vers la cellule suivante. Les objets de la classe ListeChainee pointent vers la premi\u00e8re cellule d'une cha\u00eene, ou vers None pour d\u00e9signer une liste vide. L'int\u00e9r\u00eat d'une liste cha\u00een\u00e9e, par rapport \u00e0 une impl\u00e9mentation avec un tableau dynamique ( list Python), se trouve dans les op\u00e9rations d'ajout et suppression en d\u00e9but de liste (ajout, suppression) qui sont moins co\u00fbteuses car ne n\u00e9cessitent pas de d\u00e9caler tous les \u00e9l\u00e9ments qui suivent. La cr\u00e9ation du module listechainee permet de manipuler des listes (impl\u00e9ment\u00e9es par des listes cha\u00een\u00e9es) en important la classe ListeChainee du module. Une fois import\u00e9e, cette classe masque totalement l'impl\u00e9mentation avec des cellules formant des listes cha\u00een\u00e9es. N\u00e9anmoins, le savoir permet de privil\u00e9gier certaines op\u00e9rations moins co\u00fbteuses qu'avec une impl\u00e9mentation avec des tableaux redimensionnables ( list Python). \u27a1 Pour aller plus loin \u2693\ufe0e On pourrait programmer pour notre classe ListeChainee , les autres op\u00e9rations disponibles pour le type pr\u00e9d\u00e9fini list de Python. Par exemple : la suppression en queue l'ajout/la suppression en position i la concat\u00e9nation l'inversion etc. On se rapprocherait ainsi du type list de Python mais il faut garder en t\u00eate que le co\u00fbt de certaines op\u00e9rations n'est pas forc\u00e9ment le m\u00eame : rapide en fin de liste mais co\u00fbteux en d\u00e9but pour les list Python, alors que c'est le contraire pour les listes cha\u00een\u00e9es de notre classe ListeChainee .","title":"TD - Impl\u00e9mentation d'une *liste* par une liste cha\u00een\u00e9e"},{"location":"epreuve_pratique/","text":"\u00c9preuve pratique \u2693\ufe0e Modalit\u00e9s \u2693\ufe0e Textes r\u00e8glementaires https://www.education.gouv.fr/bo/20/Special2/MENE2001797N.htm?cid_bo=149244 Dur\u00e9e : 1 heure L'\u00e9preuve pratique donne lieu \u00e0 une note sur 8 points , qui s'ajouteront aux 12 points de l'\u00e9preuve \u00e9crite. La partie pratique consiste en la r\u00e9solution de deux exercices sur ordinateur , chacun \u00e9tant not\u00e9 sur 4 points . Le candidat est \u00e9valu\u00e9 sur la base d\u2019un dialogue avec un professeur-examinateur. Un examinateur \u00e9value au maximum quatre \u00e9l\u00e8ves. L\u2019examinateur ne peut pas \u00e9valuer un \u00e9l\u00e8ve qu\u2019il a eu en classe durant l\u2019ann\u00e9e en cours. L\u2019\u00e9valuation de cette partie se d\u00e9roule au cours du deuxi\u00e8me trimestre pendant la p\u00e9riode de l\u2019\u00e9preuve \u00e9crite de sp\u00e9cialit\u00e9. Premier exercice Le premier exercice consiste \u00e0 programmer un algorithme figurant explicitement au programme, ne pr\u00e9sentant pas de difficult\u00e9 particuli\u00e8re, dont on fournit une sp\u00e9cification. Il s\u2019agit donc de restituer un algorithme rencontr\u00e9 et travaill\u00e9 \u00e0 plusieurs reprises en cours de formation. Le sujet peut proposer un jeu de test avec les r\u00e9ponses attendues pour permettre au candidat de v\u00e9rifier son travail. Deuxi\u00e8me exercice Pour le second exercice, un programme est fourni au candidat. Cet exercice ne demande pas l\u2019\u00e9criture compl\u00e8te d\u2019un programme, mais permet de valider des comp\u00e9tences de programmation suivant des modalit\u00e9s vari\u00e9es : le candidat doit, par exemple, compl\u00e9ter un programme \u00ab \u00e0 trous \u00bb afin de r\u00e9pondre \u00e0 une sp\u00e9cification donn\u00e9e, ou encore compl\u00e9ter un programme pour le documenter, ou encore compl\u00e9ter un programme en ajoutant des assertions, etc. Banque d'exercices \u2693\ufe0e Textes r\u00e8glementaires https://eduscol.education.fr/2661/banque-des-epreuves-pratiques-de-specialite-nsi La banque d'exercices est publique et peut \u00eatre t\u00e9l\u00e9charg\u00e9e en un pdf unique ici .","title":"\u00c9preuve pratique"},{"location":"epreuve_pratique/#epreuve-pratique","text":"","title":"\u00c9preuve pratique"},{"location":"memento_sql/","text":"Memento SQL \u2693\ufe0e Ce document n'a pas la vocation d'\u00eatre exhaustif. On pourra se r\u00e9f\u00e9rer \u00e0 ce site afin de le compl\u00e9ter et avoir plus de d\u00e9tails. Dans certains dialectes SQL , les points-virgules en fin de ligne sont indispensables m\u00eame s'il n'y a qu'une seule instruction. Bien que n'utilisions ici que des instructions uniques, on \u00e9crit tout de m\u00eame les points-virgules en fin de ligne. Liens directs : \u2693\ufe0e Cr\u00e9ation d'une base de donn\u00e9es Cr\u00e9ation de tables Afficher toute une table Effacer une base, une table Insertion de valeurs Suppression de valeurs Mise \u00e0 jour de valeurs S\u00e9lections Cr\u00e9ation d'une base de donn\u00e9es \u2693\ufe0e La base n'existe pas : \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE DATABASE ma_base ; Au cas o\u00f9 la base existe et que l'on ne souhaite pas l'\u00e9craser : \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE DATABASE IF NOT EXISTS ma_base ; Cr\u00e9ation de tables \u2693\ufe0e Cas de base : \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE TABLE ma_table ( attribut_1 INTEGER PRIMARY KEY AUTOINCREMENT , attribut_2 TEXT , attribut_3 VARCHAR ( 50 ) ); L\u00e0 encore on peut ajouter l'argument IF NOT EXISTS . Cl\u00e9 primaire multiple : \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE TABLE ma_table ( attribut_1 INTEGER , attribut_2 TEXT , attribut_3 VARCHAR ( 50 ), PRIMARY KEY ( attribut_1 , attribut_2 ) ); Cl\u00e9 \u00e9trang\u00e8re : \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE TABLE ma_table ( attribut_1 INTEGER PRIMARY KEY AUTOINCREMENT , attribut_2 TEXT , attribut_3 VARCHAR ( 50 ), FOREIGN KEY ( attribut_1 ) REFERENCES autre_table ( attribut_de_reference ) ); Afficher toute une table \u2693\ufe0e On effectue une requ\u00eate : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT * FROM ma_table ; Effacer une base, une table \u2693\ufe0e Une base : \ud83d\uddc2\ufe0f Requ\u00eate SQL DROP DATABASE ma_base ; Une table : \ud83d\uddc2\ufe0f Requ\u00eate SQL DROP TABLE ma_table ; Insertion de valeurs \u2693\ufe0e On renseigne touts les attributs dans l'ordre de leur cr\u00e9ation : \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO ma_table VALUES ( valeur_1 , valeur_2 , valeur_3 ); On ne renseigne que les attributs cit\u00e9s dans l'ordre souhait\u00e9 : \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO ma_table ( attribut_3 , attribut_1 ) VALUES ( valeur_3 , valeur_1 ); Insertion de plusieurs lignes : \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO ma_table ( attribut_3 , attribut_1 ) VALUES ( valeur_3_1 , valeur_1_1 ), ( valeur_3_2 , valeur_1_2 ), ( valeur_3_3 , valeur_1_3 ); Suppression de valeurs \u2693\ufe0e On supprime des entr\u00e9es, des lignes, en pr\u00e9cisant une condition (ici les entr\u00e9es dont l' attribut_1 vaut 8 ) : \ud83d\uddc2\ufe0f Requ\u00eate SQL DELETE FROM ma_table WHERE attribut_1 = 8 ; Mise \u00e0 jour de valeurs \u2693\ufe0e Modification de la valeur pour toutes les lignes d'une table : \ud83d\uddc2\ufe0f Requ\u00eate SQL UPDATE ma_table SET attribut_1 = valeur_1 ; Modification de la valeur en posant une condition : \ud83d\uddc2\ufe0f Requ\u00eate SQL UPDATE ma_table SET attribut_1 = valeur_1 WHERE condition ; S\u00e9lections \u2693\ufe0e Cas de base \u2693\ufe0e Tous les attributs : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT * FROM ma_table ; Seulement certains attributs : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT attribut_1 , attribut_3 FROM ma_table ; Avec une condition : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT attribut_1 , attribut_3 FROM ma_table WHERE attribut_2 = valeur_2 ; On peut utiliser les op\u00e9rateurs = (attention, un seul symbole contrairement au == de Python), <> (plusieurs syst\u00e8mes de gestion de BDD acceptent aussi != ), > , < , >= , <= , AND , OR . Les cha\u00eenes de caract\u00e8res : L'usage veut que l'on d\u00e9limite les cha\u00eenes de caract\u00e8res par des guillemets simples : 'chaine' . Les guillemets doubles sont r\u00e9serv\u00e9s aux noms de tables, d'attributs : \"attribut_1\" = 'chaine' . Dans les faits, cela ne change pas grand chose ! En cas de stricte \u00e9galit\u00e9 : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT attribut_1 , attribut_3 FROM ma_table WHERE attribut_2 = 'chat' Si l'on cherche les cha\u00eenes d\u00e9butant par 'chat' ( chat , chatte , chaton ...): \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT attribut_1 , attribut_3 FROM ma_table WHERE attribut_2 LIKE 'chat%' Si l'on cherche les cha\u00eenes se terminant par 'chat' ( achat , le chat ...): \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT attribut_1 , attribut_3 FROM ma_table WHERE attribut_2 LIKE '%chat' Fonctions d'agr\u00e9gation \u2693\ufe0e Compter les lignes v\u00e9rifiant une condition : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT COUNT ( * ) FROM ma_table WHERE condition ; Regrouper toutes les lignes selon la valeur d'un attribut : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT COUNT ( * ) FROM ma_table WHERE condition GROUP BY attribut_1 ; La maximum d'un attribut : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT MAX ( attribut_1 ) FROM ma_table WHERE condition ; Il existe aussi la fonction MIN . La somme d'un attribut : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT SUM ( attribut_1 ) FROM ma_table WHERE condition ; La moyenne d'un attribut : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT AVG ( attribut_1 ) FROM ma_table WHERE condition ; Trier les donn\u00e9es : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT attribut_1 FROM ma_table WHERE condition ORDER BY attribut_2 ASC ; ASC pour ASCENDING et l'ordre croissant. Utiliser DESC pour l'ordre d\u00e9croissant. N'afficher que les 10 premiers r\u00e9sultats : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT attribut_1 FROM ma_table WHERE condition LIMIT 10 ; Jointures \u2693\ufe0e Mettre en correspondance plusieurs tables gr\u00e2ce aux cl\u00e9s \u00e9trang\u00e8res : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT table_1 . attribut_1 , table_2 . attribut_3 FROM table_1 JOIN table_2 ON table_1 . attribut_1 = table_2 . attribut_de_reference JOIN table_3 ON table_2 . attribut_2 = table_3 . attribut_de_reference ; On pr\u00e9cise \u00e0 quelles tables appartiennent les attributs afin de lever les ambigu\u00eft\u00e9s si deux tables ont des attributs portant le m\u00eame nom.","title":"\ud83d\udca1 Memento SQL"},{"location":"memento_sql/#memento-sql","text":"Ce document n'a pas la vocation d'\u00eatre exhaustif. On pourra se r\u00e9f\u00e9rer \u00e0 ce site afin de le compl\u00e9ter et avoir plus de d\u00e9tails. Dans certains dialectes SQL , les points-virgules en fin de ligne sont indispensables m\u00eame s'il n'y a qu'une seule instruction. Bien que n'utilisions ici que des instructions uniques, on \u00e9crit tout de m\u00eame les points-virgules en fin de ligne.","title":"Memento SQL"},{"location":"01_lycee/lycee/","text":"Base de donn\u00e9e d'un lyc\u00e9e \u2693\ufe0e On souhaite cr\u00e9er une base de donn\u00e9e permettant de stocker les informations d\u00e9crivant les \u00e9l\u00e8ves d'un lyc\u00e9e ainsi que leur classe. Un \u00e9l\u00e8ve est d\u00e9crit par : un identifiant unique (un entier) ; son nom ; son pr\u00e9nom ; sa classe. Une classe est d\u00e9crite par : un identifiant unique (un entier) ; son nom (par exemple \u00ab Terminale 2 \u00bb) ; son niveau, nombre entier (2 pour les secondes, 1 pour les premi\u00e8res, 0 pour les terminales) ; sa fili\u00e8re (\u00ab G\u00e9n\u00e9rale \u00bb, \u00ab STI2D \u00bb, etc ...). Les classes de secondes seront dans la fili\u00e8re \u00ab Seconde \u00bb. Afin d'\u00e9viter les r\u00e9p\u00e9titions dans les tables, les informations sur les fili\u00e8res seront regroup\u00e9es dans une table s\u00e9par\u00e9e. La structure de la base est donc la suivante : Table filieres : id : identifiant (nombre entier, cl\u00e9 primaire) ; filiere : description de la fili\u00e8re (texte). Table classes : id : identifiant (nombre entier, cl\u00e9 primaire) ; nom : nom de la classe (texte) ; niveau : niveau de la classe (nombre entier) ; filiere : fili\u00e8re de la classe (entier, cl\u00e9 \u00e9trang\u00e8re faisant r\u00e9f\u00e9rence \u00e0 filieres.id ). Table eleves : id : identifiant (nombre entier, cl\u00e9 primaire) ; nom : nom de l'\u00e9l\u00e8ve (texte) ; prenom : pr\u00e9nom de l'\u00e9l\u00e8ve (texte) ; classe : classe de l'\u00e9l\u00e8ve (entier, cl\u00e9 \u00e9trang\u00e8re faisant r\u00e9f\u00e9rence \u00e0 classes.id ). Cr\u00e9ation des tables \u2693\ufe0e L'instruction SQL permettant de cr\u00e9er la table filieres est : var lycee = new Worker(path + \"/js/worker.sql-wasm.js\"); SQL CREATE TABLE filieres ( id INTEGER PRIMARY KEY AUTOINCREMENT, filiere TEXT ) Ex\u00e9cuter onElementLoaded(\"div#ide1\").then(() => { const ide = document.querySelector(\"div#ide1\"); load(ide, 'https:/e-nsi.forge.aeif.fr/exercices_bdd/01_lycee/lycee.db', '', '', lycee); }).catch(() => {}); Ex\u00e9cuter cette cellule puis afficher ci-dessous le contenu de la table filieres . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide2\").then(() => { const ide = document.querySelector(\"div#ide2\"); load(ide, '/', '', '', lycee); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT * FROM filieres ; La requ\u00eate s'est ex\u00e9cut\u00e9e normalement mais on obtient aucune sortie car la table est vide ! Elle sera peupl\u00e9e plus bas. Cr\u00e9er la table classes . D\u00e9clarer une cl\u00e9 \u00e9trang\u00e8re La d\u00e9claration d'une cl\u00e9 \u00e9trang\u00e8re se fait ainsi : FOREIGN KEY (attribut) REFERENCES table_etrangere (attribut) . Dans le cas pr\u00e9sent, on rajoutera donc : FOREIGN KEY (filiere) REFERENCES filieres (id) . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide3\").then(() => { const ide = document.querySelector(\"div#ide3\"); load(ide, '/', '', '', lycee); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE TABLE classes ( id INTEGER PRIMARY KEY AUTOINCREMENT , nom TEXT , niveau INTEGER , filiere INTEGER , FOREIGN KEY ( filiere ) REFERENCES filieres ( id ) ); Cr\u00e9er la table eleves . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide4\").then(() => { const ide = document.querySelector(\"div#ide4\"); load(ide, '/', '', '', lycee); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE TABLE eleves ( id INTEGER PRIMARY KEY AUTOINCREMENT , nom TEXT , prenom TEXT , classe INTEGER , FOREIGN KEY ( classe ) REFERENCES classes ( id ) ); Peuplement des tables \u2693\ufe0e Les tables \u00e9tant cr\u00e9\u00e9es, il faut d\u00e9sormais les peupler. Nous utiliserons la structure suivante : \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO table ( attribut_1 , attribut_2 , ...) VALUES ( valeur_1 , valeur_2 , ...), ( valeur_1 , valeur_2 , ...), ... Il ne faut bien entendu pas recopier les points de suspension ! Par exemple pour ins\u00e9rer les fili\u00e8res : SQL INSERT INTO filieres (filiere) VALUES (\"Seconde\"), (\"G\u00e9n\u00e9rale\"), (\"SI\"), (\"STI2D\") Ex\u00e9cuter onElementLoaded(\"div#ide5\").then(() => { const ide = document.querySelector(\"div#ide5\"); load(ide, '/', '', '', lycee); }).catch(() => {}); Ex\u00e9cuter cette cellule puis afficher ci-dessous le contenu de la table filieres . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide6\").then(() => { const ide = document.querySelector(\"div#ide6\"); load(ide, '/', '', '', lycee); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT * FROM filieres ; Cette fois-ci on a bien un r\u00e9sultat. On se propose de cr\u00e9er trois classes : la Seconde 1, la Premi\u00e8re 2 (de fili\u00e8re \u00ab STI2D \u00bb), la Terminale 3 (de fili\u00e8re \u00ab G\u00e9n\u00e9rale \u00bb). Une classe est caract\u00e9ris\u00e9e par les attributs id , nom , niveau et filiere . L' id \u00e9tant la cl\u00e9 primaire et auto-incr\u00e9ment\u00e9e, elle est g\u00e9r\u00e9e automatiquement par le syst\u00e8me de gestion de la base de donn\u00e9es. Il n'est donc pas n\u00e9cessaire d'ins\u00e9rer les id . L'attribut filiere est quant \u00e0 lui une cl\u00e9 \u00e9trang\u00e8re . On ne peut donc pas utiliser la valeur 'STI2D' pour cet attribut lors de l'insertion de la Premi\u00e8re 2. Il faut utiliser la valeur correspondant \u00e0 la cl\u00e9 \u00e9trang\u00e8re de r\u00e9f\u00e9rence dans la table filieres . Si par exemple on constate que dans la table filieres , STI2D est associ\u00e9 \u00e0 l' id 4 on fera : INSERT INTO classes (nom, niveau, filiere) VALUES ('Premi\u00e8re 2', 1, 4) . On a fourni 4 comme valeur de l'attribut filiere . Ins\u00e9rer les valeurs dans la table classes . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide7\").then(() => { const ide = document.querySelector(\"div#ide7\"); load(ide, '/', '', '', lycee); }).catch(() => {}); R\u00e9ponse On consid\u00e8re que la fili\u00e8re \u00ab Seconde \u00bb a pour id le 1 , 2 pour \u00ab G\u00e9n\u00e9rale \u00bb et 4 pour \u00ab STI2D \u00bb. \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO classes ( nom , niveau , filiere ) VALUES ( \"Seconde 1\" , 2 , 1 ), ( \"Premi\u00e8re 2\" , 1 , 4 ), ( \"Terminale 3\" , 0 , 2 ); Ins\u00e9rer les \u00e9l\u00e8ves suivants dans la base : Nom Pr\u00e9nom Classe Faux Marc Terminale 3 Bidon Paul Premi\u00e8re 2 Fake Marie Seconde 1 False Isabelle Premi\u00e8re 2 Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide8\").then(() => { const ide = document.querySelector(\"div#ide8\"); load(ide, '/', '', '', lycee); }).catch(() => {}); R\u00e9ponse On consid\u00e8re que la classe \u00ab Seconde 1\" a pour id le 1 , 2 pour \u00ab Premi\u00e8re 2\" et 3 pour Terminale 3 . \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO eleves ( nom , prenom , classe ) VALUES ( \"Faux\" , \"Marc\" , 3 ), ( \"Bidon\" , \"Paul\" , 2 ), ( \"Fake\" , \"Marie\" , 1 ), ( \"False\" , \"Isabelle\" , 2 ); Mise \u00e0 jour de valeurs \u2693\ufe0e Le proviseur du lyc\u00e9e souhaite changer la d\u00e9nomination des classes : il souhaite utiliser des lettres \u00e0 la place des num\u00e9ros. Il faut donc mettre \u00e0 jour les donn\u00e9es. La structure d'une instruction SQL de mise \u00e0 jour est : UPDATE table SET attribut = nouvelle_valeur WHERE condition . Par exemple, pour renommer la \u00ab Seconde 1\" en \u00ab Seconde A\" : SQL UPDATE classes SET nom = 'Seconde A' WHERE nom = 'Seconde 1' Ex\u00e9cuter onElementLoaded(\"div#ide9\").then(() => { const ide = document.querySelector(\"div#ide9\"); load(ide, '/', '', '', lycee); }).catch(() => {}); Mettre \u00e0 jour les autres noms de classes : \u00ab Premi\u00e8re 2\" devient \u00ab Premi\u00e8re B\", \u00ab Terminale 3\" devient \u00ab Terminale C\". Astuce Il est possible de saisir plusieurs instructions \u00e0 la suite en les s\u00e9parant avec un ; Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide10\").then(() => { const ide = document.querySelector(\"div#ide10\"); load(ide, '/', '', '', lycee); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL UPDATE classes SET nom = \"Premi\u00e8re B\" WHERE nom = \"Premi\u00e8re 2\" ; UPDATE classes SET nom = \"Terminale C\" WHERE nom = \"Terminale 3\" ;","title":"Lyc\u00e9e"},{"location":"01_lycee/lycee/#base-de-donnee-dun-lycee","text":"On souhaite cr\u00e9er une base de donn\u00e9e permettant de stocker les informations d\u00e9crivant les \u00e9l\u00e8ves d'un lyc\u00e9e ainsi que leur classe. Un \u00e9l\u00e8ve est d\u00e9crit par : un identifiant unique (un entier) ; son nom ; son pr\u00e9nom ; sa classe. Une classe est d\u00e9crite par : un identifiant unique (un entier) ; son nom (par exemple \u00ab Terminale 2 \u00bb) ; son niveau, nombre entier (2 pour les secondes, 1 pour les premi\u00e8res, 0 pour les terminales) ; sa fili\u00e8re (\u00ab G\u00e9n\u00e9rale \u00bb, \u00ab STI2D \u00bb, etc ...). Les classes de secondes seront dans la fili\u00e8re \u00ab Seconde \u00bb. Afin d'\u00e9viter les r\u00e9p\u00e9titions dans les tables, les informations sur les fili\u00e8res seront regroup\u00e9es dans une table s\u00e9par\u00e9e. La structure de la base est donc la suivante : Table filieres : id : identifiant (nombre entier, cl\u00e9 primaire) ; filiere : description de la fili\u00e8re (texte). Table classes : id : identifiant (nombre entier, cl\u00e9 primaire) ; nom : nom de la classe (texte) ; niveau : niveau de la classe (nombre entier) ; filiere : fili\u00e8re de la classe (entier, cl\u00e9 \u00e9trang\u00e8re faisant r\u00e9f\u00e9rence \u00e0 filieres.id ). Table eleves : id : identifiant (nombre entier, cl\u00e9 primaire) ; nom : nom de l'\u00e9l\u00e8ve (texte) ; prenom : pr\u00e9nom de l'\u00e9l\u00e8ve (texte) ; classe : classe de l'\u00e9l\u00e8ve (entier, cl\u00e9 \u00e9trang\u00e8re faisant r\u00e9f\u00e9rence \u00e0 classes.id ).","title":"Base de donn\u00e9e d'un lyc\u00e9e"},{"location":"02_imdb/imdb/","text":"Les notes des 250 meilleures s\u00e9ries selon IMDB \u2693\ufe0e Le jeu de donn\u00e9es disponible ici recense les notes attribu\u00e9es par les utilisateurs du site IMDB \u00e0 250 s\u00e9ries. Les deux fichiers CSV disponibles sur le site ont \u00e9t\u00e9 r\u00e9organis\u00e9s en trois fichiers : shows.csv : contient les informations d\u00e9crivant chacune des s\u00e9rie (son code et son titre, l'un et l'autre au format texte) global_ratings.csv : contient les notes attribu\u00e9es \u00e0 chaque s\u00e9rie ainsi que le nombre de votants. Les s\u00e9ries sont d\u00e9sign\u00e9es par un code faisant r\u00e9f\u00e9rence au code utilis\u00e9 dans le fichier pr\u00e9c\u00e9dent. Les notes sont des nombres d\u00e9cimaux et le nombre de votants des entiers. episode_ratings.csv : contient les notes attribu\u00e9es \u00e0 chaque \u00e9pisode de chaque saison de chaque s\u00e9rie. L\u00e0 encore, les s\u00e9ries sont d\u00e9sign\u00e9es par le code utilis\u00e9 dans le fichier shows.csv . Les num\u00e9ros de saison, d'\u00e9pisode sont des entiers. Les notes sont des nombres d\u00e9cimaux. La base de donn\u00e9es imdb_ratings est d\u00e9j\u00e0 cr\u00e9\u00e9e. Elle ne contient pour l'instant aucune table. Combien faut-il cr\u00e9er de tables ? Cocher la ou les bonne(s) r\u00e9ponse(s) Solution Une Deux Trois \u274c Une \u274c Deux \u2705 Trois. Il faut cr\u00e9er une table par fichier csv . [Spoiler Alert] La ou les table(s) \u00e0 utiliser Les tables utilis\u00e9es dans la suite de l'exercice sont les suivantes : shows reprend les attributs et le contenu du fichier shows.csv ; global reprend les attributs et le contenu du fichier global_ratings.csv episodes reprend les attributs et le contenu du fichier episode_ratings.csv Quelle est la cl\u00e9 primaire de la table shows correspondant au fichier show.csv ? Cocher la ou les bonne(s) r\u00e9ponse(s) Solution L'attribut code L'attribut title Les deux attributs coupl\u00e9s L'un ou l'autre des deux attributs... \u274c L'attribut code \u274c L'attribut title \u274c Les deux attributs coupl\u00e9s \u2705 L'un ou l'autre des deux attributs... Quelle est la cl\u00e9 primaire de la table global correspondant au fichier global_ratings.csv ? Cocher la ou les bonne(s) r\u00e9ponse(s) Solution L'attribut code L'attribut rating L'attribut rating_count \u2705 L'attribut code \u274c L'attribut rating \u274c L'attribut rating_count Quelle est la cl\u00e9 primaire de la table episodes correspondant au fichier episode_ratings.csv ? Cocher la ou les bonne(s) r\u00e9ponse(s) Solution L'attribut code L'attribut season L'attribut episode L'attribut rating Il faut utiliser une cl\u00e9 multiple \u274c L'attribut code \u274c L'attribut season \u274c L'attribut episode \u274c L'attribut rating \u2705 Il faut utiliser une cl\u00e9 multiple. La cl\u00e9 est form\u00e9e des attributs (code, season, episodes) Quelles sont les cl\u00e9s \u00e9trang\u00e8res pr\u00e9sentes dans cette base de donn\u00e9es ? (on d\u00e9signe les attributs au format table.attribut ) Cocher la ou les bonne(s) r\u00e9ponse(s) Solution L'attribut shows.code fait r\u00e9f\u00e9rence \u00e0 global.code L'attribut global.code fait r\u00e9f\u00e9rence \u00e0 shows.code L'attribut global.rating fait r\u00e9f\u00e9rence \u00e0 episodes.rating L'attribut episodes.code fait r\u00e9f\u00e9rence \u00e0 shows.code \u274c L'attribut shows.code fait r\u00e9f\u00e9rence \u00e0 global.code \u2705 L'attribut global.code fait r\u00e9f\u00e9rence \u00e0 shows.code \u274c L'attribut global.rating fait r\u00e9f\u00e9rence \u00e0 episodes.rating \u2705 L'attribut episodes.code fait r\u00e9f\u00e9rence \u00e0 shows.code Cr\u00e9er la table shows . Votre r\u00e9ponse var imdb = new Worker(path + \"/js/worker.sql-wasm.js\"); SQL Ex\u00e9cuter onElementLoaded(\"div#ide1\").then(() => { const ide = document.querySelector(\"div#ide1\"); load(ide, 'https:/e-nsi.forge.aeif.fr/exercices_bdd/02_imdb/imdb_ratings.db', '', '', imdb); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE TABLE shows ( code TEXT , title TEXT , PRIMARY KEY ( code ) ); Cr\u00e9er la table global . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide2\").then(() => { const ide = document.querySelector(\"div#ide2\"); load(ide, '/', '', '', imdb); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE TABLE global ( code TEXT , rating REAL , rating_count INTEGER , PRIMARY KEY ( code ), FOREIGN KEY ( code ) REFERENCES shows ( code ) ); Cr\u00e9er la table episodes . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide3\").then(() => { const ide = document.querySelector(\"div#ide3\"); load(ide, '/', '', '', imdb); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE TABLE episodes ( code TEXT , season INTEGER , episode INTEGER , rating REAL , PRIMARY KEY ( code , season , episode ), FOREIGN KEY ( code ) REFERENCES shows ( code ) ); Importer les dix premi\u00e8res s\u00e9ries dans dans la table shows . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide4\").then(() => { const ide = document.querySelector(\"div#ide4\"); load(ide, '/', '', '', imdb); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO shows VALUES ( \"tt0995832\" , \"Generation Kill\" ), ( \"tt0080306\" , \"Yes Minister\" ), ( \"tt7259746\" , \"Queer Eye\" ), ( \"tt0397150\" , \"Garth Marenghi's Darkplace\" ), ( \"tt0459159\" , \"The Thick of It\" ), ( \"tt9544034\" , \"The Family Man\" ), ( \"tt0314979\" , \"Battlestar Galactica\" ), ( \"tt0112159\" , \"Neon Genesis Evangelion\" ), ( \"tt8289930\" , \"Formula 1: Drive to Survive\" ), ( \"tt0877057\" , \"Death Note\" );","title":"S\u00e9ries"},{"location":"02_imdb/imdb/#les-notes-des-250-meilleures-series-selon-imdb","text":"Le jeu de donn\u00e9es disponible ici recense les notes attribu\u00e9es par les utilisateurs du site IMDB \u00e0 250 s\u00e9ries. Les deux fichiers CSV disponibles sur le site ont \u00e9t\u00e9 r\u00e9organis\u00e9s en trois fichiers : shows.csv : contient les informations d\u00e9crivant chacune des s\u00e9rie (son code et son titre, l'un et l'autre au format texte) global_ratings.csv : contient les notes attribu\u00e9es \u00e0 chaque s\u00e9rie ainsi que le nombre de votants. Les s\u00e9ries sont d\u00e9sign\u00e9es par un code faisant r\u00e9f\u00e9rence au code utilis\u00e9 dans le fichier pr\u00e9c\u00e9dent. Les notes sont des nombres d\u00e9cimaux et le nombre de votants des entiers. episode_ratings.csv : contient les notes attribu\u00e9es \u00e0 chaque \u00e9pisode de chaque saison de chaque s\u00e9rie. L\u00e0 encore, les s\u00e9ries sont d\u00e9sign\u00e9es par le code utilis\u00e9 dans le fichier shows.csv . Les num\u00e9ros de saison, d'\u00e9pisode sont des entiers. Les notes sont des nombres d\u00e9cimaux. La base de donn\u00e9es imdb_ratings est d\u00e9j\u00e0 cr\u00e9\u00e9e. Elle ne contient pour l'instant aucune table. Combien faut-il cr\u00e9er de tables ? Cocher la ou les bonne(s) r\u00e9ponse(s) Solution Une Deux Trois \u274c Une \u274c Deux \u2705 Trois. Il faut cr\u00e9er une table par fichier csv . [Spoiler Alert] La ou les table(s) \u00e0 utiliser Les tables utilis\u00e9es dans la suite de l'exercice sont les suivantes : shows reprend les attributs et le contenu du fichier shows.csv ; global reprend les attributs et le contenu du fichier global_ratings.csv episodes reprend les attributs et le contenu du fichier episode_ratings.csv Quelle est la cl\u00e9 primaire de la table shows correspondant au fichier show.csv ? Cocher la ou les bonne(s) r\u00e9ponse(s) Solution L'attribut code L'attribut title Les deux attributs coupl\u00e9s L'un ou l'autre des deux attributs... \u274c L'attribut code \u274c L'attribut title \u274c Les deux attributs coupl\u00e9s \u2705 L'un ou l'autre des deux attributs... Quelle est la cl\u00e9 primaire de la table global correspondant au fichier global_ratings.csv ? Cocher la ou les bonne(s) r\u00e9ponse(s) Solution L'attribut code L'attribut rating L'attribut rating_count \u2705 L'attribut code \u274c L'attribut rating \u274c L'attribut rating_count Quelle est la cl\u00e9 primaire de la table episodes correspondant au fichier episode_ratings.csv ? Cocher la ou les bonne(s) r\u00e9ponse(s) Solution L'attribut code L'attribut season L'attribut episode L'attribut rating Il faut utiliser une cl\u00e9 multiple \u274c L'attribut code \u274c L'attribut season \u274c L'attribut episode \u274c L'attribut rating \u2705 Il faut utiliser une cl\u00e9 multiple. La cl\u00e9 est form\u00e9e des attributs (code, season, episodes) Quelles sont les cl\u00e9s \u00e9trang\u00e8res pr\u00e9sentes dans cette base de donn\u00e9es ? (on d\u00e9signe les attributs au format table.attribut ) Cocher la ou les bonne(s) r\u00e9ponse(s) Solution L'attribut shows.code fait r\u00e9f\u00e9rence \u00e0 global.code L'attribut global.code fait r\u00e9f\u00e9rence \u00e0 shows.code L'attribut global.rating fait r\u00e9f\u00e9rence \u00e0 episodes.rating L'attribut episodes.code fait r\u00e9f\u00e9rence \u00e0 shows.code \u274c L'attribut shows.code fait r\u00e9f\u00e9rence \u00e0 global.code \u2705 L'attribut global.code fait r\u00e9f\u00e9rence \u00e0 shows.code \u274c L'attribut global.rating fait r\u00e9f\u00e9rence \u00e0 episodes.rating \u2705 L'attribut episodes.code fait r\u00e9f\u00e9rence \u00e0 shows.code Cr\u00e9er la table shows . Votre r\u00e9ponse var imdb = new Worker(path + \"/js/worker.sql-wasm.js\"); SQL Ex\u00e9cuter onElementLoaded(\"div#ide1\").then(() => { const ide = document.querySelector(\"div#ide1\"); load(ide, 'https:/e-nsi.forge.aeif.fr/exercices_bdd/02_imdb/imdb_ratings.db', '', '', imdb); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE TABLE shows ( code TEXT , title TEXT , PRIMARY KEY ( code ) ); Cr\u00e9er la table global . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide2\").then(() => { const ide = document.querySelector(\"div#ide2\"); load(ide, '/', '', '', imdb); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE TABLE global ( code TEXT , rating REAL , rating_count INTEGER , PRIMARY KEY ( code ), FOREIGN KEY ( code ) REFERENCES shows ( code ) ); Cr\u00e9er la table episodes . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide3\").then(() => { const ide = document.querySelector(\"div#ide3\"); load(ide, '/', '', '', imdb); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE TABLE episodes ( code TEXT , season INTEGER , episode INTEGER , rating REAL , PRIMARY KEY ( code , season , episode ), FOREIGN KEY ( code ) REFERENCES shows ( code ) ); Importer les dix premi\u00e8res s\u00e9ries dans dans la table shows . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide4\").then(() => { const ide = document.querySelector(\"div#ide4\"); load(ide, '/', '', '', imdb); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO shows VALUES ( \"tt0995832\" , \"Generation Kill\" ), ( \"tt0080306\" , \"Yes Minister\" ), ( \"tt7259746\" , \"Queer Eye\" ), ( \"tt0397150\" , \"Garth Marenghi's Darkplace\" ), ( \"tt0459159\" , \"The Thick of It\" ), ( \"tt9544034\" , \"The Family Man\" ), ( \"tt0314979\" , \"Battlestar Galactica\" ), ( \"tt0112159\" , \"Neon Genesis Evangelion\" ), ( \"tt8289930\" , \"Formula 1: Drive to Survive\" ), ( \"tt0877057\" , \"Death Note\" );","title":"Les notes des 250 meilleures s\u00e9ries selon IMDB"},{"location":"31_prenoms/prenoms/","text":"Les pr\u00e9noms en France au XX-\u00e8me si\u00e8cle \u2693\ufe0e On consid\u00e8re dans ce sujet la base de donn\u00e9es prenoms . Cette base ne comporte qu'une table, naissances , qui contient des informations d\u00e9crivant des pr\u00e9noms des enfants n\u00e9s en France au XX-i\u00e8me si\u00e8cle. Cette base est t\u00e9l\u00e9chargeable au format sqlite ici . Les attributs de cette table sont : id : l'identifiant de l'entr\u00e9e (cl\u00e9 primaire); sexe : le sexe de l'enfant au format texte : Fille ou Gar\u00e7on ; prenom : le pr\u00e9nom de l'enfant en lettres majuscules ; annee_naissance : l'ann\u00e9e de naissance (nombre entier) ; nombre : le nombre d'enfants n\u00e9s durant l'ann\u00e9e en question et portant ce pr\u00e9nom. On rappelle que la structure g\u00e9n\u00e9rale d'une requ\u00eate SQL est : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT attribut_1 , attribut_2 , ... FROM table WHERE condition ; Toutefois : il est possible d'obtenir tous les attributs en faisant SELECT * ; la condition WHERE condition n'est pas indispensable si l'on souhaite obtenir toutes les entr\u00e9es de la table. On peut alors se contenter de SELECT attributs FROM table ; il est possible de rajouter d'autres arguments qui seront pr\u00e9sent\u00e9s au fil de ce document. Afficher les dix premi\u00e8res lignes de la table. Astuce Utiliser LIMIT 10 \u00e0 la fin de la requ\u00eate afin de n'afficher que les 10 premiers r\u00e9sultats. Il y a beaucoup de lignes dans cette table ! Votre r\u00e9ponse var prenoms = new Worker(path + \"/js/worker.sql-wasm.js\"); SQL Ex\u00e9cuter onElementLoaded(\"div#ide1\").then(() => { const ide = document.querySelector(\"div#ide1\"); load(ide, 'https:/e-nsi.forge.aeif.fr/exercices_bdd/31_prenoms/prenoms.db', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT * FROM naissances LIMIT 10 ; Afficher les lignes correspondant \u00e0 l'ann\u00e9e 1923. L\u00e0 encore, mieux vaut ne demander que les 10 premi\u00e8res lignes... Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide2\").then(() => { const ide = document.querySelector(\"div#ide2\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse On peut faire : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT * FROM naissances WHERE annee_naissance = 1923 ; Ou, en limitant le nombre de r\u00e9ponses : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT * FROM naissances WHERE annee_naissance = 1923 LIMIT 10 ; Afficher les pr\u00e9noms des filles n\u00e9es en 1978. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide3\").then(() => { const ide = document.querySelector(\"div#ide3\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT prenom FROM naissances WHERE sexe = 'Fille' AND annee_naissance = 1978 ; Combien de fois le pr\u00e9nom Nicolas a-t-il \u00e9t\u00e9 donn\u00e9 en 1907 ? Astuce On fera attention aux majuscules ! Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide4\").then(() => { const ide = document.querySelector(\"div#ide4\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT sexe , nombre FROM naissances WHERE prenom = 'NICOLAS' AND annee_naissance = 1907 ; On obtient deux lignes car Nicolas peut aussi \u00eatre un pr\u00e9nom de fille ! On peut aussi utiliser la fonction d'aggr\u00e9ation sum() : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT sum ( nombre ) FROM naissances WHERE prenom = 'NICOLAS' AND annee_naissance = 1907 ; Afficher les 10 pr\u00e9noms de fille les plus donn\u00e9s en 1978 rang\u00e9s dans l'ordre d\u00e9croissant du nombre de fois o\u00f9 ils ont \u00e9t\u00e9 donn\u00e9s. Astuce On peut trier les r\u00e9sultats en ajoutant ORDER BY attribut ASC en fin de requ\u00eate. ASC signifie ASCENDING et donc l'ordre croissant. On utilise DESC pour l'ordre d\u00e9croissant. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide5\").then(() => { const ide = document.querySelector(\"div#ide5\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT prenom FROM naissances WHERE sexe = 'Fille' AND annee_naissance = 1978 ORDER BY nombre DESC LIMIT 10 ; Afficher les lignes des pr\u00e9noms de gar\u00e7ons donn\u00e9s entre 1960 et 1969 (inclus l'un et l'autre). Utiliser un AND pour tester l'encadrement des ann\u00e9es. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide6\").then(() => { const ide = document.querySelector(\"div#ide6\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT * FROM naissances WHERE sexe = 'Gar\u00e7on' AND annee_naissance >= 1960 AND annee_naissance <= 1969 ; Il est int\u00e9ressant de remarquer au passage que la condition 1960 <= annee_naissance <= 1969 ne renvoie pas le m\u00eame r\u00e9sultat. Afficher le nombre de pr\u00e9noms diff\u00e9rents de gar\u00e7ons donn\u00e9s en 1938. Coup de pouce On pourra utiliser la fonction COUNT . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide7\").then(() => { const ide = document.querySelector(\"div#ide7\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT COUNT ( * ) as differents FROM naissances WHERE sexe = 'Gar\u00e7on' AND annee_naissance = 1938 ; Le as differents est un alias, il permet de renommer un attribut ou un r\u00e9sultat (ici le d\u00e9compte total). Afficher le nombre de naissances de gar\u00e7ons observ\u00e9es en 1938. Coup de pouce Utiliser la fonction SUM afin d'additionner les nombres d'enfants portant chaque pr\u00e9nom. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide8\").then(() => { const ide = document.querySelector(\"div#ide8\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT SUM ( nombre ) FROM naissances WHERE sexe = 'Gar\u00e7on' AND annee_naissance = 1938 ; Afficher le nombre de filles et le nombre de gar\u00e7ons apparaissant dans le table. Coup de pouce Il faut sommer des valeurs et les regrouper selon le sexe de l'enfant. On utilise pour cela l'instruction GROUP BY . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide9\").then(() => { const ide = document.querySelector(\"div#ide9\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT sexe , SUM ( nombre ) FROM naissances GROUP BY sexe ; Quel est le pr\u00e9nom, pour un certain sexe, en distinguant par exemple \"Camille (fille)\" et \"Camille (gar\u00e7on)\", qui a \u00e9t\u00e9 le plus donn\u00e9 durant une ann\u00e9e donn\u00e9e ? En quelle ann\u00e9e ? Astuce Utilisez une requ\u00eate de la forme : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT ..., ..., ..., nombre FROM naissances ORDER BY ... DESC LIMIT ...; Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide10\").then(() => { const ide = document.querySelector(\"div#ide10\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse On peut saisir : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT sexe , prenom , annee_naissance , nombre FROM naissances ORDER BY nombre DESC LIMIT 1 ; Une autre approche est d'utiliser deux requ\u00eates imbriqu\u00e9es : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT sexe , prenom , annee_naissance , nombre FROM naissances WHERE nombre = ( SELECT MAX ( nombre ) FROM naissances ); Notons enfin que sqlite autorise cette approche : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT sexe , prenom , annee_naissance , MAX ( nombre ) FROM naissances ; Cette instruction risque n\u00e9anmoins de ne pas s'ex\u00e9cuter dans d'autres syst\u00e8mes de gestion de bases de donn\u00e9es. En quelle ann\u00e9e y-a-t-il eu le plus de naissances ? Astuce Regrouper les r\u00e9sultats par ann\u00e9e, les trier et n'afficher que le premier ! Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide11\").then(() => { const ide = document.querySelector(\"div#ide11\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT annee_naissance , SUM ( nombre ) as somme FROM naissances GROUP BY annee_naissance ORDER BY somme DESC LIMIT 1 ; Quels sont les 10 pr\u00e9noms les plus donn\u00e9s en France au cours du XX-\u00e8me si\u00e8cle ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide12\").then(() => { const ide = document.querySelector(\"div#ide12\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT prenom , SUM ( nombre ) as nb FROM naissances GROUP BY prenom ORDER BY nb DESC LIMIT 10 ;","title":"Pr\u00e9noms"},{"location":"31_prenoms/prenoms/#les-prenoms-en-france-au-xx-eme-siecle","text":"On consid\u00e8re dans ce sujet la base de donn\u00e9es prenoms . Cette base ne comporte qu'une table, naissances , qui contient des informations d\u00e9crivant des pr\u00e9noms des enfants n\u00e9s en France au XX-i\u00e8me si\u00e8cle. Cette base est t\u00e9l\u00e9chargeable au format sqlite ici . Les attributs de cette table sont : id : l'identifiant de l'entr\u00e9e (cl\u00e9 primaire); sexe : le sexe de l'enfant au format texte : Fille ou Gar\u00e7on ; prenom : le pr\u00e9nom de l'enfant en lettres majuscules ; annee_naissance : l'ann\u00e9e de naissance (nombre entier) ; nombre : le nombre d'enfants n\u00e9s durant l'ann\u00e9e en question et portant ce pr\u00e9nom. On rappelle que la structure g\u00e9n\u00e9rale d'une requ\u00eate SQL est : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT attribut_1 , attribut_2 , ... FROM table WHERE condition ; Toutefois : il est possible d'obtenir tous les attributs en faisant SELECT * ; la condition WHERE condition n'est pas indispensable si l'on souhaite obtenir toutes les entr\u00e9es de la table. On peut alors se contenter de SELECT attributs FROM table ; il est possible de rajouter d'autres arguments qui seront pr\u00e9sent\u00e9s au fil de ce document. Afficher les dix premi\u00e8res lignes de la table. Astuce Utiliser LIMIT 10 \u00e0 la fin de la requ\u00eate afin de n'afficher que les 10 premiers r\u00e9sultats. Il y a beaucoup de lignes dans cette table ! Votre r\u00e9ponse var prenoms = new Worker(path + \"/js/worker.sql-wasm.js\"); SQL Ex\u00e9cuter onElementLoaded(\"div#ide1\").then(() => { const ide = document.querySelector(\"div#ide1\"); load(ide, 'https:/e-nsi.forge.aeif.fr/exercices_bdd/31_prenoms/prenoms.db', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT * FROM naissances LIMIT 10 ; Afficher les lignes correspondant \u00e0 l'ann\u00e9e 1923. L\u00e0 encore, mieux vaut ne demander que les 10 premi\u00e8res lignes... Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide2\").then(() => { const ide = document.querySelector(\"div#ide2\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse On peut faire : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT * FROM naissances WHERE annee_naissance = 1923 ; Ou, en limitant le nombre de r\u00e9ponses : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT * FROM naissances WHERE annee_naissance = 1923 LIMIT 10 ; Afficher les pr\u00e9noms des filles n\u00e9es en 1978. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide3\").then(() => { const ide = document.querySelector(\"div#ide3\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT prenom FROM naissances WHERE sexe = 'Fille' AND annee_naissance = 1978 ; Combien de fois le pr\u00e9nom Nicolas a-t-il \u00e9t\u00e9 donn\u00e9 en 1907 ? Astuce On fera attention aux majuscules ! Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide4\").then(() => { const ide = document.querySelector(\"div#ide4\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT sexe , nombre FROM naissances WHERE prenom = 'NICOLAS' AND annee_naissance = 1907 ; On obtient deux lignes car Nicolas peut aussi \u00eatre un pr\u00e9nom de fille ! On peut aussi utiliser la fonction d'aggr\u00e9ation sum() : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT sum ( nombre ) FROM naissances WHERE prenom = 'NICOLAS' AND annee_naissance = 1907 ; Afficher les 10 pr\u00e9noms de fille les plus donn\u00e9s en 1978 rang\u00e9s dans l'ordre d\u00e9croissant du nombre de fois o\u00f9 ils ont \u00e9t\u00e9 donn\u00e9s. Astuce On peut trier les r\u00e9sultats en ajoutant ORDER BY attribut ASC en fin de requ\u00eate. ASC signifie ASCENDING et donc l'ordre croissant. On utilise DESC pour l'ordre d\u00e9croissant. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide5\").then(() => { const ide = document.querySelector(\"div#ide5\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT prenom FROM naissances WHERE sexe = 'Fille' AND annee_naissance = 1978 ORDER BY nombre DESC LIMIT 10 ; Afficher les lignes des pr\u00e9noms de gar\u00e7ons donn\u00e9s entre 1960 et 1969 (inclus l'un et l'autre). Utiliser un AND pour tester l'encadrement des ann\u00e9es. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide6\").then(() => { const ide = document.querySelector(\"div#ide6\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT * FROM naissances WHERE sexe = 'Gar\u00e7on' AND annee_naissance >= 1960 AND annee_naissance <= 1969 ; Il est int\u00e9ressant de remarquer au passage que la condition 1960 <= annee_naissance <= 1969 ne renvoie pas le m\u00eame r\u00e9sultat. Afficher le nombre de pr\u00e9noms diff\u00e9rents de gar\u00e7ons donn\u00e9s en 1938. Coup de pouce On pourra utiliser la fonction COUNT . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide7\").then(() => { const ide = document.querySelector(\"div#ide7\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT COUNT ( * ) as differents FROM naissances WHERE sexe = 'Gar\u00e7on' AND annee_naissance = 1938 ; Le as differents est un alias, il permet de renommer un attribut ou un r\u00e9sultat (ici le d\u00e9compte total). Afficher le nombre de naissances de gar\u00e7ons observ\u00e9es en 1938. Coup de pouce Utiliser la fonction SUM afin d'additionner les nombres d'enfants portant chaque pr\u00e9nom. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide8\").then(() => { const ide = document.querySelector(\"div#ide8\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT SUM ( nombre ) FROM naissances WHERE sexe = 'Gar\u00e7on' AND annee_naissance = 1938 ; Afficher le nombre de filles et le nombre de gar\u00e7ons apparaissant dans le table. Coup de pouce Il faut sommer des valeurs et les regrouper selon le sexe de l'enfant. On utilise pour cela l'instruction GROUP BY . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide9\").then(() => { const ide = document.querySelector(\"div#ide9\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT sexe , SUM ( nombre ) FROM naissances GROUP BY sexe ; Quel est le pr\u00e9nom, pour un certain sexe, en distinguant par exemple \"Camille (fille)\" et \"Camille (gar\u00e7on)\", qui a \u00e9t\u00e9 le plus donn\u00e9 durant une ann\u00e9e donn\u00e9e ? En quelle ann\u00e9e ? Astuce Utilisez une requ\u00eate de la forme : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT ..., ..., ..., nombre FROM naissances ORDER BY ... DESC LIMIT ...; Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide10\").then(() => { const ide = document.querySelector(\"div#ide10\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse On peut saisir : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT sexe , prenom , annee_naissance , nombre FROM naissances ORDER BY nombre DESC LIMIT 1 ; Une autre approche est d'utiliser deux requ\u00eates imbriqu\u00e9es : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT sexe , prenom , annee_naissance , nombre FROM naissances WHERE nombre = ( SELECT MAX ( nombre ) FROM naissances ); Notons enfin que sqlite autorise cette approche : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT sexe , prenom , annee_naissance , MAX ( nombre ) FROM naissances ; Cette instruction risque n\u00e9anmoins de ne pas s'ex\u00e9cuter dans d'autres syst\u00e8mes de gestion de bases de donn\u00e9es. En quelle ann\u00e9e y-a-t-il eu le plus de naissances ? Astuce Regrouper les r\u00e9sultats par ann\u00e9e, les trier et n'afficher que le premier ! Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide11\").then(() => { const ide = document.querySelector(\"div#ide11\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT annee_naissance , SUM ( nombre ) as somme FROM naissances GROUP BY annee_naissance ORDER BY somme DESC LIMIT 1 ; Quels sont les 10 pr\u00e9noms les plus donn\u00e9s en France au cours du XX-\u00e8me si\u00e8cle ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide12\").then(() => { const ide = document.querySelector(\"div#ide12\"); load(ide, '/', '', '', prenoms); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT prenom , SUM ( nombre ) as nb FROM naissances GROUP BY prenom ORDER BY nb DESC LIMIT 10 ;","title":"Les pr\u00e9noms en France au XX-\u00e8me si\u00e8cle"},{"location":"32_ramens/ramens/","text":"Notation de ramens \u2693\ufe0e Le site www.theramenrater.com propose un fichier csv reprenant les notes donn\u00e9es par son cr\u00e9ateur \u00e0 de nombreux r\u0101mens , ces nouilles servies dans du bouillon au Japon. On s'int\u00e9resse ici \u00e0 la base de donn\u00e9es notations_ramens associ\u00e9e. Cette base ne comprend qu'une table, ramens , dont les attributs sont : id : l'identifiant de l'entr\u00e9e (cl\u00e9 primaire) ; brand : la marque des r\u0101mens au format texte ; variety : le type de r\u0101mens au format texte ; style : le style des r\u0101mens ' au format texte ( Cup , Pack , Bowl ...) ; country : le pays producteur au format texte ; stars : la note (nombre d\u00e9cimal). Cette base est t\u00e9l\u00e9chargeable au format sqlite ici . Combien de r\u0101mens sont not\u00e9s ? Votre r\u00e9ponse var ramens = new Worker(path + \"/js/worker.sql-wasm.js\"); SQL Ex\u00e9cuter onElementLoaded(\"div#ide1\").then(() => { const ide = document.querySelector(\"div#ide1\"); load(ide, 'https:/e-nsi.forge.aeif.fr/exercices_bdd/32_ramens/notations_ramens.db', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT COUNT ( * ) FROM ramens ; Combien de r\u0101mens ont \u00e9t\u00e9 produits au Japon ( Japan dans la table) ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide2\").then(() => { const ide = document.querySelector(\"div#ide2\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT COUNT ( * ) FROM ramens WHERE country = 'Japan' ; Afficher les notes des r\u0101mens produits en Espagne ( Spain dans la table). Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide3\").then(() => { const ide = document.querySelector(\"div#ide3\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT stars FROM ramens WHERE country = 'Spain' ; Afficher les notes des r\u0101mens produits au Br\u00e9sil ou au P\u00e9rou ( Brazil et Peru ) ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide4\").then(() => { const ide = document.querySelector(\"div#ide4\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT stars FROM ramens WHERE country = 'Brazil' OR country = 'Peru' ; Combien de r\u0101mens ont \u00e9t\u00e9 produits par la marque \u00ab Sapporo Ichiban \u00bb ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide5\").then(() => { const ide = document.querySelector(\"div#ide5\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT COUNT ( * ) FROM ramens WHERE brand = 'Sapporo Ichiban' ; Afficher le nombre de r\u0101mens que produit chaque marque. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide6\").then(() => { const ide = document.querySelector(\"div#ide6\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT brand , COUNT ( * ) FROM ramens GROUP BY brand ; Afficher les marques des r\u0101mens servis dans des bols. On donnera les cinq premiers r\u00e9sultats dans l'ordre alphab\u00e9tique. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide7\").then(() => { const ide = document.querySelector(\"div#ide7\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT brand FROM ramens WHERE style = 'Bowl' GROUP BY brand ORDER BY brand ASC LIMIT 5 ; Quelle est la note maximale donn\u00e9e ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide8\").then(() => { const ide = document.querySelector(\"div#ide8\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT MAX ( stars ) FROM ramens ; Quelle est la note moyenne de toutes les \u00e9valuations ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide9\").then(() => { const ide = document.querySelector(\"div#ide9\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT AVG ( stars ) FROM ramens ; Combien de r\u0101mens am\u00e9ricains ont une note sup\u00e9rieure \u00e0 4 (inclus) ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide10\").then(() => { const ide = document.querySelector(\"div#ide10\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT COUNT ( * ) FROM ramens WHERE country = 'United States' AND stars >= 4 ; Classer les pays selon la note moyenne des r\u0101mens produits. On triera les r\u00e9sultats dans l'ordre d\u00e9croissant. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide11\").then(() => { const ide = document.querySelector(\"div#ide11\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT country , AVG ( stars ) as moyenne FROM ramens GROUP BY country ORDER BY moyenne DESC ;","title":"Ramens"},{"location":"32_ramens/ramens/#notation-de-ramens","text":"Le site www.theramenrater.com propose un fichier csv reprenant les notes donn\u00e9es par son cr\u00e9ateur \u00e0 de nombreux r\u0101mens , ces nouilles servies dans du bouillon au Japon. On s'int\u00e9resse ici \u00e0 la base de donn\u00e9es notations_ramens associ\u00e9e. Cette base ne comprend qu'une table, ramens , dont les attributs sont : id : l'identifiant de l'entr\u00e9e (cl\u00e9 primaire) ; brand : la marque des r\u0101mens au format texte ; variety : le type de r\u0101mens au format texte ; style : le style des r\u0101mens ' au format texte ( Cup , Pack , Bowl ...) ; country : le pays producteur au format texte ; stars : la note (nombre d\u00e9cimal). Cette base est t\u00e9l\u00e9chargeable au format sqlite ici . Combien de r\u0101mens sont not\u00e9s ? Votre r\u00e9ponse var ramens = new Worker(path + \"/js/worker.sql-wasm.js\"); SQL Ex\u00e9cuter onElementLoaded(\"div#ide1\").then(() => { const ide = document.querySelector(\"div#ide1\"); load(ide, 'https:/e-nsi.forge.aeif.fr/exercices_bdd/32_ramens/notations_ramens.db', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT COUNT ( * ) FROM ramens ; Combien de r\u0101mens ont \u00e9t\u00e9 produits au Japon ( Japan dans la table) ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide2\").then(() => { const ide = document.querySelector(\"div#ide2\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT COUNT ( * ) FROM ramens WHERE country = 'Japan' ; Afficher les notes des r\u0101mens produits en Espagne ( Spain dans la table). Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide3\").then(() => { const ide = document.querySelector(\"div#ide3\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT stars FROM ramens WHERE country = 'Spain' ; Afficher les notes des r\u0101mens produits au Br\u00e9sil ou au P\u00e9rou ( Brazil et Peru ) ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide4\").then(() => { const ide = document.querySelector(\"div#ide4\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT stars FROM ramens WHERE country = 'Brazil' OR country = 'Peru' ; Combien de r\u0101mens ont \u00e9t\u00e9 produits par la marque \u00ab Sapporo Ichiban \u00bb ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide5\").then(() => { const ide = document.querySelector(\"div#ide5\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT COUNT ( * ) FROM ramens WHERE brand = 'Sapporo Ichiban' ; Afficher le nombre de r\u0101mens que produit chaque marque. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide6\").then(() => { const ide = document.querySelector(\"div#ide6\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT brand , COUNT ( * ) FROM ramens GROUP BY brand ; Afficher les marques des r\u0101mens servis dans des bols. On donnera les cinq premiers r\u00e9sultats dans l'ordre alphab\u00e9tique. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide7\").then(() => { const ide = document.querySelector(\"div#ide7\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT brand FROM ramens WHERE style = 'Bowl' GROUP BY brand ORDER BY brand ASC LIMIT 5 ; Quelle est la note maximale donn\u00e9e ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide8\").then(() => { const ide = document.querySelector(\"div#ide8\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT MAX ( stars ) FROM ramens ; Quelle est la note moyenne de toutes les \u00e9valuations ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide9\").then(() => { const ide = document.querySelector(\"div#ide9\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT AVG ( stars ) FROM ramens ; Combien de r\u0101mens am\u00e9ricains ont une note sup\u00e9rieure \u00e0 4 (inclus) ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide10\").then(() => { const ide = document.querySelector(\"div#ide10\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT COUNT ( * ) FROM ramens WHERE country = 'United States' AND stars >= 4 ; Classer les pays selon la note moyenne des r\u0101mens produits. On triera les r\u00e9sultats dans l'ordre d\u00e9croissant. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide11\").then(() => { const ide = document.querySelector(\"div#ide11\"); load(ide, '/', '', '', ramens); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT country , AVG ( stars ) as moyenne FROM ramens GROUP BY country ORDER BY moyenne DESC ;","title":"Notation de ramens"},{"location":"41_films/films/","text":"Autour des films \u2693\ufe0e On s'int\u00e9resse ici \u00e0 la base de donn\u00e9es films regroupant diverses informations sur des films : titre, ann\u00e9e de r\u00e9alisation, nom du r\u00e9alisateur, r\u00e9sum\u00e9, nom et r\u00f4le des acteurs, note attribu\u00e9e par des internautes, etc ... Les diff\u00e9rentes tables sont repr\u00e9sent\u00e9es ci-dessous : Sur cette figure : chaque tableau correspond \u00e0 une table dont le nom est indiqu\u00e9 sur la premi\u00e8re ligne ; les lignes suivantes listent les attributs et leur type. varchar(255) signifie que l'attribut est un texte de 255 caract\u00e8res au maximum ; les cl\u00e9s primaires de chaque table sont indiqu\u00e9es en gras. Notez que la table roles a une cl\u00e9 primaire multiple ; les cl\u00e9s \u00e9trang\u00e8res sont repr\u00e9sent\u00e9es par des liaisons entre les tables. On ne d\u00e9taille pas ici la signification des nombres et des symboles aux extr\u00e9mit\u00e9s des liaisons. Les curieux pourront se reporter \u00e0 cette page . Cette base est t\u00e9l\u00e9chargeable au format sqlite ici . La source est l\u00e0 . Le fichier d'origine a \u00e9t\u00e9 compl\u00e9t\u00e9 par nos soins. Ainsi, les internautes et les notes associ\u00e9es sont des faux . En deux temps... \u2693\ufe0e Combien de films sont pr\u00e9sents dans la base ? Votre r\u00e9ponse var films = new Worker(path + \"/js/worker.sql-wasm.js\"); SQL Ex\u00e9cuter onElementLoaded(\"div#ide1\").then(() => { const ide = document.querySelector(\"div#ide1\"); load(ide, 'https:/e-nsi.forge.aeif.fr/exercices_bdd/41_films/films.db', '', '', films); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT COUNT ( * ) FROM films ; Quel est l' idRealisateur du film \u00ab Casablanca \u00bb ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide2\").then(() => { const ide = document.querySelector(\"div#ide2\"); load(ide, '/', '', '', films); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT idRealisateur FROM films WHERE titre = 'Casablanca' ; Quels sont les noms et pr\u00e9noms de ce r\u00e9alisateur ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide3\").then(() => { const ide = document.querySelector(\"div#ide3\"); load(ide, '/', '', '', films); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT nom , prenom FROM artistes WHERE idArtiste = 4109 ; Tout \u00e0 la fois ! \u2693\ufe0e Comme on peut le voir, la question \u00ab Quel est le nom du films Casablanca ? \u00bb n\u00e9cessite d'effectuer deux requ\u00eates. Les informations sont en effet r\u00e9parties sur deux tables. Il est possible de n'effectuer qu'une seule requ\u00eate en effectuant une jointure . Cette op\u00e9ration s'appuie sur les cl\u00e9s \u00e9trang\u00e8res des tables et permet de mettre deux attributs en correspondance. La structure g\u00e9n\u00e9rale d'une jointure est : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT attribut FROM table_1 JOIN table_2 ON table_1 . attribut_1 = table_2 . attribut_2 ; Plusieurs remarques : on a pr\u00e9cis\u00e9 l'origine des attributs afin d'\u00e9viter les ambigu\u00eft\u00e9s si deux attributs de deux tables diff\u00e9rentes ont le m\u00eame nom. Ce n'est pas n\u00e9cessaire s'il n'y a pas d'ambigu\u00eft\u00e9 ; il est possible de joindre d'autres tables en rajoutant des lignes JOIN table_3 ... ; on peut tout \u00e0 fait ajouter une clause WHERE \u00e0 la suite des jointures ; les attributs demand\u00e9s peuvent provenir de toutes les tables jointes SELECT table_1.attribut_1, table_2.attribut_2 . Utilisez une jointure afin de retrouver le nom et le pr\u00e9nom du r\u00e9alisateur de \u00ab Casablanca \u00bb. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide4\").then(() => { const ide = document.querySelector(\"div#ide4\"); load(ide, '/', '', '', films); }).catch(() => {}); R\u00e9ponse On peut indiff\u00e9remment partir de la table artistes : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT artistes . nom , artistes . prenom FROM artistes JOIN films ON films . idRealisateur = artistes . idArtiste WHERE films . titre = 'Casablanca' ; ou films : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT artistes . nom , artistes . prenom FROM films JOIN artistes ON films . idRealisateur = artistes . idArtiste WHERE films . titre = 'Casablanca' ; Qui est le r\u00e9alisateur de \u00ab Memento \u00bb ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide5\").then(() => { const ide = document.querySelector(\"div#ide5\"); load(ide, '/', '', '', films); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT artistes . nom , artistes . prenom FROM artistes JOIN films ON films . idRealisateur = artistes . idArtiste WHERE films . titre = 'Memento' ; Quel acteur a jou\u00e9 le r\u00f4le de \u00ab Chewbacca \u00bb ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide6\").then(() => { const ide = document.querySelector(\"div#ide6\"); load(ide, '/', '', '', films); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT artistes . nom , artistes . prenom FROM artistes JOIN roles ON roles . idActeur = artistes . idArtiste WHERE roles . nomRole = 'Chewbacca' ; Quelles notes a obtenu le film \u00ab Fargo \u00bb ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide7\").then(() => { const ide = document.querySelector(\"div#ide7\"); load(ide, '/', '', '', films); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT note FROM notes JOIN films ON films . idFilm = notes . idFilm WHERE titre = 'Fargo' ; Quels acteurs (noms et pr\u00e9noms) ont jou\u00e9 dans \u00ab Sueurs froides \u00bb ? Il va falloir joindre plus de deux tables... Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide8\").then(() => { const ide = document.querySelector(\"div#ide8\"); load(ide, '/', '', '', films); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT nom , prenom FROM artistes JOIN roles ON roles . idActeur = artistes . idArtiste JOIN films ON roles . idFilm = films . idFilm WHERE films . titre = 'Sueurs froides' ; Quels sont les films not\u00e9s par l'internaute \u00ab Guillaume Turpin \u00bb ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide9\").then(() => { const ide = document.querySelector(\"div#ide9\"); load(ide, '/', '', '', films); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT titre FROM films JOIN notes ON notes . idFilm = films . idFilm JOIN internautes ON internautes . email = notes . email WHERE prenom = 'Guillaume' AND nom = 'Turpin' ; Quels sont les films dans lesquels l'acteur \u00ab David Carradine \u00bb a jou\u00e9 le r\u00f4le de \u00ab Bill \u00bb ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide10\").then(() => { const ide = document.querySelector(\"div#ide10\"); load(ide, '/', '', '', films); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT titre FROM films JOIN roles ON roles . idFilm = films . idFilm JOIN artistes ON roles . idActeur = artistes . idArtiste WHERE prenom = 'David' AND nom = 'Carradine' and nomRole = 'Bill' ; L'acteur \u00ab Johnny Depp \u00bb a-t-il jou\u00e9 dans des films r\u00e9alis\u00e9s hors des \u00c9tats-Unis ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide11\").then(() => { const ide = document.querySelector(\"div#ide11\"); load(ide, '/', '', '', films); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT films . titre FROM films JOIN roles ON roles . idFilm = films . idFilm JOIN artistes ON artistes . idArtiste = roles . idActeur JOIN pays ON pays . code = films . codePays WHERE artistes . nom = 'Depp' AND artistes . prenom = 'Johnny' and code != 'US' ; Quel est le film ayant obtenu la meilleure note moyenne (on rappelle que ces notes ont \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9es al\u00e9atoirement). Astuce La requ\u00eate pourra ressembler \u00e0 : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT titre , AVG (...) as moyenne FROM ... JOIN ... ON ... = ... GROUP BY ... ORDER BY ... DESC LIMIT 1 ; Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide12\").then(() => { const ide = document.querySelector(\"div#ide12\"); load(ide, '/', '', '', films); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT titre , AVG ( note ) as moyenne FROM films JOIN notes ON notes . idFilm = films . idFilm GROUP BY films . idFilm ORDER BY moyenne DESC LIMIT 1 ; Classer les artistes en fonction du nombre de r\u00f4les qu'ils ont jou\u00e9s, dans l'ordre d\u00e9croissant. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide13\").then(() => { const ide = document.querySelector(\"div#ide13\"); load(ide, '/', '', '', films); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT nom , prenom , COUNT ( nomRole ) as total FROM roles JOIN artistes ON artistes . idArtiste = roles . idActeur GROUP BY idArtiste ORDER BY total DESC ;","title":"Films"},{"location":"41_films/films/#autour-des-films","text":"On s'int\u00e9resse ici \u00e0 la base de donn\u00e9es films regroupant diverses informations sur des films : titre, ann\u00e9e de r\u00e9alisation, nom du r\u00e9alisateur, r\u00e9sum\u00e9, nom et r\u00f4le des acteurs, note attribu\u00e9e par des internautes, etc ... Les diff\u00e9rentes tables sont repr\u00e9sent\u00e9es ci-dessous : Sur cette figure : chaque tableau correspond \u00e0 une table dont le nom est indiqu\u00e9 sur la premi\u00e8re ligne ; les lignes suivantes listent les attributs et leur type. varchar(255) signifie que l'attribut est un texte de 255 caract\u00e8res au maximum ; les cl\u00e9s primaires de chaque table sont indiqu\u00e9es en gras. Notez que la table roles a une cl\u00e9 primaire multiple ; les cl\u00e9s \u00e9trang\u00e8res sont repr\u00e9sent\u00e9es par des liaisons entre les tables. On ne d\u00e9taille pas ici la signification des nombres et des symboles aux extr\u00e9mit\u00e9s des liaisons. Les curieux pourront se reporter \u00e0 cette page . Cette base est t\u00e9l\u00e9chargeable au format sqlite ici . La source est l\u00e0 . Le fichier d'origine a \u00e9t\u00e9 compl\u00e9t\u00e9 par nos soins. Ainsi, les internautes et les notes associ\u00e9es sont des faux .","title":"Autour des films"},{"location":"42_cars/cars/","text":"Chacun sa voiture \u2693\ufe0e On s'int\u00e9resse ici \u00e0 la base de donn\u00e9es car_database regroupant diverses informations sur des voitures : marque et mod\u00e8le, num\u00e9ro d'immatriculation ( vehicle immatriculation number , vin dans les tables), ann\u00e9e de fabrication, nom du propri\u00e9taire, options, etc ... Les diff\u00e9rentes tables sont repr\u00e9sent\u00e9es ci-dessous : Sur cette figure : chaque tableau correspond \u00e0 une table dont le nom est indiqu\u00e9 sur la premi\u00e8re ligne ; les lignes suivantes listent les attributs et leur type. varchar(255) signifie que l'attribut est un texte de 255 caract\u00e8res au maximum ; les cl\u00e9s primaires de chaque table sont indiqu\u00e9es en gras. Notez que la table ownerships a une cl\u00e9 primaire multiple ; les cl\u00e9s \u00e9trang\u00e8res sont repr\u00e9sent\u00e9es par des liaisons entre les tables. Cette base est t\u00e9l\u00e9chargeable au format sqlite ici . Ce fichier a \u00e9t\u00e9 simplifi\u00e9 \u00e0 partir de cette source . Quelles marques ( brand en anglais) sont pr\u00e9sentes dans la base ? Votre r\u00e9ponse var cars = new Worker(path + \"/js/worker.sql-wasm.js\"); SQL Ex\u00e9cuter onElementLoaded(\"div#ide1\").then(() => { const ide = document.querySelector(\"div#ide1\"); load(ide, 'https:/e-nsi.forge.aeif.fr/exercices_bdd/42_cars/car_database.db', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT brand_name FROM brands ; Quels sont les noms de famille des clients ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide2\").then(() => { const ide = document.querySelector(\"div#ide2\"); load(ide, '/', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT last_name FROM customers ; Quels sont les noms des mod\u00e8les de la marque \u00ab Supreme \u00bb ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide3\").then(() => { const ide = document.querySelector(\"div#ide3\"); load(ide, '/', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT model_name FROM models JOIN brands ON brands . brand_id = models . brand_id WHERE brand_name = 'Supreme' ; Quel est le prix d'achat ( purchase_price ) de la voiture poss\u00e9d\u00e9e par \u00ab Maria Swabota \u00bb ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide4\").then(() => { const ide = document.querySelector(\"div#ide4\"); load(ide, '/', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT purchase_price FROM ownerships JOIN customers ON ownerships . customer_id = customers . customer_id WHERE last_name = 'Swabota' AND first_name = 'Maria' ; Quelle est la date de fabrication ( manufactured_date ) de la voiture poss\u00e9d\u00e9e par \u00ab Maria Swabota \u00bb ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide5\").then(() => { const ide = document.querySelector(\"div#ide5\"); load(ide, '/', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT manufactured_date FROM ownerships JOIN customers ON ownerships . customer_id = customers . customer_id JOIN cars ON ownerships . vin = cars . vin WHERE last_name = 'Swabota' AND first_name = 'Maria' ; Quelle est la marque de la voiture poss\u00e9d\u00e9e par \u00ab Maria Swabota \u00bb ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide6\").then(() => { const ide = document.querySelector(\"div#ide6\"); load(ide, '/', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT brand_name FROM ownerships JOIN customers ON ownerships . customer_id = customers . customer_id JOIN cars ON ownerships . vin = cars . vin JOIN models ON models . model_id = cars . model_id JOIN brands ON models . brand_id = brands . brand_id WHERE last_name = 'Swabota' AND first_name = 'Maria' ; Quels mod\u00e8les de voiture sont \u00e9quip\u00e9s de 4 roues motrices (elles ont un chassis dont le part_name vaut '4WD Chassis' ) ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide7\").then(() => { const ide = document.querySelector(\"div#ide7\"); load(ide, '/', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT model_name FROM models JOIN options ON options . model_id = models . model_id JOIN parts ON parts . part_id = options . chassis_id WHERE part_name = '4WD Chassis' ; Reprendre la requ\u00eate pr\u00e9c\u00e9dente en donnant aussi la marque des v\u00e9hicules. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide8\").then(() => { const ide = document.querySelector(\"div#ide8\"); load(ide, '/', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT model_name , brand_name FROM models JOIN brands ON brands . brand_id = models . brand_id JOIN options ON options . model_id = models . model_id JOIN parts ON parts . part_id = options . chassis_id WHERE part_name = '4WD Chassis' ; Combien de Ferrari ont \u00e9t\u00e9 vendues ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide9\").then(() => { const ide = document.querySelector(\"div#ide9\"); load(ide, '/', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT COUNT ( vin ) FROM cars JOIN models ON models . model_id = cars . model_id JOIN brands ON brands . brand_id = models . brand_id WHERE brand_name = 'Ferrari' ; Quelle voiture, de quel mod\u00e8le, de quelle marque et appartenant \u00e0 qui a co\u00fbt\u00e9 le plus cher ? Astuce Trier les r\u00e9sultats par prix d\u00e9croissant et ne garder que le premier avec LIMIT 1 . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide10\").then(() => { const ide = document.querySelector(\"div#ide10\"); load(ide, '/', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT purchase_price , model_name , brand_name , last_name , first_name FROM ownerships JOIN customers ON ownerships . customer_id = customers . customer_id JOIN cars ON ownerships . vin = cars . vin JOIN models ON models . model_id = cars . model_id JOIN brands ON brands . brand_id = models . brand_id ORDER BY purchase_price DESC LIMIT 1 ;","title":"Voitures"},{"location":"42_cars/cars/#chacun-sa-voiture","text":"On s'int\u00e9resse ici \u00e0 la base de donn\u00e9es car_database regroupant diverses informations sur des voitures : marque et mod\u00e8le, num\u00e9ro d'immatriculation ( vehicle immatriculation number , vin dans les tables), ann\u00e9e de fabrication, nom du propri\u00e9taire, options, etc ... Les diff\u00e9rentes tables sont repr\u00e9sent\u00e9es ci-dessous : Sur cette figure : chaque tableau correspond \u00e0 une table dont le nom est indiqu\u00e9 sur la premi\u00e8re ligne ; les lignes suivantes listent les attributs et leur type. varchar(255) signifie que l'attribut est un texte de 255 caract\u00e8res au maximum ; les cl\u00e9s primaires de chaque table sont indiqu\u00e9es en gras. Notez que la table ownerships a une cl\u00e9 primaire multiple ; les cl\u00e9s \u00e9trang\u00e8res sont repr\u00e9sent\u00e9es par des liaisons entre les tables. Cette base est t\u00e9l\u00e9chargeable au format sqlite ici . Ce fichier a \u00e9t\u00e9 simplifi\u00e9 \u00e0 partir de cette source . Quelles marques ( brand en anglais) sont pr\u00e9sentes dans la base ? Votre r\u00e9ponse var cars = new Worker(path + \"/js/worker.sql-wasm.js\"); SQL Ex\u00e9cuter onElementLoaded(\"div#ide1\").then(() => { const ide = document.querySelector(\"div#ide1\"); load(ide, 'https:/e-nsi.forge.aeif.fr/exercices_bdd/42_cars/car_database.db', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT brand_name FROM brands ; Quels sont les noms de famille des clients ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide2\").then(() => { const ide = document.querySelector(\"div#ide2\"); load(ide, '/', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT last_name FROM customers ; Quels sont les noms des mod\u00e8les de la marque \u00ab Supreme \u00bb ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide3\").then(() => { const ide = document.querySelector(\"div#ide3\"); load(ide, '/', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT model_name FROM models JOIN brands ON brands . brand_id = models . brand_id WHERE brand_name = 'Supreme' ; Quel est le prix d'achat ( purchase_price ) de la voiture poss\u00e9d\u00e9e par \u00ab Maria Swabota \u00bb ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide4\").then(() => { const ide = document.querySelector(\"div#ide4\"); load(ide, '/', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT purchase_price FROM ownerships JOIN customers ON ownerships . customer_id = customers . customer_id WHERE last_name = 'Swabota' AND first_name = 'Maria' ; Quelle est la date de fabrication ( manufactured_date ) de la voiture poss\u00e9d\u00e9e par \u00ab Maria Swabota \u00bb ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide5\").then(() => { const ide = document.querySelector(\"div#ide5\"); load(ide, '/', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT manufactured_date FROM ownerships JOIN customers ON ownerships . customer_id = customers . customer_id JOIN cars ON ownerships . vin = cars . vin WHERE last_name = 'Swabota' AND first_name = 'Maria' ; Quelle est la marque de la voiture poss\u00e9d\u00e9e par \u00ab Maria Swabota \u00bb ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide6\").then(() => { const ide = document.querySelector(\"div#ide6\"); load(ide, '/', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT brand_name FROM ownerships JOIN customers ON ownerships . customer_id = customers . customer_id JOIN cars ON ownerships . vin = cars . vin JOIN models ON models . model_id = cars . model_id JOIN brands ON models . brand_id = brands . brand_id WHERE last_name = 'Swabota' AND first_name = 'Maria' ; Quels mod\u00e8les de voiture sont \u00e9quip\u00e9s de 4 roues motrices (elles ont un chassis dont le part_name vaut '4WD Chassis' ) ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide7\").then(() => { const ide = document.querySelector(\"div#ide7\"); load(ide, '/', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT model_name FROM models JOIN options ON options . model_id = models . model_id JOIN parts ON parts . part_id = options . chassis_id WHERE part_name = '4WD Chassis' ; Reprendre la requ\u00eate pr\u00e9c\u00e9dente en donnant aussi la marque des v\u00e9hicules. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide8\").then(() => { const ide = document.querySelector(\"div#ide8\"); load(ide, '/', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT model_name , brand_name FROM models JOIN brands ON brands . brand_id = models . brand_id JOIN options ON options . model_id = models . model_id JOIN parts ON parts . part_id = options . chassis_id WHERE part_name = '4WD Chassis' ; Combien de Ferrari ont \u00e9t\u00e9 vendues ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide9\").then(() => { const ide = document.querySelector(\"div#ide9\"); load(ide, '/', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT COUNT ( vin ) FROM cars JOIN models ON models . model_id = cars . model_id JOIN brands ON brands . brand_id = models . brand_id WHERE brand_name = 'Ferrari' ; Quelle voiture, de quel mod\u00e8le, de quelle marque et appartenant \u00e0 qui a co\u00fbt\u00e9 le plus cher ? Astuce Trier les r\u00e9sultats par prix d\u00e9croissant et ne garder que le premier avec LIMIT 1 . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide10\").then(() => { const ide = document.querySelector(\"div#ide10\"); load(ide, '/', '', '', cars); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT purchase_price , model_name , brand_name , last_name , first_name FROM ownerships JOIN customers ON ownerships . customer_id = customers . customer_id JOIN cars ON ownerships . vin = cars . vin JOIN models ON models . model_id = cars . model_id JOIN brands ON brands . brand_id = models . brand_id ORDER BY purchase_price DESC LIMIT 1 ;","title":"Chacun sa voiture"},{"location":"51_world/world/","text":"Autour du world \u2693\ufe0e On consid\u00e8re dans ce sujet la base de donn\u00e9es world . Cette base contient trois relations/tables : Les villes Les pays Les langues parl\u00e9es city : contient des informations d\u00e9crivant des villes : ID : l'identifiant de la ville (entier, cl\u00e9 primaire) Name : le nom de la ville (texte) CountryCode : le code du pays dans lequel est situ\u00e9 la ville (texte, cl\u00e9 \u00e9trang\u00e8re vers country.Code ) District : la r\u00e9gion d'appartenance de la ville (texte) Population : la population de la ville (entier) country : contient des informations d\u00e9crivant les pays : Code : le code du pays (texte, cl\u00e9 primaire) Name : le nom du pays (texte) Continent : le continent du pays (texte) SurfaceArea : la surface du pays (nombre d\u00e9cimal) Population : la population du pays (entier) Capital : la capitale du pays (entier, cl\u00e9 \u00e9trang\u00e8re vers city.ID ) d'autres attributs qui ne nous int\u00e9ressent pas ici... countryLanguage : d\u00e9crit les langues parl\u00e9es dans le pays : CountryCode : le code du pays (texte, cl\u00e9 \u00e9trang\u00e8re vers country.Code ) Language : la langue concern\u00e9e par cette entr\u00e9e (texte) IsOfficial : cette langue est-elle officielle dans ce pays ? (texte, T pour True , F pour False ) Percentage : le pourcentage de locuteurs dans le pays (nombre d\u00e9cimal) Notez que la cl\u00e9 primaire de la table countryLanguage est le couple (CountryCode, Language) . Cette base est t\u00e9l\u00e9chargeable au format sqlite ici . La source provient de ce site . Afficher le nom de toutes les villes ainsi que leur population. Astuce Vous pouvez rajouter LIMIT 10 \u00e0 la fin de votre requ\u00eate afin de n'afficher que les 10 premiers r\u00e9sultats. Il y a beaucoup de villes ! Votre r\u00e9ponse var monde = new Worker(path + \"/js/worker.sql-wasm.js\"); SQL Ex\u00e9cuter onElementLoaded(\"div#ide1\").then(() => { const ide = document.querySelector(\"div#ide1\"); load(ide, 'https:/e-nsi.forge.aeif.fr/exercices_bdd/51_world/world.db', '', '', monde); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT Name , Population FROM city ; Afficher le nom et la population des villes de plus de huit millions d'habitants (inclus): Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide2\").then(() => { const ide = document.querySelector(\"div#ide2\"); load(ide, '/', '', '', monde); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT Name , Population FROM city WHERE Population >= 8000000 ; Quel est le Code de la France ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide3\").then(() => { const ide = document.querySelector(\"div#ide3\"); load(ide, '/', '', '', monde); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT Code FROM country WHERE Name = 'France' ; La ville de Rennes est associ\u00e9e au District de \"Haute-Normandie\" . Corriger cette erreur afin de placer Rennes en Bretagne. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide4\").then(() => { const ide = document.querySelector(\"div#ide4\"); load(ide, '/', '', '', monde); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL UPDATE city SET District = 'Bretagne' WHERE Name = 'Rennes' ; Ins\u00e9rer la ville de Vannes ( District de Bretagne et population de 53 719 habitants) Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide5\").then(() => { const ide = document.querySelector(\"div#ide5\"); load(ide, '/', '', '', monde); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO city ( District , CountryCode , Name , Population ) VALUES ( \"Bretagne\" , \"FRA\" , \"Vannes\" , 53719 ); Quels sont les noms des pays dans lesquels le portugais ( Portuguese dans la base) est une langue officielle ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide6\").then(() => { const ide = document.querySelector(\"div#ide6\"); load(ide, '/', '', '', monde); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT Name FROM country JOIN countrylanguage ON countrylanguage . CountryCode = country . Code WHERE Language = 'Portuguese' AND IsOfficial = 'T' ; Combien de villes ont un nom d\u00e9butant par les lettres Van ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide7\").then(() => { const ide = document.querySelector(\"div#ide7\"); load(ide, '/', '', '', monde); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT COUNT ( Name ) FROM city WHERE Name LIKE \"Van%\" Afficher les noms et la population des villes fran\u00e7aises de plus de 200 000 habitants dans l'ordre d\u00e9croissant de leur population. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide8\").then(() => { const ide = document.querySelector(\"div#ide8\"); load(ide, '/', '', '', monde); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT Name , Population FROM city WHERE CountryCode = 'FRA' AND Population >= 200000 ORDER BY Population DESC ; Quel est le nom et la surface du plus petit pays du monde ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide9\").then(() => { const ide = document.querySelector(\"div#ide9\"); load(ide, '/', '', '', monde); }).catch(() => {}); R\u00e9ponse En sqlite on peut faire : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT Name , MIN ( SurfaceArea ) FROM country ; Une approche plus classique est toutefois d'utiliser des requ\u00eates imbriqu\u00e9es : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT Name , SurfaceArea FROM country WHERE SurfaceArea = ( SELECT Min ( SurfaceArea ) FROM country ); Quel code permettrait de cr\u00e9er la table district dont les attributs sont : id : un entier, cl\u00e9 primaire name : nom du district, au format texte countryCode : le code du pays d'appartenance de ce district countryCode est une cl\u00e9 \u00e9trang\u00e8re pointant vers la table country . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide10\").then(() => { const ide = document.querySelector(\"div#ide10\"); load(ide, '/', '', '', monde); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE TABLE \"district\" ( \"id\" INTEGER , \"name\" TEXT , \"countryCode\" INTEGER , PRIMARY KEY ( \"id\" ), FOREIGN KEY ( \"CountryCode\" ) REFERENCES \"country\" ( \"Code\" ) );","title":"World"},{"location":"51_world/world/#autour-du-world","text":"On consid\u00e8re dans ce sujet la base de donn\u00e9es world . Cette base contient trois relations/tables : Les villes Les pays Les langues parl\u00e9es city : contient des informations d\u00e9crivant des villes : ID : l'identifiant de la ville (entier, cl\u00e9 primaire) Name : le nom de la ville (texte) CountryCode : le code du pays dans lequel est situ\u00e9 la ville (texte, cl\u00e9 \u00e9trang\u00e8re vers country.Code ) District : la r\u00e9gion d'appartenance de la ville (texte) Population : la population de la ville (entier) country : contient des informations d\u00e9crivant les pays : Code : le code du pays (texte, cl\u00e9 primaire) Name : le nom du pays (texte) Continent : le continent du pays (texte) SurfaceArea : la surface du pays (nombre d\u00e9cimal) Population : la population du pays (entier) Capital : la capitale du pays (entier, cl\u00e9 \u00e9trang\u00e8re vers city.ID ) d'autres attributs qui ne nous int\u00e9ressent pas ici... countryLanguage : d\u00e9crit les langues parl\u00e9es dans le pays : CountryCode : le code du pays (texte, cl\u00e9 \u00e9trang\u00e8re vers country.Code ) Language : la langue concern\u00e9e par cette entr\u00e9e (texte) IsOfficial : cette langue est-elle officielle dans ce pays ? (texte, T pour True , F pour False ) Percentage : le pourcentage de locuteurs dans le pays (nombre d\u00e9cimal) Notez que la cl\u00e9 primaire de la table countryLanguage est le couple (CountryCode, Language) . Cette base est t\u00e9l\u00e9chargeable au format sqlite ici . La source provient de ce site . Afficher le nom de toutes les villes ainsi que leur population. Astuce Vous pouvez rajouter LIMIT 10 \u00e0 la fin de votre requ\u00eate afin de n'afficher que les 10 premiers r\u00e9sultats. Il y a beaucoup de villes ! Votre r\u00e9ponse var monde = new Worker(path + \"/js/worker.sql-wasm.js\"); SQL Ex\u00e9cuter onElementLoaded(\"div#ide1\").then(() => { const ide = document.querySelector(\"div#ide1\"); load(ide, 'https:/e-nsi.forge.aeif.fr/exercices_bdd/51_world/world.db', '', '', monde); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT Name , Population FROM city ; Afficher le nom et la population des villes de plus de huit millions d'habitants (inclus): Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide2\").then(() => { const ide = document.querySelector(\"div#ide2\"); load(ide, '/', '', '', monde); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT Name , Population FROM city WHERE Population >= 8000000 ; Quel est le Code de la France ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide3\").then(() => { const ide = document.querySelector(\"div#ide3\"); load(ide, '/', '', '', monde); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT Code FROM country WHERE Name = 'France' ; La ville de Rennes est associ\u00e9e au District de \"Haute-Normandie\" . Corriger cette erreur afin de placer Rennes en Bretagne. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide4\").then(() => { const ide = document.querySelector(\"div#ide4\"); load(ide, '/', '', '', monde); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL UPDATE city SET District = 'Bretagne' WHERE Name = 'Rennes' ; Ins\u00e9rer la ville de Vannes ( District de Bretagne et population de 53 719 habitants) Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide5\").then(() => { const ide = document.querySelector(\"div#ide5\"); load(ide, '/', '', '', monde); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO city ( District , CountryCode , Name , Population ) VALUES ( \"Bretagne\" , \"FRA\" , \"Vannes\" , 53719 ); Quels sont les noms des pays dans lesquels le portugais ( Portuguese dans la base) est une langue officielle ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide6\").then(() => { const ide = document.querySelector(\"div#ide6\"); load(ide, '/', '', '', monde); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT Name FROM country JOIN countrylanguage ON countrylanguage . CountryCode = country . Code WHERE Language = 'Portuguese' AND IsOfficial = 'T' ; Combien de villes ont un nom d\u00e9butant par les lettres Van ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide7\").then(() => { const ide = document.querySelector(\"div#ide7\"); load(ide, '/', '', '', monde); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT COUNT ( Name ) FROM city WHERE Name LIKE \"Van%\" Afficher les noms et la population des villes fran\u00e7aises de plus de 200 000 habitants dans l'ordre d\u00e9croissant de leur population. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide8\").then(() => { const ide = document.querySelector(\"div#ide8\"); load(ide, '/', '', '', monde); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT Name , Population FROM city WHERE CountryCode = 'FRA' AND Population >= 200000 ORDER BY Population DESC ; Quel est le nom et la surface du plus petit pays du monde ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide9\").then(() => { const ide = document.querySelector(\"div#ide9\"); load(ide, '/', '', '', monde); }).catch(() => {}); R\u00e9ponse En sqlite on peut faire : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT Name , MIN ( SurfaceArea ) FROM country ; Une approche plus classique est toutefois d'utiliser des requ\u00eates imbriqu\u00e9es : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT Name , SurfaceArea FROM country WHERE SurfaceArea = ( SELECT Min ( SurfaceArea ) FROM country ); Quel code permettrait de cr\u00e9er la table district dont les attributs sont : id : un entier, cl\u00e9 primaire name : nom du district, au format texte countryCode : le code du pays d'appartenance de ce district countryCode est une cl\u00e9 \u00e9trang\u00e8re pointant vers la table country . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide10\").then(() => { const ide = document.querySelector(\"div#ide10\"); load(ide, '/', '', '', monde); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE TABLE \"district\" ( \"id\" INTEGER , \"name\" TEXT , \"countryCode\" INTEGER , PRIMARY KEY ( \"id\" ), FOREIGN KEY ( \"CountryCode\" ) REFERENCES \"country\" ( \"Code\" ) );","title":"Autour du world"},{"location":"52_netflix/netflix/","text":"Les programmes de netflix \u2693\ufe0e On consid\u00e8re dans ce sujet la base de donn\u00e9es netflix contenant des informations sur les programmes de la plateforme. Cette base contient plusieurs relations/tables : Les pays Les r\u00e9alisateurs Les genres Les programmes Les classifications Les genres de chaque programme Les types de programmes countries : contient des informations d\u00e9crivant des pays : id : l'identifiant du pays (entier, cl\u00e9 primaire) country : le nom du pays (texte) directors : contient des informations d\u00e9crivant les r\u00e9alisateurs des programmes : id : l'identifiant du r\u00e9alisateur (entier, cl\u00e9 primaire) director : le nom du ou des r\u00e9alisateurs (texte) genres : d\u00e9crit les genres des programmes : id : l'identifiant du genre (entier, cl\u00e9 primaire) genre : le nom du genre (texte) programs : d\u00e9crit les programmes : show_id : l'identifiant du programme (texte, cl\u00e9 primaire) type : l'identifiant du type de programme (entier, cl\u00e9 \u00e9trang\u00e8re pointant vers types.id ) title : le nom du programme (texte) director : l'identifiant du ou des r\u00e9alisateurs (entier, cl\u00e9 \u00e9trang\u00e8re pointant vers directors.id ) country : l'identifiant du pays du programme (entier, cl\u00e9 \u00e9trang\u00e8re pointant vers countries.id ) date_added : la date d'ajout sur la plateforme (texte) release_year : la date de r\u00e9alisation du programme (entier) ratings : l'identifiant de la classification du programme (entier, cl\u00e9 \u00e9trang\u00e8re pointant vers ratings.id ) duration : la dur\u00e9e du programme en saison ou minutes (texte) ratings : d\u00e9crit les classifications des programmes : id : l'identifiant de la classification (entier, cl\u00e9 primaire) rating : le nom de la classification (texte) show_genres : d\u00e9crit les genres associ\u00e9s \u00e0 chaque programme : show_id : l'identifiant du programme (texte, cl\u00e9 \u00e9trang\u00e8re pointant vers programs.show_id ) genre : l'identifiant du genre (entier, cl\u00e9 \u00e9trang\u00e8re pointant vers genres.id ) La cl\u00e9 primaire de cette table est le couple (show_id, genre) . types : d\u00e9crit les types de programmes : id : l'identifiant du type (entier, cl\u00e9 primaire) type : le nom du type (texte) Cette base est t\u00e9l\u00e9chargeable au format sqlite ici . La source est sur kaggle . Afficher le nom des programmes ainsi que leur date d'ajout sur la plateforme. Votre r\u00e9ponse var netflix = new Worker(path + \"/js/worker.sql-wasm.js\"); SQL Ex\u00e9cuter onElementLoaded(\"div#ide1\").then(() => { const ide = document.querySelector(\"div#ide1\"); load(ide, 'https:/e-nsi.forge.aeif.fr/exercices_bdd/52_netflix/netflix.db', '', '', netflix); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT title , date_added FROM programs ; Afficher le nom et la date de r\u00e9alisation des programmes r\u00e9alis\u00e9s apr\u00e8s 2020 (inclus): Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide2\").then(() => { const ide = document.querySelector(\"div#ide2\"); load(ide, '/', '', '', netflix); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT title , release_year FROM programs WHERE release_year >= 2020 ; Quel est l'identifiant du r\u00e9alisateur nomm\u00e9 Michael Bay ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide3\").then(() => { const ide = document.querySelector(\"div#ide3\"); load(ide, '/', '', '', netflix); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT id FROM directors WHERE director = 'Michael Bay' ; La s\u00e9rie The Witcher comporte d\u00e9sormais 2 saisons alors que la base n'en indique qu'une seule. Corriger cette erreur. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide4\").then(() => { const ide = document.querySelector(\"div#ide4\"); load(ide, '/', '', '', netflix); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL UPDATE programs SET duration = '2 seasons' WHERE title = 'The Witcher' ; Ins\u00e9rer la s\u00e9rie t\u00e9l\u00e9vis\u00e9e The Sandman , ajout\u00e9e en 2022, de r\u00e9alisateurs multiples (utiliser l'identifiant correspondant \u00e0 Not Given ), et de classification TV-MA . Les autres champs seront laiss\u00e9s vierges. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide5\").then(() => { const ide = document.querySelector(\"div#ide5\"); load(ide, '/', '', '', netflix); }).catch(() => {}); R\u00e9ponse On r\u00e9cup\u00e8re tout d'abord l'identifiant du r\u00e9alisateur Not Given : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT id FROM directors WHERE director = 'Not Given' ; On obtient le 1238 . On fait de m\u00eame avec l'identifiant de la classification TV-MA : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT id FROM ratings WHERE rating = 'TV-MA' ; On obtient le 9 . On peut alors effectuer l'insertion : \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO programs ( title , release_year , director , rating ) VALUES ( 'The Sandman' , 2022 , 1238 , 9 ); Il \u00e9tait aussi possible de faire : \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO programs ( title , release_year , director , rating ) VALUES ( 'The Sandman' , 2022 , ( SELECT id FROM directors WHERE director = 'Not Given' ), ( SELECT id FROM ratings WHERE rating = 'TV-MA' )); Quels sont les noms des programmes r\u00e9alis\u00e9s en France ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide6\").then(() => { const ide = document.querySelector(\"div#ide6\"); load(ide, '/', '', '', netflix); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT title FROM programs JOIN countries ON countries . id = programs . country WHERE countries . country = 'France' ; Combien de programmes ont \u00e9t\u00e9 r\u00e9alis\u00e9s en 2020 en Inde ( India dans la base) ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide7\").then(() => { const ide = document.querySelector(\"div#ide7\"); load(ide, '/', '', '', netflix); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT COUNT ( * ) FROM programs JOIN countries ON countries . id = programs . country WHERE countries . country = 'India' AND release_year = 2020 ; Afficher les noms et la date de r\u00e9alisation des s\u00e9ries t\u00e9l\u00e9vis\u00e9es r\u00e9alis\u00e9es en Uruguay dans l'ordre d\u00e9croissant de leur date de r\u00e9alisation. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide8\").then(() => { const ide = document.querySelector(\"div#ide8\"); load(ide, '/', '', '', netflix); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT title , release_year FROM programs JOIN countries ON countries . id = programs . country WHERE countries . country = 'Uruguay' ORDER BY release_year DESC ; \u00c0 quel genre (au format texte) est associ\u00e9e la s\u00e9rie Dowton Abbey ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide9\").then(() => { const ide = document.querySelector(\"div#ide9\"); load(ide, '/', '', '', netflix); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT genres . genre FROM show_genres JOIN programs ON programs . show_id = show_genres . show_id JOIN genres ON genres . id = show_genres . genre WHERE programs . title = 'Downton Abbey' ; Quel code permettrait de cr\u00e9er la table notations dont les attributs sont : id : un entier, cl\u00e9 primaire show_id : identifiant d'un programme, au format texte notation : la note du programme, au format entier show_id est une cl\u00e9 \u00e9trang\u00e8re pointant vers la table programs . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide10\").then(() => { const ide = document.querySelector(\"div#ide10\"); load(ide, '/', '', '', netflix); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE TABLE \"notations\" ( \"id\" INTEGER , \"show_id\" TEXT , \"notation\" INTEGER , PRIMARY KEY ( \"id\" ), FOREIGN KEY ( \"show_id\" ) REFERENCES \"programs\" ( \"show_id\" ) );","title":"Netflix"},{"location":"52_netflix/netflix/#les-programmes-de-netflix","text":"On consid\u00e8re dans ce sujet la base de donn\u00e9es netflix contenant des informations sur les programmes de la plateforme. Cette base contient plusieurs relations/tables : Les pays Les r\u00e9alisateurs Les genres Les programmes Les classifications Les genres de chaque programme Les types de programmes countries : contient des informations d\u00e9crivant des pays : id : l'identifiant du pays (entier, cl\u00e9 primaire) country : le nom du pays (texte) directors : contient des informations d\u00e9crivant les r\u00e9alisateurs des programmes : id : l'identifiant du r\u00e9alisateur (entier, cl\u00e9 primaire) director : le nom du ou des r\u00e9alisateurs (texte) genres : d\u00e9crit les genres des programmes : id : l'identifiant du genre (entier, cl\u00e9 primaire) genre : le nom du genre (texte) programs : d\u00e9crit les programmes : show_id : l'identifiant du programme (texte, cl\u00e9 primaire) type : l'identifiant du type de programme (entier, cl\u00e9 \u00e9trang\u00e8re pointant vers types.id ) title : le nom du programme (texte) director : l'identifiant du ou des r\u00e9alisateurs (entier, cl\u00e9 \u00e9trang\u00e8re pointant vers directors.id ) country : l'identifiant du pays du programme (entier, cl\u00e9 \u00e9trang\u00e8re pointant vers countries.id ) date_added : la date d'ajout sur la plateforme (texte) release_year : la date de r\u00e9alisation du programme (entier) ratings : l'identifiant de la classification du programme (entier, cl\u00e9 \u00e9trang\u00e8re pointant vers ratings.id ) duration : la dur\u00e9e du programme en saison ou minutes (texte) ratings : d\u00e9crit les classifications des programmes : id : l'identifiant de la classification (entier, cl\u00e9 primaire) rating : le nom de la classification (texte) show_genres : d\u00e9crit les genres associ\u00e9s \u00e0 chaque programme : show_id : l'identifiant du programme (texte, cl\u00e9 \u00e9trang\u00e8re pointant vers programs.show_id ) genre : l'identifiant du genre (entier, cl\u00e9 \u00e9trang\u00e8re pointant vers genres.id ) La cl\u00e9 primaire de cette table est le couple (show_id, genre) . types : d\u00e9crit les types de programmes : id : l'identifiant du type (entier, cl\u00e9 primaire) type : le nom du type (texte) Cette base est t\u00e9l\u00e9chargeable au format sqlite ici . La source est sur kaggle . Afficher le nom des programmes ainsi que leur date d'ajout sur la plateforme. Votre r\u00e9ponse var netflix = new Worker(path + \"/js/worker.sql-wasm.js\"); SQL Ex\u00e9cuter onElementLoaded(\"div#ide1\").then(() => { const ide = document.querySelector(\"div#ide1\"); load(ide, 'https:/e-nsi.forge.aeif.fr/exercices_bdd/52_netflix/netflix.db', '', '', netflix); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT title , date_added FROM programs ; Afficher le nom et la date de r\u00e9alisation des programmes r\u00e9alis\u00e9s apr\u00e8s 2020 (inclus): Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide2\").then(() => { const ide = document.querySelector(\"div#ide2\"); load(ide, '/', '', '', netflix); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT title , release_year FROM programs WHERE release_year >= 2020 ; Quel est l'identifiant du r\u00e9alisateur nomm\u00e9 Michael Bay ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide3\").then(() => { const ide = document.querySelector(\"div#ide3\"); load(ide, '/', '', '', netflix); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT id FROM directors WHERE director = 'Michael Bay' ; La s\u00e9rie The Witcher comporte d\u00e9sormais 2 saisons alors que la base n'en indique qu'une seule. Corriger cette erreur. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide4\").then(() => { const ide = document.querySelector(\"div#ide4\"); load(ide, '/', '', '', netflix); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL UPDATE programs SET duration = '2 seasons' WHERE title = 'The Witcher' ; Ins\u00e9rer la s\u00e9rie t\u00e9l\u00e9vis\u00e9e The Sandman , ajout\u00e9e en 2022, de r\u00e9alisateurs multiples (utiliser l'identifiant correspondant \u00e0 Not Given ), et de classification TV-MA . Les autres champs seront laiss\u00e9s vierges. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide5\").then(() => { const ide = document.querySelector(\"div#ide5\"); load(ide, '/', '', '', netflix); }).catch(() => {}); R\u00e9ponse On r\u00e9cup\u00e8re tout d'abord l'identifiant du r\u00e9alisateur Not Given : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT id FROM directors WHERE director = 'Not Given' ; On obtient le 1238 . On fait de m\u00eame avec l'identifiant de la classification TV-MA : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT id FROM ratings WHERE rating = 'TV-MA' ; On obtient le 9 . On peut alors effectuer l'insertion : \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO programs ( title , release_year , director , rating ) VALUES ( 'The Sandman' , 2022 , 1238 , 9 ); Il \u00e9tait aussi possible de faire : \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO programs ( title , release_year , director , rating ) VALUES ( 'The Sandman' , 2022 , ( SELECT id FROM directors WHERE director = 'Not Given' ), ( SELECT id FROM ratings WHERE rating = 'TV-MA' )); Quels sont les noms des programmes r\u00e9alis\u00e9s en France ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide6\").then(() => { const ide = document.querySelector(\"div#ide6\"); load(ide, '/', '', '', netflix); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT title FROM programs JOIN countries ON countries . id = programs . country WHERE countries . country = 'France' ; Combien de programmes ont \u00e9t\u00e9 r\u00e9alis\u00e9s en 2020 en Inde ( India dans la base) ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide7\").then(() => { const ide = document.querySelector(\"div#ide7\"); load(ide, '/', '', '', netflix); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT COUNT ( * ) FROM programs JOIN countries ON countries . id = programs . country WHERE countries . country = 'India' AND release_year = 2020 ; Afficher les noms et la date de r\u00e9alisation des s\u00e9ries t\u00e9l\u00e9vis\u00e9es r\u00e9alis\u00e9es en Uruguay dans l'ordre d\u00e9croissant de leur date de r\u00e9alisation. Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide8\").then(() => { const ide = document.querySelector(\"div#ide8\"); load(ide, '/', '', '', netflix); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT title , release_year FROM programs JOIN countries ON countries . id = programs . country WHERE countries . country = 'Uruguay' ORDER BY release_year DESC ; \u00c0 quel genre (au format texte) est associ\u00e9e la s\u00e9rie Dowton Abbey ? Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide9\").then(() => { const ide = document.querySelector(\"div#ide9\"); load(ide, '/', '', '', netflix); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT genres . genre FROM show_genres JOIN programs ON programs . show_id = show_genres . show_id JOIN genres ON genres . id = show_genres . genre WHERE programs . title = 'Downton Abbey' ; Quel code permettrait de cr\u00e9er la table notations dont les attributs sont : id : un entier, cl\u00e9 primaire show_id : identifiant d'un programme, au format texte notation : la note du programme, au format entier show_id est une cl\u00e9 \u00e9trang\u00e8re pointant vers la table programs . Votre r\u00e9ponse SQL Ex\u00e9cuter onElementLoaded(\"div#ide10\").then(() => { const ide = document.querySelector(\"div#ide10\"); load(ide, '/', '', '', netflix); }).catch(() => {}); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE TABLE \"notations\" ( \"id\" INTEGER , \"show_id\" TEXT , \"notation\" INTEGER , PRIMARY KEY ( \"id\" ), FOREIGN KEY ( \"show_id\" ) REFERENCES \"programs\" ( \"show_id\" ) );","title":"Les programmes de netflix"},{"location":"BAC/1-jipo1/","text":"2022, Polyn\u00e9sie \u2693\ufe0e BACCALAUR\u00c9AT G\u00c9N\u00c9RAL, NSI, 2022, Polyn\u00e9sie Dur\u00e9e de l'\u00e9preuve : 3 heures 30 L'usage de la calculatrice avec mode examen actif est autoris\u00e9. L'usage de la calculatrice sans m\u00e9moire, \u00ab type coll\u00e8ge \u00bb est autoris\u00e9. Le candidat traite au choix 3 exercices parmi les 5 exercices propos\u00e9s. Sujet non officiel Ce n'est pas le sujet officiel, quelques modifications mineures ont \u00e9t\u00e9 apport\u00e9es. Le sujet d'origine est disponible en t\u00e9l\u00e9chargement . EXERCICE 1 (4 points) \u2693\ufe0e Cet exercice traite du th\u00e8me \u00ab programmation \u00bb, et principalement de la r\u00e9cursivit\u00e9. On rappelle qu'une chaine de caract\u00e8res peut \u00eatre repr\u00e9sent\u00e9e en Python par un texte entre guillemets \"\" et que : la fonction len renvoie la longueur de la chaine de caract\u00e8res pass\u00e9e en param\u00e8tre ; si une variable ch d\u00e9signe une chaine de caract\u00e8res, alors ch[0] renvoie son premier caract\u00e8re, ch[1] le deuxi\u00e8me, etc ; l'op\u00e9rateur + permet de concat\u00e9ner deux chaines de caract\u00e8res. Exemples \ud83d\udc0d Console Python >>> texte = \"bricot\" >>> len ( texte ) 6 >>> texte [ 0 ] \"b\" >>> texte [ 1 ] \"r\" >>> \"a\" + texte \"abricot\" On s'int\u00e9resse dans cet exercice \u00e0 la construction de chaines de caract\u00e8res suivant certaines r\u00e8gles de construction. R\u00e8gle A Une chaine est construite suivant la r\u00e8gle A dans les deux cas suivants : soit elle est \u00e9gale \u00e0 \"a\" ; soit elle est de la forme \"a\" + chaine + \"a\" , o\u00f9 chaine est une chaine de caract\u00e8res construite suivant la r\u00e8gle A. R\u00e8gle B Une chaine est construite suivant la r\u00e8gle B dans les deux cas suivants : soit elle est de la forme \"b\" + chaine + \"b\" , o\u00f9 chaine est une chaine de caract\u00e8res construite suivant la r\u00e8gle A ; soit elle est de la forme \"b\" + chaine + \"b\" , o\u00f9 chaine est une chaine de caract\u00e8res construite suivant la r\u00e8gle B. Fonction choice du module random On a reproduit ci-dessous l'aide de la fonction choice du module random . \ud83d\udc0d Console Python >>> from random import choice >>> help ( choice ) Help on method choice in module random: choice(seq) method of random.Random instance Choose a random element from a non-empty sequence. La fonction A ci-dessous renvoie une chaine de caract\u00e8res construite suivant la r\u00e8gle A, en choisissant al\u00e9atoirement entre les deux cas de figure de cette r\u00e8gle. \ud83d\udc0d Script Python def A (): if choice ([ True , False ]): return \"a\" else : return \"a\" + A () + \"a\" 1.a) Cette fonction est-elle r\u00e9cursive ? Justifier. R\u00e9ponse La fonction A s'appelle elle-m\u00eame, donc A est une fonction r\u00e9cursive. 1.b) La fonction choice([True, False]) peut renvoyer False un tr\u00e8s grand nombre de fois cons\u00e9cutives. Expliquer pourquoi ce cas de figure am\u00e8nerait \u00e0 une erreur d'ex\u00e9cution. R\u00e9ponse Si choice([True, False]) renvoie False cons\u00e9cutivement un nombre de fois sup\u00e9rieur \u00e0 la limite de profondeur de r\u00e9cursion autoris\u00e9e (1000 par d\u00e9faut avec Python), dans ce cas une erreur d'ex\u00e9cution se produit. Pour aller plus loin On pourrait modifier cette limite \u00e0 \\(10^6\\) avec le code suivant \ud83d\udc0d Script Python import sys sys . setrecursionlimit ( 10 ** 6 ) Dans la suite, on consid\u00e8re une deuxi\u00e8me version de la fonction A . \u00c0 pr\u00e9sent, la fonction prend en param\u00e8tre un entier n tel que, si la valeur de n est n\u00e9gative ou nulle, la fonction renvoie \"a\" ; si la valeur de n est strictement positive, elle renvoie une chaine de caract\u00e8res construite suivant la r\u00e8gle A avec un n d\u00e9cr\u00e9ment\u00e9 de 1, en choisissant al\u00e9atoirement entre les deux cas de figure de cette r\u00e8gle. \ud83d\udc0d Script Python def A ( n ): if ... or choice ([ True , False ]) : return \"a\" else : return \"a\" + ... + \"a\" 2.a) Recopier sur la copie et compl\u00e9ter aux emplacements des points de suspension ... le code de cette nouvelle fonction A . R\u00e9ponse \ud83d\udc0d Script Python def A ( n ): if n <= 0 or choice ([ True , False ]) : return \"a\" else : return \"a\" + A ( n - 1 ) + \"a\" 2.b) Justifier le fait qu'un appel de la forme A(n) avec n un nombre entier positif inf\u00e9rieur \u00e0 50, termine toujours. R\u00e9ponse Pour \\(n > 0\\) , l'appel \u00e0 A(n) provoque ou bien un arr\u00eat de la fonction, ou bien un appel r\u00e9cursif avec le param\u00e8tre n - 1 . Un appel \u00e0 A(50) pourrait provoquer dans le pire des cas 50 appels r\u00e9cursifs pour arriver \u00e0 A(0) qui termine, ou alors terminer avant ! On donne ci-apr\u00e8s le code de la fonction r\u00e9cursive B qui prend en param\u00e8tre un entier n et qui renvoie une chaine de caract\u00e8res construite suivant la r\u00e8gle B. \ud83d\udc0d Script Python def B ( n ): if n <= 0 or choice ([ True , False ]): return \"b\" + A ( n - 1 ) + \"b\" else : return \"b\" + B ( n - 1 ) + \"b\" On admet que : les appels A(-1) et A(0) renvoient la chaine \"a\" ; l'appel A(1) renvoie la chaine \"a\" ou la chaine \"aaa\" ; l'appel A(2) renvoie la chaine \"a\" , la chaine \"aaa\" ou la chaine \"aaaaa\" . 3. Donner toutes les chaines possibles renvoy\u00e9es par les appels B(0) , B(1) et B(2) . R\u00e9ponse B(0) renvoie \"bab\" B(1) renvoie \"bab\" ou \"bbabb\" . B(2) renvoie \"bab\" , \"baaab\" , \"bbabb\" ou \"bbbabbb\" . On suppose maintenant qu'on dispose d'une fonction raccourcir qui prend comme param\u00e8tre une chaine de caract\u00e8res de longueur sup\u00e9rieure ou \u00e9gale \u00e0 2, et renvoie la chaine de caract\u00e8res obtenue \u00e0 partir de la chaine initiale en lui \u00f4tant le premier et le dernier caract\u00e8re. Par exemple : \ud83d\udc0d Console Python >>> raccourcir ( \"abricot\" ) \"brico\" >>> raccourcir ( \"ab\" ) \"\" 4.a) Recopier sur la copie et compl\u00e9ter les points de suspension ... du code de la fonction regle_A ci-dessous pour qu'elle renvoie True si la chaine pass\u00e9e en param\u00e8tre est construite suivant la r\u00e8gle A, et False sinon. \ud83d\udc0d Script Python def regle_A ( chaine ): n = len ( chaine ) if n >= 2 : return chaine [ 0 ] == \"a\" and chaine [ n - 1 ] == \"a\" and regle_A ( ... ) else : return chaine == ... R\u00e9ponse \ud83d\udc0d Script Python def regle_A ( chaine ): n = len ( chaine ) if n >= 2 : return chaine [ 0 ] == \"a\" and chaine [ n - 1 ] == \"a\" and regle_A ( raccourcir ( chaine )) else : return chaine == \"a\" 4.b) \u00c9crire le code d'une fonction regle_B , prenant en param\u00e8tre une chaine de caract\u00e8res et renvoyant True si la chaine est construite suivant la r\u00e8gle B, et False sinon. R\u00e9ponse \ud83d\udc0d Script Python def regle_B ( chaine ): n = len ( chaine ) if n >= 2 : return chaine [ 0 ] == \"b\" and chaine [ n - 1 ] == \"b\" and ( regle_A ( chaine [ 1 : n - 1 ]) or regle_B ( raccourcir ( chaine )) ) else : return False EXERCICE 2 (4 points) \u2693\ufe0e Cet exercice traite du th\u00e8me \u00ab architecture mat\u00e9rielle \u00bb, et principalement d'ordonnancement et d'expressions bool\u00e9ennes. Un syst\u00e8me est compos\u00e9 de 4 p\u00e9riph\u00e9riques, num\u00e9rot\u00e9s de 0 \u00e0 3, et d'une m\u00e9moire, reli\u00e9s entre eux par un bus auquel est \u00e9galement connect\u00e9 un dispositif ordonnanceur. \u00c0 l'aide d'un signal sp\u00e9cifique envoy\u00e9 sur le bus, l'ordonnanceur sollicite \u00e0 tour de r\u00f4le les p\u00e9riph\u00e9riques pour qu'ils indiquent le type d'op\u00e9ration (lecture ou \u00e9criture) qu'ils souhaitent effectuer, et l'adresse m\u00e9moire concern\u00e9e. Un tour a lieu quand les 4 p\u00e9riph\u00e9riques ont \u00e9t\u00e9 sollicit\u00e9s. Au d\u00e9but d'un nouveau tour, on consid\u00e8re que toutes les adresses sont disponibles en lecture et \u00e9criture. Si un p\u00e9riph\u00e9rique demande l'\u00e9criture \u00e0 une adresse m\u00e9moire \u00e0 laquelle on n'a pas encore acc\u00e9d\u00e9 pendant le tour, l'ordonnanceur r\u00e9pond \"OK\" et l'\u00e9criture a lieu. Si on a d\u00e9j\u00e0 demand\u00e9 la lecture ou l'\u00e9criture \u00e0 cette adresse, l'ordonnanceur r\u00e9pond \"ATT\" et l'op\u00e9ration n'a pas lieu. Si un p\u00e9riph\u00e9rique demande la lecture \u00e0 une adresse \u00e0 laquelle on n'a pas encore acc\u00e9d\u00e9 en \u00e9criture pendant le tour, l'ordonnanceur r\u00e9pond \"OK\" et la lecture a lieu. Plusieurs lectures peuvent avoir donc lieu pendant le m\u00eame tour \u00e0 la m\u00eame adresse. Si un p\u00e9riph\u00e9rique demande la lecture \u00e0 une adresse \u00e0 laquelle on a d\u00e9j\u00e0 acc\u00e9d\u00e9 en \u00e9criture, l'ordonnanceur r\u00e9pond \"ATT\" et la lecture n'a pas lieu. Ainsi, pendant un tour, une adresse peut \u00eatre utilis\u00e9e soit une seule fois en \u00e9criture, soit autant de fois qu'on veut en lecture, soit pas utilis\u00e9e. Si un p\u00e9riph\u00e9rique ne peut pas effectuer une op\u00e9ration \u00e0 une adresse, il demande la m\u00eame op\u00e9ration \u00e0 la m\u00eame adresse au tour suivant. 1. Le tableau donn\u00e9 en annexe 1 indique, sur chaque ligne, le p\u00e9riph\u00e9rique s\u00e9lectionn\u00e9, l'adresse \u00e0 laquelle il souhaite acc\u00e9der et l'op\u00e9ration \u00e0 effectuer sur cette adresse. Compl\u00e9ter dans la derni\u00e8re colonne de cette annexe, \u00e0 rendre avec la copie, la r\u00e9ponse donn\u00e9e par l'ordonnanceur pour chaque op\u00e9ration. Annexe 1 N\u00b0 p\u00e9riph\u00e9rique Adresse Op\u00e9ration R\u00e9ponse de l'ordonnanceur 0 10 \u00e9criture \"OK\" 1 11 lecture \"OK\" 2 10 lecture \"ATT\" 3 10 \u00e9criture \"ATT\" 0 12 lecture 1 10 lecture 2 10 lecture 3 10 \u00e9criture R\u00e9ponse TODO N\u00b0 p\u00e9riph\u00e9rique Adresse Op\u00e9ration R\u00e9ponse de l'ordonnanceur 0 10 \u00e9criture \"OK\" 1 11 lecture \"OK\" 2 10 lecture \"ATT\" 3 10 \u00e9criture \"ATT\" 0 12 lecture \"OK\" 1 10 lecture \"OK\" 2 10 lecture \"OK\" 3 10 \u00e9criture \"ATT\" On suppose dans toute la suite que : le p\u00e9riph\u00e9rique 0 \u00e9crit syst\u00e9matiquement \u00e0 l'adresse 10 ; le p\u00e9riph\u00e9rique 1 lit syst\u00e9matiquement \u00e0 l'adresse 10 ; le p\u00e9riph\u00e9rique 2 \u00e9crit alternativement aux adresses 11 et 12 ; le p\u00e9riph\u00e9rique 3 lit alternativement aux adresses 11 et 12 ; Pour les p\u00e9riph\u00e9riques 2 et 3, le changement d'adresse n'est effectif que lorsque l'op\u00e9ration et r\u00e9alis\u00e9e. 2. On suppose que les p\u00e9riph\u00e9riques sont s\u00e9lectionn\u00e9s \u00e0 chaque tour dans l'ordre 0 ; 1 ; 2 ; 3. Expliquer ce qu'il se passe pour le p\u00e9riph\u00e9rique 1. R\u00e9ponse Le p\u00e9riph\u00e9rique 1 ne pourra jamais effectuer sa lecture \u00e0 l\u2019adresse m\u00e9moire 10 puisque juste avant le p\u00e9riph\u00e9rique 0 aura effectu\u00e9 une \u00e9criture \u00e0 l\u2019adresse m\u00e9moire 10. Les p\u00e9riph\u00e9riques sont sollicit\u00e9s de la mani\u00e8re suivante lors de quatre tours successifs : au premier tour, ils sont sollicit\u00e9s dans l'ordre 0 ; 1 ; 2 ; 3 ; au deuxi\u00e8me tour, dans l'ordre 1 ; 2 ; 3 ; 0 ; au troisi\u00e8me tour, 2 ; 3 ; 0 ; 1 ; puis 3 ; 0 ; 1 ; 2 au dernier tour. Et on recommence... 3.a) Pr\u00e9ciser pour chacun de ces tours si le p\u00e9riph\u00e9rique 0 peut \u00e9crire et si le p\u00e9riph\u00e9rique 1 peut lire. R\u00e9ponse tour 1 : 0 peut \u00e9crire ; 1 ne peut pas lire tour 2 : 0 ne peut pas \u00e9crire ; 1 peut lire tour 3 : 0 peut \u00e9crire ; 1 ne peut pas lire tour 4 : 0 peut \u00e9crire ; 1 ne peut pas lire 3.b) En d\u00e9duire la proportion des valeurs \u00e9crites par le p\u00e9riph\u00e9rique 0 qui sont effectivement lues par le p\u00e9riph\u00e9rique 1. R\u00e9ponse 0 peut \u00e9crire trois fois et 1 peut lire une seule fois, seulement un tiers des valeurs \u00e9crites par 0 sont lues par 1, soit 33% On change la m\u00e9thode d'ordonnancement : on d\u00e9termine l'ordre des p\u00e9riph\u00e9riques au cours d'un tour \u00e0 l'aide de deux listes d'attente ATTL_L et ATT_E \u00e9tablies au tour pr\u00e9c\u00e9dent. Au cours d'un tour, on place dans la liste ATT_L toutes les op\u00e9rations de lecture mises en attente, et dans la liste d'attente ATT_E toutes les op\u00e9rations d'\u00e9criture mises en attente. Au d\u00e9but du tour suivant, on \u00e9tablit l'ordre d'interrogation des p\u00e9riph\u00e9riques en proc\u00e9dant ainsi : on interroge ceux pr\u00e9sents dans la liste ATT_L , par ordre croissant d'adresse, on interroge ensuite ceux pr\u00e9sents dans la liste ATT_E , par ordre croissant d'adresse, puis on interroge les p\u00e9riph\u00e9riques restants, par ordre croissant d'adresse. 4. Compl\u00e9ter et rendre avec la copie le tableau fourni en annexe 2, en utilisant l'ordonnancement d\u00e9crit ci-dessus, sur 3 tours. Annexe 2 Tour N\u00b0 p\u00e9riph\u00e9rique Adresse Op\u00e9ration R\u00e9ponse ordonnanceur ATT_L ATT_E 1 0 10 \u00e9criture \"OK\" vide vide 1 1 10 lecture \"ATT\" (1, 10) vide 1 2 11 \u00e9criture 1 3 11 lecture 2 1 10 lecture vide 2 2 2 3 0 10 \u00e9criture vide vide 3 1 10 lecture vide 3 2 11 \u00e9criture \"OK\" (1, 10) vide 3 3 12 lecture R\u00e9ponse Tour N\u00b0 p\u00e9riph\u00e9rique Adresse Op\u00e9ration R\u00e9ponse ordonnanceur ATT_L ATT_E 1 0 10 \u00e9criture \"OK\" vide vide 1 1 10 lecture \"ATT\" (1, 10) vide 1 2 11 \u00e9criture \"OK\" (1, 10) 1 3 11 lecture \"ATT\" (1, 10) (3, 11) vide 2 1 10 lecture \"OK\" (3, 11) vide 2 3 11 lecture \"OK\" vide vide 2 0 10 lecture \"ATT\" vide (0, 10) 2 2 12 \u00e9criture \"OK\" vide (0, 10) 3 0 10 \u00e9criture \"OK\" vide vide 3 1 10 lecture \"ATT\" (1, 10) vide 3 2 11 \u00e9criture \"OK\" (1, 10) vide 3 3 12 lecture \"OK\" (1, 10) vide Les colonnes e0 et e1 du tableau suivant recensent les deux chiffres de l'\u00e9criture binaire de l'entier n de la premi\u00e8re colonne. nombre n \u00e9criture binaire de n sur deux bits e1 e0 0 00 0 0 1 01 0 1 2 10 1 0 3 11 1 1 L'ordonnanceur attribue \u00e0 deux signaux sur le bus de donn\u00e9es les valeurs de e0 et e1 associ\u00e9es au num\u00e9ro du circuit qu'il veut s\u00e9lectionner. On souhaite construire \u00e0 l'aide des portes ET, OU et NON un circuit pour chaque p\u00e9riph\u00e9rique. Chacun des quatre circuits \u00e0 construire prend en entr\u00e9e deux signaux e0 et e1 , le signal de sortie s valant 1 uniquement lorsque les niveaux de e0 et e1 correspondent aux bits de l'\u00e9criture en binaire du num\u00e9ro du p\u00e9riph\u00e9rique correspondant. Par exemple, le circuit ci-dessous r\u00e9alise la s\u00e9lection du p\u00e9riph\u00e9rique 3. En effet, le signal s vaut 1 si et seulement si e0 et e1 valent tous les deux 1. flowchart LR e0---ET e1---ET ET---s style e0 stroke-width:0px,opacity:0 style e1 stroke-width:0px,opacity:0 style s stroke-width:0px,opacity:0 5.a) Recopier sur la copie et indiquer dans le circuit ci-dessous les entr\u00e9es e0 et e1 de fa\u00e7on \u00e0 ce que ce circuit s\u00e9lectionne le p\u00e9riph\u00e9rique 1. flowchart LR ea( )---NON---ET eb( )----ET ET---s style ea stroke-width:0px,opacity:0 style eb stroke-width:0px,opacity:0 style s stroke-width:0px,opacity:0 R\u00e9ponse flowchart LR ea(e1)---NON---ET eb(e0)----ET ET---s style ea stroke-width:0px,opacity:0 style eb stroke-width:0px,opacity:0 style s stroke-width:0px,opacity:0 5.b) Dessiner un circuit constitu\u00e9 d'une porte ET et d'une porte NON, qui s\u00e9lectionne le p\u00e9riph\u00e9rique 2. R\u00e9ponse flowchart LR ea(e1)----ET eb(e0)---NON---ET ET---s style ea stroke-width:0px,opacity:0 style eb stroke-width:0px,opacity:0 style s stroke-width:0px,opacity:0 5.c) Dessiner un circuit permettant de s\u00e9lectionner le p\u00e9riph\u00e9rique 0. R\u00e9ponse flowchart LR ea(e0)---NON eb(e1)---NON NON---ET NON---ET ET---s style ea stroke-width:0px,opacity:0 style eb stroke-width:0px,opacity:0 style s stroke-width:0px,opacity:0 flowchart LR ea(e0)---NON---ET eb(e1)---NON---ET ET---s style ea stroke-width:0px,opacity:0 style eb stroke-width:0px,opacity:0 style s stroke-width:0px,opacity:0 EXERCICE 3 (4 points) \u2693\ufe0e Cet exercice traite du th\u00e8me \u00ab base de donn\u00e9es \u00bb, et principalement du mod\u00e8le relationnel et du langage SQL. L'\u00e9nonc\u00e9 de cet exercice peut utiliser les mots du langage SQL suivants : CREATE TABLE, SELECT, FROM, WHERE, JOIN ON, INSERT INTO, VALUES, UPDATE, SET, DELETE, COUNT, DISTINCT, AND, OR, AS, ORDER BY, ASC, DESC Un site web recueille des donn\u00e9es de navigation dans une base de donn\u00e9es afin d'\u00e9tudier les profils de ses visiteurs. Chaque requ\u00eate d'interrogation d'une page de ce site est enregistr\u00e9e dans une premi\u00e8re table d\u00e9nomm\u00e9e Visites sous la forme d'un 5-uplet : (identifiant, adresse IP, date et heure de visite, nom de la page, navigateur) . Le chargement de la page index.html par 192.168.1.91 le 12 juillet 1998 \u00e0 22 h 48 aura par exemple \u00e9t\u00e9 enregistr\u00e9 de la fa\u00e7on suivante : (1534, \"192.168.1.91\", \"1998-07-12 22:48:00\", \"index.html\", \"Internet explorer 4.1\") . La commande SQL ayant permis de cr\u00e9er cette table est la suivante : \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE TABLE Visites ( identifiant INTEGER NOT NULL UNIQUE , ip VARCHAR ( 15 ), dateheure DATETIME , nompage TEXT , navigateur TEXT ); 1.a) Donner une commande d'interrogation en langage SQL permettant d'obtenir l'ensemble des 2-uplets (adresse IP, nom de la page) de cette table. R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT ip , nompage FROM Visites 1.b) Donner une commande en langage SQL permettant d'obtenir l'ensemble des adresses IP ayant interrog\u00e9 le site, sans doublon. R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT DISTINCT ip FROM Visites 1.c) Donner une commande en langage SQL permettant d'obtenir la liste des noms des pages visit\u00e9es par l'adresse IP 192.168.1.91 R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT DISTINCT nompage FROM Visites WHERE ip = \"192.168.1.91\" Ce site web met en place, sur chacune de ses pages, un programme en JavaScript qui envoie au serveur, \u00e0 intervalle r\u00e9gulier de 15 secondes, le temps en secondes de pr\u00e9sence sur la page. Ces envois contiennent tous la valeur de identifiant correspondant au chargement initial de la page. Par exemple, si le visiteur du 12 juillet 1998 est rest\u00e9 65 secondes sur la page, celle-ci a envoy\u00e9 au serveur les 4 doublets (1534, 15) , (1534, 30) , (1534, 45) et (1534, 60) . Ces donn\u00e9es sont enregistr\u00e9es dans une table nomm\u00e9e Pings cr\u00e9\u00e9e avec la commande ci-dessous : \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE TABLE Pings ( identifiant INTEGER , duree INTEGER ); En plus de l'inscription d'une ligne dans la table Visites , chaque chargement d'une nouvelle page provoque l'insertion d'une ligne dans la table Pings comprenant l'identifiant de ce chargement et une dur\u00e9e de 0. Les attributs identifiant des tables Visites et Pings partagent les m\u00eames valeurs. 2.a) De quelle table l'attribut identifiant est-il la cl\u00e9 primaire ? R\u00e9ponse l'attribut identifiant est la cl\u00e9 primaire de la table Visistes (id) 2.b) De quelle table l'attribut identifiant est-il une cl\u00e9 \u00e9trang\u00e8re ? R\u00e9ponse l'attribut identifiant est la cl\u00e9 \u00e9trang\u00e8re de la table Pings 2.c) Par cons\u00e9quent, quelles v\u00e9rifications sont automatiquement effectu\u00e9es par le syst\u00e8me de gestion de base de donn\u00e9es ? R\u00e9ponse Le SGBD va v\u00e9rifier que l\u2019attribut identifiant est unique pour chaque p-upplet de la table Visites. Le SGBD va aussi v\u00e9rifier que l\u2019attribut identifiant de la table Pings correspond bien \u00e0 un attribut identifiant de la table Visites pour chaque p-upplet de la table Pings. 3. Le serveur re\u00e7oit le doublet (identifiant, duree) suivant : (1534, 105) . \u00c9crire la commande SQL d'insertion qui permet d'ajouter cet enregistrement \u00e0 la table Pings . R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO Pings ( identifiant , duree ) VALUES ( 1534 , 105 ) On envisage ensuite d'optimiser la table en se contentant d'une seule ligne par identifiant dans la table Pings : les valeurs de l'attribut duree devraient alors \u00eatre mises \u00e0 jour \u00e0 chaque r\u00e9ception d'un nouveau doublet (identifiant, duree) . 4.a) \u00c9crire la requ\u00eate de mise \u00e0 jour permettant de fixer \u00e0 120 la valeur de l'attribut duree associ\u00e9e \u00e0 l'identifiant 1534 dans la table Pings . R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL UPDATE Pings SET duree = 120 WHERE identifiant = 1534 4.b) Expliquer pourquoi on ne peut pas \u00eatre certain que les donn\u00e9es envoy\u00e9es par une page web, depuis le navigateur d'un client, via plusieurs requ\u00eates formul\u00e9es en JavaScript, arrivent au serveur dans l'ordre dans lequel elles ont \u00e9t\u00e9 \u00e9mises. R\u00e9ponse Nous ne pouvons pas \u00eatre certains que les donn\u00e9es envoy\u00e9es par une page web, depuis le navigateur d\u2019un client, via plusieurs requ\u00eates formul\u00e9es en JavaScript, arrivent au serveur dans l\u2019ordre dans lequel elles ont \u00e9t\u00e9 \u00e9mises, car les paquets de donn\u00e9es (protocole TCP/IP) n\u2019emprunteront pas forc\u00e9ment le m\u00eame chemin pour aller du client vers le serveur (ou m\u00eame certains paquets de donn\u00e9es pourront se \u201cperdre\u201d et devront \u00eatre r\u00e9\u00e9mis par le client). Les requ\u00eates HTTP \u00e9tant constitu\u00e9s de paquets de donn\u00e9es, il n\u2019est donc pas possible de garantir l\u2019ordre d\u2019arriv\u00e9e des requ\u00eates HTTP. 4.c) En d\u00e9duire qu'il est pr\u00e9f\u00e9rable d'utiliser une requ\u00eate d'insertion plut\u00f4t qu'une requ\u00eate de mise \u00e0 jour pour ajouter des donn\u00e9es \u00e0 la table Pings . R\u00e9ponse Imaginons que le client envoie 2 requ\u00eates HTTP A et B (le client envoie la requ\u00eate A puis la requ\u00eate B). Si le serveur, en recevant la requ\u00eate B tente de mettre \u00e0 jour l\u2019entr\u00e9e correspondant \u00e0 la requ\u00eate A alors qu\u2019il n\u2019a pas encore re\u00e7u la requ\u00eate A, cela va entrainer une erreur (tente de mettre \u00e0 jour une entr\u00e9e qui n\u2019existe pas). 5. \u00c9crire une requ\u00eate SQL utilisant le mot-cl\u00e9 JOIN et une clause WHERE , permettant de trouver les noms de toutes les pages qui ont \u00e9t\u00e9 consult\u00e9es plus d'une minute par au moins un utilisateur. R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT nompage FROM Visites JOIN Pings ON Visites . identifiant = Pings . identifiant WHERE duree > 60 EXERCICE 4 (4 points) \u2693\ufe0e Cet exercice traite du th\u00e8me \u00ab structures de donn\u00e9es \u00bb, et principalement des piles. La classe Pile utilis\u00e9e dans cet exercice est impl\u00e9ment\u00e9e en utilisant des listes Python et propose quatre \u00e9l\u00e9ments d'interface : Un constructeur qui permet de cr\u00e9er une pile vide, repr\u00e9sent\u00e9e par [] ; La m\u00e9thode est_vide() qui renvoie True si l'objet est une pile ne contenant aucun \u00e9l\u00e9ment, et False sinon ; La m\u00e9thode empiler qui prend un objet quelconque en param\u00e8tre et ajoute cet objet au sommet de la pile. Dans la repr\u00e9sentation de la pile dans la console, cet objet apparait \u00e0 droite des autres \u00e9l\u00e9ments de la pile ; La m\u00e9thode depiler qui renvoie l'objet pr\u00e9sent au sommet de la pile et le retire de la pile. Exemples : \ud83d\udc0d Console Python >>> ma_pile = Pile () >>> ma_pile . empiler ( 2 ) >>> ma_pile [2] >>> ma_pile . empiler ( 3 ) >>> ma_pile . empiler ( 50 ) >>> ma_pile [2, 3, 50] >>> ma_pile . depiler () 50 >>> ma_pile [2, 3] La m\u00e9thode est_triee ci-dessous renvoie True si, en d\u00e9pilant tous les \u00e9l\u00e9ments, ils sont trait\u00e9s dans l'ordre croissant, et False sinon. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def est_triee ( self ): if not self . est_vide (): e1 = self . depiler () while not self . est_vide (): e2 = self . depiler () if e1 ... e2 : return False e1 = ... return True 1. Recopier sur la copie les lignes 6 et 8 en compl\u00e9tant les points de suspension. R\u00e9ponse \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def est_triee ( self ): if not self . est_vide (): e1 = self . depiler () while not self . est_vide (): e2 = self . depiler () if e1 > e2 : return False e1 = e2 return True On cr\u00e9e dans la console la pile A repr\u00e9sent\u00e9e par [1, 2, 3, 4] . 2.a) Donner la valeur renvoy\u00e9e par l'appel A.est_triee() . R\u00e9ponse La valeur \\(4\\) est d'abord d\u00e9pil\u00e9e, puis \\(3\\) . L'ordre n'est pas croissant, ainsi A.est_triee() renvoie False . 2.b) Donner le contenu de la pile A apr\u00e8s l'ex\u00e9cution de cette instruction. R\u00e9ponse A sera repr\u00e9sent\u00e9 par [1, 2] . On souhaite maintenant \u00e9crire le code d'une m\u00e9thode depile_max d'une pile non vide ne contenant que des nombres entiers et renvoyant le plus grand \u00e9l\u00e9ment de cette pile en le retirant de la pile. Apr\u00e8s l'ex\u00e9cution de p.depile_max() , le nombre d'\u00e9l\u00e9ments de la pile p diminue donc de 1. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def depile_max ( self ): assert not self . est_vide (), \"Pile vide\" q = Pile () maxi = self . depiler () while not self . est_vide (): elt = self . depiler () if maxi < elt : q . empiler ( maxi ) maxi = ... else : ... while not q . est_vide (): self . empiler ( q . depiler ()) return maxi 3. Recopier sur la copie les lignes 9 et 11 en compl\u00e9tant les points de suspension. R\u00e9ponse \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def depile_max ( self ): assert not self . est_vide (), \"Pile vide\" q = Pile () maxi = self . depiler () while not self . est_vide (): elt = self . depiler () if maxi < elt : q . empiler ( maxi ) maxi = elt else : q . empiler ( elt ) while not q . est_vide (): self . empiler ( q . depiler ()) return maxi On cr\u00e9e la pile B repr\u00e9sent\u00e9e par [9, -7, 8, 12, 4] et on effectue l'appel B.depile_max() . 4.a) Donner le contenu des piles B et q \u00e0 la fin de chaque it\u00e9ration de la boucle while de la ligne 5. R\u00e9ponse Initialisation Fin du tour 1 Fin du tour 2 Fin du tour 3 Fin du tour 4 B contient [9, -7, 8, 12] ; q est vide ; maxi est \u00e9gal \u00e0 4 . Juste avant le premier tour de boucle B contient [9, -7, 8] ; q contient [4] ; maxi est \u00e9gal \u00e0 12 . B contient [9, -7] ; q contient [4, 8] ; maxi est \u00e9gal \u00e0 12 . B contient [9] ; q contient [4, 8, -7] ; maxi est \u00e9gal \u00e0 12 . B est vide ; q contient [4, 8, -7, 9] ; maxi est \u00e9gal \u00e0 12 . 4.b) Donner le contenu des piles B et q avant l'ex\u00e9cution de la ligne 14. R\u00e9ponse La derni\u00e8re boucle renverse la pile q dans la pile B , ainsi, \u00e0 la ligne 14 : q est vide ; B contient [9, -7, 8, 4] . 4.c) Donner un exemple de pile qui montre que l'ordre des \u00e9l\u00e9ments restants n'est pas pr\u00e9serv\u00e9 apr\u00e8s l'ex\u00e9cution de depile_max . R\u00e9ponse Avec une pile B qui contient [3, 1, 2] Initialisation Fin du tour 1 Fin du tour 2 B contient [3, 1] ; q est vide ; maxi est \u00e9gal \u00e0 2 . Juste avant le premier tour de boucle B contient [3] ; q contient [1] ; maxi est \u00e9gal \u00e0 2 . B est vide ; q contient [1, 2] ; maxi est \u00e9gal \u00e0 3 . La derni\u00e8re boucle renverse la pile q dans la pile B , ainsi, \u00e0 la ligne 14 : q est vide ; B contient [2, 1] . Sans 3 dans la pile B initiale, on a dans l'ordre [1, 2] ce qui est diff\u00e9rent de [2, 1] obtenu ici avec depile_max . On a ainsi un exemple o\u00f9 l'ordre des \u00e9l\u00e9ments restants n'est pas pr\u00e9serv\u00e9 apr\u00e8s l'ex\u00e9cution de depile_max . On donne le code de la m\u00e9thode traiter : \ud83d\udc0d Script Python 1 2 3 4 5 6 def traiter ( self ): q = Pile () while not self . est_vide (): q . empiler ( self . depile_max ()) while not q . est_vide (): self . empiler ( q . depiler ()) 5.a) Donner les contenus successifs des piles B et q avant la ligne 3, avant la ligne 5, \u00e0 la fin de l'ex\u00e9cution de la fonction traiter lorsque la fonction traiter est appel\u00e9e avec la pile B contenant [1, 6, 4, 3, 7, 2] . R\u00e9ponse Avec B = [1, 6, 4, 3, 7, 2] , un appel B.traiter() conduit successivement \u00e0 : Avant la ligne 3, B contient [1, 6, 4, 3, 7, 2] ; q est vide. Avant la ligne 5, B est vide ; q contient [7, 6, 4, 3, 2, 1] \u00c0 la fin, B contient [1, 2, 3, 4, 6, 7] q est vide. 5.b) Expliquer le traitement effectu\u00e9 par cette m\u00e9thode. R\u00e9ponse Ce traitement est un tri de la pile. On construit d'abord q comme la pile des \u00e9l\u00e9ments de self dans l'ordre d\u00e9croissant. On renverse ensuite la pile, qui se retrouve comme si on avait empil\u00e9 les \u00e9l\u00e9ments de self dans l'ordre croissant. EXERCICE 5 (4 points) \u2693\ufe0e Cet exercice traite du th\u00e8me \u00ab algorithmique \u00bb, et principalement des algorithmes sur les arbres binaires. On manipule ici les arbres binaires avec trois fonctions : est_vide(A) renvoie True si l'arbre binaire A est vide, False s'il ne l'est pas ; sous_arbre_gauche(A) renvoie le sous-arbre \u00e0 gauche de l'arbre binaire A ; sous_arbre_droite(A) renvoie le sous-arbre \u00e0 droite de l'arbre binaire A . L'arbre binaire renvoy\u00e9 par les fonctions sous_arbre_gauche et sous_arbre_droite peut \u00e9ventuellement \u00eatre l'arbre vide. On d\u00e9finit la hauteur d'un arbre binaire non vide de la fa\u00e7on suivante : si ses sous-arbres \u00e0 gauche et \u00e0 droite sont vides, sa hauteur est \\(0\\) ; si l'un des deux au moins est non vide, alors sa hauteur est \u00e9gale \u00e0 \\(1 + M\\) , o\u00f9 \\(M\\) est la plus grande des hauteurs de ses sous-arbres (\u00e0 gauche et \u00e0 droite) non vides. 1.a) Donner la hauteur de l'arbre ci-dessous. graph TD N0( ) --> N2( ) N0 --> N1( ) N2 --> N5( ) N2 --> N6( ) linkStyle 3 stroke-width:0px; style N6 opacity:0; R\u00e9ponse Avec cette d\u00e9finition, la hauteur de cet arbre binaire est 2. 1.b) Dessiner sur la copie un arbre binaire de hauteur \\(4\\) . R\u00e9ponse Avec cette d\u00e9finition, voici un arbre binaire de hauteur \\(4\\) . graph TD N0( ) --> N1( ) N0 --> N2( ) N1 --> N3( ) N1 --> N4( ) N2 --> N5( ) N2 --> N6( ) N4 --> N7( ) N4 --> N8( ) N7 --> N9( ) N7 --> N10( ) linkStyle 7 stroke-width:0px; style N8 opacity:0; linkStyle 4 stroke-width:0px; style N5 opacity:0; La hauteur d'un arbre est calcul\u00e9e par l'algorithme r\u00e9cursif suivant : Pseudo Code 1 2 3 4 5 6 7 8 9 10 11 12 13 Algorithme hauteur(A) : test d'assertion : A est suppos\u00e9 non vide si sous_arbre_gauche(A) vide et sous_arbre_droite(A) vide : renvoyer 0 sinon, si sous_arbre_gauche(A) vide : renvoyer 1 + hauteur(sous_arbre_droite(A)) sinon, si ... : renvoyer ... sinon: renvoyer 1 + max( hauteur(sous_arbre_gauche(A)), hauteur(sous_arbre_droite(A)) ) 2. Recopier sur la copie les lignes 7 et 8 en compl\u00e9tant les points de suspension. R\u00e9ponse Pseudo Code 1 2 3 4 5 6 7 8 9 10 11 12 13 Algorithme hauteur(A) : test d'assertion : A est suppos\u00e9 non vide si sous_arbre_gauche(A) vide et sous_arbre_droite(A) vide : renvoyer 0 sinon, si sous_arbre_gauche(A) vide : renvoyer 1 + hauteur(sous_arbre_droite(A)) sinon, si sous_arbre_droite(A) vide : renvoyer 1 + hauteur(sous_arbre_gauche(A)) sinon: renvoyer 1 + max( hauteur(sous_arbre_gauche(A)), hauteur(sous_arbre_droite(A)) ) Pour aller plus loin Si on d\u00e9finit la hauteur d'un arbre binaire vide \u00e9gale \u00e0 0, (celle d'un arbre r\u00e9duit \u00e0 un seul n\u0153ud \u00e9gal \u00e0 1), on a un algorithme bien plus simple, et qui traite tous les cas : Pseudo Code 1 2 3 4 5 6 7 8 Algorithme hauteur(A) : si A vide : renvoyer 0 sinon: renvoyer 1 + max( hauteur(sous_arbre_gauche(A)), hauteur(sous_arbre_droite(A)) ) On consid\u00e8re un arbre binaire R dont on note G le sous-arbre \u00e0 gauche et D le sous-arbre \u00e0 droite. On suppose que R est de hauteur \\(4\\) et G de hauteur \\(2\\) . 3.a) Justifier le fait que D n'est pas l'arbre vide et d\u00e9terminer sa hauteur. R\u00e9ponse Si D est \u00e9gal \u00e0 l'arbre vide, alors la hauteur de R est \u00e9gale \u00e0 1 + hauteur(G) qui est \u00e9gal \u00e0 \\(1+2=3\\) , or R est de hauteur \\(4\\) . Contradiction. Ainsi D n'est pas l'arbre vide. Dans ce cas 1 + max(hauteur(G), hauteur(D)) est \u00e9gal \u00e0 \\(4\\) . D'o\u00f9 1 + max(2, hauteur(D)) est \u00e9gal \u00e0 \\(4\\) . max(2, hauteur(D)) est \u00e9gal \u00e0 \\(3\\) . hauteur(D) est \u00e9gal \u00e0 \\(3\\) . 3.b) Illustrer cette situation par un dessin. R\u00e9ponse Cet arbre est de hauteur \\(4\\) , son sous arbre \u00e0 gauche est de hauteur \\(2\\) , son sous arbre \u00e0 droite est de hauteur \\(3\\) . graph TD N0( ) --> N1( ) N0 --> N2( ) N1 --> N3( ) N1 --> N4( ) N2 --> N5( ) N2 --> N6( ) N4 --> N7( ) N4 --> N8( ) N6 --> N9( ) N6 --> N10( ) N9 --> N11( ) N9 --> N12( ) linkStyle 7 stroke-width:0px; style N8 opacity:0; linkStyle 4 stroke-width:0px; style N5 opacity:0; Soit un arbre binaire non vide de hauteur h . On note n le nombre de n\u0153uds de cet arbre. On admet que \\(h + 1 \\leqslant n \\leqslant 2^{h+1} - 1\\) . 4.a) V\u00e9rifier ces in\u00e9galit\u00e9s sur l'arbre binaire de la question 1.a) . R\u00e9ponse Dans la question 1.a) , l'arbre binaire poss\u00e8de \\(n = 4\\) n\u0153uds et a une hauteur \\(h = 2\\) . On a bien \\(2 + 1 \\leqslant 4 \\leqslant 2^{2+1}\\) qui s'\u00e9crit aussi \\(3 \\leqslant 4 \\leqslant 8\\) 4.b) Expliquer comment construire un arbre binaire de hauteur h quelconque ayant h+1 n\u0153uds. R\u00e9ponse Il suffit , par exemple, de construire un arbre binaire o\u00f9 pour chaque n\u0153ud, soit le sous arbre \u00e0 gauche est vide, soit celui \u00e0 droite. Cela peut \u00eatre toujours celui \u00e0 gauche qui est vide, on parle alors d'arbre peigne \u00e0 droite. Cela peut \u00eatre toujours celui \u00e0 droite qui est vide, on parle alors d'arbre peigne \u00e0 gauche. 4.c) Expliquer comment construire un arbre binaire de hauteur h quelconque ayant \\(2^{h+1} - 1\\) n\u0153uds. Indication : \\(2^{h+1} - 1 = 1+2+4+...+2^h\\) . R\u00e9ponse Il faut , dans ce cas, construire un arbre binaire complet ; les sous-arbres vides sont tous \u00e0 la m\u00eame profondeur. Pour aller plus loin Avec l'autre d\u00e9finition de la hauteur, l'in\u00e9galit\u00e9 s'\u00e9crit \\(h \\leqslant n \\leqslant 2^h - 1\\) , et elle est encore valable pour l'arbre binaire vide. C'est plus simple et g\u00e9n\u00e9ral. L'objectif de la fin de l'exercice est d'\u00e9crire le code d'une fonction fabrique(h, n) qui prend comme param\u00e8tres deux nombres entiers positifs h et n tels que \\(h + 1 < n < 2^{h+1} - 1\\) , et qui renvoie un arbre binaire de hauteur h \u00e0 n n\u0153uds. Pour cela, on utilise les deux fonctions suivantes : arbre_vide() , qui renvoie un arbre vide ; arbre(gauche, droite) qui renvoie l'arbre de fils \u00e0 gauche gauche et de fils \u00e0 droite droite . 5. Recopier sur la copie l'arbre binaire ci-dessous et num\u00e9roter ses n\u0153uds de 1 en 1 en commen\u00e7ant \u00e0 1, en effectuant un parcours en profondeur pr\u00e9fixe. graph TD N0( ) --> N2( ) N0 --> N1( ) N1 --> N3( ) N1 --> N4( ) N2 --> N5( ) N2 --> N6( ) linkStyle 5 stroke-width:0px; style N6 opacity:0; N3 --> N7( ) N3 --> N8( ) N4 --> N9( ) N4 --> N10( ) R\u00e9ponse graph TD N0(1) --> N2(9) N0 --> N1(2) N1 --> N3(3) N1 --> N4(6) N2 --> N5(10) N2 --> N6( ) linkStyle 5 stroke-width:0px; style N6 opacity:0; N3 --> N7(4) N3 --> N8(5) N4 --> N9(7) N4 --> N10(8) La fonction fabrique ci-dessous a pour but de r\u00e9pondre au probl\u00e8me pos\u00e9. Pour cela, la fonction annexe utilise la valeur de n , qu'elle peut modifier et renvoie un arbre binaire de hauteur hauteur_max dont le nombre de n\u0153uds est \u00e9gal \u00e0 la valeur de n au moment de son appel. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def fabrique ( h , n ): def annexe ( hauteur_max ): if n == 0 : return arbre_vide () elif hauteur_max == 0 : n = n - 1 return ... else : n = n - 1 gauche = annexe ( hauteur_max - 1 ) droite = ... return arbre ( gauche , droite ) return annexe ( h ) 6. Recopier sur la copie les lignes 7 et 11 en compl\u00e9tant les points de suspension. R\u00e9ponse \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def fabrique ( h , n ): def annexe ( hauteur_max ): if n == 0 : return arbre_vide () elif hauteur_max == 0 : n = n - 1 return arbre ( arbre_vide (), arbre_vide ()) else : n = n - 1 gauche = annexe ( hauteur_max - 1 ) droite = arbre_vide () return arbre ( gauche , droite ) return annexe ( h )","title":"2022, Polyn\u00e9sie"},{"location":"BAC/1-jipo1/#2022-polynesie","text":"BACCALAUR\u00c9AT G\u00c9N\u00c9RAL, NSI, 2022, Polyn\u00e9sie Dur\u00e9e de l'\u00e9preuve : 3 heures 30 L'usage de la calculatrice avec mode examen actif est autoris\u00e9. L'usage de la calculatrice sans m\u00e9moire, \u00ab type coll\u00e8ge \u00bb est autoris\u00e9. Le candidat traite au choix 3 exercices parmi les 5 exercices propos\u00e9s. Sujet non officiel Ce n'est pas le sujet officiel, quelques modifications mineures ont \u00e9t\u00e9 apport\u00e9es. Le sujet d'origine est disponible en t\u00e9l\u00e9chargement .","title":"2022, Polyn\u00e9sie"},{"location":"BAC/BacBlanc_2022_COR/","text":"Th\u00e8me : Epreuve Ecrite BAC BAC BAC BLANC 2022 Exercice n\u00b01 \u2693\ufe0e Q1 Chaque enregistrement de la relation Articles doit mentionner un attribut Auteur qui est une cl\u00e9 \u00e9trang\u00e8re de la relation Auteurs. Si cette derni\u00e8re est vide, un SGBD refusera donc tout enregistrement d\u2019un nouvel article, car cela violerait la contrainte de r\u00e9f\u00e9rence : chaque article doit \u00eatre reli\u00e9 \u00e0 un auteur unique. Q2 Requ\u00eate \u00e0 saisir : \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO Traitements ( article , theme ) VALUES ( 2 , 4 ) Q3 Requ\u00eate \u00e0 saisir : \ud83d\uddc2\ufe0f Requ\u00eate SQL UPDATE Auteurs SET nom = \"J\u00e8raus\" WHERE idAuteur = 2 Q4.a Le titre des articles parus apr\u00e8s le 1er janvier 2022 inclus : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT titre FROM Articles WHERE dateParution >= 20220101 Q4.b Le titre des articles \u00e9crits par l\u2019auteur \u00c9tienne Zola : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT titre FROM Articles WHERE auteur = 3 Q4.c Le nombre d\u2019articles \u00e9crits par l\u2019auteur Jacques Pulitzer (pr\u00e9sent dans la table Auteurs mais on ne conna\u00eet pas son idAuteur) : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT count ( * ) FROM Articles JOIN Auteurs ON Articles . auteur = Auteurs . idAuteur WHERE Auteurs . nom = \"Pulitzer\" AND Auteurs . prenom = \"Jacques\" Q4.d Les dates de parution des articles traitant du th\u00e8me \u00ab Sport \u00bb : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT Articles . dateParution FROM Articles JOIN Traitements ON Articles . idArticle = Traitements . article JOIN Themes ON Traitements . theme = Themes . idTheme WHERE Themes . themes = \"Sport\" Exercice n\u00b02 : \u2693\ufe0e Partie A : G\u00e9n\u00e9ralit\u00e9s \u2693\ufe0e Q1 \u00b2R\u00e9partition possible : [26, 4], [17, 13], [15, 11] et [5]. Il faut dans ce cas 4 bo\u00eetes. Q2 On faut conna\u00eetre le nombre d\u2019\u00e9l\u00e9ments de la liste repartition. On suffit donc d\u2019utiliser l\u2019instruction len(repartition). Q3 \ud83d\udc0d Script Python def poids_boite ( boite ): poids = 0 for objet in boite : poids += objet return poids Partie B : Algorithmes de r\u00e9solution \u2693\ufe0e B1 : M\u00e9thode de la premi\u00e8re bo\u00eete \u2693\ufe0e Q4.a On obtient la r\u00e9partition [8, 2], [3, 1], [9], [7]. Q4.b On pourrait faire [8, 2], [3, 7], [9, 1]. On utiliserait alors 3 bo\u00eetes au lieu de 4. La m\u00e9thode de la premi\u00e8re position n\u2019est donc pas optimale. Q5 Code possible : \ud83d\udc0d Script Python def premiere_position ( objets , poids_max ): repartition = [] # la r\u00e9partition repartition . append ([]) # on ajoute une bo\u00eete vide for objet in objets : # parcours des objets ajout = False # permet de savoir si l'objet a \u00e9t\u00e9 ajout\u00e9 for boite in repartition : if poids_boite ( boite ) + objet <= poids_max : # l'objet tient dans cette boite boite . append ( objet ) # on l'ajoute ajout = True break if not ajout : # l'objet ne tient dans aucune des premi\u00e8res bo\u00eetes... repartition . append ([ objet ]) # on l'ajoute dans une nouvelle bo\u00eete return repartition B2 : M\u00e9thode de la meilleure bo\u00eete \u2693\ufe0e Q6 Consid\u00e9rons des objets de poids [8, 1, 9, 2] et un poids maximal de 10. En appliquant la m\u00e9thode de la meilleure bo\u00eete, on obtient la r\u00e9partition [8, 1], [9], [2]. Pourtant, il est possible de faire mieux avec la r\u00e9partition [8, 2], [9, 1], qui ne fait intervenir que deux bo\u00eetes. La m\u00e9thode de la meilleure bo\u00eete n\u2019est donc pas optimale. Q7 Code possible : \ud83d\udc0d Script Python # On \"remonte\" cette bo\u00eete \u00e0 sa position tri\u00e9e while i > 0 and poids_boite ( repartition [ i ]) > poids_boite ( repartition [ i - 1 ]) : repartition [ i ], repartition [ i - 1 ] = repartition [ i - 1 ], repartition [ i ] i = i - 1 Exercice n\u00b03 : \u2693\ufe0e Partie A \u2693\ufe0e Q1.a On obtient : Q1.b Cet arbre n\u2019est pas \u00e9quilibr\u00e9 car le n\u0153ud de valeur 15 a une balance de 2. Q2.a On obtient [0, 45, 40, 48, 17, 43, None, 49, 14, 19] Q2.b On obtient : Q3.a La fonction myst permet de calculer la hauteur d\u2019un arbre. En effet, si l\u2019arbre est vide ou si la valeur de sa racine est None, on renvoie 0. Dans le cas contraire, on renvoie 1 plus de maximum des r\u00e9sultats des sous-arbres gauches et droits (indices 2 i et 2 i+1). On calcule ainsi la hauteur de l\u2019arbre. Q3.b myst(arbre, 1) renvoie 3, qui est la hauteur de l\u2019arbre Q4 Code possible : \ud83d\udc0d Script Python def est_equilibre ( arbre , i ): if i >= len ( arbre ) or arbre [ i ] is None : return True else : balance = myst ( arbre , 2 * i + 1 ) - myst ( arbre , 2 * i ) reponse = balance in [ - 1 , 0 , 1 ] return reponse and est_equilibre ( arbre , 2 * i ) and est_equilibre ( arbre , 2 * i + 1 ) Partie B \u2693\ufe0e Q4 Parcours pr\u00e9fixe : 45, 40, 17, 14, 19, 43, 48, 49 Parcours infixe : 14, 17, 19, 40, 43, 45, 48, 49 Parcours postfixe : 14, 19, 17, 43, 40, 49, 48, 45 Q6 On obtient : Q7 \ud83d\udc0d Script Python def infixe ( arbre ): pile = [] visites = [] n = 1 repetition = True while repetition : while n < len ( arbre ) and arbre [ n ] is not None : pile . append ( n ) n = 2 * n if len ( pile ) == 0 : repetition = False else : n = pile . pop () visites . append ( arbre [ n ]) n = 2 * n + 1 return visites Q8 \ud83d\udc0d Script Python def construire_ABR ( i , ordre ): while len ( nouveau ) != i + 1 : nouveau . append ( None ) i_milieu = len ( ordre ) // 2 nouveau [ i ] = ordre [ i_milieu ] gauche = ordre [: i_milieu ] if gauche != []: construire_ABR ( 2 * i , gauche ) droite = ordre [( i_milieu + 1 ):] if droite != []: construire_ABR ( 2 * i + 1 , droite )","title":"BacBlanc 2022 COR"},{"location":"BAC/France_J1_2022/","text":"Th\u00e8me : Epreuve Ecrite BAC BAC France J1 2022 Exercice n\u00b01 : \u2693\ufe0e Cet exercice compos\u00e9 de deux parties A et B, porte sur les structures de donn\u00e9es. Partie A : Expression correctement parenth\u00e9s\u00e9e On veut d\u00e9terminer si une expression arithm\u00e9tique est correctement parenth\u00e9s\u00e9e. Pour chaque parenth\u00e8se fermante \")\" correspond une parenth\u00e8se pr\u00e9c\u00e9demment ouverte \"(\". Exemples : L\u2019expression arithm\u00e9tique \"(2 + 3) \u00d7 (18/(4 + 2))\" est correctement parenth\u00e9s\u00e9e. L\u2019expression arithm\u00e9tique \"(2 + 3) \u00d7 (18/(4 + 2\" est non correctement parenth\u00e9s\u00e9e. Pour simplifier les expressions arithm\u00e9tiques, on enregistre, dans une structure de donn\u00e9es, uniquement les parenth\u00e8ses dans leur ordre d\u2019apparition. On appelle expression simplifi\u00e9e cette structure. 1) Indiquer si la phrase \u00ab les \u00e9l\u00e9ments sont maintenant retir\u00e9s (pour \u00eatre lus) de cette structure de donn\u00e9es dans le m\u00eame ordre qu\u2019ils y ont \u00e9t\u00e9 ajout\u00e9s lors de l\u2019enregistrement \u00bb d\u00e9crit le comportement d\u2019une file ou d\u2019une pile. Justifier. R\u00e9ponse La phrase d\u00e9crit le comportement d\u2019une file puisque le premier \u00e9l\u00e9ment entr\u00e9 est aussi le premier \u00e9l\u00e9ment qui sera lu (first in first out) . Pour v\u00e9rifier le parenth\u00e9sage, on peut utiliser une variable controleur qui : - est un nombre entier \u00e9gal \u00e0 0 en d\u00e9but d\u2019analyse de l\u2019expression simplifi\u00e9e ; - augmente de 1 si l\u2019on rencontre une parenth\u00e8se ouvrante \"(\" ; - diminue de 1 si l\u2019on rencontre une parenth\u00e8se fermante \")\". Exemple : On consid\u00e8re l\u2019 expression simplifi\u00e9e A : \"( )( ( ) )\" Lors de l\u2019analyse de l\u2019expression A, controleur (initialement \u00e9gal \u00e0 0) prend successivement pour valeur 1, 0, 1, 2, 1, 0. Le parenth\u00e9sage est correct. 2) \u00c9crire, pour chacune des 2 expressions simplifi\u00e9es B et C suivantes, les valeurs successives prises par la variable controleur lors de leur analyse. Expression simplifi\u00e9e B : \" ((( )( )\" Expression simplifi\u00e9e C : \"(( )))(\" R\u00e9ponse Pour l\u2019expression B, la variable contr\u00f4leur prend successivement les valeurs: 1, 2, 3, 2, 3, 2 Pour l\u2019expression C, la variable contr\u00f4leur prend successivement les valeurs: 1, 2, 1, 0, -1, 0 3) L\u2019expression simplifi\u00e9e B pr\u00e9c\u00e9dente est mal parenth\u00e9s\u00e9e (parenth\u00e8ses fermantes manquantes) car le controleur est diff\u00e9rent de z\u00e9ro en fin d\u2019analyse. L\u2019expression simplifi\u00e9e C pr\u00e9c\u00e9dente est \u00e9galement mal parenth\u00e9s\u00e9e (parenth\u00e8se fermante sans parenth\u00e8se ouvrante) car le controleur prend une valeur n\u00e9gative pendant l\u2019analyse. Recopier et compl\u00e9ter uniquement les lignes 13 et 16 du code ci-dessous pour que la fonction parenthesage_correct r\u00e9ponde \u00e0 sa description. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def parenthesage_correct ( expression ): ''' fonction retournant True si l'expression arithm\u00e9tique simplifi\u00e9e (str) est correctement parenth\u00e9s\u00e9e, False sinon. Condition: expression ne contient que des parenth\u00e8ses ouvrantes et fermantes''' controleur = 0 for parenthese in expression : #pour chaque parenth\u00e8se if parenthese == '(' : controleur = controleur + 1 else : # parenthese == ')' controleur = controleur - 1 if controleur ... : # test 1 (\u00e0 recopier et compl\u00e9ter) #parenth\u00e8se fermante sans parenth\u00e8se ouvrante return False if controleur ... : # test 2 (\u00e0 recopier et compl\u00e9ter) return True #le parenth\u00e9sage est correct else : return False #parenth\u00e8se(s) fermante(s) manquante(s) R\u00e9ponse \ud83d\udc0d Script Python if controleur < 0 : #parenth\u00e8sage fermante sans parenth\u00e8se ouvrante return False if controleur == 0 : Partie B : Texte correctement balis\u00e9 On peut faire l\u2019analogie entre le texte simplifi\u00e9 des fichiers HTML (uniquement constitu\u00e9 de balises ouvrantes <nom> et fermantes </nom> ) et les expressions parenth\u00e9s\u00e9es : Par exemple, l\u2019expression HTML simplifi\u00e9e : \"<p><strong><em></em></strong></p>\" est correctement balis\u00e9e. On ne tiendra pas compte dans cette partie des balises ne comportant pas de fermeture comme <br> ou <img> . Afin de v\u00e9rifier qu\u2019une expression HTML simplifi\u00e9e est correctement balis\u00e9e, on peut utiliser une pile (initialement vide) selon l\u2019algorithme suivant : On parcourt successivement chaque balise de l\u2019expression : - lorsque l\u2019on rencontre une balise ouvrante, on l\u2019empile ; - lorsque l\u2019on rencontre une balise fermante : - si la pile est vide, alors l\u2019analyse s\u2019arr\u00eate : le balisage est incorrect , - sinon, on d\u00e9pile et on v\u00e9rifie que les deux balises (la balise fermante rencontr\u00e9e et la balise ouvrante d\u00e9pil\u00e9e) correspondent (c\u2019est-\u00e0-dire ont le m\u00eame nom) si ce n\u2019est pas le cas, l\u2019analyse s\u2019arr\u00eate (balisage incorrect). Exemple : \u00c9tat de la pile lors du d\u00e9roulement de cet algorithme pour l\u2019expression simplifi\u00e9e \"<p><em></p></em>\" qui n\u2019est pas correctement balis\u00e9e. Cette question traite de l\u2019\u00e9tat de la pile lors du d\u00e9roulement de l\u2019algorithme. 4.a) Repr\u00e9senter la pile \u00e0 chaque \u00e9tape du d\u00e9roulement de cet algorithme pour l\u2019expression \"<p><em></em></p>\" (balisage correct). R\u00e9ponse <p><em></em></p> Pile Balise ouvrante, on empile <em></em></p> : Pile <p> balise ouvrante, on empile </em></p> : Pile <em> <p> balise fermante, on d\u00e9pile <em></em></p> : Pile <p> balise fermante, on d\u00e9pile <p><em></em></p> : Pile 4.b) Indiquer quelle condition simple (sur le contenu de la pile) permet alors de dire que le balisage est correct lorsque toute l\u2019expression HTML simplifi\u00e9e a \u00e9t\u00e9 enti\u00e8rement parcourue, sans que l\u2019analyse ne s\u2019arr\u00eate. R\u00e9ponse Comme d\u00e9crit dans le a., \u00e0 la fin du parcours de l\u2019expression si l\u2019analyse ne s\u2019est pas arr\u00eat\u00e9e et si la pile est vide alors le balisage est correct. 5) Une expression HTML correctement balis\u00e9e contient 12 balises. Indiquer le nombre d\u2019\u00e9l\u00e9ments que pourrait contenir au maximum la pile lors de son analyse. R\u00e9ponse Si une expression correctement balis\u00e9e contient 12 balises, c\u2019est qu\u2019elle contient 6 balises ouvrantes et 6 balises fermantes. Le nombre d\u2019\u00e9l\u00e9ments que pourraient contenir lapile au maximum correspond au cas o\u00f9 l\u2019expression est d\u2019abord compos\u00e9e des 6 balises ouvrantes suivies des 6 balises fermantes. Cela signifie, si l\u2019on suit l\u2019algorithme donn\u00e9 dans l\u2019\u00e9nonc\u00e9 que les 6 balises ouvrantes vont \u00eatre d\u2019abord empil\u00e9es avant d\u2019\u00eatre d\u00e9pil\u00e9es. Dans ce cas, la pile contiendra au maximum 6 \u00e9l\u00e9ments. Exercice n\u00b02 : \u2693\ufe0e Cet exercice porte sur les bases de donn\u00e9es. On pourra utiliser les mots cl\u00e9s SQL suivants : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT , FROM , WHERE , JOIN , ON , INSERT , INTO , VALUES , UPDATE , SET , AND . Nous allons \u00e9tudier une base de donn\u00e9es traitant du cin\u00e9ma dont voici le sch\u00e9ma relationnel qui comporte 3 relations : - la relation individu (id_ind, nom, prenom, naissance) - la relation realisation (id_rea, titre, annee, type) - la relation emploi (id_emp, description, #id_ind, #id_rea) Les cl\u00e9s primaires sont soulign\u00e9es et les cl\u00e9s \u00e9trang\u00e8res sont pr\u00e9c\u00e9d\u00e9es d\u2019un # . Ainsi emploi.id_ind est une cl\u00e9 \u00e9trang\u00e8re faisant r\u00e9f\u00e9rence \u00e0 individu.id_ind . Voici un extrait des tables individu et realisation : On s\u2019int\u00e9resse ici \u00e0 la r\u00e9cup\u00e9ration de donn\u00e9es dans une relation. 1.a) \u00c9crire ce que renvoie la requ\u00eate ci-dessous : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT nom , prenom , naissance FROM individu WHERE nom = 'Crog' ; R\u00e9ponse La requ\u00eate renvoie les attributs nom, prenom et naissance des entit\u00e9s de la relation individu dont le nom est \u2018Crog\u2019 soit : \u2018Grog\u2019 \u2018Daniel\u2019 \u201807-07-1968\u2019 1.b) Fournir une requ\u00eate SQL permettant de r\u00e9cup\u00e9rer le titre et la cl\u00e9 primaire de chaque film dont la date de sortie est strictement sup\u00e9rieure \u00e0 2020. R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT titre , id_rea FROM realisation WHERE annee > 2020 ; Cette question traite de la modification de relations. 2.a) Dire s\u2019il faut utiliser la requ\u00eate 1 ou la requ\u00eate 2 propos\u00e9es ci-dessous pour modifier la date de naissance de Daniel Crog. Justifier votre r\u00e9ponse en expliquant pourquoi la requ\u00eate refus\u00e9e ne pourra pas fonctionner. Requ\u00eate 1 \ud83d\uddc2\ufe0f Requ\u00eate SQL UPDATE individu SET naissance = '02-03-1968' WHERE id_ind = 688 AND nom = 'Crog' AND prenom = 'Daniel' ; Requ\u00eate 2 \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO individu VALUES ( 688 , 'Crog' , 'Daniel' , '02-03-1968' ); R\u00e9ponse Il faut utiliser la requ\u00eate 1 pour modifier la date de naissance de Daniel Grog. En effet, la requ\u00eate 2 entrainerait une erreur dans la mesure o\u00f9 l\u2019entit\u00e9 de la relation individu qui a pour cl\u00e9 primaire id_ind = 688 existe d\u00e9j\u00e0 donc il est impossible d\u2019en cr\u00e9er une autre, la cl\u00e9 primaire est unique. 2.b) Expliquer si la relation individu peut accepter (ou pas) deux individus portant le m\u00eame nom, le m\u00eame pr\u00e9nom et la m\u00eame date de naissance. R\u00e9ponse C\u2019est possible dans la mesure o\u00f9 seule la cl\u00e9 primaire id_ind doit \u00eatre unique. Donc la relation pourrait tr\u00e8s bien contenir une deuxi\u00e8me entit\u00e9 avec les m\u00eames nom, pr\u00e9nom et date de naissance mais avec une cl\u00e9 primaire id_ind diff\u00e9rente. Cette question porte sur la notion de cl\u00e9s \u00e9trang\u00e8res. 3.a) Recopier sur votre copie les demandes ci-dessous, dans leur int\u00e9gralit\u00e9, et les compl\u00e9ter correctement pour qu\u2019elles ajoutent dans la relation emploi les r\u00f4les de Daniel Crog en tant que James Bond dans le film nomm\u00e9 \u2018Casino Imp\u00e9rial\u2019 puis dans le film \u2018Ciel tombant\u2019. \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO emploi VALUES ( 5400 , 'Acteur(James Bond)' , ... ); INSERT INTO emploi VALUES ( 5401 , 'Acteur(James Bond)' , ... ); R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO emploi VALUES ( 5400 , \u2019 Acteur ( James Bond ) \u2019 , 688 , 105 ) ; INSERT INTO emploi VALUES ( 5401 , \u2019 Acteur ( James Bond \u2019 , 688 , 325 ) ; 3.b) On d\u00e9sire rajouter un nouvel emploi de Daniel Crog en tant que James Bond dans le film 'Docteur Yes'. Expliquer si l\u2019on doit d\u2019abord cr\u00e9er l\u2019enregistrement du film dans la relation realisation ou si l\u2019on doit d\u2019abord cr\u00e9er le r\u00f4le dans la relation emploi. R\u00e9ponse Pour pouvoir ajouter une nouvelle entit\u00e9 dans la table emploi , il faut que les cl\u00e9s \u00e9trang\u00e8res de cette nouvelle entit\u00e9 Id_ind et id_rea existent d\u00e9j\u00e0 comme cl\u00e9s primaires dans les tables individu et r\u00e9alisation . Or la cl\u00e9 primaire du film \u2018Docteur Yes\u2019 n\u2019existe pas encore dans la table r\u00e9alisation puisque le film n\u2019a pas encore \u00e9t\u00e9 cr\u00e9\u00e9 dans cette table. Il faut donc commencer par cr\u00e9er l\u2019entit\u00e9 \u2018Docteur Yes\u2019 de ce film dans la table r\u00e9alisation et ensuite seulement, il sera possible de cr\u00e9er l\u2019entit\u00e9 demand\u00e9e dans la table emploi . Cette question traite des jointures. 4.a) Recopier sur votre copie la requ\u00eate SQL ci-dessous, dans son int\u00e9gralit\u00e9, et la compl\u00e9ter de fa\u00e7on \u00e0 ce qu\u2019elle renvoie le nom de l\u2019acteur, le titre du film et l\u2019ann\u00e9e de sortie du film, \u00e0 partir de tous les enregistrements de la relation emploi pour lesquels la description de l\u2019emploi est 'Acteur(James Bond)'. \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT ... FROM emploi JOIN individu ON ... JOIN realisation ON ... WHERE emploi . description = 'Acteur(James Bond)' ; R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT individu . nom , realisation . titre , realisation . annee FROM emploi JOIN individu ON individu . id_ind = emploi . id_ind JOIN realisation ON realisation . id_rea = emploi . id_rea WHERE emploi . description = \u2018 Acteur ( James Bond ) \u2019 ; 4.b) Fournir une requ\u00eate SQL permettant de trouver toutes les descriptions des emplois de Denis Johnson (Denis est son pr\u00e9nom et Johnson est son nom). On veillera \u00e0 n\u2019afficher que la description des emplois et non les films associ\u00e9s \u00e0 ces emplois. R\u00e9ponse \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT emploi . description FROM emploi JOIN individu ON individu . id_ind = emploi . id_ind WHERE individu . nom = \u2018 Johnson \u2019 AND individu . prenom = \u2018 Denis \u2019 ; Exercice n\u00b03 : \u2693\ufe0e Cet exercice porte sur les repr\u00e9sentations binaires et les protocoles de routage. Une adresse IPv4 est repr\u00e9sent\u00e9e sous la forme de 4 nombres s\u00e9par\u00e9s par des points. Chacun de ces 4 nombres peut \u00eatre repr\u00e9sent\u00e9 sur un octet. 1.a) Donner en \u00e9criture d\u00e9cimale l\u2019adresse IPv4 correspondant \u00e0 l\u2019\u00e9criture binaire : 11000000.10101000.10000000.10000011 R\u00e9ponse 11000000 = 192 en base 10 10101000 = 168 10000000 = 128 10000011 = 131 L\u2019adresse est donc 192.168.128.131 1.b) Tous les ordinateurs du r\u00e9seau A ont une adresse IPv4 de la forme : 192.168.128. _ _ _ , o\u00f9 seul le dernier octet (repr\u00e9sent\u00e9 par _ _ _ ) diff\u00e8re. Donner le nombre d\u2019adresses diff\u00e9rentes possibles du r\u00e9seau A R\u00e9ponse Sur un octet il est possible d\u2019avoir \\(2^6=256\\) valeurs allant de 0 \u00e0 255 sachant que deux valeurs 0 et 255 sont r\u00e9serv\u00e9es, il reste alors 254 valeurs \u00e0 attribuer. On rappelle que le protocole RIP cherche \u00e0 minimiser le nombre de routeurs travers\u00e9s (qui correspond \u00e0 la m\u00e9trique). On donne les tables de routage d\u2019un r\u00e9seau informatique compos\u00e9 de 5 routeurs (appel\u00e9s A, B, C, D et E), chacun associ\u00e9 directement \u00e0 un r\u00e9seau du m\u00eame nom obtenues avec le protocole RIP : 2.a) Donner la liste des routeurs avec lesquels le routeur A est directement reli\u00e9 R\u00e9ponse Les routeurs connect\u00e9s \u00e0 A sont \u00e0 un saut, donc d\u2019apr\u00e8s la table : B,C et D sont directement reli\u00e8s \u00e0 A 2.b) Repr\u00e9senter graphiquement et de mani\u00e8re sommaire les 5 routeurs ainsi que les liaisons existantes entre ceux-ci. R\u00e9ponse 3.) Le protocole OSPF est un protocole de routage qui cherche \u00e0 minimiser la somme des m\u00e9triques des liaisons entre routeurs. Dans le protocole de routage OSPF le d\u00e9bit des liaisons entre routeurs agit sur la m\u00e9trique via la relation : \\(m\u00e9trique = \\dfrac{10^8}{d\u00e9bit}\\) dans laquelle le d\u00e9bit est exprim\u00e9 en bit par seconde (bps). On rappelle qu\u2019un kbps est \u00e9gal \u00e0 10 bps et qu\u2019un Mbps est \u00e9gal \u00e0 10 bps. Recopier sur votre copie et compl\u00e9ter le tableau suivant : D\u00e9bit 100 kbps 500 kbps ? 100 Mbps M\u00e9trique associ\u00e9\u00e9 1000 ? 10 1 R\u00e9ponse D\u00e9bit 100 kbps 500 kbps 10 Mbps 100 Mbps M\u00e9trique associ\u00e9\u00e9 1000 200 10 1 Voici la repr\u00e9sentation d\u2019un r\u00e9seau et la table de routage incompl\u00e8te du routeur F obtenue avec le protocole OSPF : Les nombres pr\u00e9sents sur les liaisons repr\u00e9sentent les co\u00fbts des routes avec le protocole OSPF. 4.a) Indiquer le chemin emprunt\u00e9 par un message d\u2019un ordinateur du r\u00e9seau F \u00e0 destination d\u2019un ordinateur du r\u00e9seau I. Justifier votre r\u00e9ponse. R\u00e9ponse Le chemin le plus court en tenant compte de la m\u00e9trique est : F\u2192 H \u2192 J \u2192 K \u2192 I pour une m\u00e9trique de 13 4.b) Recopier et compl\u00e9ter la table de routage du routeur F. R\u00e9ponse Destination M\u00e9trique F 0 G 8 H 5 I 13 J 6 K 8 L 11 4.c) Citer une unique panne qui suffirait \u00e0 ce que toutes les donn\u00e9es des \u00e9changes de tout autre r\u00e9seau \u00e0 destination du r\u00e9seau F transitent par le routeur G. Expliquer en d\u00e9tail votre r\u00e9ponse. R\u00e9ponse Tous les \u00e9changes \u00e0 dezstination de F passent par G si on coupe la liaison entre F et H de m\u00e9trique 5. En effet en enlevant la connexion F-H tous les chemins les plus courts passent par G-F de m\u00e9trique 10. L\u2019autre possibilit\u00e9 est de passer par F-I de m\u00e9trique 20 qui allonge trop le chemin par rapport aux autres liaisons. Exercice n\u00b0 4 \u2693\ufe0e Cet exercice, compos\u00e9 de deux parties A et B, porte sur le parcours des arbres binaires, le principe \u201cdiviser pour r\u00e9gner\u201d et la r\u00e9cursivit\u00e9. Cet exercice, compos\u00e9 de deux parties A et B, porte sur le parcours des arbres binaires, le principe \u201cdiviser pour r\u00e9gner\u201d et la r\u00e9cursivit\u00e9. Cet exercice traite du calcul de la somme d\u2019un arbre binaire. Cette somme consiste \u00e0 additionner toutes les valeurs num\u00e9riques contenues dans les n\u0153uds de l\u2019arbre. L\u2019arbre utilis\u00e9 dans les parties A et B est le suivant : Partie A : Parcours d'un arbre 1.) Donner la somme de l\u2019arbre pr\u00e9c\u00e9dent. Justifier la r\u00e9ponse en explicitant le calcul qui a permis de l\u2019obtenir. R\u00e9ponse \\(3+6+2+7+4+9+1 = 32\\) utilisation d\u2019un parcours en largeur d'abord. Autre possibilit\u00e9 : En utilisant les sous-arbres de gauche et de droite \\(3 + (6 +(7+4))+(2+(9+1)) = 3+(6+11)+(2+10)=3+17+12=32\\) 2.) Indiquer la lettre correspondante aux noms \u2018racine\u2019, \u2018feuille\u2019, \u2018n\u0153ud\u2019, \u2018SAG\u2019 (Sous Arbre Gauche) et \u2018SAD\u2019 (Sous Arbre Droit). Chaque lettre A, B, C, D et E devra \u00eatre utilis\u00e9e une seule fois. R\u00e9ponse A : racine ; B : N\u0153ud ; C : Feuille ; D : Sous-arbre gauche ; E : Sous arbre droit. 3.) Parmi les quatre propositions A, B, C et D ci-dessous, donnant un parcours en largeur d\u2019abord de l\u2019arbre, une seule est correcte. Indiquer laquelle. Proposition A : 7 - 6 - 4 - 3 - 9 - 2 - 1 Proposition B : 3 - 6 - 7 - 4 - 2 - 9 - 1 Proposition C : 3 - 6 - 2 - 7 - 4 - 9 - 1 Proposition D : 7 - 4 - 6 - 9 - 1 - 2 \u2013 3 R\u00e9ponse Le parcours en largeur d'abord correspond \u00e0 la proposition C 4.) \u00c9crire en langage Python la fonction somme qui prend en param\u00e8tre une liste de nombres et qui renvoie la somme de ses \u00e9l\u00e9ments. Exemple : somme([1, 2, 3, 4]) est \u00e9gale \u00e0 10. R\u00e9ponse \ud83d\udc0d Script Python def somme ( liste ): somme = 0 for nombre in liste : somme += nombre return somme 5.) La fonction parcourir(arbre) pourrait se traduire en langage naturel par : \ud83d\udccb Texte parcourir(A): L = liste_vide F = file_vide enfiler A dans F Tant que F n\u2019est pas vide d\u00e9filer S de F ajouter la valeur de la racine de S dans L Pour chaque sous arbre SA non vide de S enfiler SA dans F renvoyer L Donner le type de parcours obtenu gr\u00e2ce \u00e0 la fonction parcourir. R\u00e9ponse Le parcours obtenu avec fonction parcourir est un parcours en largeur d'abord; Partie B : M\u00e9thode 'diviser pour r\u00e9gner' 6.) Parmi les quatre propositions A,B, C et D ci-dessous, indiquer la seule proposition correcte. En informatique, le principe diviser pour r\u00e9gner signifie : Proposition A : diviser une fonction en deux fonctions plus petites Proposition B : utiliser plusieurs modules Proposition C : s\u00e9parer les informations en fonction de leur types Proposition D : diviser un probl\u00e8me en deux probl\u00e8mes plus petits et ind\u00e9pendants R\u00e9ponse Proposition D : le principe diviser pour r\u00e9gner signifie : diviser un probl\u00e8me en deux probl\u00e8mes plus petits et ind\u00e9pendants. 7.) L\u2019arbre pr\u00e9sent\u00e9 dans le probl\u00e8me peut \u00eatre d\u00e9compos\u00e9 en racine et sous arbres : Indiquer dans l\u2019esprit de \u2018diviser pour r\u00e9gner\u2019 l\u2019\u00e9galit\u00e9 donnant la somme d\u2019un arbre en fonction de la somme des sous arbres et de la valeur num\u00e9rique de la racine. R\u00e9ponse \ud83d\udc0d Script Python Somme ( A ) = Valeur ( racine ) + Somme ( SAG ) + Somme ( SAD ) 8.) \u00c9crire en langage Python une fonction r\u00e9cursive calcul_somme(arbre) . Cette fonction calcule la somme de l\u2019arbre pass\u00e9 en param\u00e8tre. Les fonctions suivantes sont disponibles : est_vide(arbre) : renvoie True si arbre est vide et renvoie False sinon ; valeur_racine(arbre) : renvoie la valeur num\u00e9rique de la racine de arbre ; arbre_gauche(arbre) : renvoie le sous arbre gauche de arbre ; arbre_droit(arbre) : renvoie le sous arbre droit de arbre. R\u00e9ponse \ud83d\udc0d Script Python def calcul_somme ( arbre ): if est_vide ( arbre ): return 0 else : return valeur_racine ( arbre ) + calcul_somme ( arbre_gauche ( arbre )) + calcul_somme ( droit ( arbre )) Exercice n\u00b05 : \u2693\ufe0e Cet exercice porte sur la Programmation Orient\u00e9e Objet. Les participants \u00e0 un jeu de LaserGame sont r\u00e9partis en \u00e9quipes et s\u2019affrontent dans ce jeu de tir, rev\u00eatus d\u2019une veste \u00e0 capteurs et munis d\u2019une arme factice \u00e9mettant des infrarouges. Les ordinateurs embarqu\u00e9s dans ces vestes utilisent la programmation orient\u00e9e objet pour mod\u00e9liser les joueurs. La classe Joueur est d\u00e9finie comme suit : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Joueur : def __init__ ( self , pseudo , identifiant , equipe ): '''constructeur''' self . pseudo = pseudo self . equipe = equipe self . id = identifiant self . nb_de_tirs_emis = 0 self . liste_id_tirs_recus = [] self . est_actif = True def tire ( self ): '''m\u00e9thode d\u00e9clench\u00e9e par l'appui sur la gachette''' if self . est_actif == True : self . nb_de_tirs_emis = self . nb_de_tirs_emis + 1 def est_determine ( self ): '''methode qui renvoie True si le joueur r\u00e9alise un grand nombre de tirs''' return self . nb_de_tirs_emis > 500 def subit_un_tir ( self , id_recu ): '''m\u00e9thode d\u00e9clench\u00e9e par les capteurs de la veste''' if self . est_actif == True : self . est_actif = False self . liste_id_tirs_recus . append ( id_recu ) 1.) Parmi les instructions suivantes, recopier celle qui permet de d\u00e9clarer un objet joueur1, instance de la classe Joueur, correspondant \u00e0 un joueur dont le pseudo est \u201cSniper\u201d, dont l\u2019identifiant est 319 et qui est int\u00e9gr\u00e9 \u00e0 l\u2019\u00e9quipe \u201cA\u201d: Instruction 1 : joueur1 = [\"Sniper\", 319, \"A\"] Instruction 2 : joueur1 = new Joueur[\"Sniper\", 319, \"A\"] Instruction 3 : joueur1 = Joueur(\"Sniper\", 319, \"A\") Instruction 4 : joueur1 = Joueur{\"pseudo\":\"Sniper\", \"id\":319, \"equipe\":\"A\"} R\u00e9ponse L\u2019instruction 3 est la bonne fa\u00e7on de d\u00e9clarer un objet. \ud83d\udc0d Script Python joueur1 = Joueur ( \"Sniper\" , 319 , \"A\" ) La m\u00e9thode subit_un_tir r\u00e9alise les actions suivantes : Lorsqu'un joueur actif subit un tir capt\u00e9 par sa veste, l'identifiant du tireur est ajout\u00e9 \u00e0 l'attribut liste_id_tirs_recus et l'attribut est_actif prend la valeur False (le joueur est d\u00e9sactiv\u00e9). Il doit alors revenir \u00e0 son camp de base pour \u00eatre de nouveau actif. 2.a) \u00c9crire la m\u00e9thode redevenir_actif qui rend \u00e0 nouveau le joueur actif uniquement s\u2019il \u00e9tait pr\u00e9c\u00e9demment d\u00e9sactiv\u00e9. R\u00e9ponse \ud83d\udc0d Script Python def redevenir_actif ( self ): if not self . est_actif : self . est_actif = True 2.b) \u00c9crire la m\u00e9thode nb_de_tirs_recus qui renvoie le nombre de tirs re\u00e7us par un joueur en utilisant son attribut liste_id_tirs_recus . R\u00e9ponse \ud83d\udc0d Script Python def nb_de_tirs_recus ( self ): return len ( self . liste_id_tirs_recus ) Lorsque la partie est termin\u00e9e, les participants rejoignent leur camp de base respectif o\u00f9 un ordinateur, qui utilise la classe Base, r\u00e9cup\u00e8re les donn\u00e9es. La classe Base est d\u00e9finie par : - ses attributs : - equipe : nom de l\u2019\u00e9quipe (str). Par exemple, \u201cA\u201d , - liste_des_id_de_l_equipe qui correspond \u00e0 la liste (list) des identifiants connus des joueurs de l\u2019\u00e9quipe, - score : score (int) de l\u2019\u00e9quipe, dont la valeur initiale est 1000 ; ses m\u00e9thodes : est_un_id_allie qui renvoie True si l\u2019identifiant pass\u00e9 en param\u00e8tre est un identifiant d\u2019un joueur de l\u2019\u00e9quipe, False sinon, incremente_score qui fait varier l\u2019attribut score du nombre pass\u00e9 en param\u00e8tre, collecte_information qui r\u00e9cup\u00e8re les statistiques d\u2019un participant pass\u00e9 en param\u00e8tre (instance de la classe Joueur) pour calculer le score de l\u2019\u00e9quipe . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def collecte_information ( self , participant ): if participant . equipe == self . equipe : # test 1 for id in participant . liste_id_tirs_recus : if self . est_un_id_allie ( id ): # test 2 self . incremente_score ( - 20 ) else : self . incremente_score ( - 10 ) 3.a) Indiquer le num\u00e9ro du test (test 1 ou test 2) qui permet de v\u00e9rifier qu\u2019en fin de partie un participant \u00e9gar\u00e9 n\u2019a pas rejoint par erreur la base adverse. R\u00e9ponse Le test 1 v\u00e9rifie l\u2019appartenance d\u2019un joueur \u00e0 l\u2019\u00e9quipe 3.b) D\u00e9crire comment varie quantitativement le score de la base lorsqu\u2019un joueur de cette \u00e9quipe a \u00e9t\u00e9 touch\u00e9 par le tir d\u2019un co\u00e9quipier. R\u00e9ponse Le test 2 v\u00e9rifie si l\u2019identifiant d\u2019un joueur pr\u00e9sent dans la liste des tirs est un co\u00e9quipier ou un joueur de l\u2019\u00e9quipe adverse. Si le joueur a \u00e9t\u00e9 touch\u00e9 par un co\u00e9quipier le score de l\u2019\u00e9quipe baisse de 20 si le joueur a \u00e9t\u00e9 touch\u00e9 par un adverse le score baisse de 10. On souhaite accorder \u00e0 la base un bonus de 40 points pour chaque joueur particuli\u00e8rement d\u00e9termin\u00e9 (qui r\u00e9alise un grand nombre de tirs). 4.) Recopier et compl\u00e9ter, en utilisant les m\u00e9thodes des classes Joueur et Base, les 2 lignes de codes suivantes qu\u2019il faut ajouter \u00e0 la fin de la m\u00e9thode collecte_information : \ud83d\udc0d Script Python ........ #si le participant r\u00e9alise un grand nombre de tirs ......... #le score de la Base augmente de 40 R\u00e9ponse \ud83d\udc0d Script Python if participant . est_determine (): # si le participant r\u00e9alise un grand nombre de tirs self . incremente_score ( 40 ) # le score de la base augmente de 40","title":"France J1 2022"},{"location":"BAC/France_Remplacement_Sept_2021_Cor/","text":"Th\u00e8me : Sujet \u00e9crit BAC BAC France Septembre 2021 - Sujet 1 - Correction Exercice n\u00b01 : \u2693\ufe0e Partie A 1 TCP : protocole de transport charg\u00e9 de d\u00e9couper et d\u2019assembler les paquets IP : protocole de routage charg\u00e9 de trouver la bonne route 2.a Le masque \u00e9tant 255.255.255.0, on garde les trois premiers nombres de l'adresse IP pour obtenir l'adresse du r\u00e9seau soit 200.100.10.0 2.b Les adresses possibles pour les machines sont dans la plage : 200.100.10.1 - 200.100.10.254. Soit au total 254 machines possibles. Partie B 1 Le masque de sous-r\u00e9seaux est 255.255.0.0 donc on ne garde que les deux premiers nombres \ud83d\udccb Texte - machine A : 172.16.0.0 - machine F : 10.0.0.0 2 Pour le r\u00e9seau 1, les machine poss\u00e8dent toutes la m\u00eame adresse r\u00e9seau 172.16.0.0 et font partir du m\u00eame r\u00e9seau. Par contre seules les machines F \u00e0 I appartiennent au r\u00e9seau 10.0.0.0. La machine J appartient au r\u00e9seau 8.0.0.0. 3 R\u00e9seeau 1 : \\(256^^2 - 2\\) 4 il est n\u00e9cessaire d\u2019utiliser un routeur qui va servir de passerelles entre les r\u00e9seaux. Et on va utiliser deux switch pour relier les ordinateurs de chaque r\u00e9seau. A, B, C, D et E sur un switch connect\u00e9 au routeur F, G, H, I sur un 2eme switch connect\u00e9 au routeur J directement connect\u00e9 au routeur Exercice n\u00b02 \u2693\ufe0e Partie A 1 Vrai 2 Logarithmique, (on divise en 2 \u00e0 chaque \u00e9tape) On pose \\(n=2^p\\) - A chaque \u00e9tape on divise par 2 : - etape 1 : \\(2^{p-1}\\) - etape 2 : $2^^{p-2} - etc On a alors \\(n=2^p\\) etapes soit p = log_2(n)$ d'o\u00f9 une comp^l\u00e9xit\u00e9 de \\(O(log(n))\\) 3 fin \u2192 \\(1/2^n\\) taille(liste) \u2013 1, donc fin \u2192 -1 quand n \u2192 +\u221e deb \u2192 1/2n taille(liste) + 1, donc deb \u2192 + 1 quand n \u2192 +\u221e la condition de continuation deb <= fin n\u2019est plus r\u00e9alis\u00e9e Partie B 1 La liste est pass\u00e9e en param\u00e8tre et on ne conna\u00eet pas \u00e0 priori la taille de liste 2 \ud83d\udccb Texte algorithme quotient(num\u00e9rateur : entier, diviseur : entier) : entier quotient : entier := 0 tant que ( ((quotient + 1) * diviseur) < num\u00e9rateur ) faire quotient := quotient + 1 renvoyer quotient 3 4 \ud83d\udc0d Script Python def rechercheDicho ( elem , liste ): deb = 0 fin = len ( liste ) - 1 m = ( deb + fin ) // 2 while deb <= fin : if liste [ m ] == elem : return True , m elif liste [ m ] > elem : fin = m - 1 else : deb = m + 1 m = ( deb + fin ) // 2 return False , - 1 Partie C 1 Programme qui s\u2019appelle lui m\u00eame 2 \ud83d\udc0d Script Python def rechercheDicho ( elem : str , liste : list , deb : int , fin : int ) -> bool : \"\"\" recherche dichotomique d\u2019un \u00e9l\u00e9ment dans une liste renvoie True si l\u2019objet a \u00e9t\u00e9 trouv\u00e9, False sinon.\"\"\" if deb > fin : return False m = ( deb + fin ) // 2 if liste [ m ] == elem : return True elif liste [ m ] > elem : return rechercheDicho ( elem , liste , deb , m - 1 ) else : return rechercheDicho ( elem , liste , m + 1 , fin ) Exercice n\u00b03 : SQL \u2693\ufe0e Partie A 1 Table : Aeroport Attribut : codeIATA 2 a : 1 b : 3 Partie B 1 Contrainte d\u2019int\u00e9grit\u00e9 r\u00e9f\u00e9rentielle : la clef \u00e9trang\u00e8re BCN n\u2019existe pas dans la table Aeroport 2 Contrainte d\u2019int\u00e9grit\u00e9 de cl\u00e9 : la clef F-KI452 existe d\u00e9j\u00e0 dans la table Avion 3 Contrainte d\u2019int\u00e9grit\u00e9 de domaine : le valeur \u00ab environ 200 \u00bb n\u2019est pas de type entier Partie C 1 Supprime tous les vols de la table vol dont la date de d\u00e9part est ant\u00e9rieure au 11 janvier 2021 2 \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO Type VALUES ( \u02ba A310\u02ba , 250 , \u02ba Airbus\u02ba ) ; 3 \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT DISTINCT Type . nomT FROM Type , Vol , Avion WHERE Vol . dateVol = \u02ba 10 / 01 / 2021 \u02ba AND Avion . numA = Vol . numAvion AND Type . nomT = Avion . type ORDER BY Type . nomT ASC Exercice n\u00b04 : \u2693\ufe0e Partie A 1 _nom : str (nom de la chambre), accesseur get_nom() _occupation : list (tableau de 365 bool\u00e9ens), accesseur get_occupation(), mutateur reserver() 2 assert 0 < date < 366 3 \ud83d\udc0d Script Python def AnnulerReserver ( self , date : int ): assert 0 < date < 366 self . _occupation [ date - 1 ] = False Partie B 1 \ud83d\udc0d Script Python GiteBN . ajouter_chambres ( \"Ch1\" ) 2 \ud83d\udc0d Script Python def ajouter_chambres ( self , nom_ch : str ) -> bool : if nom_ch not in self . get_nchambres (): self . _chambres . append ( Chambre ( nom_ch )) return True return False 3.a Tableau d\u2019objet Chambre 3.b Ch2 3.c get_chambres() : tableau d\u2019objet Chambre get_nchambres() : tableau de nom de chambre 4.a la liste des chambres inoccup\u00e9es en date du jour j 4.b def mystere(self, date : int) -> list: attribut : self._chambres m\u00e9thode : get_occupation() get_nom() Exercice n\u00b05 : \u2693\ufe0e 1.a Un arbre binaire de recherche est un arbre binaire dans lequel chaque noeud poss\u00e8de une cl\u00e9 , telle que chaque noeud du sous-arbre gauche ait une cl\u00e9 inf\u00e9rieure ou \u00e9gale \u00e0 celle du noeud consid\u00e9r\u00e9, et que chaque noeud du sous-arbre droit poss\u00e8de une cl\u00e9 sup\u00e9rieure ou \u00e9gale \u00e0 celle-ci. 1.b 15 1.c Hauteur : 4 2 3 2 3 4 6 7 9 13 15 17 18 20 on obtient une liste tri\u00e9e 4 \ud83d\udccb Texte Recherche(A, x) : Si EstVide(A) alors Faux Si Racine(A) = x alors Vrai Si x<Racine(A) alors Sag(A, x) Sinon Sad(A, x)","title":"France Remplacement Sept 2021 Cor"},{"location":"BAC/Polynesie_sujet2_2021/","text":"Th\u00e8me : Sujet \u00e9crit BAC BAC Polyn\u00e9sie 2021 - Sujet 2 Exercice 1 \u2693\ufe0e Partie A \u2693\ufe0e Q1 8 [8, 7, 18, 16, 12, 9, 17, 3] Q2` \ud83d\udc0d Script Python print ( notes [ 2 : 5 ]) ou \ud83d\udc0d Script Python for i in [ 2 , 3 , 4 ]: print ( notes [ i ]) ou \ud83d\udc0d Script Python for i in range [ 2 , 5 ]: print ( notes [ i ]) Partie B \u2693\ufe0e Q1 \ud83d\udccb Texte def tri_insertion(liste): \"\"\"trie par insertion la liste en param\u00e8tre \"\"\" for indice_courant in range(1, len(liste)): element_a_inserer = liste[indice_courant] i = indice_courant - 1 while i >= 0 and liste[i] > element_a_inserer: liste[i+1] = liste[i] i = i - 1 liste[i + 1] = element_a_inserer Q2 [7, 8, 18, 14, 12, 9, 17, 3] Q3 [7, 8, 14, 18, 12, 9, 17, 3] Partie C \u2693\ufe0e Q1 r\u00e9cursif : \u00e0 l'\u00e9tape (3) l'algorithme de tri fusion s'appelle lui-m\u00eame. Q2 Comparer les cartes du haut des 2 tas. Placer la carte de valeur plus faible dans la main. Recommencer l'\u00e9tape 1 jusqu'\u00e0 \u00e9puisement des tas. On pose ensuite le dernier tas restant. Q3 \ud83d\udc0d Script Python from math import floor def tri_fusion ( liste , i_debut , i_fin ): \"\"\" trie par fusion la liste en param\u00e8tre depuis i_debut jusqu'\u00e0 i_fin \"\"\" if i_debut < i_fin : i_partage = floor (( i_debut + i_fin ) / 2 ) # milieu pour diviser le tableau en deux moiti\u00e9s tri_fusion ( liste , i_debut , i_partage ) # Appel tri_fusion pour 1\u00e8re moiti\u00e9 du tableau tri_fusion ( liste , i_partage + 1 , i_fin ) # Appel tri_fusion pour 2\u00e8me moiti\u00e9 du tableau fusionner ( liste , i_debut , i_partage , i_fin ) # Fusion des deux moiti\u00e9s tri\u00e9es Q4 permet d'importer la fonction floor() du module math utilis\u00e9e \u00e0 la ligne 7 partie D \u2693\ufe0e Q1 tri par fusion : \u00e0 chaque \u00e9tape, le tri se fait par fusion de 2 tas d\u00e9j\u00e0 tri\u00e9s Q2 tri par insertion : \\(O(n\u00b2)\\) tri par fusion : \\(O(n.\\log_2 n)\\) Q3 Le tri par insertion utilise 2 boucles imbriqu\u00e9es, soit dans le pire des cas \\(\\dfrac{1/2} n(n+1)\\) op\u00e9rations. Le tri par fusion, divise la liste \u00e0 trier par 2 pour chaque it\u00e9rations, soit \\(\\log_2 n\\) op\u00e9rations. r\u00e9peter \\(n\\) fois. Exercice 2 \u2693\ufe0e Partie A \u2693\ufe0e Q1 Clients : IdClient Articles : IdArticle Q2 Email : VARCHAR(50), cha\u00eene de 50 caract\u00e8res Quantity : INT, entier sign\u00e9 Q3 \ud83d\uddc2\ufe0f Requ\u00eate SQL CREATE TABLE Commandes ( IdCmdINT PRIMARY KEY , IdClientINT , Date DATE , AdresseLivraisonVARCHAR ( 90 ), PaiementValideBOOLEAN , LivraisonFaiteBOOLEAN , FOREIGN KEY ( IdClient ) REFERENCES Clients ( IdClient ) ); Partie B \u2693\ufe0e Q1 La m\u00e9thode POST fait passer les informations \u00e0 envoyer dans le corps de la requ\u00eate HTTP et ne figurent pas dans l'adresse URL du serveur, contrairement \u00e0 la m\u00e9thode GET. Q2 Le protocole HTTPS est chiffr\u00e9 de bout en bout ce qui est indispensable pour assurer la confidentialit\u00e9 des transactions bancaires. Q3 Afin d'assurer la coh\u00e9rence des donn\u00e9es en vue de leur traitement ult\u00e9rieur. Ex : envoi d'un mailing. Partie C \u2693\ufe0e Q1 \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT IdArticle , Libelle FROM Articles WHERE PrixEnCentimes < 1500 Q2 La requ\u00eate s\u00e9lectionne tous les identifiants et les m\u00e8ls des clients, ainsi que les identifiants et les adresses de livraison de leurs commandes pour des paiements qui n'ont pas \u00e9t\u00e9 valid\u00e9s. Q3 \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT Articles . Libelle FROM Articles , ArticlesCommande WHERE ArticlesCommande . IdCmd = 1345 AND ArticlesCommande . IdArticle = Articles . IdArticle ORBER BY Articles . Libelle Q4 \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO Articles VALUES ( NULL , 'Imperm\u00e9able' , 'Cet imperm\u00e9able se replie en forme de pochette.' , 999 ) Partie D \u2693\ufe0e Q1 Articles Clients IdArticle INT IdClient INT Libelle VARCHAR(50) Nom VARCHAR(50) Description VARCHAR(90) Prenom VARCHAR(50) PrixEnCentimes INT Email VARCHAR(50) Stock INT AdresseLivraison VARCHAR(90) Q2 Il ne faut pas d\u00e9cr\u00e9menter stock de 1 mais de la quantit\u00e9 command\u00e9e : Stock \u2190 Stock -- Quantit\u00e9 Exercice 3 \u2693\ufe0e Partie A \u2693\ufe0e Q1 Racine : 5 Fils gauche : 2 Fils droit : 7 Q2 Noeuds : [5, 2] Q3 Partie B \u2693\ufe0e Q1 init initialise les attributs de l'objet lors de l'instanciation de la classe. Q2 L'\u00e9l\u00e9ment \u00e0 ins\u00e9rer est ignor\u00e9. Q3 \ud83d\udc0d Script Python arbre = ABR ( 5 ) arbre . insererElement ( 2 ) arbre . insererElement ( 3 ) arbre . insererElement ( 7 ) arbre . insererElement ( 8 ) Partie C \u2693\ufe0e Q1 Parcours infixe Q2 La complexit\u00e9 est de l'ordre du tri par fusion ~ O(nln 2 n) Alors que les complexit\u00e9s des tris par s\u00e9lection et insertion sont ~ O(n\u00b2) Exercice 4 \u2693\ufe0e Partie A \u2693\ufe0e Q1 Le r\u00e9seau fonctionne sur le principe de la commutation de paquets. TCP d\u00e9coupe le message en paquets (datagrammes). Ces paquets sont rout\u00e9s par IP gr\u00e2ce aux en-t\u00eates qui encapsulent le message. Q2a Le sommets repr\u00e9sentent le nom des routeurs. Les ar\u00eates repr\u00e9sentent les connexions entre les routeurs. Q2b RIP utilise le nombre de sauts entre les routeurs. Partie B \u2693\ufe0e Q1 L'interblocage se produit lorsque des processus concurrents s'attendent mutuellement. Exemple d'interblocage : le processus P1 utilise la ressource R2 qui est attendue par le processus P2 qui utilise la ressource R1 , attendue par P1 . Q2 Utilisation de mutex. Algorithme du Banquier. Partie C \u2693\ufe0e Q1 Q2 IP : UC. Registre qui contient l'adresse m\u00e9moire de l'instruction en cours d'ex\u00e9cution ou prochainement ex\u00e9cut\u00e9e. Une fois l'instruction charg\u00e9e, il est automatiquement incr\u00e9ment\u00e9 pour pointer l'instruction suivante. IR : UC. Registre qui contient l'instruction en cours d'ex\u00e9cution ou de d\u00e9codage. Q3 Q4 M\u00e9moire morte : m\u00e9moire non volatile dont le contenu est fix\u00e9 lors de leur fabrication, qui peut \u00eatre lue plusieurs fois et qui n'est pas pr\u00e9vue pour \u00eatre modifi\u00e9e. M\u00e9moire vive : m\u00e9moire volatile dans laquelle des donn\u00e9es peuvent \u00eatre \u00e9crites, lues et modifi\u00e9es. Un microcontr\u00f4leur ex\u00e9cute un programme d\u00e8s qu\\'il est mis sous tension. Ce programme ne doit pas \u00eatre modifi\u00e9 par un simple utilisateur. Partie D \u2693\ufe0e Q1 Chaque microprocesseur peut effectuer une t\u00e2che sp\u00e9cialiser pour augmenter la rapidit\u00e9 du traitement. Q2 La vitesse des diff\u00e9rents composants (CPU, RAM, circuits d'entr\u00e9es/sorties, ...) \u00e9volue en fonction de la technologie. Cette \u00e9volution n'est pas la m\u00eame pour tous les composants. Q3 La miniaturisation permet d'avoir des fonctions avanc\u00e9es de taille r\u00e9duite, facile \u00e0 int\u00e9grer physiquement dans des syst\u00e8mes dits embarqu\u00e9s. Q4 La puissance de calcul est g\u00e9n\u00e9ralement plus faible qu'avec une architecture classique. Exercice 5 \u2693\ufe0e Partie A \u2693\ufe0e Q1 Relation Films : IdFilm Relation Abonn\u00e9s : IdAbonne Q2 IdFilm : entier non sign\u00e9 Description : cha\u00eene de 150 caract\u00e8res Q3 clef primaire : IdCpt clef \u00e9trang\u00e8re : IdAbonne Q4 Il faut cr\u00e9er une Relation Acteurs dont le sch\u00e9ma relationnel est le suivant : \ud83d\uddc2\ufe0f Requ\u00eate SQL Acteurs ( * IdActeur * , Nom , Prenom ) La clef primaire est soulign\u00e9. Les attributs Nom et Prenom doivent \u00eatre de type VARCHAR(20) Il faut d\u00e9finir une clef unique sur le couple (Nom, Prenom) pour \u00e9viter les doublons. Et une relation ActeursPrincipaux dont le sch\u00e9ma relationnel est le suivant : \ud83d\uddc2\ufe0f Requ\u00eate SQL ActeursPrincipaux ( # IdActeur , # IdFilm ) Les clef \u00e9trang\u00e8res commencent par # et r\u00e9f\u00e9rencent respectivement les relations Acteurs et Films. Q5 Il faut rajouter un Attribut DateNaissance de type DATE \u00e0 la relation Clients. Et ajouter un attribut AgeMinimum de type INT \u00e0 la relation Films. Partie B \u2693\ufe0e Q1 \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT IdCpt , Pseudo FROM ComptesAbonnes WHERE IdAbonne = 237 Q2 Calcule la moyenne du nombre d'\u00e9toiles attribu\u00e9 au film dont l'identifiant est 1542 Q3 S\u00e9lectionne, par ordre d\u00e9croissant en nombre d'\u00e9toiles, les identifiants, les titres des films et les nombres d'\u00e9toiles attribu\u00e9s par le compte abonn\u00e9 n\u00b0 508 Q4 \ud83d\uddc2\ufe0f Requ\u00eate SQL UPDATE ComptesAbonnes SET pseudo = 'Champion' WHERE IdAbonne = 508 Partie C \u2693\ufe0e Q1 La fonction calcule, dans une liste de films non vide, la moyenne des \u00e9carts des notes attribu\u00e9es \u00e0 chaque film par deux comptes d'abonn\u00e9s. Q2 \ud83d\udc0d Script Python def conseilsFilms ( IdCpt : int ) -> list : conseils = [] liste_films = podiumCompte ( IdCpt ) liste_spectateurs = spectateurs ( liste_films ) for spectateur in liste_spectateurs : if distance ( IdCpt , spectateur , liste_films ) < 10 : film_preferes = podiumCompte ( spectateur ) for i in range ( 3 ): if i < len ( film_preferes ): conseils . append ( film_preferes [ i ]) return conseils","title":"Polynesie sujet2 2021"},{"location":"BAC/Sujet_0/","text":"Th\u00e8me : Sujet \u00e9crit BAC BAC Sujet Dur\u00e9e de l\u2019\u00e9preuve : 3 heures 30 L\u2019usage de la calculatrice n\u2019est pas autoris\u00e9. D\u00e8s que ce sujet vous est remis, assurez-vous qu\u2019il est complet. Ce sujet comporte 13 pages num\u00e9rot\u00e9es de 1/13 \u00e0 13/13. Le candidat traite au choix 3 exercices parmi les 5 exercices propos\u00e9s. Chaque exercice est not\u00e9 sur 4 points.","title":"Sujet 0"},{"location":"BAC/Sujet_2021_01/","text":"@@include Sujet_2021_01_Ex4.md {% include-markdown \"docs/includes/Sujet_2021_01_Ex4.md\" heading-offset=1 }","title":"Sujet 2021 01"},{"location":"BAC/Sujet_2021_01bis/","text":"Exercice 4 \u2693\ufe0e Extrait sujet BAC 2021 Cet exercice porte sur la gestion des processus par un syst\u00e8me d\u2019exploitation. Partie A : Processus La commande UNIX ps pr\u00e9sente un clich\u00e9 instantan\u00e9 des processus en cours d'ex\u00e9cution. Avec l\u2019option \u2212eo pid,ppid,stat,command, cette commande affiche dans l\u2019ordre l\u2019identifiant du processus PID (process identifier), le PPID (parent process identifier), l\u2019\u00e9tat STAT et le nom de la commande \u00e0 l\u2019origine du processus. Les valeurs du champ STAT indique l\u2019\u00e9tat des processus : - R : processus en cours d\u2019ex\u00e9cution - S : processus endormi Sur un ordinateur, on ex\u00e9cute la commande ps \u2212eo pid,ppid,stat,command et on obtient un affichage dont on donne ci-dessous un extrait. \u00c0 l'aide de cet affichage, r\u00e9pondre aux questions ci-dessous. Q.1. Quel est le nom de la premi\u00e8re commande ex\u00e9cut\u00e9e par le syst\u00e8me d'exploitation lors du d\u00e9marrage ? Correction La premi\u00e8re commande ex\u00e9cut\u00e9e par le syst\u00e8me d\u2019exploitation lors du d\u00e9marrage est la commande init Q.2. Quels sont les identifiants des processus actifs sur cet ordinateur au moment de l\u2019appel de la commande ps ? Justifier la r\u00e9ponse. Correction Les processus actifs sont les processus ayant pour PID 5440 et 5450 (pr\u00e9sence de l\u2019indicateur R dans la colonne STAT pour ces 2 processus). Q.3. Depuis quelle application a-t-on ex\u00e9cut\u00e9 la commande ps ? Donner les autres commandes qui ont \u00e9t\u00e9 ex\u00e9cut\u00e9es \u00e0 partir de cette application. Correction La commande ps a \u00e9t\u00e9 ex\u00e9cut\u00e9e depuis l\u2019application Bash (car le processus ps a pour PPID 1912 qui correspond au PID de Bash). Deux autres processus Bash (PID 2014 et PID 2013) et un processus python programme1.py (PID 5437) ont \u00e9t\u00e9 lanc\u00e9s depuis le processus Bash de PID 1912 Q.4. Expliquer l'ordre dans lequel les deux commandes python programme1.py et python programme2.py ont \u00e9t\u00e9 ex\u00e9cut\u00e9es. Correction Le processus python programme1.py a un PID de 5437 alors que le processus python programme2.py a un PID de 5440. python programme1.py a \u00e9t\u00e9 ex\u00e9cut\u00e9 avant python programme2.py. Q.5. Peut-on pr\u00e9dire que l'une des deux commandes python programme1.py et python programme2.py finira avant l\u2019autre ? Correction Non, aucune pr\u00e9diction n\u2019est possible.","title":"Sujet 2021 01bis"},{"location":"BAC/Sujet_Libre_2_2021/","text":"Th\u00e8me : Epreuve Ecrite BAC BAC France Septembre 2021 Dur\u00e9e de l\u2019\u00e9preuve : 3 heures 30 L\u2019usage de la calculatrice n\u2019est pas autoris\u00e9. D\u00e8s que ce sujet vous est remis, assurez-vous qu\u2019il est complet. Le candidat traite au choix 3 exercices parmi les 5 exercices propos\u00e9s. Chaque exercice est not\u00e9 sur 4 points. Exercice n\u00b01 - 4 points \u2693\ufe0e Principaux th\u00e8mes abord\u00e9s : protocoles de communication, architecture d\u2019un r\u00e9seau et protocoles de routage. Les parties A et B sont ind\u00e9pendantes. Partie A : R\u00e9seau Q.1. Parmi les termes ci-dessous, pr\u00e9ciser celui qui d\u00e9signe l'ensemble des r\u00e8gles de communication utilis\u00e9es pour r\u00e9aliser un service particulier sur le r\u00e9seau ? \u25a1 Architecture \u25a1 Protocole \u25a1 Paquet Q.2. On consid\u00e8re le sch\u00e9ma r\u00e9seau de l\u2019entreprise Lambda : Parmi les quatre propositions suivantes (Routeur, Commutateur (Switch), Contr\u00f4leur WIFI et Serveur), pr\u00e9ciser celle qui correspond \u00e0 : a) L\u2019\u00e9l\u00e9ment A b) L\u2019\u00e9l\u00e9ment B Q.3. En reprenant le sch\u00e9ma de la question 2. et le tableau d\u2019adressage du r\u00e9seau de l'entreprise Lambda, recopier sur votre copie et compl\u00e9ter la ligne du tableau du poste 3 : Partie B L\u2019extrait de la table de routage d\u2019un routeur R1 est donn\u00e9 ci-dessous : Q.1. Indiquer sur votre copie les adresses IP du(des) r\u00e9seau(x) directement connect\u00e9s \u00e0 ce routeur. Q.2. Indiquer sur votre copie l\u2019interface utilis\u00e9e pour transf\u00e9rer les paquets contenant les adresses IP destination suivantes : Adresse IP destination Interface Machine ou Port 192.168.1.55 172.18.10.10 Q.3. On consid\u00e8re un r\u00e9seau selon le sch\u00e9ma ci-dessous. Recopier sur votre copie et compl\u00e9ter la table de routage simplifi\u00e9e du Routeur1 (R1) (ci-dessous) en prenant comme m\u00e9trique le nombre de routeurs \u00e0 \u00ab traverser \u00bb avant d\u2019atteindre le r\u00e9seau de la machine destinataire. Exercice n\u00b02 - 4 points \u2693\ufe0e Principaux th\u00e8mes abord\u00e9s : structure de donn\u00e9es (tableaux, dictionnaires) et langages et programmation (sp\u00e9cification). Objectif de l\u2019exercice : Les Aventuriers du Rail\u00a9 est un jeu de soci\u00e9t\u00e9 dans lequel les joueurs doivent construire des lignes de chemin de fer entre diff\u00e9rentes villes d'un pays. La carte des liaisons possibles dans la r\u00e9gion Occitanie est donn\u00e9e en annexe 1 de l\u2019exercice 2. Dans l\u2019 annexe 2 de l\u2019exercice 2, les liaisons poss\u00e9d\u00e9es par le joueur 1 sont en noir, et celles du joueur 2 en blanc. Les liaisons en gris sont encore en jeu. Codages des structures de donn\u00e9es utilis\u00e9es : Liste des liaisons d'un joueur : Toutes les liaisons directes (sans ville interm\u00e9diaire) construites par un joueur seront enregistr\u00e9es dans une variable de type \"tableau de tableaux\". Le joueur 1 poss\u00e8de les lignes directes \"Toulouse-Muret\", \"Toulouse-Montauban\", \"Gaillac-St Sulpice\" et \"Muret-Pamiers\" (liaisons indiqu\u00e9es en noir dans l\u2019annexe 2 de l\u2019exercice 2). Ces liaisons sont m\u00e9moris\u00e9es dans la variable ci-dessous. \ud83d\udc0d Script Python liaisonsJoueur1 = [ [ \"Toulouse\" , \"Muret\" ], [ \"Toulouse\" , \"Montauban\" ], [ \"Gaillac\" , \"St Sulpice\" ], [ \"Muret\" , \"Pamiers\" ] ] Remarque : Seules les liaisons directes existent, par exemple [\"Toulouse\",\"Muret\"] ou [\"Muret\",\"Toulouse\"] . Par contre, le tableau [\"Toulouse\",\"Mazamet\"] n'existe pas, puisque la ligne Toulouse-Mazamet passe par Castres. Dictionnaire associ\u00e9 \u00e0 un joueur : On code la liste des villes et des trajets poss\u00e9d\u00e9e par un joueur en utilisant un dictionnaire de tableaux . Chaque clef de ce dictionnaire est une ville de d\u00e9part, et chaque valeur est un tableau contenant les villes d'arriv\u00e9e possibles en fonction des liaisons poss\u00e9d\u00e9es par le joueur. Le dictionnaire de tableaux du joueur 1 est donn\u00e9 ci-dessous : \ud83d\udc0d Script Python DictJoueur1 = { \"Toulouse\" :[ \"Muret\" , \"Montauban\" ], \"Montauban\" :[ \"Toulouse\" ], \"Gaillac\" :[ \"St Sulpice\" ], \"St Sulpice\" :[ \"Gaillac\" ], \"Muret\" :[ \"Toulouse\" , \"Pamiers\" ], \"Pamiers \" :[ \"Muret\" ] } Q.1. Expliquer pourquoi la liste des liaisons suivante n'est pas valide : \ud83d\udc0d Script Python tableauliaisons = [[ \"Toulouse\" , \"Auch\" ], [ \"Luchon\" , \"Muret\" ], [ \"Quillan\" , \"Limoux\" ] ] Q.2. Cette question concerne le joueur n\u00b02 (Rappel : les liaisons poss\u00e9d\u00e9es par le joueur n\u00b02 sont repr\u00e9sent\u00e9es par un rectangle blanc dans l\u2019 annexe 2 de l\u2019exercice 2 ). 2.a) Donner le tableau liaisonsJoueur2, des liaisons poss\u00e9d\u00e9es par le joueur n\u00b02. 2.b) Recopier et compl\u00e9ter le dictionnaire suivant, associ\u00e9 au joueur n\u00b02 : python DictJoueur2 = { \"Toulouse\":[\"Castres\",\"Castelnaudary\"], ... } Q.3. \u00c0 partir du tableau de tableaux contenant les liaisons d'un joueur, on souhaite construire le dictionnaire correspondant au joueur. Une premi\u00e8re proposition a abouti \u00e0 la fonction construireDict ci-dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def construireDict ( listeLiaisons ): \"\"\" listeLiaisons est un tableau de tableaux repr\u00e9sentant la liste des liaisons d'un joueur comme d\u00e9crit dans le probl\u00e8me \"\"\" Dict = {} for liaison in listeLiaisons : villeA = liaison [ 0 ] villeB = liaison [ 1 ] if not villeA in Dict . keys () : Dict [ villeA ] = [ villeB ] else : destinationsA = Dict [ villeA ] if not villeB in destinationsA : destinationsA . append ( villeB ) return Dict 3.a) \u00c9crire sur votre copie un assert dans la fonction construireDict qui permet de v\u00e9rifier que la listeLiaisons n\u2019est pas vide. 3.b) Sur votre copie, donner le r\u00e9sultat de cette fonction ayant comme argument la variable liaisonsJoueur1 donn\u00e9e dans l\u2019\u00e9nonc\u00e9 et expliquer en quoi cette fonction ne r\u00e9pond que partiellement \u00e0 la demande. 3.c) La fonction construireDict , d\u00e9finie ci-dessus, est donc partiellement inexacte. Compl\u00e9ter la fonction construireDict pour qu\u2019elle g\u00e9n\u00e8re bien l\u2019ensemble du dictionnaire de tableaux correspondant \u00e0 la liste de liaisons donn\u00e9es en argument. \u00c0 l\u2019aide des num\u00e9ros de lignes, on pr\u00e9cisera o\u00f9 est ins\u00e9r\u00e9 ce code. Exercice n\u00b03 - 4 points \u2693\ufe0e Principaux th\u00e8mes abord\u00e9s : bases de donn\u00e9es (mod\u00e8le relationnel, base de donn\u00e9es relationnelle et langage SQL). Dans notre monde, l\u2019information a de plus en plus de valeur et d\u2019importance mais nous sommes de plus en plus confront\u00e9s \u00e0 l\u2019infob\u00e9sit\u00e9. Consid\u00e9rons l\u2019utilisation des donn\u00e9es issues de la table de Mendele\u00efev (tableau p\u00e9riodique des \u00e9l\u00e9ments). Il est contraignant de faire des recherches sur des moteurs d\u00e9di\u00e9s \u00e0 chaque fois qu\u2019une valeur est n\u00e9cessaire (masse volumique, rayon de covalence, point de fusion\u2026). Les lignes 3, 4 et 5 de cette table Mendele\u00efev ont permis de construire, en annexe 1 de l\u2019exercice 3 , une base de donn\u00e9es des diff\u00e9rents atomes correspondants. Q.1. Donner le nom du langage informatique utilis\u00e9 pour acc\u00e9der aux donn\u00e9es dans une base de donn\u00e9es ? Q.2. a) Lister les diff\u00e9rents attributs des tables ATOMES et VALENCE en pr\u00e9cisant le type du domaine de chacun. b) D\u00e9terminer si des attributs de la table ATOMES peuvent avoir un r\u00f4le de cl\u00e9 primaire et/ou de cl\u00e9 \u00e9trang\u00e8re. Justifier. c) Donner le sch\u00e9ma relationnel pour les deux tables ATOMES et VALENCE. Q.3. Donner les r\u00e9ponses des deux requ\u00eates suivantes : a) \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT nom FROM ATOMES WHERE L = '3' ORDER BY Sym b) \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT DISTINCT C FROM ATOMES Q.4. Donner la requ\u00eate SQL : a) Pour afficher le nom et la masse atomique des atomes. b) Pour afficher le symbole des atomes dont la couche de valence est s. Q.5. On a remarqu\u00e9 une erreur de saisie dans la table ATOMES, la masse atomique de l\u2019argon (Ar) n\u2019est pas 29,948 g.mol \\(^{-1}\\) mais 39,948 g.mol \\(^{-1}\\) . \u00c9crire la requ\u00eate SQL pour corriger cette erreur de saisie. ANNEXE 1 Exercice n\u00b04 - 4 points \u2693\ufe0e Principaux th\u00e8mes abord\u00e9s : structure de donn\u00e9es (programmation objet) et langages et programmation (sp\u00e9cification). Une entreprise fabrique des yaourts qui peuvent \u00eatre soit nature (sans ar\u00f4me), soit aromatis\u00e9s (fraise, abricot ou vanille). Pour pouvoir traiter informatiquement les sp\u00e9cificit\u00e9s de ce produit, on va donc cr\u00e9er une classe Yaourt qui poss\u00e8dera un certain nombre d\u2019attributs : Son genre : nature ou aromatis\u00e9 Son ar\u00f4me : fraise, abricot, vanille ou aucun Sa date de durabilit\u00e9 minimale (DDM) exprim\u00e9e par un entier compris entre 1 et 365 (on ne g\u00e8re pas les ann\u00e9es bissextiles). Par exemple, si la DDM est \u00e9gale \u00e0 15, la date de durabilit\u00e9 minimale est le 15 janvier. On va cr\u00e9er \u00e9galement des m\u00e9thodes permettant d\u2019interagir avec l\u2019objet Yaourt pour attribuer un ar\u00f4me ou r\u00e9cup\u00e9rer un genre par exemple. On peut repr\u00e9senter cette classe par le tableau de sp\u00e9cifications ci-dessous : Q.1. La classe Yaourt est d\u00e9clar\u00e9e en Python \u00e0 l\u2019aide du mot-cl\u00e9 class : \ud83d\udc0d Script Python class Yaourt : \"\"\" Classe d\u00e9finissant un yaourt caract\u00e9ris\u00e9 par : - son arome- son genre - sa dur\u00e9e de durabilit\u00e9 minimale \"\"\" L\u2019annexe 1 de l\u2019exercice 4 donne le code existant et l\u2019endroit des codes \u00e0 produire dans les questions suivantes. a) Quelles sont les assertions \u00e0 pr\u00e9voir pour v\u00e9rifier que l\u2019ar\u00f4me et la dur\u00e9e correspondent bien \u00e0 des valeurs acceptables. Il faudra aussi expliciter les commentaires qui seront renvoy\u00e9s. Pour rappel : L\u2019ar\u00f4me doit prendre comme valeur 'fraise', 'abricot', 'vanille' ou 'aucun'. Sa date de durabilit\u00e9 minimale (DDM) est une valeur positive. b) Pour cr\u00e9er un yaourt, on ex\u00e9cutera la commande suivante : \ud83d\udc0d Script Python Mon_Yaourt = Yaourt ( 'fraise' , 24 ) Quelle valeur sera affect\u00e9e \u00e0 l\u2019attribut genre associ\u00e9 \u00e0 Mon_Yaourt ? c) \u00c9crire en python une fonction GetArome(self) , renvoyant l\u2019ar\u00f4me du yaourt cr\u00e9\u00e9. Q.2. On appelle mutateur une m\u00e9thode permettant de modifier un ou plusieurs attributs d\u2019un objet. Sur votre copie, \u00e9crire en Python le mutateur SetArome(self,arome) permettant de modifier l\u2019ar\u00f4me du yaourt. On veillera \u00e0 garder une coh\u00e9rence entre l\u2019ar\u00f4me et le genre. Q.3. On veut cr\u00e9er une pile contenant le stock de yaourts. Pour cela il faut tout d\u2019abord cr\u00e9er une pile vide : \ud83d\udc0d Script Python def creer_pile (): pile = [ ] return pile a) Cr\u00e9er une fonction empiler(p,Yaourt) qui renvoie la pile p apr\u00e8s avoir ajout\u00e9 un objet de type Yaourt \u00e0 la fin. b) Cr\u00e9er une fonction depiler(p) qui renvoie l\u2019objet \u00e0 d\u00e9piler. c) Cr\u00e9er une fonction estVide(p) qui renvoie True si la pile est vide et False sinon. d) Qu\u2019affiche le bloc de commandes suivantes ci-dessous ? \ud83d\udc0d Script Python mon_Yaourt1 = Yaourt ( 'aucun' , 18 ) mon_Yaourt2 = Yaourt ( 'fraise' , 24 ) ma_pile = creer_pile () empiler ( ma_pile , mon_Yaourt1 ) empiler ( ma_pile , mon_Yaourt 2 ) print ( depiler ( ma_pile ) . GetDuree ()) print ( estVide ( ma_pile )) ANNEXE Exercice n\u00b05 - 4 points \u2693\ufe0e Principaux th\u00e8mes abord\u00e9s : Traitement de donn\u00e9es en tables (CSV) et langages et programmation (sp\u00e9cification). Afin d\u2019am\u00e9liorer l\u2019ergonomie d\u2019un logiciel de traitement des inscriptions dans une universit\u00e9, un programmeur souhaite exploiter l\u2019intelligence artificielle pour renseigner certains champs par auto-compl\u00e9tion. Il s\u2019int\u00e9resse au descripteur \u00ab genre \u00bb (masculin, f\u00e9minin ou ind\u00e9termin\u00e9). Pour cela il propose d\u2019exploiter les derni\u00e8res lettres du pr\u00e9nom pour proposer automatiquement le genre. Pour v\u00e9rifier son hypoth\u00e8se, il r\u00e9cup\u00e8re un fichier CSV associant plus de 60 000 pr\u00e9noms du monde entier au genre de la personne portant ce pr\u00e9nom. En utilisant seulement la derni\u00e8re lettre, le taux de r\u00e9ussite de sa d\u00e9marche est de 72,9% avec la fonction d\u00e9finie ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def genre ( prenom ): liste_M = [ 'f' , 'd' , 'c' , 'b' , 'o' , 'n' , 'm' , 'l' , 'k' , 'j' , '\u00e9' , 'h' , 'w' , 'v' , 'u' , 't' , 's' , 'r' , 'q' , 'p' , 'i' , '\u00fe' , 'z' , 'x' , '\u00e7' , '\u00f6' , '\u00e3' , '\u00e2' , '\u00ef' , 'g' ] liste_F = [ 'e' , 'a' , '\u00e4' , '\u00fc' , 'y' , '\u00eb' ] if prenom [ len ( prenom ) - 1 ] . lower () in liste_M : return \"M\" elif prenom [ len ( prenom ) - 1 ] . lower () in liste_F : return \"F\" else : return \"I\" # Pour rappel, C.lower() convertit le caract\u00e8re C en minuscule. Q.1. Appropriation a) Expliquer ce qu\u2019est un fichier CSV. b) Donner le type de l\u2019argument prenom de la fonction genre, et le type de la r\u00e9ponse renvoy\u00e9e. Q.2. D\u00e9veloppement Pour effectuer son \u00e9tude sur les pr\u00e9noms \u00e0 partir du fichier CSV, le programmeur souhaite utiliser la biblioth\u00e8que csv. a) La biblioth\u00e8que csv est un module natif du moteur python. Donner, dans ce cas, l\u2019instruction d\u2019importation. b) Au cours du d\u00e9veloppement de son projet, le programmeur souhaite ins\u00e9rer une assertion sur l\u2019argument donn\u00e9 \u00e0 la fonction. Proposer une assertion sur le type de l\u2019argument qui corrige une erreur lorsque le type ne correspond pas \u00e0 celui attendu. c) Avant le d\u00e9ploiement de sa solution, le programmeur d\u00e9cide de rendre sa fonction plus robuste. Pour cela il veut remplacer l\u2019assertion propos\u00e9e dans la question 2.b) par une gestion de l\u2019argument pour \u00e9viter toutes erreurs emp\u00eachant la poursuite du programme. Proposer alors une ou plusieurs instructions en Python utilisant l\u2019argument afin de s\u2019assurer que la fonction se termine quel que soit le type de l\u2019argument. Q.3. En prenant en compte les deux derni\u00e8res lettres du pr\u00e9nom, il parvient \u00e0 augmenter son taux de r\u00e9ussite \u00e0 74,4%. Pour cela, son \u00e9tude du fichier CSV lui permet de cr\u00e9er deux listes : liste_M2 pour les terminaisons de deux lettres associ\u00e9es aux pr\u00e9noms masculins et liste_F2 pour les pr\u00e9noms f\u00e9minins. Sur votre copie, recopier et modifier la structure conditionnelle (lignes 8 \u00e0 13) de la fonction genre afin de prendre en compte les terminaisons de deux lettres des listes liste_M2 et liste_F2 .","title":"France Septembre 2021"},{"location":"BAC/Sujet_Libre_2_2021_cor/","text":"Th\u00e8me : Sujet \u00e9crit BAC BAC Candidat Libre Juin 2021 - Sujet 2 Dur\u00e9e de l\u2019\u00e9preuve : 3 heures 30 L\u2019usage de la calculatrice n\u2019est pas autoris\u00e9. D\u00e8s que ce sujet vous est remis, assurez-vous qu\u2019il est complet. Ce sujet comporte 13 pages num\u00e9rot\u00e9es de 1/13 \u00e0 13/13. Le candidat traite au choix 3 exercices parmi les 5 exercices propos\u00e9s. Chaque exercice est not\u00e9 sur 4 points. Exercice n\u00b01 - 4 points \u2693\ufe0e Principaux th\u00e8mes abord\u00e9s : protocoles de communication, architecture d\u2019un r\u00e9seau et protocoles de routage. Les parties A et B sont ind\u00e9pendantes. Partie A : R\u00e9seau Q.1. Parmi les termes ci-dessous, pr\u00e9ciser celui qui d\u00e9signe l'ensemble des r\u00e8gles de communication utilis\u00e9es pour r\u00e9aliser un service particulier sur le r\u00e9seau ? \u25a1 Architecture \u25a1 Protocole \u25a1 Paquet Correction Protocole Q.2. On consid\u00e8re le sch\u00e9ma r\u00e9seau de l\u2019entreprise Lambda : Parmi les quatre propositions suivantes (Routeur, Commutateur (Switch), Contr\u00f4leur WIFI et Serveur), pr\u00e9ciser celle qui correspond \u00e0 : a) L\u2019\u00e9l\u00e9ment A b) L\u2019\u00e9l\u00e9ment B Correction a) \u00e9l\u00e9ment A : Routeur b) \u00e9l\u00e9ment B : Switch Q.3. En reprenant le sch\u00e9ma de la question 2. et le tableau d\u2019adressage du r\u00e9seau de l'entreprise Lambda, recopier sur votre copie et compl\u00e9ter la ligne du tableau du poste 3 : Correction Partie B L\u2019extrait de la table de routage d\u2019un routeur R1 est donn\u00e9 ci-dessous : Q.1. Indiquer sur votre copie les adresses IP du(des) r\u00e9seau(x) directement connect\u00e9s \u00e0 ce routeur. Correction Les adresses IP des r\u00e9seaux directement connect\u00e9s au routeur R1 (m\u00e9trique \u00e9gale \u00e0 0) sont : 10.0.0.0, 172.16.0.0 et 192.168.0.0 Q.2. Indiquer sur votre copie l\u2019interface utilis\u00e9e pour transf\u00e9rer les paquets contenant les adresses IP destination suivantes : Adresse IP destination Interface Machine ou Port 192.168.1.55 172.18.10.10 Correction Q.3. On consid\u00e8re un r\u00e9seau selon le sch\u00e9ma ci-dessous. Recopier sur votre copie et compl\u00e9ter la table de routage simplifi\u00e9e du Routeur1 (R1) (cidessous) en prenant comme m\u00e9trique le nombre de routeurs \u00e0 \u00ab traverser \u00bb avant d\u2019atteindre le r\u00e9seau de la machine destinataire. Correction La question n\u2019est pas tr\u00e8s claire. Est-ce que l\u2019on devrait consid\u00e9rer toutes les routes possibles pour atteindre un routeur donn\u00e9 ou seulement la route la plus courte ? La premi\u00e8re solution \u00e9tant tr\u00e8s tr\u00e8s longue, j\u2019ai choisi de traiter la deuxi\u00e8me. Exercice n\u00b02 - 4 points \u2693\ufe0e Principaux th\u00e8mes abord\u00e9s : structure de donn\u00e9es (tableaux, dictionnaires) et langages et programmation (sp\u00e9cification). Objectif de l\u2019exercice : Les Aventuriers du Rail\u00a9 est un jeu de soci\u00e9t\u00e9 dans lequel les joueurs doivent construire des lignes de chemin de fer entre diff\u00e9rentes villes d'un pays. La carte des liaisons possibles dans la r\u00e9gion Occitanie est donn\u00e9e en annexe 1 de l\u2019exercice 2. Dans l\u2019 annexe 2 de l\u2019exercice 2, les liaisons poss\u00e9d\u00e9es par le joueur 1 sont en noir, et celles du joueur 2 en blanc. Les liaisons en gris sont encore en jeu. Codages des structures de donn\u00e9es utilis\u00e9es : Liste des liaisons d'un joueur : Toutes les liaisons directes (sans ville interm\u00e9diaire) construites par un joueur seront enregistr\u00e9es dans une variable de type \"tableau de tableaux\". Le joueur 1 poss\u00e8de les lignes directes \"Toulouse-Muret\", \"Toulouse-Montauban\", \"Gaillac-St Sulpice\" et \"Muret-Pamiers\" (liaisons indiqu\u00e9es en noir dans l\u2019annexe 2 de l\u2019exercice 2). Ces liaisons sont m\u00e9moris\u00e9es dans la variable ci-dessous. \ud83d\udc0d Script Python liaisonsJoueur1 = [ [ \"Toulouse\" , \"Muret\" ], [ \"Toulouse\" , \"Montauban\" ], [ \"Gaillac\" , \"St Sulpice\" ], [ \"Muret\" , \"Pamiers\" ] ] Remarque : Seules les liaisons directes existent, par exemple [\"Toulouse\",\"Muret\"] ou [\"Muret\",\"Toulouse\"] . Par contre, le tableau [\"Toulouse\",\"Mazamet\"] n'existe pas, puisque la ligne Toulouse-Mazamet passe par Castres. - Dictionnaire associ\u00e9 \u00e0 un joueur : On code la liste des villes et des trajets poss\u00e9d\u00e9e par un joueur en utilisant un dictionnaire de tableaux . Chaque clef de ce dictionnaire est une ville de d\u00e9part, et chaque valeur est un tableau contenant les villes d'arriv\u00e9e possibles en fonction des liaisons poss\u00e9d\u00e9es par le joueur. Le dictionnaire de tableaux du joueur 1 est donn\u00e9 ci-dessous : \ud83d\udc0d Script Python DictJoueur1 = { \"Toulouse\" :[ \"Muret\" , \"Montauban\" ], \"Montauban\" :[ \"Toulouse\" ], \"Gaillac\" :[ \"St Sulpice\" ], \"St Sulpice\" :[ \"Gaillac\" ], \"Muret\" :[ \"Toulouse\" , \"Pamiers\" ], \"Pamiers \" :[ \"Muret\" ] } Q.1. Expliquer pourquoi la liste des liaisons suivante n'est pas valide : \ud83d\udc0d Script Python tableauliaisons = [[ \"Toulouse\" , \"Auch\" ], [ \"Luchon\" , \"Muret\" ], [ \"Quillan\" , \"Limoux\" ] ] Correction La liste propos\u00e9e n\u2019est pas valide car la liaison [\u201cLuchon\u201d, \u201cMuret\u201d] n\u2019est pas directe. Q.2. Cette question concerne le joueur n\u00b02 (Rappel : les liaisons poss\u00e9d\u00e9es par le joueur n\u00b02 sont repr\u00e9sent\u00e9es par un rectangle blanc dans l\u2019 annexe 2 de l\u2019exercice 2 ). a) Donner le tableau liaisonsJoueur2, des liaisons poss\u00e9d\u00e9es par le joueur n\u00b02. b) Recopier et compl\u00e9ter le dictionnaire suivant, associ\u00e9 au joueur n\u00b02 : python DictJoueur2 = { \"Toulouse\":[\"Castres\",\"Castelnaudary\"], ... } Correction 2.a) \ud83d\udc0d Script Python liaisonsJoueur2 = [[ \"Toulouse\" , \"Castres\" ], [ \"Toulouse\" , \"Castelnaudary\" ], [ \"Castres\" , \"Mazamet\" ], [ \"Castelnaudary\" , \"Carcassonne\" ], [ \"Tarbes\" , \"St Gaudens\" ]] 2b) \ud83d\udc0d Script Python DictJoueur2 = { \"Toulouse\" : [ \"Castres\" , \"Castelnaudary\" ], \"Castres\" : [ \"Toulouse\" , \"Mazamet\" ], \"Castelnaudary\" : [ \"Toulouse\" , \"Carcassonne\" ], \"Mazamet\" : [ \"Castres\" ], \"Carcassonne\" : [ \"Castelnaudary\" ], \"Tarbes\" : [ \"St Gaudens\" ], \"St Gaudens\" : [ \"Tarbes\" ] } Q.3. \u00c0 partir du tableau de tableaux contenant les liaisons d'un joueur, on souhaite construire le dictionnaire correspondant au joueur. Une premi\u00e8re proposition a abouti \u00e0 la fonction construireDict ci-dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def construireDict ( listeLiaisons ): \"\"\" listeLiaisons est un tableau de tableaux repr\u00e9sentant la liste des liaisons d'un joueur comme d\u00e9crit dans le probl\u00e8me \"\"\" Dict = {} for liaison in listeLiaisons : villeA = liaison [ 0 ] villeB = liaison [ 1 ] if not villeA in Dict . keys () : Dict [ villeA ] = [ villeB ] else : destinationsA = Dict [ villeA ] if not villeB in destinationsA : destinationsA . append ( villeB ) return Dict a) \u00c9crire sur votre copie un assert dans la fonction construireDict qui permet de v\u00e9rifier que la listeLiaisons n\u2019est pas vide. b) Sur votre copie, donner le r\u00e9sultat de cette fonction ayant comme argument la variable liaisonsJoueur1 donn\u00e9e dans l\u2019\u00e9nonc\u00e9 et expliquer en quoi cette fonction ne r\u00e9pond que partiellement \u00e0 la demande. c) La fonction construireDict , d\u00e9finie ci-dessus, est donc partiellement inexacte. Compl\u00e9ter la fonction construireDict pour qu\u2019elle g\u00e9n\u00e8re bien l\u2019ensemble du dictionnaire de tableaux correspondant \u00e0 la liste de liaisons donn\u00e9es en argument. \u00c0 l\u2019aide des num\u00e9ros de lignes, on pr\u00e9cisera o\u00f9 est ins\u00e9r\u00e9 ce code. Correction 3a) \ud83d\udc0d Script Python assert len ( listeLiaisons ) != 0 , \"la liste est vide\" 3b) R\u00e9sultat de l\u2019ex\u00e9cution de la fonction construireDict : \ud83d\udc0d Script Python { 'Toulouse' : [ 'Castres' , 'Castelnaudary' ], 'Castres' : [ 'Mazamet' ], 'Castelnaudary' : [ 'Carcassonne' ], 'Tarbes' : [ 'St Gaudens' ]} La fonction g\u00e8re la liaison A-B mais pas la liaison B-A. Par exemple, pour la cl\u00e9 \u201cToulouse \u201c on retrouve bien \u201cCastelnaudary\u201d dans le tableau alors que pour la cl\u00e9 \u201cCastelnaudary\u201d , on ne retrouve pas \u201cToulouse \u201c dans le tableau. 3c) \ud83d\udc0d Script Python def construireDict ( listeLiaisons ): assert len ( listeLiaisons ) != 0 , \"la liste est vide\" Dict = {} for liaison in listeLiaisons : villeA = liaison [ 0 ] villeB = liaison [ 1 ] if not villeA in Dict . keys () : Dict [ villeA ] = [ villeB ] else : destinationsA = Dict [ villeA ] if not villeB in destinationsA : destinationsA . append ( villeB ) if not villeB in Dict . keys () : Dict [ villeB ] = [ villeA ] else : destinationsB = Dict [ villeB ] if not villeA in destinationsB : destinationsB . append ( villeA ) return Dict Exercice n\u00b03 - 4 points \u2693\ufe0e Principaux th\u00e8mes abord\u00e9s : bases de donn\u00e9es (mod\u00e8le relationnel, base de donn\u00e9es relationnelle et langage SQL). Dans notre monde, l\u2019information a de plus en plus de valeur et d\u2019importance mais nous sommes de plus en plus confront\u00e9s \u00e0 l\u2019infob\u00e9sit\u00e9. Consid\u00e9rons l\u2019utilisation des donn\u00e9es issues de la table de Mendele\u00efev (tableau p\u00e9riodique des \u00e9l\u00e9ments). Il est contraignant de faire des recherches sur des moteurs d\u00e9di\u00e9s \u00e0 chaque fois qu\u2019une valeur est n\u00e9cessaire (masse volumique, rayon de covalence, point de fusion\u2026). Les lignes 3, 4 et 5 de cette table Mendele\u00efev ont permis de construire, en annexe 1 de l\u2019exercice 3 , une base de donn\u00e9es des diff\u00e9rents atomes correspondants. Q.1. Donner le nom du langage informatique utilis\u00e9 pour acc\u00e9der aux donn\u00e9es dans une base de donn\u00e9es ? Correction Pour effectuer des requ\u00eates sur une base de donn\u00e9es relationnelle, on utilise le langage SQL Q.2. a) Lister les diff\u00e9rents attributs des tables ATOMES et VALENCE en pr\u00e9cisant le type du domaine de chacun. b) D\u00e9terminer si des attributs de la table ATOMES peuvent avoir un r\u00f4le de cl\u00e9 primaire et/ou de cl\u00e9 \u00e9trang\u00e8re. Justifier. c) Donner le sch\u00e9ma relationnel pour les deux tables ATOMES et VALENCE. Correction 2a \ud83d\uddc2\ufe0f Requ\u00eate SQL ATOME ( Z : INT , nom : TEXT , Sym : TEXT , L : INT , C : INT , masse_atom : FLOAT ) VALENCE ( Col : INT , Couche : TEXT ) 2b) l\u2019attribut Z peut jouer le r\u00f4le de cl\u00e9 primaire car il existe un Z unique pour chaque \u00e9l\u00e9ment chimique. l\u2019attribut C va jouer le r\u00f4le de cl\u00e9 \u00e9trang\u00e8re car cet attribut va permettre d\u2019\u00e9tablir une \u201cliaison\u201d avec l\u2019attribut Col de la table VALENCE 2c) \ud83d\uddc2\ufe0f Requ\u00eate SQL ATOME ( Z : INT , nom : TEXT , Sym : TEXT , L : INT , # C : INT , masse_atom : FLOAT ) VALENCE ( Col : INT , Couche : TEXT ) Q.3. Donner les r\u00e9ponses des deux requ\u00eates suivantes : a) \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT nom FROM ATOMES WHERE L = '3' ORDER BY Sym b) \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT DISTINCT C FROM ATOMES Correction 3a) On obtient la liste de nom d\u2019atomes suivante : aluminium, argon, chlore, magnesium, sodium, phosphore, silicium, soufre 3b) On obtient la liste des colonnes : 1, 2 ,3 ,4 ,5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18 Q.4. Donner la requ\u00eate SQL : a) Pour afficher le nom et la masse atomique des atomes. b) Pour afficher le symbole des atomes dont la couche de valence est s. Correction 4a) \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT nom , masse_atom FROM ATOMES 4b) \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT Sym FROM ATOMES INNER JOIN VALENCE ON ATOMES . C = VALENCE . Col WHERE Couche = 's' Q.5. On a remarqu\u00e9 une erreur de saisie dans la table ATOMES, la masse atomique de l\u2019argon (Ar) n\u2019est pas 29,948 g.mol \\(^{-1}\\) mais 39,948 g.mol \\(^{-1}\\) . \u00c9crire la requ\u00eate SQL pour corriger cette erreur de saisie. Correction \ud83d\uddc2\ufe0f Requ\u00eate SQL UPDATE ATOMES SET mass_atom = 39 . 948 WHERE nom = 'argon' ANNEXE 1 Exercice n\u00b04 - 4 points \u2693\ufe0e Principaux th\u00e8mes abord\u00e9s : structure de donn\u00e9es (programmation objet) et langages et programmation (sp\u00e9cification). Une entreprise fabrique des yaourts qui peuvent \u00eatre soit nature (sans ar\u00f4me), soit aromatis\u00e9s (fraise, abricot ou vanille). Pour pouvoir traiter informatiquement les sp\u00e9cificit\u00e9s de ce produit, on va donc cr\u00e9er une classe Yaourt qui poss\u00e8dera un certain nombre d\u2019attributs : - Son genre : nature ou aromatis\u00e9 - Son ar\u00f4me : fraise, abricot, vanille ou aucun - Sa date de durabilit\u00e9 minimale (DDM) exprim\u00e9e par un entier compris entre 1 et 365 (on ne g\u00e8re pas les ann\u00e9es bissextiles). Par exemple, si la DDM est \u00e9gale \u00e0 15, la date de durabilit\u00e9 minimale est le 15 janvier. On va cr\u00e9er \u00e9galement des m\u00e9thodes permettant d\u2019interagir avec l\u2019objet Yaourt pour attribuer un ar\u00f4me ou r\u00e9cup\u00e9rer un genre par exemple. On peut repr\u00e9senter cette classe par le tableau de sp\u00e9cifications ci-dessous : Q.1. La classe Yaourt est d\u00e9clar\u00e9e en Python \u00e0 l\u2019aide du mot-cl\u00e9 class : \ud83d\udc0d Script Python class Yaourt : \"\"\" Classe d\u00e9finissant un yaourt caract\u00e9ris\u00e9 par : - son arome- son genre - sa dur\u00e9e de durabilit\u00e9 minimale \"\"\" L\u2019annexe 1 de l\u2019exercice 4 donne le code existant et l\u2019endroit des codes \u00e0 produire dans les questions suivantes. a) Quelles sont les assertions \u00e0 pr\u00e9voir pour v\u00e9rifier que l\u2019ar\u00f4me et la dur\u00e9e correspondent bien \u00e0 des valeurs acceptables. Il faudra aussi expliciter les commentaires qui seront renvoy\u00e9s. Pour rappel : L\u2019ar\u00f4me doit prendre comme valeur 'fraise', 'abricot', 'vanille' ou 'aucun'. Sa date de durabilit\u00e9 minimale (DDM) est une valeur positive. b) Pour cr\u00e9er un yaourt, on ex\u00e9cutera la commande suivante : \ud83d\udc0d Script Python Mon_Yaourt = Yaourt ( 'fraise' , 24 ) Quelle valeur sera affect\u00e9e \u00e0 l\u2019attribut genre associ\u00e9 \u00e0 Mon_Yaourt ? c) \u00c9crire en python une fonction GetArome(self) , renvoyant l\u2019ar\u00f4me du yaourt cr\u00e9\u00e9. Correction 1a) voici les 2 assertions dans la m\u00e9thode __init__ : \ud83d\udc0d Script Python class Yaourt : def __init__ ( self , arome , duree ): assert arome in [ 'fraise' , 'abricot' , 'vanille' , 'aucun' ], \"Cet arome est inconnu \" assert duree > 0 and duree < 366 , \"la dur\u00e9e doit \u00eatre comprise entre 1 et 365\" self . __arome = arome self . __duree = duree if arome == 'aucun' : self . __genre = 'nature' else : self . __genre = 'aromatise' 1b) Le genre associ\u00e9 \u00e0 Mon_Yaourt sera aromatise 1c) Voici la m\u00e9thode GetArome : \ud83d\udc0d Script Python def GetArome ( self ): return self . __arome Q.2. On appelle mutateur une m\u00e9thode permettant de modifier un ou plusieurs attributs d\u2019un objet. Sur votre copie, \u00e9crire en Python le mutateur SetArome(self,arome) permettant de modifier l\u2019ar\u00f4me du yaourt. On veillera \u00e0 garder une coh\u00e9rence entre l\u2019ar\u00f4me et le genre. Correction \ud83d\udc0d Script Python def SetArome ( self , arome ): assert arome in [ 'fraise' , 'abricot' , 'vanille' , 'aucun' ], \"Cet arome est inconnu \" self . __arome = arome self . __SetGenre ( arome ) Q.3. On veut cr\u00e9er une pile contenant le stock de yaourts. Pour cela il faut tout d\u2019abord cr\u00e9er une pile vide : \ud83d\udc0d Script Python def creer_pile (): pile = [ ] return pile a) Cr\u00e9er une fonction empiler(p,Yaourt) qui renvoie la pile p apr\u00e8s avoir ajout\u00e9 un objet de type Yaourt \u00e0 la fin. b) Cr\u00e9er une fonction depiler(p) qui renvoie l\u2019objet \u00e0 d\u00e9piler. c) Cr\u00e9er une fonction estVide(p) qui renvoie True si la pile est vide et False sinon. d) Qu\u2019affiche le bloc de commandes suivantes ci-dessous ? \ud83d\udc0d Script Python mon_Yaourt1 = Yaourt ( 'aucun' , 18 ) mon_Yaourt2 = Yaourt ( 'fraise' , 24 ) ma_pile = creer_pile () empiler ( ma_pile , mon_Yaourt1 ) empiler ( ma_pile , mon_Yaourt2 ) print ( depiler ( ma_pile ) . GetDuree ()) print ( estVide ( ma_pile )) Correction 3a) \ud83d\udc0d Script Python def empiler ( p , Yaourt ): p . append ( Yaourt ) 3b) \ud83d\udc0d Script Python def depiler ( p ): return p . pop () 3c) \ud83d\udc0d Script Python def estVide ( p ): if len ( p ) == 0 : return True else : return False 3d) 24 False ANNEXE Exercice n\u00b05 - 4 points \u2693\ufe0e Principaux th\u00e8mes abord\u00e9s : Traitement de donn\u00e9es en tables (CSV) et langages et programmation (sp\u00e9cification). Afin d\u2019am\u00e9liorer l\u2019ergonomie d\u2019un logiciel de traitement des inscriptions dans une universit\u00e9, un programmeur souhaite exploiter l\u2019intelligence artificielle pour renseigner certains champs par auto-compl\u00e9tion. Il s\u2019int\u00e9resse au descripteur \u00ab genre \u00bb (masculin, f\u00e9minin ou ind\u00e9termin\u00e9). Pour cela il propose d\u2019exploiter les derni\u00e8res lettres du pr\u00e9nom pour proposer automatiquement le genre. Pour v\u00e9rifier son hypoth\u00e8se, il r\u00e9cup\u00e8re un fichier CSV associant plus de 60 000 pr\u00e9noms du monde entier au genre de la personne portant ce pr\u00e9nom. En utilisant seulement la derni\u00e8re lettre, le taux de r\u00e9ussite de sa d\u00e9marche est de 72,9% avec la fonction d\u00e9finie ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def genre ( prenom ): liste_M = [ 'f' , 'd' , 'c' , 'b' , 'o' , 'n' , 'm' , 'l' , 'k' , 'j' , '\u00e9' , 'h' , 'w' , 'v' , 'u' , 't' , 's' , 'r' , 'q' , 'p' , 'i' , '\u00fe' , 'z' , 'x' , '\u00e7' , '\u00f6' , '\u00e3' , '\u00e2' , '\u00ef' , 'g' ] liste_F = [ 'e' , 'a' , '\u00e4' , '\u00fc' , 'y' , '\u00eb' ] if prenom [ len ( prenom ) - 1 ] . lower () in liste_M : return \"M\" elif prenom [ len ( prenom ) - 1 ] . lower () in liste_F : return \"F\" else : return \"I\" # Pour rappel, C.lower() convertit le caract\u00e8re C en minuscule. Q.1. Appropriation a) Expliquer ce qu\u2019est un fichier CSV. b) Donner le type de l\u2019argument prenom de la fonction genre, et le type de la r\u00e9ponse renvoy\u00e9e. Correction 1.a) Un fichier CSV est un fichier au format \u201ctexte\u201d permettant de \u201cstocker\u201d des donn\u00e9es tabul\u00e9es. Les donn\u00e9es sont s\u00e9par\u00e9es par des virgules, d\u2019o\u00f9 l\u2019acronyme CSV : Comma Separated Values 1.b) prenom est de type string la r\u00e9ponse renvoy\u00e9e par la fonction est aussi de type string Q.2. D\u00e9veloppement Pour effectuer son \u00e9tude sur les pr\u00e9noms \u00e0 partir du fichier CSV, le programmeur souhaite utiliser la biblioth\u00e8que csv. a) La biblioth\u00e8que csv est un module natif du moteur python. Donner, dans ce cas, l\u2019instruction d\u2019importation. b) Au cours du d\u00e9veloppement de son projet, le programmeur souhaite ins\u00e9rer une assertion sur l\u2019argument donn\u00e9 \u00e0 la fonction. Proposer une assertion sur le type de l\u2019argument qui corrige une erreur lorsque le type ne correspond pas \u00e0 celui attendu. c) Avant le d\u00e9ploiement de sa solution, le programmeur d\u00e9cide de rendre sa fonction plus robuste. Pour cela il veut remplacer l\u2019assertion propos\u00e9e dans la question 2.b) par une gestion de l\u2019argument pour \u00e9viter toutes erreurs emp\u00eachant la poursuite du programme. Proposer alors une ou plusieurs instructions en Python utilisant l\u2019argument afin de s\u2019assurer que la fonction se termine quel que soit le type de l\u2019argument. Correction 2a) \ud83d\udc0d Script Python import csv 2b) \ud83d\udc0d Script Python assert isinstance ( prenom , str ) 2c) \ud83d\udc0d Script Python def genre ( prenom ): liste_M = [ 'f' , 'd' , 'c' , 'b' , 'o' , 'n' , 'm' , 'l' , 'k' , 'j' , '\u00e9' , 'h' , 'w' , 'v' , 'u' , 't' , 's' , 'r' , 'q' , 'p' , 'i' , '\u00fe' , 'z' , 'x' , '\u00e7' , '\u00f6' , '\u00e3' , '\u00e2' , '\u00ef' , 'g' ] liste_F = [ 'e' , 'a' , '\u00e4' , '\u00fc' , 'y' , '\u00eb' ] if not isinstance ( prenom , str ): return \"erreur, le pr\u00e9nom doit \u00eatre une cha\u00eene de caract\u00e8res\" if prenom [ len ( prenom ) - 1 ] . lower () in liste_M : return \"M\" elif prenom [ len ( prenom ) - 1 ] . lower () in liste_F : return \"F\" else : return \"I\" Q.3. En prenant en compte les deux derni\u00e8res lettres du pr\u00e9nom, il parvient \u00e0 augmenter son taux de r\u00e9ussite \u00e0 74,4%. Pour cela, son \u00e9tude du fichier CSV lui permet de cr\u00e9er deux listes : liste_M2 pour les terminaisons de deux lettres associ\u00e9es aux pr\u00e9noms masculins et liste_F2 pour les pr\u00e9noms f\u00e9minins. Sur votre copie, recopier et modifier la structure conditionnelle (lignes 8 \u00e0 13) de la fonction genre afin de prendre en compte les terminaisons de deux lettres des listes liste_M2 et liste_F2 . Correction modification de la fonction genre (de la ligne 7 \u00e0 la ligne 13) : \ud83d\udc0d Script Python term = prenom [ len ( prenom ) - 2 ] + prenom [ len ( prenom ) - 1 ] if term . lower () in liste_M2 : return \"M\" elif term . lower () in liste_F2 : return \"F\" else : return \"I\"","title":"Sujet Libre 2 2021 cor"},{"location":"BasesDonnees/TD18_Revision_SQL_BAC/","text":"TD n\u00b018 : Retour sur le langage SQL - Sujet BAC Th\u00e8me : Bases de donn\u00e9es FRANCE Sujet 2 - Juin 2021 SUJET BAC Une restauratrice a mis en place un site Web pour g\u00e9rer ses r\u00e9servations en ligne. Chaque client peut s\u2019inscrire en saisissant ses identifiants. Une fois connect\u00e9, il peut effectuer une r\u00e9servation en renseignant le jour et l\u2019heure. Il peut \u00e9galement commander son menu en ligne et \u00e9crire un avis sur le restaurant. Le gestionnaire du site Web a cr\u00e9\u00e9 une base de donn\u00e9es associ\u00e9e au site nomm\u00e9e restaurant, contenant les quatre relations du sch\u00e9ma relationnel ci-dessous : Dans le sch\u00e9ma relationnel pr\u00e9c\u00e9dent, un attribut soulign\u00e9 indique qu\u2019il s\u2019agit d\u2019une cl\u00e9 primaire. Un attibut pr\u00e9c\u00e9d\u00e9 du symbole # indique qu\u2019il s\u2019agit d\u2019une cl\u00e9 \u00e9trang\u00e8re et la fl\u00e8che associ\u00e9e indique l\u2019attribut r\u00e9f\u00e9renc\u00e9. Ainsi, par exemple, l'attribut idPlat de la relation Commande est une cl\u00e9 \u00e9trang\u00e8re qui fait r\u00e9f\u00e9rence \u00e0 l'attribut idPlat de la relation Plat. Dans la suite, les mots cl\u00e9s suivants du langage SQL pourront \u00eatre utilis\u00e9s dans les requ\u00eates : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT , FROM , WHERE , JOIN , ON , DELETE , UPDATE , SET , INSERT INTO , AND , OR . Question 1 Parmi les trois requ\u00eates suivantes, \u00e9crites dans le langage SQL, laquelle renvoie les valeurs de tous les attributs des plats de la cat\u00e9gorie 'entr\u00e9e' : R1 : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT nom , prix FROM Plat WHERE categorie = 'entr\u00e9e' ; R2 : \ud83d\uddc2\ufe0f Requ\u00eate SQL SELECT * FROM Plat WHERE categorie = 'entr\u00e9e' ; R3 : \ud83d\uddc2\ufe0f Requ\u00eate SQL R3 : UPDATE Plat SET categorie = 'entr\u00e9e' WHERE 1 ; Question 2 \u00c9crire, dans le langage SQL, des requ\u00eates d\u2019interrogation sur la base de donn\u00e9es restaurant permettant de r\u00e9aliser les t\u00e2ches suivantes : a. Afficher les noms et les avis des clients ayant effectu\u00e9 une r\u00e9servation pour la date du '2021-06-05' \u00e0 l\u2019heure '19:30:00'. b. Afficher le nom des plats des cat\u00e9gories 'plat principal' et 'dessert', correspondant aux commandes de la date '2021-04-12'. Question 3 Que r\u00e9alise la requ\u00eate SQL suivante ? \ud83d\uddc2\ufe0f Requ\u00eate SQL INSERT INTO Plat VALUES ( 58 , 'P\u00eache Melba' , 'dessert' , 'P\u00eaches et glace vanille' , 6 . 5 ); Question 4 \u00c9crire des requ\u00eates SQL permettant de r\u00e9aliser les t\u00e2ches suivantes : a. Supprimer les commandes ayant comme idReservation la valeur 2047. b. Augmenter de 5% tous les prix de la relation plat strictement inf\u00e9rieurs \u00e0 20.00.","title":"TD18 Revision SQL BAC"},{"location":"BasesDonnees/TP17_JO/","text":"TP n\u00b017 : Retour sur le langage SQL - Les JO Londres 2012 Th\u00e8me : Bases de donn\u00e9es EXERCICES Nous allons travailler sur une base de donn\u00e9es li\u00e9e aux Jeux Olympiques de Londres qui ont eu lieu en 2012. Partie 1 : \u00c9tude du sch\u00e9ma relationnel \u2693\ufe0e Avec un *\u00e9diteur de texte tout simple * (type Notepad, Notepad++) ouvrir le fichier create_JO.sql ; regarder les lignes qui d\u00e9finissent les diff\u00e9rentes tables de la BDD et sur une feuille de papier ou sur un document num\u00e9rique , donner sous forme \u00e9crite son sch\u00e9ma relationnel en soulignant cl\u00e9s primaires (en trait plein) et cl\u00e9s \u00e9trang\u00e8re (en pointill\u00e9s). Pour savoir ce qu'est une cl\u00e9 primaire ou \u00e9trang\u00e8re, renseignez vous aupr\u00e8s du cours. Partie 2 : Requ\u00eates SQL \u2693\ufe0e Ex\u00e9cuter les bonnes requ\u00eates SQL pour obtenir les donn\u00e9es suivantes. Requ\u00eates sans jointures \u2693\ufe0e Q1. Afficher le nom et pr\u00e9nom des sportifs. \ud83d\udccb Texte Q2. Afficher les codes des pays dont viennent les sportifs par ordre alphab\u00e9tique en \u00e9liminant les doublons. \ud83d\udccb Texte Q3. Afficher la liste des sportifs fran\u00e7ais (utiliser cio = \u2019France\u2019 ). \ud83d\udccb Texte Q4. Afficher la liste des 301 disciplines tri\u00e9es par l\u2019identifiant du sport auxquelles elles se rapportent. \ud83d\udccb Texte Q5. Afficher les noms des 86 pays situ\u00e9s apr\u00e8s la France et avant la Russie (Russia) par ordre alphab\u00e9tique. Utiliser les op\u00e9rateurs < et > . Remarquer que l\u2019op\u00e9rateur BETWEEN ne produit pas le r\u00e9sultat attendu (88 pays). \ud83d\udccb Texte Q6. Afficher les 98 identifiants de discipline dont au moins une \u00e9preuve a eu lieu entre le 27 et le 31 juillet 2012 inclus. \ud83d\udccb Texte Q7. Afficher les noms des 61 sportifs qui sont soit fran\u00e7ais (FRA) soit britanniques (GBR). \ud83d\udccb Texte Q8. Afficher les intitul\u00e9s des 131 disciplines contenant la cha\u00eene de caract\u00e8res \u00ab WOMEN \u00bb. \ud83d\udccb Texte Q9. Donner les 3 pays (CIO, nom) dont on ne conna\u00eet pas le code ISO2 ou ISO3 (utiliser le crit\u00e8re IS NULL ). \ud83d\udccb Texte Q10. Donner les noms et pr\u00e9noms des 2 sportifs dont le sexe est mentionn\u00e9 dans la BDD. \ud83d\udccb Texte Q11. \u00c0 l\u2019aide de la fonction COUNT , donner le nombre de sports (pas la liste). \ud83d\udccb Texte Q12. Donner le nombre de discipline(s) du sport d\u2019identifiant 1 (pas la liste). \ud83d\udccb Texte Q13. Combien de noms de familles diff\u00e9rents sont port\u00e9s par les sportifs ? \ud83d\udccb Texte Q14. Donner le nombre de pays n\u2019ont pas d\u2019ISO2. \ud83d\udccb Texte Q15. Donner le nombre de m\u00e9dailles d\u2019or attribu\u00e9s lors de ces JO. \ud83d\udccb Texte Q16. Afficher en une table le premier et le dernier \u00e9v\u00e8nement sportif de ces JO. \ud83d\udccb Texte Requ\u00eates avec jointures \u2693\ufe0e Q17. Afficher la listes des noms et pr\u00e9noms des sportifs europ\u00e9ens. \ud83d\udccb Texte Q18. Afficher la liste des disciplines d\u00e9pendant de l\u2019athl\u00e9tisme. \ud83d\udccb Texte Q19. Afficher toutes jours pendant lesquels un \u00e9v\u00e8nement li\u00e9 \u00e0 l\u2019athl\u00e9tisme eu lieu. \ud83d\udccb Texte Q20. Afficher les noms, pr\u00e9noms et m\u00e9dailles gagn\u00e9es par des sportifs dont le sexe figure dans la BDD. \ud83d\udccb Texte Q21. Afficher la liste des Fran\u00e7ais m\u00e9daill\u00e9s d\u2019or. \ud83d\udccb Texte Q22. Afficher les noms, pr\u00e9noms, sports et disciplines des sportifs ayant obtenu une m\u00e9daille d\u2019or. \ud83d\udccb Texte","title":"TP17 JO"},{"location":"DM/DM_POO/","text":"TD n\u00b09 : Programmation Orient\u00e9e Objet (POO) Th\u00e8me 1 : Structures de donn\u00e9es COURS et EXERCICES Compl\u00e9ter les classes suivantes : Pour la classe bancaire, suivre les consignes Pour la classe Calcul de moyenne, rajouter toutes les fonctions qui vous semblent pertinentes Une class GBancaire Un compte bancaire (simplifi\u00e9) est d\u00e9fini par le solde disponible sur le compte. Les op\u00e9rations de manipulation minimales seront : Initialiser un compte bancaire Acc\u00e9der au solde d\u2019un compte bancaire Cr\u00e9diter un compte bancaire D\u00e9biter un compte bancaire On \u00e9tendra \u00e9galement l\u2019interface avec : Un constructeur permettant d\u2019initialiser le solde. Une m\u00e9thode afficher qui affiche l\u2019objet sous le forme suivant : \ud83d\udccb Texte Titulaire : nom du titulaire Banque : nom de la banque Solde : solde du compte Une m\u00e9thode virerVers qui effectue un virement vers un autre compte bancaire. \ud83d\udc0d Script Python class CompteBancaire : def __init__ ( self , idNumber , nomPrenom , solde ): self . idNumber = idNumber self . nomPrenom = nomPrenom self . solde = solde def versement ( self , argent ): self . solde = self . solde + argent def retrait ( self , argent ): if ( self . solde < argent ): print ( \" Impossible d'effectuer l'op\u00e9ration. Solde insuffisant !\" ) else : self . solde = self . solde - argent def agios ( self ): self . solde = self . solde * 95 / 100 def afficher ( self ): print ( \"Compte num\u00e9ro : \" , self . idNumber ) print ( \"Nom & Pr\u00e9nom : \" , self . nomPrenom ) print ( \" Solde : \" , self . solde , \" euros \" ) print ( \"Sauf erreur ou omisssion ! \" ) def virervers ( self , other , somme ): self . solde -= somme other . solde += somme monCompte = CompteBancaire ( 16168891 , \" Martin Pierre\" , 22300 ) monCompte2 = CompteBancaire ( 36 , \" Dupond Jean\" , 300 ) monCompte . versement ( 1500 ) monCompte . retrait ( 24000 ) monCompte . agios () monCompte . afficher () monCompte . virervers ( monCompte2 , 1500 ) monCompte2 . afficher () \ud83d\udccb Texte Impossible d'effectuer l'op\u00e9ration. Solde insuffisant ! Compte num\u00e9ro : 16168891 Nom & Pr\u00e9nom : Martin Pierre Solde : 22610.0 euros Sauf erreur ou omisssion ! Compte num\u00e9ro : 36 Nom & Pr\u00e9nom : Dupond Jean Solde : 1800 euros Sauf erreur ou omisssion ! Calcul de moyenne Ecrire une interface et compl\u00e9ter la class suivante \ud83d\udc0d Script Python class Eleve : def __init__ ( self , nom ): self . ListeDeMatieres = {} self . nom = nom self . ListeDeNotes = {} def Nom ( self ): return self . nom def Matieres ( self ): return self . ListeDeMatieres def Notes ( self ): return self . ListeDeNotes def ajouterMatiere ( self , matiere , coeff ): self . ListeDeMatieres [ matiere ] = coeff self . ListeDeNotes [ matiere ] = [] def ajouterNote ( self , matiere , note ): if matiere not in self . ListeDeMatieres : print ( \"La mati\u00e8re n'existe pas encore, on va la rajouter :\" ) coeff = input ( 'Donnes le coefficient de cette mati\u00e8re :' ) self . ajouterMatiere ( matiere , coeff ) self . ajouterNote ( matiere , note ) else : self . ListeDeNotes [ matiere ] . append ( note ) def CalculMoyenneMatiere ( self , matiere ): if matiere not in self . ListeDeMatieres : print ( \"La mati\u00e8re n'existe pas encore\" ) else : sommeNote = 0 for note in self . ListeDeNotes [ matiere ]: sommeNote += note return sommeNote / len ( self . ListeDeNotes [ matiere ]) def CalculMoyenneGenerale ( self ): sommeNote = 0 sommeCoeff = 0 for matiere in self . ListeDeMatieres : sommeNote += float ( self . CalculMoyenneMatiere ( matiere )) * float ( self . ListeDeMatieres [ matiere ]) sommeCoeff += float ( self . ListeDeMatieres [ matiere ]) return sommeNote / sommeCoeff def afficher ( self ): print ( f \"Les informations concernant { self . nom } sont\" ) for matiere in self . ListeDeMatieres : print ( f \"La moyenne en { matiere } est { self . CalculMoyenneMatiere ( matiere ) } pour un coefficient de { self . ListeDeMatieres [ matiere ] } \" ) print ( f \"La moyenne g\u00e9n\u00e9rale est de { self . CalculMoyenneGenerale () } \" ) def __repr__ ( self ): ch = \"Les informations concernant \" + self . nom + \" sont : \\n \" for matiere in self . ListeDeMatieres : ch += \"- La moyenne en \" + matiere + \" est \" + str ( self . CalculMoyenneMatiere ( matiere )) + \" pour un coefficient de \" + str ( self . ListeDeMatieres [ matiere ]) + \" \\n \" ch += \"La moyenne g\u00e9n\u00e9rale est de \" + str ( self . CalculMoyenneGenerale ()) return ch \ud83d\udc0d Script Python pierre = Eleve ( 'Pierre' ) pierre . ajouterMatiere ( 'Maths' , 16 ) pierre . ajouterMatiere ( 'NSI' , 8 ) pierre . ajouterMatiere ( 'PC' , 16 ) print ( pierre . Matieres ()) print ( pierre . Notes ()) pierre . ajouterNote ( 'NSI' , 14 ) print ( pierre . Notes ()) pierre . ajouterNote ( 'NSI' , 12 ) print ( pierre . Notes ()) pierre . ajouterNote ( 'NSI' , 10 ) print ( pierre . Notes ()) pierre . ajouterNote ( 'Maths' , 10 ) print ( pierre . Notes ()) pierre . ajouterNote ( 'Maths' , 15 ) print ( pierre . Notes ()) pierre . ajouterNote ( 'PC' , 13 ) print ( pierre . Notes ()) pierre . ajouterNote ( 'PC' , 7 ) print ( pierre . Notes ()) pierre . ajouterNote ( 'Anglais' , 7 ) pierre . Notes () print ( pierre . CalculMoyenneMatiere ( 'NSI' )) print ( pierre . CalculMoyenneMatiere ( 'Maths' )) print ( pierre . CalculMoyenneMatiere ( 'PC' )) print ( pierre . CalculMoyenneGenerale ()) print ( pierre ) \ud83d\udccb Texte {'Maths': 16, 'NSI': 8, 'PC': 16} {'Maths': [], 'NSI': [], 'PC': []} {'Maths': [], 'NSI': [14], 'PC': []} {'Maths': [], 'NSI': [14, 12], 'PC': []} {'Maths': [], 'NSI': [14, 12, 10], 'PC': []} {'Maths': [10], 'NSI': [14, 12, 10], 'PC': []} {'Maths': [10, 15], 'NSI': [14, 12, 10], 'PC': []} {'Maths': [10, 15], 'NSI': [14, 12, 10], 'PC': [13]} {'Maths': [10, 15], 'NSI': [14, 12, 10], 'PC': [13, 7]} La mati\u00e8re n'existe pas encore, on va la rajouter : Donnes le coefficient de cette mati\u00e8re : 6 12.0 12.5 10.0 10.826086956521738 Les informations concernant Pierre sont : - La moyenne en Maths est 12.5 pour un coefficient de 16 - La moyenne en NSI est 12.0 pour un coefficient de 8 - La moyenne en PC est 10.0 pour un coefficient de 16 - La moyenne en Anglais est 7.0 pour un coefficient de 6 La moyenne g\u00e9n\u00e9rale est de 10.826086956521738 \ud83d\udc0d Script Python \ud83d\udc0d Script Python","title":"DM POO"},{"location":"Devoirs/DS%20_Listes_Piles_Files/","text":"Devoir : Listes - Piles et Files Th\u00e8me 1 : Structures de donn\u00e9e EVALUATION Exercice n\u00b01 : \u2693\ufe0e On rappelle qu\u2019une file est une structure de donn\u00e9es abstraite fond\u00e9e sur le principe \u00ab premier arriv\u00e9, premier sorti \u00bb : On munit la structure de donn\u00e9es File de quatre fonctions primitives d\u00e9finies dans le tableau ci-dessous : Structure de donn\u00e9es abstraite : Pile Op\u00e9rations : creer_file_vide : \\(\\varnothing\\) \\(\\rightarrow\\) File creer_file_vide() renvoie une file vide est_vide : File \\(\\rightarrow\\) Bool\u00e9en est_vide(file) renvoie True si file est vide, False sinon enfiler : File, \u00c9l\u00e9ment \\(\\rightarrow\\) Rien enfiler(file, element) ajoute element \u00e0 la file defiler : File \\(\\rightarrow\\) \u00c9l\u00e9ment defiler(file) renvoie l\u2019\u00e9l\u00e9ment en t\u00eate de la file en le retirant de la file Question n\u00b01 : Enonc\u00e9 Solution On suppose dans cette question que le contenu de la file F est le suivant \ud83d\udccb Texte < 9 , 4 , 2 , 5 , 8 < Quel serait le contenu de la file F1 apr\u00e9s l'ex\u00e9cution de la suite d'instruction suivante ? \ud83d\udc0d Script Python S = 0 F1 = creer_file_vide () while not est_vide ( F ): S += defiler ( F ) enfiler ( F1 , S ) Ce script permet de parcourir la file et d'additionner tous les \u00e9l\u00e9ments en fonction de son rang. situation de d\u00e9part on d\u00e9file F on calcule S et on enfile F1 on d\u00e9file F on calcule S et on enfile F1 etc.... < 9 , 13 , 15 , 20 , 28 < Question n\u00b02 : Enonc\u00e9 Solution On appelle hauteur d\u2019une file le nombre d\u2019\u00e9l\u00e9ments qu\u2019elle contient. La fonction hauteur_file prend en param\u00e8tre une file F et renvoie sa hauteur. Apr\u00e8s appel de cette fonction, la file F doit avoir retrouv\u00e9 son \u00e9tat d\u2019origine. Exemple : si F est la file de la question 1 : hauteur_file(F) = 5. Recopier et compl\u00e9ter sur votre copie le programme Python suivant impl\u00e9mentant la fonction hauteur_file en rempla\u00e7ant les ??? par les bonnes instructions. \ud83d\udc0d Script Python def hauteur_file ( F ): Q = creer_file_vide () n = 0 while not ( est_vide ( F )): ??? x = defiler ( F ) ??? while not ( est_vide ( Q )): ??? enfiler ( F , x ) return ??? \ud83d\udc0d Script Python def hauteur_file ( F ): Q = creer_file_vide () n = 0 while not ( est_vide ( F )): n = n + 1 x = defiler ( F ) enfiler ( Q , x ) while not ( est_vide ( Q )): x = defiler ( Q ) enfiler ( F , x ) return n Question n\u00b03 : Enonc\u00e9 Solution Cr\u00e9er une fonction min_file ayant pour param\u00e8tre une file F. Cette fonction renvoie la position j de l\u2019\u00e9l\u00e9ment minimum de la file F. Apr\u00e8s appel de cette fonction, la file F devra avoir retrouv\u00e9 son \u00e9tat d\u2019origine. Exemple : si F est la file de la question 1 : min_File(F) = 2. \ud83d\udc0d Script Python def min_file ( F ): Q = creer_file_vide () mini = defiler ( F ) enfiler ( Q , mini ) pos = 0 posmin = 0 while not ( est_vide ( F )): x = defiler ( F ) pos += 1 if x < mini : mini = x posmin = pos enfiler ( Q , x ) while not ( est_vide ( Q )): #on re-remplit la file F de d\u00e9part x = defiler ( Q ) enfiler ( F , x ) return posmin Question n\u00b04 : Enonc\u00e9 Solution Cr\u00e9er une fonction sup_element_file ayant pour param\u00e8tres une file F et un \u00e9l\u00e9ment e. Cette fonction supprime l'\u00e9l\u00e9ment e de la file et renvoie la file F sans cet \u00e9l\u00e9ment . Exemple : si F est la file de la question 1 : sup_element_file(F,4) doit retourner : < 9 , 2 , 5 , 8 < \ud83d\udc0d Script Python def sup_element_file ( F , e ): Q = creer_file_vide () while not ( est_vide ( F )): x = defiler ( F ) if x != e : enfiler ( Q , x ) while not ( est_vide ( Q )): x = defiler ( Q ) enfiler ( F , x ) return F Question n\u00b05 : Enonc\u00e9 Solution On donne la foncton suivante qui renvoie la valeur du minimum de la file F. \ud83d\udc0d Script Python def valeur_min_file ( F ): Q = creer_file_vide () min = defiler ( F ) enfiler ( Q , min ) while not ( est_vide ( F )): x = defiler ( F ) if x < min : min = x enfiler ( Q , x ) while not ( est_vide ( Q )): x = defiler ( Q ) enfiler ( F , x ) return min Cr\u00e9er une fonction sup_min_file ayant pour param\u00e8tre une file F. Cette fonction supprime le minimum de la file et renvoie la file F sans cet \u00e9l\u00e9ment. Exemple : si F est la file de la question 1 : sup_min_File(F) doit retourner : < 9 , 4 , 5 , 8 < \ud83d\udc0d Script Python def sup_min_file ( F ): x = valeur_min_file ( F ) F = sup_element_file ( F , x ) return F Question n\u00b06 : Enonc\u00e9 Solution On donne la fonction suivante : \ud83d\udc0d Script Python def mystere_file ( F ): Q = creer_file_vide () while not ( est_vide ( F )): e = valeur_min_file ( F ) enfiler ( Q , e ) sup_min_file ( F ) while not ( est_vide ( Q )): x = defiler ( Q ) enfiler ( F , x ) return F Donner l'\u00e9tat de la file F de la question 1. Cette fonction renverse la file : < 2 , 4 , 5 , 8 , 9 < Exercice n\u00b02 : \u2693\ufe0e On choisit de stocker les donn\u00e9es des processus en attente \u00e0 l'aide d'une liste Python lst. On dispose d\u00e9j\u00e0 d'une fonction retirer(lst) qui renvoie l'\u00e9l\u00e9ment lst[0] puis le supprime de la liste lst . Question 1 Enonc\u00e9 Solution On choisit de stocker les donn\u00e9es des processus en attente \u00e0 l'aide d'une liste Python lst. On dispose d\u00e9j\u00e0 d'une fonction retirer(lst) qui renvoie l'\u00e9l\u00e9ment lst[0] puis le supprime de la liste lst . \u00c9crire en Python le code d'une fonction ajouter(lst, proc) qui ajoute \u00e0 la fin de la liste lst le nouveau processus en attente proc . \ud83d\udc0d Script Python def ajouter ( lst , proc ): lst . append ( proc ) On choisit maintenant d'impl\u00e9menter une file file \u00e0 l'aide d'un couple ( p1,p2) o\u00f9 p1 et p2 sont des piles. Ainsi file[0] et file[1] sont respectivement les piles p1 et p2 . Pour enfiler un nouvel \u00e9l\u00e9ment elt dans file , on l'empile dans p1 . Pour d\u00e9filer file , deux cas se pr\u00e9sentent. La pile p2 n'est pas vide : on d\u00e9pile p2 . La pile p2 est vide : on d\u00e9pile les \u00e9l\u00e9ments de p1 en les empilant dans p2 jusqu'\u00e0 ce que p1 soit vide, puis on d\u00e9pile p2 . Question 2 Enonc\u00e9e Solution On consid\u00e8re la situation repr\u00e9sent\u00e9e ci-dessous. On ex\u00e9cute la s\u00e9quence d'instructions suivante : \ud83d\udccb Texte enfiler(file,ps6) defiler(file) defiler(file) defiler(file) enfiler(file,ps7) Repr\u00e9senter le contenu final des deux piles \u00e0 la suite de ces instructions. Question 3 Enonc\u00e9e Solution 3.a Solution 3.b Solution 3.c On dispose des fonctions : empiler(p,elt) qui empile l'\u00e9l\u00e9ment elt dans la pile p , depiler(p) qui renvoie le sommet de la pile p si p n'est pas vide et le supprime, pile_vide(p) qui renvoie True si la pile p est vide, False si la pile p n'est pas vide. a. \u00c9crire en Python une fonction est_ vide(f) qui prend en argument un couple de piles f et qui renvoie True si la file repr\u00e9sent\u00e9e par f est vide, False sinon. b. \u00c9crire en Python une fonction enfiler(f,elt) qui prend en arguments un couple de piles f et un \u00e9l\u00e9ment elt et qui ajoute elt en queue de la file repr\u00e9sent\u00e9e par f . c. \u00c9crire en Python une fonction defiler(f) qui prend en argument un couple de piles f et qui renvoie l'\u00e9lement en t\u00eate de la file repr\u00e9sent\u00e9e par f en le retirant. \ud83d\udc0d Script Python def est_vide ( f ): return pile_vide ( f [ 0 ]) and pile_vide ( f [ 1 ]) \ud83d\udc0d Script Python def enfiler ( f , elt ): empiler ( f [ 0 ], elt ) \ud83d\udc0d Script Python def defiler ( f ): p1 = f [ 0 ] p2 = f [ 1 ] if pile_vide ( p2 ): while not pile_vide ( p1 ): v = depiler ( p1 ) empiler ( p2 , v ) return depiler ( p2 )","title":"DS  Listes Piles Files"},{"location":"Devoirs/DS_03_01_22/","text":"Devoir n\u00b05 : Les Piles et les Files Th\u00e8me 1 : Structures de donn\u00e9es EVALUATION Exercice n\u00b01 Exercice n\u00b02 Bar\u00e8me 8 pts 8 pts Exercice n\u00b01 : Sujet BAC 2021 Cet exercice traite des notions de piles et de programmation orient\u00e9e objet. On cr\u00e9e une classe Pile qui mod\u00e9lise la structure d'une pile d'entiers. Le constructeur de la classe initialise une pile vide. La d\u00e9finition de cette classe sans l\u2019impl\u00e9mentation de ses m\u00e9thodes est donn\u00e9e ci-dessous. \ud83d\udc0d Script Python class Pile : def __init__ ( self ): \"\"\"Initialise la pile comme une pile vide.\"\"\" def est_vide ( self ): \"\"\"Renvoie True si la liste est vide, False sinon.\"\"\" def empiler ( self , e ): \"\"\"Ajoute l'\u00e9l\u00e9ment e sur le sommet de la pile, ne renvoie rien.\"\"\" def depiler ( self ): \"\"\"Retire l\u2019\u00e9l\u00e9ment au sommet de la pile et le renvoie.\"\"\" def nb_elements ( self ): \"\"\"Renvoie le nombre d'\u00e9l\u00e9ments de la pile. \"\"\" def afficher ( self ): \"\"\"Affiche de gauche \u00e0 droite les \u00e9l\u00e9ments de la pile, du fond de la pile vers son sommet. Le sommet est alors l\u2019\u00e9l\u00e9ment affich\u00e9 le plus \u00e0 droite. Les \u00e9l\u00e9ments sont s\u00e9par\u00e9s par une virgule. Si la pile est vide la m\u00e9thode affiche \u00ab pile vide \u00bb.\"\"\" Seules les m\u00e9thodes de la classe ci-dessus doivent \u00eatre utilis\u00e9es pour manipuler les objets Pile. 1.a \u00c9crire une suite d\u2019instructions permettant de cr\u00e9er une instance de la classe Pile affect\u00e9e \u00e0 une variable pile1 contenant les \u00e9l\u00e9ments 7, 5 et 2 ins\u00e9r\u00e9s dans cet ordre. Ainsi, \u00e0 l\u2019issue de ces instructions, l\u2019instruction pile1.afficher() produit l\u2019affichage : 7, 5, 2. 1.b Donner l\u2019affichage produit apr\u00e8s l\u2019ex\u00e9cution des instructions suivantes. \ud83d\udccb Texte element1 = pile1.depiler() pile1.empiler(5) pile1.empiler(element1) pile1.afficher() 2. On donne la fonction mystere suivante : \ud83d\udc0d Script Python def mystere ( pile , element ): pile2 = Pile () nb_elements = pile . nb_elements () for i in range ( nb_elements ): elem = pile . depiler () pile2 . empiler ( elem ) if elem == element : return pile2 return pile2 a. Dans chacun des quatre cas suivants, quel est l\u2019affichage obtenu dans la console ? Cas n\u00b01 \ud83d\udc0d Script Python >>> pile . afficher () 7 , 5 , 2 , 3 >>> mystere ( pile , 2 ) . afficher () Cas n\u00b02 \ud83d\udc0d Script Python >>> pile . afficher () 7 , 5 , 2 , 3 >>> mystere ( pile , 9 ) . afficher () Cas n\u00b03 \ud83d\udc0d Script Python >>> pile . afficher () 7 , 5 , 2 , 3 >>> mystere ( pile , 3 ) . afficher () Cas n\u00b04 \ud83d\udc0d Script Python >>> pile . est_vide () True >>> mystere ( pile , 3 ) . afficher () b. Expliquer ce que permet d\u2019obtenir la fonction mystere . 3. \u00c9crire une fonction etendre(pile1, pile2) qui prend en arguments deux objets Pile appel\u00e9s pile1 et pile2 et qui modifie pile1 en lui ajoutant les \u00e9l\u00e9ments de pile2 rang\u00e9s dans l'ordre inverse. Cette fonction ne renvoie rien. On donne ci-dessous les r\u00e9sultats attendus pour certaines instructions. \ud83d\udc0d Script Python >>> pile1 . afficher () 7 , 5 , 2 , 3 >>> pile2 . afficher () 1 , 3 , 4 >>> etendre ( pile1 , pile2 ) >>> pile1 . afficher () 7 , 5 , 2 , 3 , 4 , 3 , 1 >>> pile2 . est_vide () True 4. \u00c9crire une fonction supprime_toutes_occurences(pile, element) qui prend en arguments un objet Pile appel\u00e9 pile et un \u00e9l\u00e9ment element et supprime tous les \u00e9l\u00e9ments element de pile. On donne ci-dessous les r\u00e9sultats attendus pour certaines instructions. \ud83d\udc0d Script Python >>> pile . afficher () 7 , 5 , 2 , 3 , 5 >>> supprime_toutes_occurences ( pile , 5 ) >>> pile . afficher () 7 , 2 , 3 Exercice n\u00b02 : Sujet BAC 2021 On cherche \u00e0 obtenir un m\u00e9lange d'une liste comportant un nombre pair d'\u00e9l\u00e9ments. Dans cet exercice, on notera N le nombre d'\u00e9l\u00e9ments de la liste \u00e0 m\u00e9langer. La m\u00e9thode de m\u00e9lange utilis\u00e9e dans cette partie est inspir\u00e9e d\u2019un m\u00e9lange de jeux de cartes : On s\u00e9pare la liste en deux piles : \u00e0 gauche, la premi\u00e8re pile contient les N/2 premiers \u00e9l\u00e9ments de la liste ; \u00e0 droite, la deuxi\u00e8me pile contient les N/2 derniers \u00e9l\u00e9ments de la liste. On cr\u00e9e une liste vide. On prend alors le sommet de la pile de gauche et on le met en d\u00e9but de liste. On prend ensuite le sommet de la pile de droite que l\u2019on ajoute \u00e0 la liste et ainsi de suite jusqu\u2019\u00e0 ce que les piles soient vides. Par exemple, si on applique cette m\u00e9thode de m\u00e9lange \u00e0 la liste ['V','D','R','3','7','10'] , on obtient pour le partage de la liste en 2 piles : La nouvelle liste \u00e0 la fin du m\u00e9lange sera donc ['R','10','D','7','V','3'] Question 1 Que devient la liste ['7','8','9','10','V','D','R','A'] si on lui applique cette m\u00e9thode de m\u00e9lange ? On consid\u00e8re que l\u2019on dispose de la structure de donn\u00e9es de type pile, munie des seules instructions suivantes : \ud83d\udccb Texte p = Pile() : cr\u00e9e une pile vide nomm\u00e9e p p.est_vide() : renvoie Vrai si la liste est vide, Faux sinon p.empiler(e) : ajoute l\u2019\u00e9l\u00e9ment e dans la pile e = p.depiler() : retire le dernier \u00e9l\u00e9ment ajout\u00e9 dans la pile et le retourne (et l\u2019affecte \u00e0 la variable e) p2 = p.copier() : renvoie une copie de la pile p sans modifier la pile p et l\u2019affecte \u00e0 une nouvelle pile p2 Question 2 Recopier et compl\u00e9ter le code de la fonction suivante qui transforme une liste en pile. \ud83d\udc0d Script Python def liste_vers_pile ( L ): '''prend en param\u00e8tre une liste et renvoie une pile''' N = len ( L ) p_temp = Pile () for i in range ( N ): ... return ... Question 3 On consid\u00e8re la fonction suivante qui partage une liste en deux piles. Lors de sa mise au point et pour aider au d\u00e9buggage, des appels \u00e0 la fonction affichage_pile ont \u00e9t\u00e9 ins\u00e9r\u00e9s. La fonction affichage_pile(p) affiche la pile p \u00e0 l\u2019\u00e9cran verticalement sous la forme suivante : \ud83d\udc0d Script Python def partage ( L ): N = len ( L ) p_gauche = Pile () p_droite = Pile () for i in range ( N / 2 ): p_gauche . empile ( L [ i ]) for i in range ( N / 2 , N ): p_droite . empile ( L [ i ]) affichage_pile ( p_gauche ) affichage_pile ( p_droite ) return p_gauche , p_droite Quels affichages obtient-on \u00e0 l\u2019\u00e9cran lors de l\u2019ex\u00e9cution de l\u2019instruction : \ud83d\udc0d Script Python partage ([ 1 , 2 , 3 , 4 , 5 , 6 ]) ? Question 4 4.a Dans un cas g\u00e9n\u00e9ral et en vous appuyant sur une s\u00e9quence de sch\u00e9mas, expliquer en quelques lignes comment fusionner deux piles p_gauche et p_droite pour former une liste L en alternant un \u00e0 un les \u00e9l\u00e9ments de la pile p_gauche et de la pile p_droite. 4.b. \u00c9crire une fonction fusion(p1,p2) qui renvoie une liste construite \u00e0 partir des deux piles p1 et p2. Question 5 Compl\u00e9ter la derni\u00e8re ligne du code de la fonction affichage_pile pour qu\u2019elle fonctionne de mani\u00e8re r\u00e9cursive. \ud83d\udc0d Script Python def affichage_pile ( p ): p_temp = p . copier () if p_temp . est_vide (): print ( '____' ) else : elt = p_temp . depiler () print ( '| ' , elt , ' |' )) ... # ligne \u00e0 compl\u00e9ter","title":"DS 03 01 22"},{"location":"Devoirs/DS_03_01_22_correction/","text":"Devoir n\u00b05 : Les Piles et les Files Th\u00e8me 1 : Structures de donn\u00e9es EVALUATION Exercice n\u00b01 Exercice n\u00b02 Bar\u00e8me 8 pts 8 pts Exercice n\u00b01 : Sujet BAC 2021 Cet exercice traite des notions de piles et de programmation orient\u00e9e objet. On cr\u00e9e une classe Pile qui mod\u00e9lise la structure d'une pile d'entiers. Le constructeur de la classe initialise une pile vide. La d\u00e9finition de cette classe sans l\u2019impl\u00e9mentation de ses m\u00e9thodes est donn\u00e9e ci-dessous. \ud83d\udc0d Script Python class Pile : def __init__ ( self ): \"\"\"Initialise la pile comme une pile vide.\"\"\" def est_vide ( self ): \"\"\"Renvoie True si la liste est vide, False sinon.\"\"\" def empiler ( self , e ): \"\"\"Ajoute l'\u00e9l\u00e9ment e sur le sommet de la pile, ne renvoie rien.\"\"\" def depiler ( self ): \"\"\"Retire l\u2019\u00e9l\u00e9ment au sommet de la pile et le renvoie.\"\"\" def nb_elements ( self ): \"\"\"Renvoie le nombre d'\u00e9l\u00e9ments de la pile. \"\"\" def afficher ( self ): \"\"\"Affiche de gauche \u00e0 droite les \u00e9l\u00e9ments de la pile, du fond de la pile vers son sommet. Le sommet est alors l\u2019\u00e9l\u00e9ment affich\u00e9 le plus \u00e0 droite. Les \u00e9l\u00e9ments sont s\u00e9par\u00e9s par une virgule. Si la pile est vide la m\u00e9thode affiche \u00ab pile vide \u00bb.\"\"\" Seules les m\u00e9thodes de la classe ci-dessus doivent \u00eatre utilis\u00e9es pour manipuler les objets Pile. 1.a Enonc\u00e9 Solution \u00c9crire une suite d\u2019instructions permettant de cr\u00e9er une instance de la classe Pile affect\u00e9e \u00e0 une variable pile1 contenant les \u00e9l\u00e9ments 7, 5 et 2 ins\u00e9r\u00e9s dans cet ordre. Ainsi, \u00e0 l\u2019issue de ces instructions, l\u2019instruction pile1.afficher() produit l\u2019affichage : 7, 5, 2. \ud83d\udc0d Script Python pile1 = Pile () pile1 . empiler ( 7 ) pile1 . empiler ( 5 ) pile1 . empiler ( 2 ) 1.b Enonc\u00e9 Solution Donner l\u2019affichage produit apr\u00e8s l\u2019ex\u00e9cution des instructions suivantes. \ud83d\udccb Texte element1 = pile1.depiler() pile1.empiler(5) pile1.empiler(element1) pile1.afficher() 7, 5, 5, 2 2. Enonc\u00e9 Solution On donne la fonction mystere suivante : \ud83d\udc0d Script Python def mystere ( pile , element ): pile2 = Pile () nb_elements = pile . nb_elements () for i in range ( nb_elements ): elem = pile . depiler () pile2 . empiler ( elem ) if elem == element : return pile2 return pile2 a. Dans chacun des quatre cas suivants, quel est l\u2019affichage obtenu dans la console ? Cas n\u00b01 \ud83d\udc0d Script Python >>> pile . afficher () 7 , 5 , 2 , 3 >>> mystere ( pile , 2 ) . afficher () Cas n\u00b02 \ud83d\udc0d Script Python >>> pile . afficher () 7 , 5 , 2 , 3 >>> mystere ( pile , 9 ) . afficher () Cas n\u00b03 \ud83d\udc0d Script Python >>> pile . afficher () 7 , 5 , 2 , 3 >>> mystere ( pile , 3 ) . afficher () Cas n\u00b04 \ud83d\udc0d Script Python >>> pile . est_vide () True >>> mystere ( pile , 3 ) . afficher () b. Expliquer ce que permet d\u2019obtenir la fonction mystere . 2.a cas n\u00b01 : 3, 2 cas n\u00b02 : 3, 2, 5, 7 cas n\u00b03 : 3 cas n\u00b04 : pile vide 2b La fonction mystere renvoie une pile qui contiendra tous les \u00e9l\u00e9ments de la pile pass\u00e9e en param\u00e8tre (pile) \u00e0 condition qu\u2019ils soient situ\u00e9s au-dessus de l\u2019\u00e9l\u00e9ment pass\u00e9 en param\u00e8tre (element). L\u2019\u00e9l\u00e9ment element sera lui aussi pr\u00e9sent dans la pile renvoy\u00e9e par la fonction. 3. Enonc\u00e9 Solution \u00c9crire une fonction etendre(pile1, pile2) qui prend en arguments deux objets Pile appel\u00e9s pile1 et pile2 et qui modifie pile1 en lui ajoutant les \u00e9l\u00e9ments de pile2 rang\u00e9s dans l'ordre inverse. Cette fonction ne renvoie rien. On donne ci-dessous les r\u00e9sultats attendus pour certaines instructions. \ud83d\udc0d Script Python >>> pile1 . afficher () 7 , 5 , 2 , 3 >>> pile2 . afficher () 1 , 3 , 4 >>> etendre ( pile1 , pile2 ) >>> pile1 . afficher () 7 , 5 , 2 , 3 , 4 , 3 , 1 >>> pile2 . est_vide () True \ud83d\udc0d Script Python def etendre ( pile1 , pile2 ): while not pile2 . est_vide (): x = pile2 . depiler () pile1 . empiler ( x ) 4. Enonc\u00e9 Solution \u00c9crire une fonction supprime_toutes_occurences(pile, element) qui prend en arguments un objet Pile appel\u00e9 pile et un \u00e9l\u00e9ment element et supprime tous les \u00e9l\u00e9ments element de pile. On donne ci-dessous les r\u00e9sultats attendus pour certaines instructions. \ud83d\udc0d Script Python >>> pile . afficher () 7 , 5 , 2 , 3 , 5 >>> supprime_toutes_occurences ( pile , 5 ) >>> pile . afficher () 7 , 2 , 3 \ud83d\udc0d Script Python def supprime_toutes_occurences ( pile , element ): p2 = Pile () while not pile . est_vide (): x = pile . depiler () if x != element : p2 . empiler ( x ) while not p2 . est_vide (): x = p2 . depiler () pile . empiler ( x ) Exercice n\u00b02 : Sujet BAC 2021 On cherche \u00e0 obtenir un m\u00e9lange d'une liste comportant un nombre pair d'\u00e9l\u00e9ments. Dans cet exercice, on notera N le nombre d'\u00e9l\u00e9ments de la liste \u00e0 m\u00e9langer. La m\u00e9thode de m\u00e9lange utilis\u00e9e dans cette partie est inspir\u00e9e d\u2019un m\u00e9lange de jeux de cartes : On s\u00e9pare la liste en deux piles : \u00e0 gauche, la premi\u00e8re pile contient les N/2 premiers \u00e9l\u00e9ments de la liste ; \u00e0 droite, la deuxi\u00e8me pile contient les N/2 derniers \u00e9l\u00e9ments de la liste. On cr\u00e9e une liste vide. On prend alors le sommet de la pile de gauche et on le met en d\u00e9but de liste. On prend ensuite le sommet de la pile de droite que l\u2019on ajoute \u00e0 la liste et ainsi de suite jusqu\u2019\u00e0 ce que les piles soient vides. Par exemple, si on applique cette m\u00e9thode de m\u00e9lange \u00e0 la liste ['V','D','R','3','7','10'] , on obtient pour le partage de la liste en 2 piles : La nouvelle liste \u00e0 la fin du m\u00e9lange sera donc ['R','10','D','7','V','3'] Question 1 Enonc\u00e9 Solution Que devient la liste ['7','8','9','10','V','D','R','A'] si on lui applique cette m\u00e9thode de m\u00e9lange ? Avec cette m\u00e9thode de m\u00e9lange, on obtient : ['10', 'A', '9', 'R', '8', 'D', '7', 'V'] On consid\u00e8re que l\u2019on dispose de la structure de donn\u00e9es de type pile, munie des seules instructions suivantes : \ud83d\udccb Texte p = Pile() : cr\u00e9e une pile vide nomm\u00e9e p p.est_vide() : renvoie Vrai si la liste est vide, Faux sinon p.empiler(e) : ajoute l\u2019\u00e9l\u00e9ment e dans la pile e = p.depiler() : retire le dernier \u00e9l\u00e9ment ajout\u00e9 dans la pile et le retourne (et l\u2019affecte \u00e0 la variable e) p2 = p.copier() : renvoie une copie de la pile p sans modifier la pile p et l\u2019affecte \u00e0 une nouvelle pile p2 Question 2 Enonc\u00e9 Solution Recopier et compl\u00e9ter le code de la fonction suivante qui transforme une liste en pile. \ud83d\udc0d Script Python def liste_vers_pile ( L ): '''prend en param\u00e8tre une liste et renvoie une pile''' N = len ( L ) p_temp = Pile () for i in range ( N ): ... return ... \ud83d\udc0d Script Python def liste_vers_pile ( L ): N = len ( L ) p_temp = Pile () for i in range ( N ): p_temp . empiler ( L [ i ]) return p_temp Question 3 Enonc\u00e9 Solution On consid\u00e8re la fonction suivante qui partage une liste en deux piles. Lors de sa mise au point et pour aider au d\u00e9buggage, des appels \u00e0 la fonction affichage_pile ont \u00e9t\u00e9 ins\u00e9r\u00e9s. La fonction affichage_pile(p) affiche la pile p \u00e0 l\u2019\u00e9cran verticalement sous la forme suivante : \ud83d\udc0d Script Python def partage ( L ): N = len ( L ) p_gauche = Pile () p_droite = Pile () for i in range ( N / 2 ): p_gauche . empile ( L [ i ]) for i in range ( N / 2 , N ): p_droite . empile ( L [ i ]) affichage_pile ( p_gauche ) affichage_pile ( p_droite ) return p_gauche , p_droite Quels affichages obtient-on \u00e0 l\u2019\u00e9cran lors de l\u2019ex\u00e9cution de l\u2019instruction : \ud83d\udc0d Script Python partage ([ 1 , 2 , 3 , 4 , 5 , 6 ]) ? Il y a des erreurs dans l\u2019\u00e9nonc\u00e9 pour la fonction partage, voici la fonction partage corrig\u00e9e : \ud83d\udc0d Script Python def partage ( L ): N = len ( L ) p_gauche = Pile () p_droite = Pile () for i in range ( N // 2 ): p_gauche . empiler ( L [ i ]) for i in range ( N // 2 , N ): p_droite . empiler ( L [ i ]) affichage_pile ( p_gauche ) affichage_pile ( p_droite ) return p_gauche , p_droite On obtient l\u2019affichage suivant : 3 2 1 et 6 5 4 Question 4 Enonc\u00e9 Solution 4.a Dans un cas g\u00e9n\u00e9ral et en vous appuyant sur une s\u00e9quence de sch\u00e9mas, expliquer en quelques lignes comment fusionner deux piles p_gauche et p_droite pour former une liste L en alternant un \u00e0 un les \u00e9l\u00e9ments de la pile p_gauche et de la pile p_droite. 4.b. \u00c9crire une fonction fusion(p1,p2) qui renvoie une liste construite \u00e0 partir des deux piles p1 et p2. 4.a 4.b \ud83d\udc0d Script Python def fusion ( p1 , p2 ): L = [] while not p1 . est_vide (): L . append ( p1 . depiler ()) L . append ( p2 . depiler ()) return L Question 5 Enonc\u00e9 Solution Compl\u00e9ter la derni\u00e8re ligne du code de la fonction affichage_pile pour qu\u2019elle fonctionne de mani\u00e8re r\u00e9cursive. \ud83d\udc0d Script Python def affichage_pile ( p ): p_temp = p . copier () if p_temp . est_vide (): print ( '____' ) else : elt = p_temp . depiler () print ( '| ' , elt , ' |' )) ... # ligne \u00e0 compl\u00e9ter Attention dans le sujet il y a une parenth\u00e8se en trop au niveau de 2e print \ud83d\udc0d Script Python def affichage_pile ( p ): p_temp = p . copier () if p_temp . est_vide (): print ( '______' ) else : elt = p_temp . depiler () print ( '| ' , elt , ' |' ) affichage_pile ( p_temp )","title":"DS 03 01 22 correction"},{"location":"Devoirs/DS_14_12_21_arbres/","text":"Devoir n\u00b04 : Les arbres binaires et arbres binaires de recherche Th\u00e8me 1 : Structures de donn\u00e9es EVALUATION Exercice n\u00b01 Exercice n\u00b02 Exercice n\u00b03 Exercice n\u00b04 : BAC Bar\u00e8me 3 pts 2 pts 7 pts 8 pts Exercice n\u00b01 : \u2693\ufe0e On consid\u00e8re l'expression suivante : \\((3+2 \\times (4-2)) / (4 -2 \\times (3+1))+ (4-3) / (2- 7 \\times (2+5))\\) Repr\u00e9senter cette expression par un arbre binaire dans lequel les noeuds sont les op\u00e9rations et les feuilles, les nombres. Exercice n\u00b02 : D\u00e9monstration de cours \u2693\ufe0e Justifier que pour tout arbre binaire de hauteur h et de taille \\(n \\geq\\) 2, on a : \\(h \\leq n \\leq 2^h -1\\) Exercice n\u00b03 : \u2693\ufe0e Dans cet exercice, on utilisera la d\u00e9finition suivante pour la hauteur d\u2019un arbre : un arbre poss\u00e9dant un seul n\u0153ud (la racine) poss\u00e8de une hauteur \\(h = 1\\) un arbre vide poss\u00e8de une hauteur \\(h = 0\\) On consid\u00e8re l\u2019arbre binaire de recherche repr\u00e9sent\u00e9 ci-dessous, o\u00f9 val repr\u00e9sente un entier : Question 1 Indiquer : a) Taille de l\u2019arbre b) Hauteur de l\u2019arbre c) Les feuilles d) Donner les valeurs enti\u00e8res possibles de val pour cet arbre binaire de recherche. On suppose pour la suite que val est \u00e9gal \u00e0 14 Question 2 S\u2019agit-il d\u2019un arbre complet ? (Justifier la r\u00e9ponse) Question 3 Donner le r\u00e9sultat du parcours en profondeur infixe. Question 4 Donner le r\u00e9sultat du parcours en profondeur pr\u00e9fixe. Question 5 Donner le r\u00e9sultat du parcours en profondeur sufixe. Question 6 Donner le r\u00e9sultat du parcours en largeur d'abord. Exercice n\u00b04 : Exercice BAC \u2693\ufe0e Notion abord\u00e9e : les arbres binaires de recherche Un arbre binaire est soit vide, soit un n\u0153ud qui a une valeur et au plus deux fils (le sous-arbre gauche et le sous-arbre droit). X est un n\u0153ud, sa valeur est X.valeur G1 est le fils gauche de X, not\u00e9 X.fils_gauche D1 est le fils droit de X, not\u00e9 X.fils_droit Un arbre binaire de recherche est ordonn\u00e9 de la mani\u00e8re suivante : Pour chaque n\u0153ud X, les valeurs de tous les n\u0153uds du sous-arbre gauche sont strictement inf\u00e9rieures \u00e0 la valeur du n\u0153ud X les valeurs de tous les n\u0153uds du sous-arbre droit sont sup\u00e9rieures ou \u00e9gales \u00e0 la valeur du n\u0153ud X Ainsi, par exemple, toutes les valeurs des n\u0153uds G1, G2 et G3 sont strictement inf\u00e9rieures \u00e0 la valeur du n\u0153ud X et toutes les valeurs des n\u0153uds D1, D2 et D3 sont sup\u00e9rieures ou \u00e9gales \u00e0 la valeur du n\u0153ud X. Voici un exemple d'arbre binaire de recherche dans lequel on a stock\u00e9 dans cet ordre les valeurs : [26, 3, 42, 15, 29, 19, 13, 1, 32, 37, 30] L'\u00e9tiquette d'un n\u0153ud indique la valeur du n\u0153ud suivie du nom du n\u0153ud. Les n\u0153uds ont \u00e9t\u00e9 nomm\u00e9s dans l'ordre de leur insertion dans l'arbre ci-dessous. '29, noeud04' signifie que le n\u0153ud nomm\u00e9 noeud04 poss\u00e8de la valeur 29. Question 1 On ins\u00e8re la valeur 25 dans l'arbre, dans un nouveau n\u0153ud nomm\u00e9 n\u0153ud11. Recopier l'arbre binaire de recherche \u00e9tudi\u00e9 et placer la valeur 25 sur cet arbre en coloriant en rouge le chemin parcouru. Pr\u00e9ciser sous quel n\u0153ud la valeur 25 sera ins\u00e9r\u00e9e et si elle est ins\u00e9r\u00e9e en fils gauche ou en fils droit, et expliquer toutes les \u00e9tapes de la d\u00e9cision. Question 2 Pr\u00e9ciser toutes les valeurs enti\u00e8res que l\u2019on peut stocker dans le n\u0153ud fils gauche du n\u0153ud04 (vide pour l'instant), en respectant les r\u00e8gles sur les arbres binaires de recherche ? Question 3 Voici un algorithme r\u00e9cursif permettant de parcourir et d'afficher les valeurs de l'arbre : \ud83d\udc0d Script Python Parcours ( A ) # A est un arbre binaire de recherche Afficher ( A . valeur ) Parcours ( A . fils_gauche ) Parcours ( A . fils_droit ) 3.a. \u00c9crire la liste de toutes les valeurs dans l'ordre o\u00f9 elles seront affich\u00e9es. 3.b. Choisir le type de parcours d'arbres binaires de recherche r\u00e9alis\u00e9 parmi les propositions suivantes : Pr\u00e9fixe, Suffixe ou Infixe Question 4 En vous inspirant de l\u2019algorithme pr\u00e9c\u00e9dent, \u00e9crire un algorithme Parcours2 permettant de parcourir et d'afficher les valeurs de l'arbre A dans l'ordre croissant.","title":"DS 14 12 21 arbres"},{"location":"Devoirs/DS_14_12_21_arbres_Correction/","text":"Devoir n\u00b04 : Les arbres binaires et arbres binaires de recherche Th\u00e8me 1 : Structures de donn\u00e9es EVALUATION Exercice n\u00b01 Exercice n\u00b02 Exercice n\u00b03 Exercice n\u00b04 : BAC Bar\u00e8me 3 pts 2 pts 7 pts 8 pts Exercice n\u00b01 : \u2693\ufe0e Exercice n\u00b01 : Enonc\u00e9 Solution On consid\u00e8re l'expression suivante : \\((3+2 \\times (4-2)) / (4 -2 \\times (3+1))+ (4-3) / (2- 7 \\times (2+5))\\) Repr\u00e9senter cette expression par un arbre binaire dans lequel les noeuds sont les op\u00e9rations et les feuilles, les nombres. Exercice n\u00b02 : D\u00e9monstration de cours \u2693\ufe0e Exercice n\u00b02 : Enonc\u00e9 Solution Justifier que pour tout arbre binaire de hauteur h et de taille \\(n \\geq\\) 2, on a : \\(h \\leq n \\leq 2^h -1\\) La hauteur d'un arbre binaire est la profondeur maximale de ses noeuds. Cependant un arbre binaire d'une taille donn\u00e9e peut avoir un aspect totalement diff\u00e9rent. En effet, les deux arbres binaires suivants sont de m\u00eame taille (\u00e9gale \u00e0 7) mais ont des \"formes\" tr\u00e8s diff\u00e9rentes. Dans le premier cas, on a un taille \\(t\\) v\u00e9rifiant $ \\(t\\) =h$ Dans le cas d'un arbre complet, on a : \\(t= 1 + 2 + 2^2 + 2^3 + ... + 2^{h-1}\\) ceci est la somme \\(S\\) des \\(h\\) premiers termes d'une suite g\u00e9om\u00e9trique de raison 2 et de premier terme 1, d'o\u00f9 \\(S= \\dfrac{1-2^{h}}{1-2} = 2^{h} -1\\) . On en d\u00e9duit donc l'in\u00e9galit\u00e9 sur l'encadrement de la taille \\(t\\) d'un arbre binaire (non n\u00e9cessairement complet) de hauteur \\(h\\) : \\(h \\leqslant t \\leqslant 2^{h}-1\\) Exercice n\u00b03 : \u2693\ufe0e Dans cet exercice, on utilisera la d\u00e9finition suivante pour la hauteur d\u2019un arbre : un arbre poss\u00e9dant un seul n\u0153ud (la racine) poss\u00e8de une hauteur \\(h = 1\\) un arbre vide poss\u00e8de une hauteur \\(h = 0\\) On consid\u00e8re l\u2019arbre binaire de recherche repr\u00e9sent\u00e9 ci-dessous, o\u00f9 val repr\u00e9sente un entier : Question 1 Enonc\u00e9 Solution Indiquer : a) Taille de l\u2019arbre b) Hauteur de l\u2019arbre c) Les feuilles d) Donner les valeurs enti\u00e8res possibles de val pour cet arbre binaire de recherche. a) Taille = 12 b) hauteur = 4 c) Les feuilles sont 1 - 4 - 7 -11 - val et 19 d) Les valeurs possibles pour val sont : 13 - 14 et 15. On suppose pour la suite que val est \u00e9gal \u00e0 14 Question 2 Enonc\u00e9 Solution S\u2019agit-il d\u2019un arbre complet ? (Justifier la r\u00e9ponse) Il ne s'agit pas d'un arbre complet car le noeud 8 a un sous-arbre gauche mais par de sous-arbre droit. Question 3 Enonc\u00e9 Solution Donner le r\u00e9sultat du parcours en profondeur infixe. 1 - 3 - 4 - 6 - 7 - 8 - 9 - 11 - 12 - 14 - 15 - 19 Question 4 Enonc\u00e9 Solution Donner le r\u00e9sultat du parcours en profondeur pr\u00e9fixe. 9 - 6 - 3 - 1 - 4 - 8 - 7 - 12 - 11 - 15 - 14 - 19 Question 5 Enonc\u00e9 Solution Donner le r\u00e9sultat du parcours en profondeur sufixe. 1 - 4 - 3 - 7 - 8 - 6 - 11 - 14 - 19 - 15 -12 - 9 Question 6 Enonc\u00e9 Solution Donner le r\u00e9sultat du parcours en largeur d'abord. 9 - 6 - 12 - 3 - 8 -11 - 15 - 1 - 4 - 7 - 14 - 19 Exercice n\u00b04 : Exercice BAC \u2693\ufe0e Notion abord\u00e9e : les arbres binaires de recherche Un arbre binaire est soit vide, soit un n\u0153ud qui a une valeur et au plus deux fils (le sous-arbre gauche et le sous-arbre droit). X est un n\u0153ud, sa valeur est X.valeur G1 est le fils gauche de X, not\u00e9 X.fils_gauche D1 est le fils droit de X, not\u00e9 X.fils_droit Un arbre binaire de recherche est ordonn\u00e9 de la mani\u00e8re suivante : Pour chaque n\u0153ud X, les valeurs de tous les n\u0153uds du sous-arbre gauche sont strictement inf\u00e9rieures \u00e0 la valeur du n\u0153ud X les valeurs de tous les n\u0153uds du sous-arbre droit sont sup\u00e9rieures ou \u00e9gales \u00e0 la valeur du n\u0153ud X Ainsi, par exemple, toutes les valeurs des n\u0153uds G1, G2 et G3 sont strictement inf\u00e9rieures \u00e0 la valeur du n\u0153ud X et toutes les valeurs des n\u0153uds D1, D2 et D3 sont sup\u00e9rieures ou \u00e9gales \u00e0 la valeur du n\u0153ud X. Voici un exemple d'arbre binaire de recherche dans lequel on a stock\u00e9 dans cet ordre les valeurs : [26, 3, 42, 15, 29, 19, 13, 1, 32, 37, 30] L'\u00e9tiquette d'un n\u0153ud indique la valeur du n\u0153ud suivie du nom du n\u0153ud. Les n\u0153uds ont \u00e9t\u00e9 nomm\u00e9s dans l'ordre de leur insertion dans l'arbre ci-dessous. '29, noeud04' signifie que le n\u0153ud nomm\u00e9 noeud04 poss\u00e8de la valeur 29. Question 1 Enonc\u00e9 Solution On ins\u00e8re la valeur 25 dans l'arbre, dans un nouveau n\u0153ud nomm\u00e9 n\u0153ud11. Recopier l'arbre binaire de recherche \u00e9tudi\u00e9 et placer la valeur 25 sur cet arbre en coloriant en rouge le chemin parcouru. Pr\u00e9ciser sous quel n\u0153ud la valeur 25 sera ins\u00e9r\u00e9e et si elle est ins\u00e9r\u00e9e en fils gauche ou en fils droit, et expliquer toutes les \u00e9tapes de la d\u00e9cision. On d\u00e9sire ins\u00e9rer le noeud11 (valeur 25). On part de la racine (noeud00 de valeur 26), 25 est plus petit que 26, on consid\u00e8re donc le sous-arbre gauche et on se retrouve au niveau du noeud01 valeur 3). 25 est plus grand que 3, on consid\u00e8re donc le sous-arbre droit au noeud01 et on se retrouve au niveau du noeud03 (valeur 15). 25 est plus grand que 15, on consid\u00e8re donc le sous-arbre droit au noeud03 et on se retrouve au niveau du noeud05 (valeur 19). 25 est plus grand que 19, on consid\u00e8re donc le sous-arbre droit du noeud05, ce sous-arbre droit est vide et on ins\u00e8re donc le noeud11 \u00e0 cet mplacement. Le noeud11 est donc ins\u00e9r\u00e9 sous le noeud5 en fils droit. Question 2 Enonc\u00e9 Solution Pr\u00e9ciser toutes les valeurs enti\u00e8res que l\u2019on peut stocker dans le n\u0153ud fils gauche du n\u0153ud04 (vide pour l'instant), en respectant les r\u00e8gles sur les arbres binaires de recherche ? Il est possible de stocker toutes les valeurs comprises entre 26 et 29, c\u2019est \u00e0 dire : 27 et 28 Question 3 Enonc\u00e9 Solution Voici un algorithme r\u00e9cursif permettant de parcourir et d'afficher les valeurs de l'arbre : \ud83d\udc0d Script Python Parcours ( A ) # A est un arbre binaire de recherche Afficher ( A . valeur ) Parcours ( A . fils_gauche ) Parcours ( A . fils_droit ) 3.a. \u00c9crire la liste de toutes les valeurs dans l'ordre o\u00f9 elles seront affich\u00e9es. 3.b. Choisir le type de parcours d'arbres binaires de recherche r\u00e9alis\u00e9 parmi les propositions suivantes : Pr\u00e9fixe, Suffixe ou Infixe 3.a) 26 - 3 - 1 - 15 - 13 - 19 - 25 - 42 - 29 - 32 - 30 - 37 3.b) C\u2019est un parcours pr\u00e9fixe Question 4 Enonc\u00e9 Solution En vous inspirant de l\u2019algorithme pr\u00e9c\u00e9dent, \u00e9crire un algorithme Parcours2 permettant de parcourir et d'afficher les valeurs de l'arbre A dans l'ordre croissant. \ud83d\udc0d Script Python Parcours2 ( A ) Parcours2 ( A . fils_gauche ) Afficher ( A . valeur ) Parcours2 ( A . fils_droit )","title":"DS 14 12 21 arbres Correction"},{"location":"Devoirs/DS_25_01_22/","text":"Devoir n\u00b06 : Routage Exercice n\u00b01 Exercice n\u00b02 Bar\u00e8me 8 pts 4 pts Exercice n\u00b01 Cet exercice porte sur les r\u00e9seaux et les protocoles de routage. On repr\u00e9sente ci-dessous un r\u00e9seau dans lequel R1, R2, R3, R4, R5 et R6 sont des routeurs. Le r\u00e9seau local L1 est reli\u00e9 au routeur R1 et le r\u00e9seau local L2 au routeur R6. Rappels et notations Dans cet exercice, les adresses IP sont compos\u00e9es de 4 octets, soit 32 bits. Elles sont not\u00e9es X1.X2.X3.X4, o\u00f9 X1, X2, X3 et X4 sont les valeurs des 4 octets, convertis en notation d\u00e9cimale. La notation X1.X2.X3.X4/n signifie que les n premiers bits de poids forts de l\u2019adresse IP repr\u00e9sentent la partie \u00ab r\u00e9seau \u00bb, les bits suivants repr\u00e9sentent la partie \u00ab h\u00f4te \u00bb. Toutes les adresses des h\u00f4tes connect\u00e9s \u00e0 un r\u00e9seau local ont la m\u00eame partie r\u00e9seau et peuvent donc communiquer directement. L\u2019adresse IP dont tous les bits de la partie \u00ab h\u00f4te \u00bb sont \u00e0 0 est appel\u00e9e \u00ab adresse du r\u00e9seau \u00bb. On donne \u00e9galement des extraits de la table de routage des routeurs R1 \u00e0 R5 dans le tableau suivant : Routeur R\u00e9seau destinataire Passerelle Interface R1 54.37.122.0/24 86.154.10.1 86.154.10.56 R2 54.37.122.0/24 37.49.236.22 37.49.236.23 R3 54.37.122.0/24 62.34.2.8 62.34.2.9 R4 54.37.122.0/24 94.23.122.10 94.23.122.11 R5 54.37.122.0/24 218.32.15.1 218.32.15.2 Question 1 Un paquet part du r\u00e9seau local L1 \u00e0 destination du r\u00e9seau local L2. a. En utilisant l\u2019extrait de la table de routage de R1, vers quel routeur R1 envoie-t-il ce paquet : R2 ou R3 ? Justifier. b. A l\u2019aide des extraits de tables de routage ci-dessus, nommer les routeurs travers\u00e9s par ce paquet, lorsqu\u2019il va du r\u00e9seau L1 au r\u00e9seau L2. Question 2 La liaison entre R1 et R2 est rompue. a. Sachant que ce r\u00e9seau utilise le protocole RIP (distance en nombre de sauts), donner l\u2019un des deux chemins possibles que pourra suivre un paquet allant de L1 vers L2. b. Dans les extraits de tables de routage ci-dessus, pour le chemin de la question 2.a, quelle(s) ligne(s) sera (seront) modifi\u00e9e(s) ? Question 3 On a r\u00e9tabli la liaison entre R1 et R2. Par ailleurs, pour tenir compte du d\u00e9bit des liaisons, on d\u00e9cide d\u2019utiliser le protocole OSPF (distance li\u00e9e au co\u00fbt minimal des liaisons) pour effectuer le routage. Le co\u00fbt des liaisons entre les routeurs est donn\u00e9 par le tableau suivant : Liaison R1-R2 R1-R3 R2-R3 R2-R4 R2-R5 Co\u00fbt 100 100 ? 1 10 Liaison R2-R6 R3-R4 R4-R5 R4-R6 R5-R6 Co\u00fbt 10 10 1 10 1 a. Le co\u00fbt \\(C\\) d'une liaison est donn\u00e9 ici par la formule \u0b3d \\(C=\\dfrac{10^9}{BP}\\) o\u00f9 \\(BP\\) est la bande passante de la connexion en bps (bit par seconde). Sachant que la bande passante de la liaison R2-R3 est de 10 Mbps, calculer le co\u00fbt correspondant. b. D\u00e9terminer le chemin parcouru par un paquet partant du r\u00e9seau L1 et arrivant au r\u00e9seau L2, en utilisant le protocole OSPF. c. Indiquer pour quel(s) routeur(s) l\u2019extrait de la table de routage sera modifi\u00e9 pour un paquet \u00e0 destination de L2, avec la m\u00e9trique OSPF. Exercice n\u00b02 On consid\u00e8re le r\u00e9seau mod\u00e9lis\u00e9 par le sch\u00e9ma ci-dessous. Les routeurs sont identifi\u00e9s par les lettres de A \u00e0 F ; les d\u00e9bits des liaisons entre les routeurs sont indiqu\u00e9s sur le sch\u00e9ma. Question 1 Dans cette question, tous les routeurs utilisent le protocole RIP (distance en nombre de sauts). On s'int\u00e9resse aux routes utilis\u00e9es pour rejoindre F une fois les tables stabilis\u00e9es. Recopier et compl\u00e9ter sur la copie la table suivante : Question 2 Dans cette question tous les routeurs utilisent le protocole OSPF (distance en co\u00fbt des routes). Le co\u00fbt d'une liaison est mod\u00e9lis\u00e9 par la formule \\(\\dfrac{10^8}{d}\\) o\u00f9 \u0740 \\(d\\) est le d\u00e9bit de cette liaison exprim\u00e9 en bit par seconde. On s\u2019int\u00e9resse aux routes utilis\u00e9es pour rejoindre F une fois les tables stabilis\u00e9es. Recopier et compl\u00e9ter sur la copie la table suivante : Question3 Des protocoles RIP et OSPF, lequel fournit le routage entre A et F le plus performant en terme de d\u00e9bit ? Justifier la r\u00e9ponse.","title":"DS 25 01 22"},{"location":"Devoirs/DS_EP/","text":"Devoir Surveill\u00e9 : Epreuve pratique Th\u00e8me : Epreuve Pratique BAC TYPE BAC Exercice n\u00b01 : \u2693\ufe0e Exercice n\u00b01 : \u00c9crire une fonction recherche qui prend en param\u00e8tre un tableau de nombres entiers tab , et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : \ud83d\udc0d Script Python >>> recherche ([ 1 , 4 , 3 , 5 ]) [] >>> recherche ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> recherche ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> recherche ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] Exercice n\u00b02 : \u2693\ufe0e Exercice n\u00b02 : On veut r\u00e9aliser une impl\u00e9mentation objet d\u2019une file en utilisant deux piles. Vous utiliserez l\u2019impl\u00e9mentation suivante d\u2019une pile pour travailler \ud83d\udc0d Script Python class Pile : def __init__ ( self ): self . contenu = [] def empiler ( self , e ): self . contenu . append ( e ) def depiler ( self ): assert self . taille != 0 , \"on ne peut pas d\u00e9piler une pile vide\" self . contenu . pop () def sommet ( self ): assert self . taille != 0 , \"une pile vide n\u2019a pas de sommet\" return self . contenu [ - 1 ] def taille ( self ): return len ( self . contenu ) # pour repr\u00e9senter la Pile def __repr__ ( self ): ch = \"\" for e in self . contenu : ch = str ( e ) + \",\" + ch # ne pas oublier de convertir les \u00e9l\u00e9ments en chaine de caract\u00e8res ch = ch [: - 1 ] # pour enlever la derni\u00e8re virgule ch = \">\" + ch + ']' return ch Pour simplifier, l\u2019op\u00e9ration defiler renverra \u00e9galement le premier \u00e9l\u00e9ment (en plus de le retirer de la file). L\u2019op\u00e9ration premier n\u2019est alors plus n\u00e9cessaire. Vous devez donc impl\u00e9menter une classe File permettant les op\u00e9rations suivantes : cr\u00e9ation d\u2019une file vide enfiler : ajout en queue de file defiler : renvoie le premier \u00e9lement de la file et retire cet \u00e9l\u00e9ment de la file len : acc\u00e8s au nombre d\u2019\u00e9l\u00e9ments Aide : Op\u00e9ration enfiler (simple) : C\u2019est toujours dans l\u2019une des deux piles (par exemple pA) que l\u2019on empile un nouvel \u00e9l\u00e9ment \u00e0 enfiler. Op\u00e9ration defiler : Si l\u2019autre pile (pB) n\u2019est pas vide, son sommet est le premier \u00e9l\u00e9ment de la file (celui \u00e0 d\u00e9filer) Sinon (si pB est vide), le premier \u00e9l\u00e9ment de la file (celui \u00e0 d\u00e9filer) est au fond de pA. On peut alors \u201cretourner\u201d pA sur pB pour le premier \u00e9l\u00e9ment de la file arrive au sommet de pB. Op\u00e9ration len (simple) : il suffit d\u2019utiliser la m\u00e9thode taille d\u00e9finie dans la classe Pile. Compl\u00e9ter les pointill\u00e9s ... \ud83d\udc0d Script Python class File : \"\"\"File avec deux piles\"\"\" def __init__ ( self ): self . pA = Pile () # pA et pB sont les deux attributs de nos objets de la classe File self . pB = Pile () def enfiler ( self , e ): return self . pA . empiler ( e ) def __len__ ( self ): return .... def defiler ( self ): if self . pA . taille () == 0 and self . pB . taille () == 0 : raise ValueError ( \"on ne peut pas d\u00e9filer une file vide\" ) # La m\u00e9thode __repr__ est d\u00e9finie pour que vous puissiez voir l\u2019\u00e9tat d\u2019une file else : if self . pB . taille () == 0 : for x in range ( .... ): x =.... self . pB . empiler ( x ) .... self . pA . depiler () print ( 'pA' , self . pA ) print ( 'pB1' , self . pB ) else : .... def __repr__ ( self ): import copy #print(\"pile A : \", repr(self.pA)) # pour voir le contenu des deux piles #print(\"pile B : \", repr(self.pB)) lstA = copy . copy ( self . pA . contenu ) # copie des list Python repr\u00e9sentant nos deux piles lstB = copy . copy ( self . pB . contenu ) # pour ne pas les modifier lstB . reverse () # on a besoin de renverser lstB pour avoir nos \u00e9l\u00e9ments dans l\u2019ordre d\u2019entr\u00e9e lst = lstB + lstA # et de concat\u00e9ner lstB et lstA dans cet ordre # on construit ensuite la chaine \"<...<\" qui repr\u00e9sente nos files ch = \"\" for e in lst : ch = ch + str ( e ) + \",\" ch = ch [: - 1 ] # pour enlever la derni\u00e8re virgule ch = \"<\" + ch + \"<\" return ch Exercice n\u00b03 : \u2693\ufe0e Exercice n\u00b02 : Les variables liste_eleves et liste_notes ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction meilleures_notes renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction meilleures_notes ci-dessous. \ud83d\udc0d Script Python liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range ( ... ): if liste_notes [ compteur ] == ... : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ ... ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = ... liste_maxi = [ ... ] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Une fois compl\u00e9t\u00e9, le code ci-dessus donne \ud83d\udc0d Script Python >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ]) \ud83d\udc0d Script Python liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range ( ... ): if liste_notes [ compteur ] == ... : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ ... ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = ... liste_maxi = [ ... ] return ( note_maxi , nb_eleves_note_maxi , liste_maxi )","title":"DS EP"},{"location":"Devoirs/DS_EP/#exercice-n2","text":"Exercice n\u00b02 : On veut r\u00e9aliser une impl\u00e9mentation objet d\u2019une file en utilisant deux piles. Vous utiliserez l\u2019impl\u00e9mentation suivante d\u2019une pile pour travailler \ud83d\udc0d Script Python class Pile : def __init__ ( self ): self . contenu = [] def empiler ( self , e ): self . contenu . append ( e ) def depiler ( self ): assert self . taille != 0 , \"on ne peut pas d\u00e9piler une pile vide\" self . contenu . pop () def sommet ( self ): assert self . taille != 0 , \"une pile vide n\u2019a pas de sommet\" return self . contenu [ - 1 ] def taille ( self ): return len ( self . contenu ) # pour repr\u00e9senter la Pile def __repr__ ( self ): ch = \"\" for e in self . contenu : ch = str ( e ) + \",\" + ch # ne pas oublier de convertir les \u00e9l\u00e9ments en chaine de caract\u00e8res ch = ch [: - 1 ] # pour enlever la derni\u00e8re virgule ch = \">\" + ch + ']' return ch Pour simplifier, l\u2019op\u00e9ration defiler renverra \u00e9galement le premier \u00e9l\u00e9ment (en plus de le retirer de la file). L\u2019op\u00e9ration premier n\u2019est alors plus n\u00e9cessaire. Vous devez donc impl\u00e9menter une classe File permettant les op\u00e9rations suivantes : cr\u00e9ation d\u2019une file vide enfiler : ajout en queue de file defiler : renvoie le premier \u00e9lement de la file et retire cet \u00e9l\u00e9ment de la file len : acc\u00e8s au nombre d\u2019\u00e9l\u00e9ments Aide : Op\u00e9ration enfiler (simple) : C\u2019est toujours dans l\u2019une des deux piles (par exemple pA) que l\u2019on empile un nouvel \u00e9l\u00e9ment \u00e0 enfiler. Op\u00e9ration defiler : Si l\u2019autre pile (pB) n\u2019est pas vide, son sommet est le premier \u00e9l\u00e9ment de la file (celui \u00e0 d\u00e9filer) Sinon (si pB est vide), le premier \u00e9l\u00e9ment de la file (celui \u00e0 d\u00e9filer) est au fond de pA. On peut alors \u201cretourner\u201d pA sur pB pour le premier \u00e9l\u00e9ment de la file arrive au sommet de pB. Op\u00e9ration len (simple) : il suffit d\u2019utiliser la m\u00e9thode taille d\u00e9finie dans la classe Pile. Compl\u00e9ter les pointill\u00e9s ... \ud83d\udc0d Script Python class File : \"\"\"File avec deux piles\"\"\" def __init__ ( self ): self . pA = Pile () # pA et pB sont les deux attributs de nos objets de la classe File self . pB = Pile () def enfiler ( self , e ): return self . pA . empiler ( e ) def __len__ ( self ): return .... def defiler ( self ): if self . pA . taille () == 0 and self . pB . taille () == 0 : raise ValueError ( \"on ne peut pas d\u00e9filer une file vide\" ) # La m\u00e9thode __repr__ est d\u00e9finie pour que vous puissiez voir l\u2019\u00e9tat d\u2019une file else : if self . pB . taille () == 0 : for x in range ( .... ): x =.... self . pB . empiler ( x ) .... self . pA . depiler () print ( 'pA' , self . pA ) print ( 'pB1' , self . pB ) else : .... def __repr__ ( self ): import copy #print(\"pile A : \", repr(self.pA)) # pour voir le contenu des deux piles #print(\"pile B : \", repr(self.pB)) lstA = copy . copy ( self . pA . contenu ) # copie des list Python repr\u00e9sentant nos deux piles lstB = copy . copy ( self . pB . contenu ) # pour ne pas les modifier lstB . reverse () # on a besoin de renverser lstB pour avoir nos \u00e9l\u00e9ments dans l\u2019ordre d\u2019entr\u00e9e lst = lstB + lstA # et de concat\u00e9ner lstB et lstA dans cet ordre # on construit ensuite la chaine \"<...<\" qui repr\u00e9sente nos files ch = \"\" for e in lst : ch = ch + str ( e ) + \",\" ch = ch [: - 1 ] # pour enlever la derni\u00e8re virgule ch = \"<\" + ch + \"<\" return ch","title":"Exercice n\u00b02 :"},{"location":"Devoirs/DS_EP/#exercice-n3","text":"Exercice n\u00b02 : Les variables liste_eleves et liste_notes ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction meilleures_notes renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction meilleures_notes ci-dessous. \ud83d\udc0d Script Python liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range ( ... ): if liste_notes [ compteur ] == ... : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ ... ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = ... liste_maxi = [ ... ] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Une fois compl\u00e9t\u00e9, le code ci-dessus donne \ud83d\udc0d Script Python >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ]) \ud83d\udc0d Script Python liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range ( ... ): if liste_notes [ compteur ] == ... : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ ... ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = ... liste_maxi = [ ... ] return ( note_maxi , nb_eleves_note_maxi , liste_maxi )","title":"Exercice n\u00b03 :"},{"location":"Graphe/TD_Graphe/","text":"Th\u00e8me : Structure de donn\u00e9es 23 Les Graphes Le programme de N.S.I en Terminale : Contenus Capacit\u00e9s attendues Commentaires Graphes - structures relationnelles. Mod\u00e9liser des situations sous forme de graphes On s'appuie sur des exemples comme le r\u00e9seau routier, le r\u00e9seau \u00e9lectrique, Internet, les r\u00e9seaux sociaux. Sommets, arcs, ar\u00eates, graphes orient\u00e9s ou non orient\u00e9s. \u00c9crire les impl\u00e9mentations correspondantes d'un graphe : matrice d'adjacence, liste de successeurs/de pr\u00e9d\u00e9cesseurs. Le choix de la repr\u00e9sentation d\u00e9pend du traitement qu'on veut mettre en place : Passer d'une repr\u00e9sentation \u00e0 une autre. on fait le lien avec la rubrique \u00ab algorithmique \u00bb Initi\u00e9e par le grand math\u00e9maticien suisse Euler , avec le c\u00e9l\u00e8bre probl\u00e8me des 7 ponts de K\u00f6nigsberg, les applications de la th\u00e9orie des graphes et de la recherche op\u00e9rationnelle sont aujourd'hui immenses tant au plan civil que militaire : aide \u00e0 la prise de d\u00e9cision ; recherche de la meilleure strat\u00e9gie ; optimisation (plus court chemin, GPS, co\u00fbt minimal, ordonnancement des t\u00e2ches ...) ; r\u00e9seaux de transports (autoroutes, chemins de fer, m\u00e9tro, lignes a\u00e9riennes ...) ; transport de l'\u00e9nergie (\u00e9lectricit\u00e9, gaz ...) ; transport de l'informations : internet, r\u00e9seaux sociaux ... La th\u00e9orie des graphes n'est pas une branche ind\u00e9pendante des math\u00e9matiques, elle se rattache \u00e0 la programmation lin\u00e9aire, la programmation convexe (o\u00f9 le concept plus g\u00e9n\u00e9ral de fonction convexe remplace les fonctions lin\u00e9aires et affines), le calcul des probabilit\u00e9s. Les graphes sont une structure de donn\u00e9es tr\u00e8s riche permettant de mod\u00e9liser des situations vari\u00e9es de relations entre un ensemble d'entit\u00e9s : entre les ordinateurs du r\u00e9seau internet ; entre des personnes sur un r\u00e9seau social ; entre les villes dans un r\u00e9seau routier ou de distribution ; entre les atomes d'une mol\u00e9cule ; etc Un peu de vocabulaire sur les graphes \u2693\ufe0e Ce qu'il faut retenir D\u2019un point de vue math\u00e9matique, un graphe est la donn\u00e9e d\u2019un certain nombre de points du plan, appel\u00e9s sommets , certains \u00e9tant reli\u00e9s par des segments de droites ou de courbes (simples) appel\u00e9s ar\u00eates , la disposition des sommets et la forme choisie pour les ar\u00eates n\u2019intervenant pas. Le nombre de sommets du graphe est son ordre . Sauf indication contraire, un graphe sera consid\u00e9r\u00e9 comme non orient\u00e9 et les ar\u00eates pourront \u00eatre parcourues dans les deux sens. Vocabulaire des graphes non orient\u00e9s \u2693\ufe0e Ce qu'il faut retenir Dans le cas des graphes non orient\u00e9s, les relations entre deux sommets se font dans les deux sens. On appelle ses relations des ar\u00eates (edges en anglais), et on a les d\u00e9finitions suivantes : Sommets adjacents : deux sommets sont adjacents s\u2019ils sont reli\u00e9s entre eux par une ar\u00eate. On dit que l\u2019ar\u00eate est incidente aux deux sommets. Voisins d\u2019un sommet x : ce sont tous les sommets reli\u00e9s \u00e0 x par une ar\u00eate. Degr\u00e9 d\u2019un sommet x : nombre d\u2019ar\u00eates incidentes au sommet, on le note d (x). Cha\u00eene : s\u00e9quence ordonn\u00e9e d\u2019ar\u00eates telle que chaque ar\u00eate a une extr\u00e9mit\u00e9 en commun avec l\u2019ar\u00eate suivante. Cycle : dans un graphe non orient\u00e9, un cycle est une suite d\u2019ar\u00eates cons\u00e9cutives (cha\u00eene) dont les deux sommets extr\u00e9mit\u00e9s sont identiques. Boucle : il peut exister des ar\u00eates entre un sommet x et lui-m\u00eame. Elles sont appel\u00e9s boucles. Exercice 1 Citer des sommets adjacents. Donner le degr\u00e9 de chacun des sommets. Citer une cha\u00eene. Donner un cycle. Y-t-il une boucle ? Vocabulaire des graphes orient\u00e9s \u2693\ufe0e Ce qu'il faut retenir Dans le cas des graphes orient\u00e9s, les ar\u00eates ont un sens et elles sont appel\u00e9es arcs. Par exemple, l\u2019ar\u00eate a = (x, y) indique qu\u2019il y a un arc d\u2019origine x et d\u2019extr\u00e9mit\u00e9 finale y. De plus, on a les d\u00e9finitions suivantes. Successeurs et pr\u00e9d\u00e9cesseurs d\u2019un sommet x : dans un graphe orient\u00e9 on ne parle plus de voisins d\u2019un sommet mais de ses successeurs et de ses pr\u00e9d\u00e9cesseurs : le successeurs de x sont tous les sommets y tels qu\u2019il existe un arc (x, y) (de x vers y) et les pr\u00e9d\u00e9cesseurs de x sont tous les sommets w tels qu\u2019il existe un arc (w, x) (de w vers x). Chemin : s\u00e9quence ordonn\u00e9e d\u2019arcs cons\u00e9cutifs (on parlait de cha\u00eene dans un graphe non orient\u00e9). Circuit : dans un graphe orient\u00e9, un circuit est une suite d\u2019arcs cons\u00e9cutifs (chemin) dont les deux sommets extr\u00e9mit\u00e9s sont identiques. Degr\u00e9 d\u2019un sommet x : cette notion existe aussi dans le cas des graphes orient\u00e9s. On distingue le degr\u00e9 entrant d\u2019un sommet x (not\u00e9 \\(d_-(x)\\) = nombre de pr\u00e9d\u00e9cesseurs de x) et le degr\u00e9 sortant d\u2019un sommet x (not\u00e9 \\(d_+(x)\\) = nombre de successeurs de x ). Le degr\u00e9 d\u2019un sommet x vaut \\(d (x) = d_+(x) + d_-(x)\\) . \u2022 Boucle : ce sont les arcs entre un sommet et lui-m\u00eame. Exercice 2 Citer le(s) successeurs de A et le(s) pr\u00e9d\u00e9cesseur(s) de A. Donner le degr\u00e9 de chacun des sommets. \\(A,B,F\\) est-il un chemin. Donner un circuit. Y-t-il une boucle ? Graphes valu\u00e9s ou pond\u00e9r\u00e9es \u2693\ufe0e Ce qu'il faut retenir Certains graphes (orient\u00e9s ou non) sont dits valu\u00e9s : on ajoute un co\u00fbt (ou valuation, ou poids) \u00e0 chaque ar\u00eate/arc. Dans le cas d'un graphe repr\u00e9sentant un r\u00e9seau routier, le co\u00fbt sur chaque ar\u00eate pourrait, par exemple, \u00eatre la distance entre deux villes. R\u00e9seaux sociaux : mod\u00e9lisation par un graphe \u2693\ufe0e Au premier trimestre 2020, Facebook\u00a9 revendiquait 2,6 milliards d'utilisateurs actifs chaque mois, en hausse de 9,2% par rapport \u00e0 d\u00e9but 2019. Le r\u00e9seau social am\u00e9ricain a pass\u00e9 la barre symbolique des 2 milliards au deuxi\u00e8me trimestre 2017. A noter que 42% des utilisateurs actifs mensuels de Facebook viennent d'Asie-Pacifique, 15,6% sont Europ\u00e9ens et 9,7% sont Nord-am\u00e9ricains. Facebook permet \u00e0 ses utilisateurs d'entrer des informations personnelles et d'interagir avec d'autres utilisateurs. Les interactions entre utilisateurs reposent sur la notion \u00ab d'amis \u00bb. Principe de la mod\u00e9lisation par un graphe non orient\u00e9 \u2693\ufe0e Imaginez un r\u00e9seau social ayant 7 abonn\u00e9s (L, M, N, O, P, Q et R) o\u00f9 : L est ami avec M, N, O et P ; M est ami avec L et P ; N est ami avec L, O et P ; O est ami avec L,N,P,Q et R ; P est ami avec O,L et M ; Q est ami avec N et O ; R est ami avec O. La description de ce r\u00e9seau social, malgr\u00e9 son faible nombre d'abonn\u00e9s, est d\u00e9j\u00e0 quelque peu compliqu\u00e9e, alors imaginez cette m\u00eame description avec un r\u00e9seau social comportant des millions d'entre eux ! Il existe un moyen plus \"visuel\" pour repr\u00e9senter ce r\u00e9seau social : on peut repr\u00e9senter chaque abonn\u00e9 par un cercle (avec le nom de l'abonn\u00e9 situ\u00e9 dans le cercle) et chaque relation \"X est ami avec Y\" par un segment de droite reliant X et Y (\"X est ami avec Y\" et \"Y est ami avec X\" \u00e9tant repr\u00e9sent\u00e9 par le m\u00eame segment de droite). Le mini-r\u00e9seau social d\u00e9crit pr\u00e9c\u00e9demment peut \u00eatre mod\u00e9lis\u00e9 sous la forme du graphe ci-dessous : Un peu de vocabulaire sur les graphes des r\u00e9seaux sociaux... La distance entre deux sommets d\u2019un graphe est le nombre minimum d\u2019ar\u00eates pour aller du sommet \u00e0 un autre. Exemple : entre L et R la distance est 2. L\u2019 \u00e9cartement d\u2019un sommet est la distance maximale existant entre ce sommet et les autres sommets du graphe. Exemple : pour le sommet Q, la plus grande distance avec un autre sommet est 3 ; l\u2019\u00e9cartement est donc de 3. Le centre d\u2019un graphe est le sommet d\u2019\u00e9cartement minimal (le centre n\u2019est pas n\u00e9cessairement unique). Exemple : les sommets Q et R ont un \u00e9cartement de 3, les autres un \u00e9cartement de 2 ; les centres sont donc L, N, O, P. Le rayon d\u2019un graphe est l\u2019\u00e9cartement d\u2019un centre du graphe. Exemple : les centres L, N, O, P ont un \u00e9cartement de 2 ; le rayon du graphe est donc 2. Le diam\u00e8tre d\u2019un graphe est la distance maximale entre deux sommets du graphe. Exemple : l\u2019\u00e9cartement max \u00e9tant 3 (entre Q et M ou entre R et M), le diam\u00e8tre du graphe est 3. Exercice 3 Construisez un graphe de r\u00e9seau social \u00e0 partir des informations suivantes : A est ami avec B, D et E ; B est ami avec A, C et D ; C est ami avec B et D ; D est ami avec A, B, C et E ; E est ami avec A et F ; F est ami avec E. Compl\u00e9ter le tableau ci-dessous des distances entre sommets : Quel est le centre du graphe Quel est le rayon du graphe ? Quel est le diam\u00e8tre du graphe ? Impl\u00e9mentation d'un graphe non orient\u00e9 \u00e0 l'aide d'une matrice d'adjacence \u2693\ufe0e Un graphe non orient\u00e9 peut \u00eatre transcrit sous la forme d'une matrice d'adjacence qui sera simple \u00e0 coder dans un programme Python. Matrice d'adjacence Une matrice M est un tableau de nombres, qui peut \u00eatre repr\u00e9sent\u00e9 en machine par un tableau de tableaux (ou une liste de listes) not\u00e9 matrice. Chaque nombre de cette matrice est rep\u00e9r\u00e9 par son num\u00e9ro de ligne \\(i\\) et son num\u00e9ro de colonne \\(j\\) . On note ce nombre \\(M_{i,j}\\) et on peut y acc\u00e9der par l'instruction matrice[i][j] . Un graphe \u00e0 \\(n\\) sommets peut \u00eatre repr\u00e9sent\u00e9e par une matrice d'adjacence de taille \\(n \\times n\\) , o\u00f9 la valeur du coefficient d'indice \\(i,j\\) d\u00e9pend de l'existence d'une ar\u00eate ou d'un arc reliant les sommets \\(i\\) et \\(j\\) . Comment construire une matrice d'adjacence ? Il faut savoir qu'\u00e0 chaque ligne correspond un sommet du graphe et qu'\u00e0 chaque colonne correspond aussi un sommet du graphe. \u00c0 chaque intersection ligne \\(i\\) -colonne \\(j\\) (ligne \\(i\\) correspond au sommet \\(i\\) et colonne \\(j\\) correspond au sommet \\(j\\) ), on place un 1 s'il existe une ar\u00eate entre le sommet \\(i\\) et le sommet \\(j\\) , et un z\u00e9ro s'il n'existe pas d'ar\u00eate entre le sommet \\(i\\) et le sommet \\(j\\) . En d'autre terme, pour construire la matrice d'adjacence associ\u00e9e \u00e0 un graphe, il suffit, pour chaque intersection ligne / colonne, de r\u00e9pondre \u00e0 la question : Est-ce que le sommet \u00ab X \u00bb est reli\u00e9 directement au sommet \u00ab Y \u00bb par une ar\u00eate ? Si la r\u00e9ponse est OUI \u2192 1 Si la r\u00e9ponse est NON \u2192 0 Graphe non orient\u00e9 est ami avec En Python on code une matrice d'adjacence sous la forme d'une liste de listes. Chaque sous-liste repr\u00e9sente une colonne de la matrice d'adjacence. \ud83d\udc0d Script Python #Matrice d'adjacence : m = [[ 0 , 1 , 1 , 1 , 0 , 0 ], [ 1 , 0 , 0 , 1 , 0 , 0 ], [ 1 , 0 , 0 , 1 , 1 , 0 ], [ 1 , 1 , 1 , 0 , 1 , 1 ], [ 0 , 0 , 1 , 1 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 , 0 ], ] Remarque Une matrice d\u2019adjacence est qualifi\u00e9e de matrice carr\u00e9e car elle comporte toujours le m\u00eame nombre de lignes et de colonnes. Dans le cadre d\u2019un graphe non orient\u00e9 de type \u00ab est ami avec \u00bb, les \u00e9l\u00e9ments de la matrice d\u2019adjacence associ\u00e9e sont sym\u00e9trique par rapport \u00e0 la grande diagonale des 0. Exercice 4 Compl\u00e9ter la matrice d'adjacence et \u00e9crire son codage Python correspondant au graphe non orient\u00e9 suivant traduisant la relation \u00ab est ami avec \u00bb \u00c9crire un programme Python permettant de calculer le nombre d'amis de chaque utilisateur du r\u00e9seau \u00ab d'amiti\u00e9s \u00bb pr\u00e9c\u00e9dent \u00e0 partir de la matrice d'adjacence. Impl\u00e9mentation d'un graphe orient\u00e9 \u00e0 l'aide d'une matrice d'adjacence \u2693\ufe0e Dans le mod\u00e8le du mini-r\u00e9seau social pr\u00e9c\u00e9dent, le graphe est non orient\u00e9 : il traduit seulement le fait qu'un utilisateur est ami avec un autre (relation bijective). La notion de \u00ab followers \u00bb que l'on rencontre dans de nombreux r\u00e9seaux sociaux (Twitter en est un exemple), n\u00e9cessite quant \u00e0 elle d'orienter les ar\u00eates du graphe (elles deviennent alors des arcs) afin de traduire la relation \u00ab X \u00bb suit \u00ab Y \u00bb. Ainsi dans l'exemple de graphe orient\u00e9 ci-dessous, Alice (origine) suit Zo\u00e9 et Chlo\u00e9 (extr\u00e9mit\u00e9s). Graphe orient\u00e9 est ami avec Exercice 5 Comment peut-on obtenir facilement le nombre de personnes suivies par une personne donn\u00e9e ? \u00c9crire la fonction Python correspondante. Comment peut-on obtenir facilement le nombre de personnes qui suivent une personne donn\u00e9e ? \u00c9crire la fonction Python correspondante. Compl\u00e9ter le programme Python afin qu'il affiche, pour une personne donn\u00e9e, le nombre de personnes qu'elle suit et le nombre de personnes qui la suivent? Repr\u00e9sentation par matrice d'adjacence -- Exercice \u2693\ufe0e On consid\u00e8re le graphe non orient\u00e9 suivant : Question \u00c9crire la matrice d'adjacence Ce qu'il faut retenir Dans le cas d'un graphe non orient\u00e9, la matrice d'adjacence est n\u00e9cessairement sym\u00e9trique par rapport \u00e0 sa diagonale : on a \\(M_{i,j}=M_{j,i}\\) .gr On consid\u00e8re le graphe orient\u00e9 suivant : Question \u00c9crire la matrice d'adjacence Ce qu'il faut retenir Comme les arcs ont un sens, la matrice d'adjacence d'un graphe orient\u00e9 n'est g\u00e9n\u00e9ralement pas sym\u00e9trique. Repr\u00e9sentation par listes des successeurs \u2693\ufe0e Une autre fa\u00e7on de repr\u00e9senter un graphe est d'associer \u00e0 chaque sommet la liste des sommets auxquels il est reli\u00e9. Dans le cas d'un graphe orient\u00e9, on parle de liste de successeurs, alors que dans le cas d'un graphe non orient\u00e9 on parle de liste de voisins. Une fa\u00e7on simple et efficace est d'utiliser un dictionnaire o\u00f9 chaque sommet est associ\u00e9 \u00e0 la liste de ses successeurs/voisins. Exemple : Graphe non orient\u00e9 Ce graphe peut \u00eatre repr\u00e9sent\u00e9 par le dictionnaire suivant, o\u00f9 les cl\u00e9s sont les sommets et les valeurs sont les listes de voisins. \ud83d\udc0d Script Python graphe1 = { \"A\" : [ \"B\" , \"F\" , \"G\" ], \"B\" : [ \"A\" , \"C\" , \"F\" ], \"C\" : [ \"B\" , \"D\" , \"F\" ], \"D\" : [ \"C\" , \"E\" ], \"E\" : [ \"D\" , \"E\" , \"F\" ], \"F\" : [ \"A\" , \"B\" , \"C\" , \"E\" , \"G\" ], \"G\" : [ \"A\" , \"F\" ] } Exemple : Graphe orient\u00e9 Question Compl\u00e9tez le programme suivant : \ud83d\udc0d Script Python graphe2 = { \"A\" : ... \"B\" : ... \"C\" : ... \"D\" : ... \"E\" : ... \"F\" : ... \"G\" : ... } Un autre exemple Le code suivant permet d'impl\u00e9menter un graphe en langage Python \ud83d\udc0d Script Python graphe = dict () # cr\u00e9ation d'un dictionnaire vide graphe [ \"A\" ] = [ \"B\" , \"C\" , \"E\" , \"F\" , \"H\" ] # liens de A vers les sommets list\u00e9s graphe [ \"B\" ] = [ \"A\" , \"D\" , \"H\" ] graphe [ \"C\" ] = [ \"A\" , \"F\" , \"G\" , \"H\" ] graphe [ \"D\" ] = [ \"B\" , \"H\" ] graphe [ \"E\" ] = [ \"A\" , \"H\" ] graphe [ \"F\" ] = [ \"A\" , \"C\" ] graphe [ \"G\" ] = [ \"C\" , \"H\" ] graphe [ \"H\" ] = [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"G\" ] Rappel Vous avez vu l\u2019an dernier dans le cours sur les dictionnaires, qu\u2019il est possible : d\u2019obtenir l\u2019ensemble des cl\u00e9s avec la m\u00e9thode keys() en sachant que graphe.keys() est un it\u00e9rable, d\u2019obtenir l\u2019ensemble des cl\u00e9s avec la m\u00e9thode values() en sachant que graphe.values() est un it\u00e9rable. Question En s'aidant de la remarque pr\u00e9c\u00e9dente, proposer une fonction ordre en langage Python qui re\u00e7oit en param\u00e8tre un dictionnaire et renvoie l'ordre de ce graphe. Question Tester votre fonction ordre en utilisant le graphe de l'exemple introductif, impl\u00e9ment\u00e9 en langage Python ci-dessus. Question \u00c9crire une fonction sommets_adjacents qui prend en param\u00e8tre un dictionnaire ainsi qu'un sommet sous forme de cha\u00eene de caract\u00e8res et qui renvoie la liste des sommets adjacents \u00e0 ce sommet entr\u00e9 comme param\u00e8tre. Question Tester la fonction sommets_adjacents sur le sommet A. Question Proposer des pr\u00e9conditions. Question Proposer une fonction lister_aretes qui prend en param\u00e8tre un dictionnaire et renvoie la liste des ar\u00eates d'un graphe. Une ar\u00eate sera repr\u00e9sent\u00e9e par un tuple \u00e0 deux \u00e9l\u00e9ments. ( Attention aux doublons) Question \u00c9crire une fonction degre qui prend en param\u00e8tre un dictionnaire ainsi qu'un sommet sous forme de cha\u00eene de caract\u00e8res et qui renvoie le degr\u00e9 de ce sommet entr\u00e9 comme param\u00e8tre. Question Tester la fonction degre. Question Proposer des pr\u00e9conditions. Question Proposer une fonction nombre_aretes qui prend en param\u00e8tre un dictionnaire et renvoie le nombre d'ar\u00eates d'un graphe. Efficacit\u00e9 des repr\u00e9sentations \u2693\ufe0e La matrice d'adjacence est simple \u00e0 mettre en \u0153uvre mais n\u00e9cessite un espace m\u00e9moire proportionnel \u00e0 \\(n \\times n\\) (o\u00f9 \\(n\\) est le nombre de sommets). Ainsi, un graphe de 1000 sommets n\u00e9cessitent une matrice d'un million de nombres m\u00eame si le graphe contient peu d'ar\u00eates/arcs. Pour le m\u00eame graphe contenant peu d'ar\u00eates/arcs, le dictionnaire ne m\u00e9moriserait pour chaque sommet que les voisins/successeurs (les 1) sans avoir \u00e0 m\u00e9moriser les autres (les 0). En revanche, pour un graphe contenant beaucoup d'ar\u00eates/arcs, la dictionnaire occuperait plus d'espace m\u00e9moire que la matrice d'adjacence. Cela implique en outre que l'acc\u00e8s aux voisins/successeurs d'un sommet est plus rapide avec le dictionnaire car il n'est pas n\u00e9cessaire de parcourir toute la ligne de la matrice ( \\(n\\) valeurs) alors m\u00eame que celle-ci peut ne contenir que tr\u00e8s peu de 1. De plus, l'utilisation d'un dictionnaire permet de nommer les sommets sans ambigu\u00eft\u00e9 et ne les limite pas \u00e0 des entiers comme c'est le cas pour la matrice d'adjacence (m\u00eame si on peut associer chacun de ces entiers au sommet correspondant, ce que nous avons fait pr\u00e9c\u00e9demment). Enfin, au lieu d'utiliser le type liste (list de Python ici) pour m\u00e9moriser les voisins/successeurs, on peut avantageusement utiliser le type ensemble (type pr\u00e9d\u00e9fini set de Python) qui est une structure de donn\u00e9es permettant un acc\u00e8s plus efficace aux \u00e9l\u00e9ments (l'impl\u00e9mentation se fait par des tables de hachage, hors programme de NSI).","title":"Graphe - Cours"},{"location":"Graphe/TD_Graphe_Exercices/","text":"Th\u00e8me : Structure de donn\u00e9es 24 Les Graphes - Exercices et Impl\u00e9mentation Exercice 1 \u2693\ufe0e Voici deux graphes que l'on appelera respectivement G1 et G2 . Graphe G1 Graphe G2 Question Lequel est non orient\u00e9 ? Question Pour le graphe non orient\u00e9 : Donner deux sommets adjacents et deux sommets non adjacents. Donner les voisins de A ? Quels sont les degr\u00e9s des sommets B, C et E ? S'il y en a, donner un cycle de ce graphe. Donner toutes les cha\u00eenes entre les sommets A et D. Question Pour le graphe orient\u00e9 : Donner les successeurs et les pr\u00e9d\u00e9cesseurs des sommets A et C. S'il y en a, donner un chemin entre G et B. Et entre B et D ? S'il y en a, donner un circuit de ce graphe. Quel est le sommet dont le degr\u00e9 est le plus grand ? Question Donner la matrice d'adjacence de chacun de ces graphes (on prendra les indices des sommets dans l'ordre alphab\u00e9tique). Question Donner la repr\u00e9sentation de chacun de deux graphes sous la forme d'un dictionnaire de liste de successeurs. Exercice 2 : Impl\u00e9mentation par matrice d'adjacence \u2693\ufe0e Cet exercice a pour objectif d'impl\u00e9menter un graphe (non orient\u00e9 puis orient\u00e9) par une matrice d'adjacence. Graphe non orient\u00e9 Type abstrait GrapheNonOriente \u2693\ufe0e On peut doter le type abstrait des constructeurs suivants : faire_graphe(sommets) pour construire un graphe (sans ar\u00eates) \u00e0 partir de la liste sommets de ses sommets. ajouter_arete(G, x, y) pour ajouter une ar\u00eate entre les sommets x et y du graphe G . Pour pouvoir parcourir un graphe non orient\u00e9, on a besoin d'acc\u00e9der \u00e0 la liste des sommets et d'acc\u00e9der aux sommets voisins d'un sommet donn\u00e9. sommets(G) pour acc\u00e9der \u00e0 la liste des sommets du graphe G . voisins(G, x) pour acc\u00e9der \u00e0 la liste des voisins du sommet x du graphe G . Repr\u00e9sentation par matrice d'adjacence \u2693\ufe0e On choisit de cr\u00e9er une classe GrapheNoMa pour impl\u00e9menter un graphe non orient\u00e9 par sa matrice d'adjacence \u00e0 partir de la liste sommets de ses sommets (au sens list de Python). En voici une impl\u00e9mentation incompl\u00e8te puisqu'il manque la m\u00e9thode voisins(self, x) . \ud83d\udc0d Script Python class GrapheNoMa : def __init__ ( self , sommets ): self . som = sommets self . dimension = len ( sommets ) self . adjacence = [[ 0 for i in range ( self . dimension )] for j in range ( self . dimension )] def ajouter_arete ( self , x , y ): i = self . som . index ( x ) j = self . som . index ( y ) self . adjacence [ i ][ j ] = 1 self . adjacence [ j ][ i ] = 1 def sommets ( self ): return self . som def voisins ( self , x ): pass Question Combien d'attributs poss\u00e8dent les (objets) graphes de cette classe ? Quels sont leurs noms ? Lors de la cr\u00e9ation d'un objet GrapheNonOriente de cette classe, que contient la matrice d'adjacence ? Est-ce normal ? Question Quelle instruction permet de cr\u00e9er un objet g1 de cette classe contenant les sommets \"a\" , \"b\" , \"c\" , et \"d\" ? Question Quelles instructions permettent d'acc\u00e9der aux attributs du graphe g1 ? Question Expliquer le r\u00f4le de chaque ligne de la m\u00e9thode ajouter_arete en commentant directement le code. N'h\u00e9sitez pas \u00e0 consulter la documentation de Python sur les listes . Question Ecrivez les instructions pour ajouter les ar\u00eates ( \"a\" , \"b\" ), ( \"a\" , \"c\" ) et ( \"c\" , \"d\" ). Vous v\u00e9rifiez ensuite que la matrice d'adjacence est coh\u00e9rente. Question Ajoutez la m\u00e9thode voisins \u00e0 la classe pour qu'elle soit compl\u00e8te. Question Quelle instruction \u00e9crire pour afficher la liste des voisins du sommet \"a\" ? Et pour les autres sommets ? Question Impl\u00e9menter le graphe G2 Graphe orient\u00e9 \u2693\ufe0e Question En vous inspirant de ce qui vient d'\u00eatre fait, proposez un nouveau type abstrait GrapheOriente (vous donnerez les op\u00e9rations de base) et son impl\u00e9mentation par une matrice d'adjacence sous forme d'une classe GrapheOMa . Question \u00c9crivez ensuite les instructions permettant de construire le graphe orient\u00e9 g1. V\u00e9rifiez que le contenu de la matrice d'adjacence est coh\u00e9rent. Exercice 3 : Impl\u00e9mentation par liste de successeurs \u2693\ufe0e Cet exercice a pour objectif d'impl\u00e9menter les types abstraits GrapheNonOriente et GrapheOriente (d\u00e9finis dans l'exercice pr\u00e9c\u00e9dent) par un dictionnaire contenant les listes de voisins/successeurs de chaque sommet. Graphe non orient\u00e9 \u2693\ufe0e Type abstrait GrapheNonOriente \u2693\ufe0e On reprend le m\u00eame type abstrait que celui de l'exercice pr\u00e9c\u00e9dent, il poss\u00e8de donc exactement la m\u00eame interface que l'on rappelle ici. faire_graphe(sommets) pour construire un graphe (sans ar\u00eates) \u00e0 partir de la liste sommets de ses sommets. ajouter_arete(G, x, y) pour ajouter une ar\u00eate entre les sommets x et y du graphe G . sommets(G) pour acc\u00e9der \u00e0 la liste des sommets du graphe G . voisins(G, x) pour acc\u00e9der \u00e0 la liste des voisins du sommet x du graphe G . Repr\u00e9sentation par liste de successeurs \u2693\ufe0e On choisit de cr\u00e9er une classe GrapheNoLs pour impl\u00e9menter un graphe non orient\u00e9 par liste de successeurs. Remarque importante : pour que l'utilisateur qui utilise le type GrapheNonOriente via l'interface fournie ne constate aucune diff\u00e9rence (entre les deux impl\u00e9mentations), l'initialisation d'un objet de la classe GrapheNoLs se fera \u00e9galement par la donn\u00e9e de la liste de successeurs (au sens list de Python) : c'est-\u00e0-dire que g1 = GrapheNoLs([\"a\", \"b\", \"c\", \"d\"]) cr\u00e9e un graphe dont les sommets sont \"a\" , \"b\" , \"c\" , \"d\" . Voici le d\u00e9but de l'impl\u00e9mentation avec uniquement la m\u00e9thode sp\u00e9ciale __init__ . \ud83d\udc0d Script Python # classe avec uniquement la m\u00e9thode __init__ class GrapheNoLs : def __init__ ( self , sommets ): self . som = sommets self . dic = { sommet : [] for sommet in self . som } # cr\u00e9ation par compr\u00e9hension Question Combien d'attributs poss\u00e8dent les (objets) graphes de cette classe ? Quels sont leurs noms ? Lors de la cr\u00e9ation d'un objet GrapheNonOriente de cette classe, que contient le dictionnaire des successeurs ? Est-ce normal ? Question Quelle instruction permet de cr\u00e9er un objet g3 de cette classe contenant les sommets \"a\" , \"b\" , \"c\" , et \"d\" ? Question Quelles instructions permettent d'acc\u00e9der aux attributs du graphe g3 ? Question Compl\u00e9tez la classe GrapheNoLs avec les trois m\u00e9thodes manquantes. Attention : pour l'ajout d'une ar\u00eate il faudra v\u00e9rifier que ses sommets ne sont pas d\u00e9j\u00e0 dans la liste des successeurs/voisins correspondante, sous peine d'ajouter plusieurs fois le m\u00eame successeur/voisin . Question Ecrivez les instructions pour ajouter les ar\u00eates ( \"a\" , \"b\" ), ( \"a\" , \"c\" ) et ( \"c\" , \"d\" ) au graphe g3 d\u00e9fini plus haut. Vous v\u00e9rifiez ensuite que le dictionnaire est coh\u00e9rent et que si on ajoute une nouvelle fois une des ar\u00eates existantes, les listes de successeurs ne contiennent pas plusieurs fois le m\u00eame successeur. Question Quelle instruction \u00e9crire pour afficher la liste des voisins du sommet \"a\" ? Et pour les autres sommets ? Graphe orient\u00e9 \u2693\ufe0e Question En vous inspirant de ce qui vient d'\u00eatre fait, proposez une impl\u00e9mentation du type abstrait GrapheOriente (voir exercice pr\u00e9c\u00e9dent) par liste de successeurs sous forme d'une classe GrapheOLs . Question Ecrivez ensuite les instructions permettant de construire le graphe orient\u00e9 G1. V\u00e9rifiez que le contenu de la matrice d'adjacence est coh\u00e9rent. Exercice 4 : Passer d'une repr\u00e9sentation \u00e0 l'autre \u2693\ufe0e Avec le type abstrait d\u00e9fini et les repr\u00e9sentations symboliques choisies, passer d'une repr\u00e9sentation \u00e0 l'autre consiste simplement \u00e0 \u00e9num\u00e9rer les sommets et les voisins depuis une repr\u00e9sentation tout en construisant l'autre repr\u00e9sentation. Question Ecrivez une fonction ma_to_ls(gma) qui prend en argument un objet gma de la classe GrapheNoMa et qui renvoie un objet de la classe GrapheNoLs repr\u00e9sentant le m\u00eame graphe. Autrement dit une fonction qui permet de passer de la matrice d'adjacence \u00e0 la liste de successeurs. Relisez bien le paragraphe pr\u00e9c\u00e9dent pour la m\u00e9thode. \ud83d\udc0d Script Python # \u00e0 compl\u00e9ter def ma_to_ls ( gma ): #cr\u00e9er un graphe repr \u00e9 sent \u00e9 par liste de successeurs avec #les memes sommets que gma parcourir tous les sommets x de gma #et pour chaque sommet voisin de x , cr \u00e9 er l ' arete correspondante #dans le graphe repr \u00e9 sent \u00e9 par liste de successeurs #renvoyer et le graphe ainsi cr\u00e9e pass Question V\u00e9rifiez sur un exemple (ou plusieurs) que votre fonction fait bien le travail. Vous pourrez v\u00e9rifier le contenu de la matrice et du dictionnaire de listes de successeurs . Question Ecrivez la fonction de traduction r\u00e9ciproque permettant de passer des listes de successeurs \u00e0 une matrice d'adjacence. Exercice 5 : Ajout de quelques m\u00e9thodes \u2693\ufe0e On propose dans cet exercice d'ajouter quelques m\u00e9thodes aux classes GrapheNoMa et GrapheNoLs des deux exercices pr\u00e9c\u00e9dents. M\u00e9thode sp\u00e9ciale __repr__ \u2693\ufe0e Question Compl\u00e9ter le code de la classe GrapheNoMa et ajoutez-y la m\u00e9thode sp\u00e9ciale __repr__ pour afficher le graphe cr\u00e9e sous la forme suivante : a -> b c b -> a c -> a d d -> c c'est-\u00e0-dire une ligne par sommet, avec pour chacun la liste de ses voisins. Question Compl\u00e9ter le code de la classe GrapheNoLs de l'exercice 4 et ajoutez-y la m\u00e9thode sp\u00e9ciale __repr__ pour afficher le graphe cr\u00e9e sous la forme suivante : a -> b c b -> a c -> a d d -> c c'est-\u00e0-dire une ligne par sommet, avec pour chacun la liste de ses voisins. M\u00e9thode degre sommet \u2693\ufe0e Question Ajoutez aux deux classes GrapheNoMa et GrapheNoLs une m\u00e9thode degre_sommet qui permet de renvoyer le degr\u00e9 d'un sommet.","title":"Graphe - Exercices"},{"location":"Graphe/TD_Graphe_Parcours/","text":"Th\u00e8me : Structure de donn\u00e9es 25 Les Graphes : Parcours Introduction \u2693\ufe0e Un des premiers algorithmes qu'on doit savoir utiliser sur un graphe est celui de son parcours. Parcourir un graphe, c'est visiter ses diff\u00e9rents sommets, afin de pouvoir op\u00e9rer une action tour \u00e0 tour sur eux. Les deux algorithmes fondamentaux permettant de parcourir un graphe s'appellent : le parcours en profondeur d'abord ; le parcours en largeur d'abord. Selon les actions op\u00e9r\u00e9es au cours d'un parcours, on peut d\u00e9tecter des cycles dans le graphe, trouver le chemin le plus court entre deux sommets, calculer la distance entre deux sommets, etc. Les algorithmes sur les graphes sont tr\u00e8s utilis\u00e9s dans la vie courante, ils permettent par exemple : le routage des paquets de donn\u00e9es dans un r\u00e9seau ; de trouver le chemin le plus court entre deux villes (utilis\u00e9 par les GPS) ; de sortir d'un labyrinthe ; etc. le parcours en largeur \u2693\ufe0e Parcours en largeur : \u00e0 partir d'un sommet, on explore tous ses voisins (ou successeurs), puis on explore tous les voisins de ces voisins, et ainsi de suite. Le parcours balaie ainsi chaque \"branche\" au m\u00eame rythme, d'o\u00f9 le nom de parcours en largeur . A retenir Principe de l\u2019algorithme de parcours en largeur : On choisit un sommet de d\u00e9part On l\u2019enfile : Tant que la file n\u2019est pas vide : On d\u00e9file son premier \u00e9l\u00e9ment S\u2019il n\u2019a pas encore \u00e9t\u00e9 visit\u00e9 on le marque et on enfile tous ses voisins non encore visit\u00e9s Sinon, on ne fait rien (on passe donc directement \u00e0 l\u2019it\u00e9ration suivante) Question A mettre en pratique sur le graphe suivant en partant de A : Pour visualiser le parcours : Parcours Largeur Graphe 1 Question A mettre en pratique sur le graphe suivant en partant de A : Pour visualiser le parcours : Parcours Largeur Graphe 2 Question Impl\u00e9mentation en Python : A compl\u00e9ter :\\ La structure file est impl\u00e9ment\u00e9e par une liste Python mais on peut bien s\u00fbr utiliser n'importe quelle autre impl\u00e9mentation.\\ Voici l'impl\u00e9mentation du graphe G1 : \ud83d\udc0d Script Python g1 = GrapheNoLs ([ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" ]) g1 . ajouter_arete ( 'A' , 'B' ) g1 . ajouter_arete ( 'A' , 'D' ) g1 . ajouter_arete ( 'B' , 'C' ) g1 . ajouter_arete ( 'B' , 'E' ) g1 . ajouter_arete ( 'D' , 'E' ) g1 . ajouter_arete ( 'C' , 'E' ) g1 . ajouter_arete ( 'C' , 'F' ) g1 . ajouter_arete ( 'C' , 'G' ) Voici l'impl\u00e9mentation du graphe G2 : \ud83d\udc0d Script Python g2 = GrapheNoLs ([ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" ]) g2 . ajouter_arete ( 'A' , 'B' ) g2 . ajouter_arete ( 'A' , 'F' ) g2 . ajouter_arete ( 'B' , 'C' ) g2 . ajouter_arete ( 'B' , 'D' ) g2 . ajouter_arete ( 'B' , 'G' ) g2 . ajouter_arete ( 'C' , 'E' ) g2 . ajouter_arete ( 'D' , 'H' ) g2 . ajouter_arete ( 'D' , 'I' ) g2 . ajouter_arete ( 'E' , 'I' ) g2 . ajouter_arete ( 'F' , 'G' ) g2 . ajouter_arete ( 'F' , 'H' ) g2 . ajouter_arete ( 'G' , 'I' ) def parcours_larg ( graphe , debut ): visites = [] file = [ debut ] while len ( file ) > 0 : pass return visites Parcours en profondeur \u2693\ufe0e Parcours en profondeur : \u00e0 partir d'un sommet, on explore un de ses voisins (ou successeurs), et ainsi de suite. S'il n'y a plus de voisins, on revient au sommet pr\u00e9c\u00e9dent et on passe \u00e0 un autre de ses enfants. Cette fa\u00e7on de faire implique que chaque \"branche\" est explor\u00e9e jusqu'au bout, avant de revenir sur nos pas, d'o\u00f9 le nom de parcours en profondeur . A retenir Principe de l\u2019algorithme de parcours en profondeur : On choisit un sommet de d\u00e9part On l\u2019empile Tant que la pile n\u2019est pas vide : On d\u00e9pile son sommet S\u2019il n\u2019a pas encore \u00e9t\u00e9 visit\u00e9 on le marque on \u00e9tudie ses voisins : si le voisin a d\u00e9j\u00e0 \u00e9t\u00e9 visit\u00e9, on l\u2019ignore si le voisin n\u2019a pas encore \u00e9t\u00e9 visit\u00e9, on l\u2019empile et on reprend \u00e0 l\u2019\u00e9tape 2 Sinon, on ne fait rien (on passe donc directement \u00e0 l\u2019it\u00e9ration suivante) En stockant les sommets encore \u00e0 visiter dans une pile , on s'assure que ce sont les derniers sommets d\u00e9couverts qui vont \u00eatre visit\u00e9s en premier (LIFO, Last In First Out) . Question A mettre en pratique sur les exemples suivants en partant de A : Pour visualiser le parcours : Parcours Longueur Graphe1 Pour visualiser le parcours : Parcours Longueur Graphe2 Pour visualiser le parcours : Parcours Longueur Graphe3 Impl\u00e9mentation en Python : A compl\u00e9ter :\\ La structure file est impl\u00e9ment\u00e9e par une liste Python mais on peut bien s\u00fbr utiliser n'importe quelle autre impl\u00e9mentation.\\ Voici l'impl\u00e9mentation du graphe G1 : \ud83d\udc0d Script Python g1 = GrapheNoLs ([ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" ]) g1 . ajouter_arete ( 'A' , 'B' ) g1 . ajouter_arete ( 'A' , 'D' ) g1 . ajouter_arete ( 'B' , 'C' ) g1 . ajouter_arete ( 'B' , 'E' ) g1 . ajouter_arete ( 'D' , 'E' ) g1 . ajouter_arete ( 'C' , 'E' ) g1 . ajouter_arete ( 'C' , 'F' ) g1 . ajouter_arete ( 'C' , 'G' ) Voici l'impl\u00e9mentation du graphe G2 : \ud83d\udc0d Script Python g2 = GrapheNoLs ([ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" ]) g2 . ajouter_arete ( 'A' , 'B' ) g2 . ajouter_arete ( 'A' , 'F' ) g2 . ajouter_arete ( 'B' , 'C' ) g2 . ajouter_arete ( 'B' , 'D' ) g2 . ajouter_arete ( 'B' , 'G' ) g2 . ajouter_arete ( 'C' , 'E' ) g2 . ajouter_arete ( 'D' , 'H' ) g2 . ajouter_arete ( 'D' , 'I' ) g2 . ajouter_arete ( 'E' , 'I' ) g2 . ajouter_arete ( 'F' , 'G' ) g2 . ajouter_arete ( 'F' , 'H' ) g2 . ajouter_arete ( 'G' , 'I' ) Voici l'impl\u00e9mentation du graphe G3 : \ud83d\udc0d Script Python g3 = GrapheNoLs ([ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" ]) g3 . ajouter_arete ( 'A' , 'B' ) g3 . ajouter_arete ( 'A' , 'F' ) g3 . ajouter_arete ( 'B' , 'C' ) g3 . ajouter_arete ( 'B' , 'D' ) g3 . ajouter_arete ( 'B' , 'G' ) g3 . ajouter_arete ( 'C' , 'E' ) g3 . ajouter_arete ( 'D' , 'H' ) g3 . ajouter_arete ( 'D' , 'I' ) g3 . ajouter_arete ( 'E' , 'I' ) g3 . ajouter_arete ( 'F' , 'G' ) g3 . ajouter_arete ( 'F' , 'H' ) g3 . ajouter_arete ( 'G' , 'I' ) g3 . ajouter_arete ( 'H' , 'I' ) \ud83d\udc0d Script Python def parcours_prof ( graphe , visites , s ): \"\"\"parcours en profondeur depuis le sommet s\"\"\" if s not in visites : visites . append ( s ) for voisin in graphe . voisins ( s ): parcours_prof ( ... , ... , ... ) return visites def parcours_prof_rec ( graphe , debut ): return parcours_prof ( ... , ... , ... ) print ( parcours_prof_rec ( g1 , 'A' )) print ( parcours_prof_rec ( g2 , 'A' )) print ( parcours_prof_rec ( g3 , 'A' ))","title":"Graphe - Parcours"},{"location":"Processus/Gestion_Processus/","text":"Gestion des processus et des ressources - EXERCICES Exercice 1 \u2693\ufe0e Partie A \u2693\ufe0e Q1 : Cr\u00e9ez un script Python infini.py contenant une boucle infinie. Q2 : Lancez un terminal et tapez la commande top pour voir les processus ex\u00e9cut\u00e9s en temps r\u00e9el. Q3 : Lancez un autre terminal et lancez votre script Python avec la commande python inifini.py (il faut bien s\u00fbr \u00eatre plac\u00e9 dans le repertoire de ce script). Q4 : Regardez le premier terminal pour voir le processus correspondant \u00e0 l'ex\u00e9cution de ce script Python. Comment voir que ce processus va monopoliser l'ensemble de ressources processeur ? Q5 : Rep\u00e9rez le PID de ce processus et stoppez son ex\u00e9cution avec la commande kill PIDduProcessus . Partie B \u2693\ufe0e Q6 : Utilisez la commande cat /proc/cpuinfo et notez le nombre processeurs disponibles sur votre machine. Q7 : Cr\u00e9ez un autre script Python appel\u00e9 bidon.py contenant \ud83d\udc0d Script Python def bidon (): a = 0 for i in range ( 100000 ): a = a ** 3 Q8 : Dans la console Python, ex\u00e9cutez le script de la question pr\u00e9c\u00e9dente puis tapez les commandes \ud83d\udc0d Script Python >>> from timeit import timeit >>> timeit ( bidon , number = 100 ) qui permettent de lancer 100 fois la fonction bidon et renvoyer le temps d'ex\u00e9cution (pour les 100 it\u00e9rations). Q9 : Tapez dans un terminal la commande python infini.py & autant de fois qu'il y a de processeurs sur la machine. On va ainsi monopoliser l'ensemble des ressources processeurs de la machine avec des boucles infinies. Q10 : Dans la console Python, relancez timeit(bidon, number=100) . Vous devriez observer un ralentissement. Comment l'expliquer ? Q11 : ATTENTION : N'oubliez pas de stopper les 4 processus infinis en ex\u00e9cutant kill PID1 PID2 PID3 PID4 o\u00f9 PIDx sont les PID des 4 processus correspondants au script infini.py . Exercice 2 \u2693\ufe0e Lancez Firefox, ouvrez deux ou trois onglets et chargez une page Web dans chacun d'eux. Utilisez la commande ps -aef pour rep\u00e9rer les processus correspondant \u00e0 l'ex\u00e9cution de Firefox et r\u00e9pondez aux questions suivantes : Combien de processus ont \u00e9t\u00e9 cr\u00e9\u00e9s ? Vous donnerez leurs PID. Quel processus est le p\u00e8re de tous les autres ? Expliquez. V\u00e9rifiez en ex\u00e9cutant la commande pidof firefox qui donne le PID de tous les processus li\u00e9s \u00e0 l'ex\u00e9cution de Firefox. Utilisez la commande top pour voir tous les processus en temps r\u00e9el. Appuyez ensuite sur la touche \"i\" pour filter les processus inactifs (cela ne montre que ceux qui travaillent r\u00e9ellement) et \u00e9ventuellement sur la touche \"P\" pour trier les processus par ordre d\u00e9croissant d'occupation processeur. Rep\u00e9rez les PID des processus correspondant aux onglets ouverts sur Firefox. Essayez la commande kill PIDduProcessus sur un des processus fils. Que constatez-vous ? Et sur le processus p\u00e8re ? Exercice 3 : Algorithmes d'ordonnancement \u2693\ufe0e Soient les diff\u00e9rents processus suivants : Processus Date d'arriv\u00e9e Dur\u00e9e de traitement \\(P_1\\) 0 3 \\(P_2\\) 1 6 \\(P_3\\) 3 4 \\(P_4\\) 6 5 \\(P_5\\) 8 2 Application de plusieurs algorithmes \u2693\ufe0e Q1 : Donnez le diagramme de Gantt pour l'ex\u00e9cution de ces diff\u00e9rents processus en utilisant successivement les algorithmes FCFS, RR (quantum = 2 unit\u00e9s de temps) et SRT. Performances des algorithmes d'ordonnancement \u2693\ufe0e On d\u00e9finit les m\u00e9triques suivantes : le temps de s\u00e9jour (ou d'ex\u00e9cution) (ou de rotation) d'un processus : c'est la diff\u00e9rence entre la date de fin d'ex\u00e9cution et la date d'arriv\u00e9e : \\( \\(T_{\\text{sej}} = \\text{date fin d'ex\u00e9cution} - \\text{date d'arriv\u00e9e}\\) \\) le temps d'attente d'un processus : c'est la diff\u00e9rence entre le temps de s\u00e9jour et la dur\u00e9e du processus : \\( \\(T_{\\text{att}} = T_{\\text{sej}} - \\text{dur\u00e9e du processus}\\) \\) le rendement d'un processus : c'est le quotient entre la dur\u00e9e du processus et le temps de s\u00e9jour : \\( \\(\\text{rendement} = \\dfrac{\\text{dur\u00e9e du processus}}{T_{\\text{sej}}}\\) \\) Q2 : Pour chacun des trois algorithmes, calculez le temps de s\u00e9jour, le temps d'attente et le rendement de chaque processus. Q3 : Quel vous semble \u00eatre le meilleur des trois algorithmes dans notre exemple ? Expliquer. Exercice 3 - Un probl\u00e8me de synchronisation \u2693\ufe0e Voici un script Python dans lequel on cr\u00e9e une variable globale nombre qui vaut 0 au d\u00e9part et \u00e0 laquelle on ajoute 100 quatre fois successivement gr\u00e2ce \u00e0 la fonction ajoute_100 . \ud83d\udc0d Script Python import time def ajoute_100 (): global nombre for i in range ( 100 ): time . sleep ( 0.001 ) # pour simuler un traitement avec des calculs nombre = nombre + 1 if __name__ == '__main__' : nombre = 0 for i in range ( 4 ): ajoute_100 () print ( \"valeur finale :\" , nombre ) Q1 : Copiez et ex\u00e9cutez le script dans un terminal pour v\u00e9rifier que la valeur finale de la variable nombre est bien \u00e9gale \u00e0 400. On va maintenant supposer qu'une telle variable est partag\u00e9e par 4 processus, chacun \u00e9tant charg\u00e9 d'ajouter 100 \u00e0 cette variable. On a vu dans le cours le programme suivant qui permettait d'illustrer les probl\u00e8mes de synchronisation dans le cas de ressources partag\u00e9es (ici une variable partag\u00e9e) entre plusieurs processus. \ud83d\udc0d Script Python from multiprocessing import Process , Value import time def prendre_un_pion ( nombre ): if nombre . value >= 1 : time . sleep ( 0.001 ) # pour simuler un traitement avec des calculs temp = nombre . value nombre . value = temp - 1 # on d\u00e9cr\u00e9mente le nombre de pions if __name__ == '__main__' : # cr\u00e9ation de la variable partag\u00e9e initialis\u00e9e \u00e0 1 nb_pions = Value ( 'i' , 1 ) # on cr\u00e9e deux processus p1 = Process ( target = prendre_un_pion , args = [ nb_pions ]) p2 = Process ( target = prendre_un_pion , args = [ nb_pions ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () print ( \"nombre final de pions :\" , nb_pions . value ) Q2 : Inspirez-vous de ce programme pour cr\u00e9er un script permettant : - de cr\u00e9er une variable partag\u00e9e enti\u00e8re appel\u00e9e nombre_partage et initialis\u00e9e \u00e0 0 - de cr\u00e9er 4 processus ayant pour r\u00f4le d'ex\u00e9cuter une fonction ajouter_100 \u00e0 laquelle on passe nombre_partage en argument : - la fonction ajouter_100(nombre) doit ajouter 100 \u00e0 la variable partag\u00e9e nombre en utilisant une boucle for qui incr\u00e9mente 100 fois d'une unit\u00e9 la variable - on laissera une temporisation pour simuler d'autres calculs - de d\u00e9marrer les 4 processus et d'attendre la fin de leur ex\u00e9cution - d'afficher la valeur finale de la variable nombre_partage Q3 : Ex\u00e9cutez ce script dans un terminal et observez que la valeur finale de la variable nombre_partage n'est pas (toujours) \u00e9gale \u00e0 400 comme on pourrait s'y attendre. Comment peut-on expliquer cela ? Q4 : Ajoutez des affichages dans la fonction ajouter_100 pour observer ce qu'il se passe. Vous afficherez le num\u00e9ro du processus en cours d'ex\u00e9cution et la valeur de la variable partag\u00e9e \u00e0 la fin de chaque tour de boucle. Q5 : Utilisez ensuite un verrou pour r\u00e9gler ce probl\u00e8me de synchronisation en prot\u00e9geant la section critique de la fonction ajouter_100 . V\u00e9rifiez que la valeur finale est toujours \u00e9gale \u00e0 400. Exercice 5 \u2693\ufe0e d'apr\u00e8s le sujet du bac NSI 2021 1) La commande ps suivie \u00e9ventuellement de diverses options permet de lister les processus actifs ou en attente sur une machine. Sur une machine \u00e9quip\u00e9e du syst\u00e8me d\u2019exploitation GNU/Linux, la commande \u201cps -aef\u201d permet d\u2019obtenir la sortie suivante (extrait) : a) Quelle est la particularit\u00e9 de l\u2019utilisateur \u201croot\u201d ? b) Quel est le processus parent du processus ayant pour PID 3383 Dans un bureau d\u2019architectes, on dispose de certaines ressources qui ne peuvent \u00eatre utilis\u00e9es simultan\u00e9ment par plus d\u2019un processus, comme l\u2019imprimante, la table tra\u00e7ante, le modem. Chaque programme, lorsqu\u2019il s\u2019ex\u00e9cute, demande l\u2019allocation des ressources qui lui sont n\u00e9cessaires. Lorsqu\u2019il a fini de s\u2019ex\u00e9cuter, il lib\u00e8re ses ressources. 2) On appelle p1, p2 et p3 les processus associ\u00e9s respectivement aux programmes 1, 2 et 3. a) Justifier qu'une situation d'interblocage peut se produire. b) Modifier l'ordre des instructions du programme 3 pour qu'une telle situation ne puisse pas se produire. Exercice 6 \u2693\ufe0e cet exercice est issu du sujet 2021 du bac NSI Partie A Cette partie est un questionnaire \u00e0 choix multiples (QCM). Pour chacune des questions, une seule des quatre r\u00e9ponses est exacte. Le candidat indiquera sur sa copie le num\u00e9ro de la question et la lettre correspondant \u00e0 la r\u00e9ponse exacte. Aucune justification n\u2019est demand\u00e9e. Une r\u00e9ponse fausse ou une absence de r\u00e9ponse n\u2019enl\u00e8ve aucun point. 1) Parmi les commandes ci-dessous, laquelle permet d\u2019afficher les processus en cours d\u2019ex\u00e9cution ? \ud83d\udccb Texte a. dir b. ps c. man d. ls 2) Quelle abr\u00e9viation d\u00e9signe l\u2019identifiant d\u2019un processus dans un syst\u00e8me d\u2019exploitation de type UNIX ? \ud83d\udccb Texte a. PIX b. SIG c. PID d. SID 3) Comment s\u2019appelle la gestion du partage du processeur entre diff\u00e9rents processus ? \ud83d\udccb Texte a. L\u2019interblocage b. L\u2019ordonnancement c. La planification d. La priorisation 4) Quelle commande permet d\u2019interrompre un processus dans un syst\u00e8me d\u2019exploitation de type UNIX ? \ud83d\udccb Texte a. stop b. interrupt c. end d. kill Partie B 1) Un processeur choisit \u00e0 chaque cycle d\u2019ex\u00e9cution le processus qui doit \u00eatre ex\u00e9cut\u00e9. Le tableau ci-dessous donne pour trois processus P1, P2, P3 : la dur\u00e9e d\u2019ex\u00e9cution (en nombre de cycles), l\u2019instant d\u2019arriv\u00e9e sur le processeur (exprim\u00e9 en nombre de cycles \u00e0 partir de 0), le num\u00e9ro de priorit\u00e9. Le num\u00e9ro de priorit\u00e9 est d\u2019autant plus petit que la priorit\u00e9 est grande. On suppose qu\u2019\u00e0 chaque instant, c\u2019est le processus qui a le plus petit num\u00e9ro de priorit\u00e9 qui est ex\u00e9cut\u00e9, ce qui peut provoquer la suspension d\u2019un autre processus, lequel reprendra lorsqu\u2019il sera le plus prioritaire. Reproduire le tableau ci-dessous sur la copie et indiquer dans chacune des cases le processus ex\u00e9cut\u00e9 \u00e0 chaque cycle. 2) On suppose maintenant que les trois processus pr\u00e9c\u00e9dents s\u2019ex\u00e9cutent et utilisent une ou plusieurs ressources parmi R1, R2 et R3. Parmi les sc\u00e9narios suivants, lequel provoque un interblocage ? Justifier. R\u00e9f\u00e9rences : - Equipe \u00e9ducative DIU EIL, cours et exercices sur le Partage des ressources et virtualisation , Audrey Queudet, Universit\u00e9 de Nantes. - Cours d'Olivier Lecluse sur la Gestion des ressources - Documentation officielle de la bilbioth\u00e8que multiprocessing de Python. - D\u00e9p\u00f4t GitHub de David Roche pour les \u00e9nonc\u00e9s des exercices 5 et 6 au format Markdown (extrait d'exercices de bac). Germain BECKER, Lyc\u00e9e Mounier, ANGERS Ressource \u00e9ducative libre distribu\u00e9e sous Licence Creative Commons Attribution - Partage dans les M\u00eames Conditions 4.0 International","title":"Gestion Processus"},{"location":"Processus/Gestion_Processus/#exercice-1","text":"","title":"Exercice 1"},{"location":"Processus/Gestion_Processus/#exercice-2","text":"Lancez Firefox, ouvrez deux ou trois onglets et chargez une page Web dans chacun d'eux. Utilisez la commande ps -aef pour rep\u00e9rer les processus correspondant \u00e0 l'ex\u00e9cution de Firefox et r\u00e9pondez aux questions suivantes : Combien de processus ont \u00e9t\u00e9 cr\u00e9\u00e9s ? Vous donnerez leurs PID. Quel processus est le p\u00e8re de tous les autres ? Expliquez. V\u00e9rifiez en ex\u00e9cutant la commande pidof firefox qui donne le PID de tous les processus li\u00e9s \u00e0 l'ex\u00e9cution de Firefox. Utilisez la commande top pour voir tous les processus en temps r\u00e9el. Appuyez ensuite sur la touche \"i\" pour filter les processus inactifs (cela ne montre que ceux qui travaillent r\u00e9ellement) et \u00e9ventuellement sur la touche \"P\" pour trier les processus par ordre d\u00e9croissant d'occupation processeur. Rep\u00e9rez les PID des processus correspondant aux onglets ouverts sur Firefox. Essayez la commande kill PIDduProcessus sur un des processus fils. Que constatez-vous ? Et sur le processus p\u00e8re ?","title":"Exercice 2"},{"location":"Processus/Gestion_Processus/#exercice-3-algorithmes-dordonnancement","text":"Soient les diff\u00e9rents processus suivants : Processus Date d'arriv\u00e9e Dur\u00e9e de traitement \\(P_1\\) 0 3 \\(P_2\\) 1 6 \\(P_3\\) 3 4 \\(P_4\\) 6 5 \\(P_5\\) 8 2","title":"Exercice 3 : Algorithmes d'ordonnancement"},{"location":"Processus/Gestion_Processus/#exercice-3-un-probleme-de-synchronisation","text":"Voici un script Python dans lequel on cr\u00e9e une variable globale nombre qui vaut 0 au d\u00e9part et \u00e0 laquelle on ajoute 100 quatre fois successivement gr\u00e2ce \u00e0 la fonction ajoute_100 . \ud83d\udc0d Script Python import time def ajoute_100 (): global nombre for i in range ( 100 ): time . sleep ( 0.001 ) # pour simuler un traitement avec des calculs nombre = nombre + 1 if __name__ == '__main__' : nombre = 0 for i in range ( 4 ): ajoute_100 () print ( \"valeur finale :\" , nombre ) Q1 : Copiez et ex\u00e9cutez le script dans un terminal pour v\u00e9rifier que la valeur finale de la variable nombre est bien \u00e9gale \u00e0 400. On va maintenant supposer qu'une telle variable est partag\u00e9e par 4 processus, chacun \u00e9tant charg\u00e9 d'ajouter 100 \u00e0 cette variable. On a vu dans le cours le programme suivant qui permettait d'illustrer les probl\u00e8mes de synchronisation dans le cas de ressources partag\u00e9es (ici une variable partag\u00e9e) entre plusieurs processus. \ud83d\udc0d Script Python from multiprocessing import Process , Value import time def prendre_un_pion ( nombre ): if nombre . value >= 1 : time . sleep ( 0.001 ) # pour simuler un traitement avec des calculs temp = nombre . value nombre . value = temp - 1 # on d\u00e9cr\u00e9mente le nombre de pions if __name__ == '__main__' : # cr\u00e9ation de la variable partag\u00e9e initialis\u00e9e \u00e0 1 nb_pions = Value ( 'i' , 1 ) # on cr\u00e9e deux processus p1 = Process ( target = prendre_un_pion , args = [ nb_pions ]) p2 = Process ( target = prendre_un_pion , args = [ nb_pions ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () print ( \"nombre final de pions :\" , nb_pions . value ) Q2 : Inspirez-vous de ce programme pour cr\u00e9er un script permettant : - de cr\u00e9er une variable partag\u00e9e enti\u00e8re appel\u00e9e nombre_partage et initialis\u00e9e \u00e0 0 - de cr\u00e9er 4 processus ayant pour r\u00f4le d'ex\u00e9cuter une fonction ajouter_100 \u00e0 laquelle on passe nombre_partage en argument : - la fonction ajouter_100(nombre) doit ajouter 100 \u00e0 la variable partag\u00e9e nombre en utilisant une boucle for qui incr\u00e9mente 100 fois d'une unit\u00e9 la variable - on laissera une temporisation pour simuler d'autres calculs - de d\u00e9marrer les 4 processus et d'attendre la fin de leur ex\u00e9cution - d'afficher la valeur finale de la variable nombre_partage Q3 : Ex\u00e9cutez ce script dans un terminal et observez que la valeur finale de la variable nombre_partage n'est pas (toujours) \u00e9gale \u00e0 400 comme on pourrait s'y attendre. Comment peut-on expliquer cela ? Q4 : Ajoutez des affichages dans la fonction ajouter_100 pour observer ce qu'il se passe. Vous afficherez le num\u00e9ro du processus en cours d'ex\u00e9cution et la valeur de la variable partag\u00e9e \u00e0 la fin de chaque tour de boucle. Q5 : Utilisez ensuite un verrou pour r\u00e9gler ce probl\u00e8me de synchronisation en prot\u00e9geant la section critique de la fonction ajouter_100 . V\u00e9rifiez que la valeur finale est toujours \u00e9gale \u00e0 400.","title":"Exercice 3 - Un probl\u00e8me de synchronisation"},{"location":"Processus/Gestion_Processus/#exercice-5","text":"d'apr\u00e8s le sujet du bac NSI 2021 1) La commande ps suivie \u00e9ventuellement de diverses options permet de lister les processus actifs ou en attente sur une machine. Sur une machine \u00e9quip\u00e9e du syst\u00e8me d\u2019exploitation GNU/Linux, la commande \u201cps -aef\u201d permet d\u2019obtenir la sortie suivante (extrait) : a) Quelle est la particularit\u00e9 de l\u2019utilisateur \u201croot\u201d ? b) Quel est le processus parent du processus ayant pour PID 3383 Dans un bureau d\u2019architectes, on dispose de certaines ressources qui ne peuvent \u00eatre utilis\u00e9es simultan\u00e9ment par plus d\u2019un processus, comme l\u2019imprimante, la table tra\u00e7ante, le modem. Chaque programme, lorsqu\u2019il s\u2019ex\u00e9cute, demande l\u2019allocation des ressources qui lui sont n\u00e9cessaires. Lorsqu\u2019il a fini de s\u2019ex\u00e9cuter, il lib\u00e8re ses ressources. 2) On appelle p1, p2 et p3 les processus associ\u00e9s respectivement aux programmes 1, 2 et 3. a) Justifier qu'une situation d'interblocage peut se produire. b) Modifier l'ordre des instructions du programme 3 pour qu'une telle situation ne puisse pas se produire.","title":"Exercice 5"},{"location":"Processus/Gestion_Processus/#exercice-6","text":"cet exercice est issu du sujet 2021 du bac NSI Partie A Cette partie est un questionnaire \u00e0 choix multiples (QCM). Pour chacune des questions, une seule des quatre r\u00e9ponses est exacte. Le candidat indiquera sur sa copie le num\u00e9ro de la question et la lettre correspondant \u00e0 la r\u00e9ponse exacte. Aucune justification n\u2019est demand\u00e9e. Une r\u00e9ponse fausse ou une absence de r\u00e9ponse n\u2019enl\u00e8ve aucun point. 1) Parmi les commandes ci-dessous, laquelle permet d\u2019afficher les processus en cours d\u2019ex\u00e9cution ? \ud83d\udccb Texte a. dir b. ps c. man d. ls 2) Quelle abr\u00e9viation d\u00e9signe l\u2019identifiant d\u2019un processus dans un syst\u00e8me d\u2019exploitation de type UNIX ? \ud83d\udccb Texte a. PIX b. SIG c. PID d. SID 3) Comment s\u2019appelle la gestion du partage du processeur entre diff\u00e9rents processus ? \ud83d\udccb Texte a. L\u2019interblocage b. L\u2019ordonnancement c. La planification d. La priorisation 4) Quelle commande permet d\u2019interrompre un processus dans un syst\u00e8me d\u2019exploitation de type UNIX ? \ud83d\udccb Texte a. stop b. interrupt c. end d. kill Partie B 1) Un processeur choisit \u00e0 chaque cycle d\u2019ex\u00e9cution le processus qui doit \u00eatre ex\u00e9cut\u00e9. Le tableau ci-dessous donne pour trois processus P1, P2, P3 : la dur\u00e9e d\u2019ex\u00e9cution (en nombre de cycles), l\u2019instant d\u2019arriv\u00e9e sur le processeur (exprim\u00e9 en nombre de cycles \u00e0 partir de 0), le num\u00e9ro de priorit\u00e9. Le num\u00e9ro de priorit\u00e9 est d\u2019autant plus petit que la priorit\u00e9 est grande. On suppose qu\u2019\u00e0 chaque instant, c\u2019est le processus qui a le plus petit num\u00e9ro de priorit\u00e9 qui est ex\u00e9cut\u00e9, ce qui peut provoquer la suspension d\u2019un autre processus, lequel reprendra lorsqu\u2019il sera le plus prioritaire. Reproduire le tableau ci-dessous sur la copie et indiquer dans chacune des cases le processus ex\u00e9cut\u00e9 \u00e0 chaque cycle. 2) On suppose maintenant que les trois processus pr\u00e9c\u00e9dents s\u2019ex\u00e9cutent et utilisent une ou plusieurs ressources parmi R1, R2 et R3. Parmi les sc\u00e9narios suivants, lequel provoque un interblocage ? Justifier. R\u00e9f\u00e9rences : - Equipe \u00e9ducative DIU EIL, cours et exercices sur le Partage des ressources et virtualisation , Audrey Queudet, Universit\u00e9 de Nantes. - Cours d'Olivier Lecluse sur la Gestion des ressources - Documentation officielle de la bilbioth\u00e8que multiprocessing de Python. - D\u00e9p\u00f4t GitHub de David Roche pour les \u00e9nonc\u00e9s des exercices 5 et 6 au format Markdown (extrait d'exercices de bac). Germain BECKER, Lyc\u00e9e Mounier, ANGERS Ressource \u00e9ducative libre distribu\u00e9e sous Licence Creative Commons Attribution - Partage dans les M\u00eames Conditions 4.0 International","title":"Exercice 6"},{"location":"Processus/Gestion_Processus_C/","text":"Th\u00e8me 3 : Architecture mat\u00e9rielle 23 Cours : Gestion des processus Rappel\u2693\ufe0e \u2693\ufe0e Un microprocesseur ne comprend que le langage machine. \u00c0 chaque code d'instruction correspond un circuit \u00e9lectronique afin de pouvoir ex\u00e9cuter l'instruction. Pour rappel, voici les \u00e9tapes d'ex\u00e9cution d'une instruction. l'instruction point\u00e9e par le pointeur d'instruction est charg\u00e9e en m\u00e9moire Le pointeur d'instruction est incr\u00e9ment\u00e9 vers l'adresse suivante l'instruction est d\u00e9cod\u00e9e l'instruction est ex\u00e9cut\u00e9e Gestion des processus - ordonnanceur\u2693\ufe0e \u2693\ufe0e Lors de l'ex\u00e9cution d'un programme, celui ci est d'abord charg\u00e9 en m\u00e9moire. Le pointeur d'instruction pointe alors vers la premi\u00e8re instruction. Puis l'encha\u00eenement des \u00e9tapes d\u00e9crites pr\u00e9c\u00e9demment s'effectue. Si tel \u00e9tait r\u00e9ellement le cas, une fois un programme lanc\u00e9, il faudrait attendre qu'il soit termin\u00e9 pour pouvoir en lancer un autre. L'encha\u00eenement pr\u00e9c\u00e9dent est correct, mais il faut en plus ajouter le principe des interruptions. Une interruption est un signal, qui comme son nom l'indique, a pour objectif d'interrompre le cours normal d'un programme afin d'ex\u00e9cuter une t\u00e2che particuli\u00e8re. Le gestionnaire d'interruption re\u00e7oit plusieurs arguments, en particulier : un code lui permettant de reconna\u00eetre le signale de l'interruption et ce qui en est \u00e0 l'origine. une copie des valeurs des registres. Exemple Voici quelques interruptions mat\u00e9rielles : un disque dur informe qu'il a fini d'\u00e9crire des donn\u00e9es, une carte r\u00e9seau informe qu'elle a re\u00e7oit des donn\u00e9es, le clavier informe que des combinaisons de touches ont \u00e9t\u00e9 appuy\u00e9es. l'horloge interne envoie r\u00e9guli\u00e8rement un signal. Cet envoi r\u00e9gulier de signaux de l'horloge, va permettre de g\u00e9rer plusieurs programmes \"simultan\u00e9ment\". Processus concurrents\u2693\ufe0e \u2693\ufe0e Vocabulaire Voici quelques mots de vocabulaire : Ex\u00e9cutable : fichier binaire, directement ex\u00e9cutable par le processeur. Programme : Suite d'instructions qui peut \u00e9ventuellement \u00eatre ex\u00e9cut\u00e9. Processus : Programme en cours d'ex\u00e9cution. C'est une instance d'un programme qui est recopi\u00e9 en m\u00e9moire vive. Il est identifi\u00e9 par un num\u00e9ro unique par le syst\u00e8me d'exploitation. Il est caract\u00e9ris\u00e9 par : l'ensemble de la m\u00e9moire qui lui est allou\u00e9e (binaire, donn\u00e9es manipul\u00e9es, donn\u00e9es de la pile .) l'ensemble des ressources utilis\u00e9es (fichiers, connexions r\u00e9seau, mat\u00e9riel...) les valeurs stock\u00e9es dans tous les registres du processeur Un m\u00eame programme peut \u00eatre ex\u00e9cut\u00e9 plusieurs fois, chacun dans un processus propre. Ex\u00e9cution concurrente : deux processus s'ex\u00e9cutent de mani\u00e8re concurrente lorsque sur un m\u00eame processeur, l'ex\u00e9cution de l'un est entrecoup\u00e9e par l'ex\u00e9cution de l'autre. Ex\u00e9cution parall\u00e8le : deux processus s'ex\u00e9cutent de mani\u00e8re parall\u00e8le, s'ils s'ex\u00e9cutent simultan\u00e9ment. Cela implique la pr\u00e9sence de plusieurs c\u0153urs. Afin de g\u00e9rer les diff\u00e9rents processus en cours, le syst\u00e8me d'exploitation poss\u00e8de un gestionnaire de processus appel\u00e9 ordonnanceur. Son r\u00f4le est : g\u00e9rer la r\u00e9cup\u00e9ration du contexte d'ex\u00e9cution de chaque processus. Faire une sauvegarde du contexte du processus qui va \u00eatre interrompu ou recharger une sauvegarde d'un contexte du processus qui va poursuivre son ex\u00e9cution. g\u00e9rer l'ordre dans lequel vont s'ex\u00e9cuter les diff\u00e9rents processus. Exemple typique On consid\u00e8re qu'un \u00e9diteur de texte, un logiciel de lecture musicale, un navigateur web et d'autres applications sont en action. L'\u00e9diteur de texte est en cours d'ex\u00e9cution. Un signal de l'horloge est envoy\u00e9 et provoque une interruption. L'ordonnanceur r\u00e9agit \u00e0 ce signal. Il re\u00e7oit le contexte d'ex\u00e9cution du processus correspondant \u00e0 l'\u00e9diteur de texte en action. L'ordonnanceur stocke dans un endroit de la m\u00e9moire le contexte d'ex\u00e9cution. Il choisit de donner la main au logiciel de lecture musicale. Il restaure le contexte d'ex\u00e9cution et donc entre autre, la valeur du pointeur d'instruction qui pointe vers la prochaine instruction \u00e0 ex\u00e9cuter dans le lecteur musical. L'ordonnanceur rend la main. La prochaine instruction qui sera ex\u00e9cut\u00e9e, sera donc celle du lecteur musical. Le lecteur musical poursuit son ex\u00e9cution. Un signal de l'horloge est envoy\u00e9 et provoque une interruption. etc. \u00c9tat d'un processus Durant son ex\u00e9cution, un processus passe par plusieurs \u00e9tats : Nouveau : Au lancement d'un programme, est cr\u00e9\u00e9 un nouveau processus auquel est affect\u00e9 un num\u00e9ro PID Pr\u00eat/\u00c9lu : Le processus est pr\u00eat \u00e0 \u00eatre ex\u00e9cut\u00e9/poursuivre son ex\u00e9cution. En ex\u00e9cution : Le processus ex\u00e9cute une suite d'instructions. Bloqu\u00e9/En attente : Le processus est en attente de ressources (typiquement des E/S de donn\u00e9es : clavier, lecture de fichiers...). Il ne peut pas poursuivre son ex\u00e9cution tant que ces ressources ne sont pas fournies. Termin\u00e9 : Le processus a termin\u00e9 son ex\u00e9cution. Il faut alors lib\u00e9rer la m\u00e9moire utilis\u00e9e et les ressources utilis\u00e9es. On peut r\u00e9sumer le cycle d'un processus avec le sch\u00e9ma suivant : fig sch\u00e9ma cycle des \u00e9tats d'un processus Remarque En fonction de l'attente d'une ressource ou pas, apr\u00e8s le stade ex\u00e9cution, un processus repasse \u00e0 l'\u00e9tat : pr\u00eat : s'il n'attend aucune ressource, mais seulement que le processeur lui accorde du temps bloqu\u00e9 : s'il est en attente d'une ressource De plus quel que soit son \u00e9tat, il peut aller vers l'\u00e9tat Termin\u00e9 en raison d'une situation anormale (erreur dans le programme, erreur mat\u00e9rielle...) Observation des processus\u2693\ufe0e \u2693\ufe0e Sous Linux, on peut observer les processus et leur \u00e9tat en ligne de commande. Pour tester, cela on peut utiliser : terminal linux en ligne Voici quelques commandes utiles pour observer les processus : ps |: elle permet d'afficher la liste des processus en cours. (Pour avoir des informations sur les options taper man ps) Pour lister tous les processus : ps - ef top : Pour observer en temps r\u00e9els les diff\u00e9rents processus.(penser \u00e0 utiliser man top) la commande f permet de g\u00e9rer les colonnes affich\u00e9es. kill : elle permet de tuer un processus en lui envoyant un signal de fin. 15 pour arr\u00eater le processus proprement 9 pour arr\u00eater imm\u00e9diatement le processus. exemple d'utilisation : kill -15 7654 pour tuer proprement le processus de PID 7564 Exercice Dans un nouvel onglet ouvrir : terminal linux en ligne cr\u00e9er un premier terminal : utiliser les commandes de l'ann\u00e9e pr\u00e9c\u00e9dentes : ls, cd, touch, cat pour d\u00e9terminer le nom d'utilisateur : whoami cr\u00e9er un fichier vide test.py : touch test.py \u00e9diter le fichier test.py avec la commande : nano test.py y \u00e9crire le code suivant : python for a in range(100000): print(a) pour sortir de l'\u00e9diteur : Ctrl+X, puis Y, puis Enter pour confirmer le nom lancer le programme avec : python3 test.py cr\u00e9er un second fichier p2.py avec le code suivant : \ud83d\udc0d Script Python while True : pass le lancer Il tourne sans fin. Pour l'arr\u00eater : Ctrl+C v\u00e9rifier la pr\u00e9sence dans le dossier des fichiers cr\u00e9\u00e9s, avec ls ouvrir un second terminal puis : dans ce second terminal lancer python3 sans nom de fichier dans le premier terminal taper ps -ef rep\u00e9rer le PID du processus python3 et le tuer avec la commande kill -9 (voir syntaxe au dessus) ouvrir un troisi\u00e8me terminal dans ce troisi\u00e8me terminal lancer la commande top modifier l'affichage pour faire appara\u00eetre le PPID (taper f, puis s\u00e9lectionner/ d\u00e9placer avec les touches curseur. Revenir \u00e0 l'affichage avec Esc) Enfin ouvrir des terminaux suppl\u00e9mentaires pour en avoir au moins 5 et lancer dans les terminaux : 1 aucun processus 1 avec nano 1 avec python3 1 avec python3 lan\u00e7ant p2.py 1 avec top observer les processus et essayer de les tuer avec la commande kill \u00e0 partir du premier terminal recommencer en relan\u00e7ant les processus et tuer les processus avec le terminal lan\u00e7ant top(puis commande k) Algorithmes d'ordonnancement\u2693\ufe0e \u2693\ufe0e Il existe plusieurs algorithmes d'ordonnancement. En voici quelques exemples : FCFS (First Come First Serve) : Les diff\u00e9rents processus sont stock\u00e9s dans une file. Le premier processus s'ex\u00e9cute jusqu'\u00e0 ce qu'il soit dans l'\u00e9tat bloqu\u00e9. Il est alors mis \u00e0 la fin de la file d'attente. SJF (Shortest Job First) : Le processus avec le temps suppos\u00e9 le plus court est prioritaire. Si on consid\u00e8re un processus p1 de temps d'ex\u00e9cution t1, un processus p2 de temps d'ex\u00e9cution t2, un processus p3 de temps d'ex\u00e9cution t3. Si les processus sont ex\u00e9cut\u00e9s les un apr\u00e8s les autres alors p1 est termin\u00e9 au bout de t1, p2 au bout de t1+t2 et p3 au bout de t1+t2+t3. Le temps cumul\u00e9 pour l'ensemble des processus est alors 3t1+2t2+t3. Pour le minimiser, il faut que : t1<t2<t3. Round Robin (ou Algorithme en tourniquet) : Chaque processus se voit attribuer un m\u00eame temps d'ex\u00e9cution \u00e0 tour de r\u00f4le. Interblocage (deadlock)\u2693\ufe0e \u2693\ufe0e Lorsque tous les processus utilisent des ressources ind\u00e9pendantes, tout se passe pour le mieux. Mais que se passe-t-il, si un processus utilise une ressource d\u00e9pendante de ou requise par un autre processus. On consid\u00e8re les deux programmes suivants : Un programme enregistrer_son qui enregistre via le micro. Ce programme demande l'acc\u00e8s \u00e0 la carte son et enregistre le son sur la sortie standard, puis lib\u00e8re la carte son. Un deuxi\u00e8me programme jouer_son joue le son qui arrive sur son entr\u00e9e standard. Ce programme demande l'acc\u00e8s \u00e0 la carte son, joue ce qui arrive sur son entr\u00e9e standard, puis lib\u00e8re la carte son. Remarque L'entr\u00e9e standard correspond g\u00e9n\u00e9ralement \u00e0 la suite des caract\u00e8res entr\u00e9e au clavier. Elle peut \u00eatre red\u00e9finie. Dans le cadre de la carte son, cela revient \u00e0 envoyer une suite d'octets correspondant au son \u00e0 jouer. La sortie standard est g\u00e9n\u00e9ralement la console. Elle peut, elle aussi, \u00eatre redirig\u00e9e vers une autre destination (fichier, \u00e9cran, entr\u00e9e d'un autre programme...) Imaginons la situation suivante : On dirige la sortie standard du programme enregistrer_son vers un fichier son.mp3. Une fois l'enregistrement termin\u00e9, ce fichier est ensuite envoy\u00e9 sur l'entr\u00e9e de jouer_son. Remarque Sous linux les commandes ressembleraient \u00e0 : Bash $ enregistrer_son > fichier.son $ cat fichier.son > jouer_son rappel : la commande cat permet d'envoyer sur la sortie standard le contenu d'un fichier. Ici tout se passe bien. Il y a d'abord l'enregistrement du son dans un fichier, puis il y lecture du fichier. La carte son est acquise pour utilisation, d'abord par le programme enregistrer_son, puis , une fois que celui-ci l'a lib\u00e9r\u00e9e, par le programme jouer_son. Imaginons maintenant la situation suivante : Maintenant on lance les deux programmes de telle fa\u00e7on que la sortie du premier soit envoy\u00e9e sur l'entr\u00e9e du second. Remarque Sous linux les commandes ressembleraient \u00e0 : \ud83d\udccb Texte $ enregistrer_son > jouer_son Le processus p1 cr\u00e9\u00e9 pour enregistrer_son requiert l'utilisation de la carte son pour acc\u00e9der aux donn\u00e9es lues par le micro. Le processus p2 cr\u00e9\u00e9 pour jouer_son requiert \u00e9galement l'utilisation de la carte son. Mais la carte est monopolis\u00e9e par p1. Le processus p2 est donc bloqu\u00e9 et mis en attente. Le processus p1 continue \u00e0 enregistrer, jusqu'\u00e0 ce que la m\u00e9moire tampon soit pleine. En effet celle-ci n'est pas vid\u00e9e, car le processus p2 ne peut pas y acc\u00e9der. Le processus p1 ne peut alors plus enregistrer. Il est \u00e9galement bloqu\u00e9. Ce ph\u00e9nom\u00e8ne est appel\u00e9 interblocage(ou deadlock). C'est typiquement le probl\u00e8me de 4 voitures \u00e0 un carrefour sans priorit\u00e9 particutli\u00e8re. Devant laisser la priorit\u00e9 \u00e0 droite, aucune voiture ne peut avancer. Cette situation d'interblocage a \u00e9t\u00e9 th\u00e9oris\u00e9e par l'informaticien Edward Coffman (1934-) qui a \u00e9nonc\u00e9 quatre conditions (appel\u00e9es conditions de Coffman ) menant \u00e0 l'interblocage : Exclusion mutuelle : au moins une des ressources du syst\u00e8me doit \u00eatre en acc\u00e8s exclusif. R\u00e9tention des ressources : un processus d\u00e9tient au moins une ressource et requiert une autre ressource d\u00e9tenue par un autre processus Non-pr\u00e9emption : Seul le d\u00e9tenteur d'une ressource peut la lib\u00e9rer. Attente circulaire : Chaque processus attend une ressource d\u00e9tenue par un autre processus. P_1 attend une ressource d\u00e9tenue par P_2 qui \u00e0 son tour attend une ressource d\u00e9tenue par P_3 etc... qui attend une ressource d\u00e9tenue par P_1 ce qui clos la boucle. Exemple Dans l'exemple pr\u00e9c\u00e9dent : Exclusion mutuelle : La carte son est en acc\u00e8s exclusif par le processus p1 R\u00e9tention des ressources : le processus p1 d\u00e9tient l'acc\u00e8s \u00e0 la carte son et veut \u00e9crire sur sa sortie standard qui est satur\u00e9e(elle n'est donc plus accessible). Non-pr\u00e9emption : Seul p1 peut lib\u00e9rer la carte son, p2 ne peut pas la prend l'acc\u00e8s de force. Attente circulaire : p1 attend que sa sortie soit accessible (c'est \u00e0 dire que le tampon m\u00e9moire soit lue), alors qu'elle est bloqu\u00e9e par p2 qui attend d'avoir l'acc\u00e8s \u00e0 la carte son elle-m\u00eame d\u00e9tenue par p1. D'o\u00f9 la boucle d'attente. Simulation d'interblocage\u2693\ufe0e \u2693\ufe0e Robosomes cr\u00e9\u00e9 par Alain BUSSER , S\u00e9bastien HOARAU (Voir ici : Robosomes - IREM de la r\u00e9union Le jeu robosomes se joue \u00e0 un seul joueur sur une grille rectangulaire. Chaque case peut \u00eatre soit vide soit couverte par un obstacle fixe (en noir comme aux mots crois\u00e9s) soit couverte d\u2019un pion pouvant bouger, appel\u00e9 robot Chaque robot peut \u00eatre tourn\u00e9 dans l\u2019une des quatre directions cardinales \u25c0\u25b2\u25b6\u25bc. Les robots peuvent bouger tous en m\u00eame temps de l\u2019une des fa\u00e7ons suivantes : G : tous les robots tournent vers leur gauche (de 90\u00b0) en m\u00eame temps D : tous les robots tournent vers leur droite (de 90\u00b0) en m\u00eame temps A : les robots qui peuvent avancer d\u2019une case, le font. Un robot peut avancer d\u2019une case s\u2019il n\u2019y a pas d\u2019obstacle sur cette case et si aucun robot ne s\u2019appr\u00eate \u00e0 aller sur cette case. Les cases du bord de la grille sont toutes couvertes d\u2019obstacles fixes, \u00e0 l\u2019exception de l\u2019une d\u2019entre elles appel\u00e9e \u00ab sortie \u00bb. Lorsqu\u2019un robot est sur la case de sortie, tourn\u00e9 vers l\u2019ext\u00e9rieur de la grille, il quitte le jeu et n\u2019est plus soumis aux ordres donn\u00e9s. Le but du jeu est de faire sortir tous les robots de la grille, en \u00e9crivant un mot dans l\u2019alphabet A,G,D, appel\u00e9 programme et que les robots interpr\u00e9teront comme d\u00e9crit ci-dessus. Voici quelques exemples : Un premier exemple pour se mettre en route. Interblocage Interblocage 1 Interblocage 2 Interblocage 3 Interblocage 4 Interblocage perp\u00e9tuel ou pas Interblocage 8","title":"TD n\u00b023 - gestion des processus"},{"location":"Processus/Gestion_Processus_Cours/","text":"Introduction \u2693\ufe0e Dans les ann\u00e9es 1970 les ordinateurs personnels \u00e9taient incapables d'ex\u00e9cuter plusieurs t\u00e2ches \u00e0 la fois : il fallait attendre qu'un programme lanc\u00e9 se termine pour en ex\u00e9cuter un autre. Les syst\u00e8mes d'exploitations r\u00e9cents (GNU/Linux, macOS, iOS, Android, Windows...) permettent d'ex\u00e9cuter des t\u00e2ches \"simultan\u00e9ment\". En effet, la plupart du temps, lorsque l'on utilise un ordinateur, plusieurs programmes sont ex\u00e9cut\u00e9s \"en m\u00eame temps\" : par exemple, on peut tr\u00e8s bien ouvrir simultan\u00e9ment un navigateur Web, un traitement de texte, un IDE Python, un logiciel de musique (sans parler de tous les programmes ex\u00e9cut\u00e9s en arri\u00e8re-plan) ... Ces programmes en cours d'ex\u00e9cution s'appellent des processus . Une des t\u00e2ches du syst\u00e8me d'exploitation est d'allouer \u00e0 chacun des processus les ressources dont il a besoin en termes de m\u00e9moire, entr\u00e9es-sorties ou temps d'acc\u00e8s au processeur, et de s'assurer que les processus ne se g\u00eanent pas les uns les autres. Pourtant, on rappelle qu'un programme n'est qu'une suite d'instructions machine ex\u00e9cut\u00e9es l'une apr\u00e8s l'autre par le processeur (cf. cours de Premi\u00e8re sur le Mod\u00e8le d'architecture d'un ordinateur ) et qu'un processeur n'est capable d'ex\u00e9cuter qu'une seule instruction \u00e0 la fois. Comment est-il alors possible que plusieurs programmes soient ex\u00e9cut\u00e9s en m\u00eame temps ? Processus \u2693\ufe0e Qu'est-ce qu'un processus ? \u2693\ufe0e Il ne faut pas confondre programme et processus : Un programme est un fichier binaire (on dit aussi un ex\u00e9cutable ) contenant des instructions machines que seul le processeur peut comprendre. Un processus est un programme en cours d'ex\u00e9cution , autrement dit le ph\u00e9nom\u00e8ne dynamique li\u00e9 \u00e0 l'ex\u00e9cution d'un programme par l'ordinateur. Ainsi, lorsque nous cliquons sur l'ic\u00f4ne d'un programme (ou lorsque nous ex\u00e9cutons une instruction dans la console pour lancer un programme), nous provoquons la naissance d'un ou plusieurs processus li\u00e9s au programme que nous lan\u00e7ons. Un processus est donc une instance d'un programme auquel est associ\u00e9 : du code des donn\u00e9es/variables manipul\u00e9es des ressources : processeur, m\u00e9moire, p\u00e9riph\u00e9riques d'entr\u00e9e/sortie (voir paragraphe suivant) Il n'est d'ailleurs pas rare qu'un m\u00eame programme soit ex\u00e9cut\u00e9 plusieurs fois sur une machine au m\u00eame moment en occupant des espaces m\u00e9moires diff\u00e9rents : par exemple deux documents ouverts avec un traitement de texte, ou trois consoles distinctes... qui correspondent \u00e0 autant d'instances du m\u00eame programme et donc \u00e0 des processus diff\u00e9rents. Observer les processus \u2693\ufe0e Il est tr\u00e8s facile de voir les diff\u00e9rents processus s'ex\u00e9cutant sur une machine. Sous GNU/Linux, on peut utiliser la commande ps (comme p roces s , la traduction anglaise de processus ) pour afficher les informations sur les processus. En passant des options \u00e0 cette commande on peut obtenir des choses int\u00e9ressantes. Par exemple, en ex\u00e9cutant dans un terminal la commande ps -aef , on peut visualiser tous les processus en cours sur notre ordinateur : Cr\u00e9ation d'un processus \u2693\ufe0e Un processus peut \u00eatre cr\u00e9\u00e9 : au d\u00e9marrage du syst\u00e8me par un autre processus par une action d'un utilisateur (lancement d'un programme) Sous GNU/Linux, un tout premier processus est cr\u00e9\u00e9 au d\u00e9marrage (c'est le processus 0 ou encore Swapper ). Ce processus cr\u00e9e un processus souvent appel\u00e9 init qui est le fils du processus 0. Ensuite, \u00e0 partir de init , les autres processus n\u00e9cessaires au fonctionnement du syst\u00e8me sont cr\u00e9\u00e9s. Ces processus cr\u00e9ent ensuite eux-m\u00eames d'autres processus, etc. Un processus peut cr\u00e9er un ou plusieurs processus, ce qui aboutit \u00e0 une structure arborescente comme nous allons le voir maintenant. PID et PPID \u2693\ufe0e La commande pr\u00e9c\u00e9dente permet de voir que chaque processus est identifi\u00e9 par un num\u00e9ro : son PID (pour Process Identifier ). Ce num\u00e9ro est donn\u00e9 \u00e0 chaque processus par le syst\u00e8me d'exploitation. On constate \u00e9galement que chaque processus poss\u00e8de un PPID (pour Parent Process Identifier ), il s'agit du PID du processus parent, c'est-\u00e0-dire celui qui a d\u00e9clench\u00e9 la cr\u00e9ation du processus. En effet, un processus peut cr\u00e9er lui m\u00eame un ou plusieurs autres processus, appel\u00e9s processus fils . \u00c0 vous de jouer ! Si ce n'est pas d\u00e9j\u00e0 fait, lancez un terminal et ex\u00e9cutez la commande ps -aef (\u00e9largissez la fen\u00eatre du terminal au maximum pour bien voir toutes les colonnes). \u00c0 quoi correspond le dernier processus lanc\u00e9 ? Quel est son processus parent et pourquoi ? Ouvrez Writer de LibreOffice puis ex\u00e9cutez \u00e0 nouveau la commande. Cherchez dans la liste des processus celui ou ceux correspondant \u00e0 l'ex\u00e9cution du programme Writer ? Cherchez le processus parent du processus correspondant \u00e0 l'ex\u00e9cution du programme Writer ? Fermez LibreOffice puis ex\u00e9cutez \u00e0 nouveau la commande et v\u00e9rifiez qu'il n'y a plus de processus correspond \u00e0 l'ex\u00e9cution de Writer. Vous devriez avoir le navigateur ouvert pour visualiser ce cours (lancez-le si ce n'est pas le cas). Ex\u00e9cutez \u00e0 nouveau la commande puis : Cherchez dans la liste des processus le premier correspondant \u00e0 l'ex\u00e9cution du navigateur Cherchez ensuite les processus fils de ce processus. Ouvrez un nouvel onglet et rendez-vous sur une page Web de votre choix. Ex\u00e9cutez \u00e0 nouveau la commande, vous devriez constater qu'au moins un nouveau processus li\u00e9 \u00e0 l'ex\u00e9cution du navigateur a \u00e9t\u00e9 cr\u00e9\u00e9. Sous GNU/Linux il est possible de voir l'arborescence des processus avec la commande pstree . \u00c0 vous de jouer ! Testez la commande et cherchez dans l'arborescence les processus correspond \u00e0 l'ex\u00e9cution du navigateur (qui doit \u00eatre lanc\u00e9, cela va de soi) Gestion des processus et des ressources \u2693\ufe0e Ex\u00e9cution concurrente \u2693\ufe0e Les syst\u00e8mes d'exploitation modernes sont capable d'ex\u00e9cuter plusieurs processus \"en m\u00eame temps\". En r\u00e9alit\u00e9 ces processus ne sont pas toujours ex\u00e9cut\u00e9s \"en m\u00eame temps\" mais plut\u00f4t \"\u00e0 tour de r\u00f4le\". On parle d'ex\u00e9cution concurrente car les processus sont en concurrence pour obtenir l'acc\u00e8s au processeur charg\u00e9 de les ex\u00e9cuter. Remarque : Sur un syst\u00e8me multiprocesseur, il est possible d'ex\u00e9cuter de mani\u00e8re parall\u00e8le plusieurs processus, autant qu'il y a de processeurs. Mais sur un m\u00eame processeur, un seul processus ne peut \u00eatre ex\u00e9cut\u00e9 \u00e0 la fois. On peut voir assez facilement cette ex\u00e9cution concurrente. Consid\u00e9rons les deux programmes Python suivants : progA.py \ud83d\udc0d Script Python import time for i in range ( 100 ): print ( \"programme A en cours, it\u00e9ration\" , i ) time . sleep ( 0.01 ) # pour simuler un traitement avec des calculs progB.py \ud83d\udc0d Script Python import time for i in range ( 100 ): print ( \"programme B en cours, it\u00e9ration\" , i ) time . sleep ( 0.01 ) # pour simuler un traitement avec des calculs En ouvrant un Terminal, on peut lancer simultan\u00e9ment ces deux programmes avec la commande Bash $ python progA.py & python progB.py & Le caract\u00e8re & qui suit une commande permet de lancer l'ex\u00e9cution en arri\u00e8re plan et de rendre la main au terminal. Le shell indique alors dans la console les PID des processus correspondant \u00e0 l'ex\u00e9cution de ces deux programmes (ici 9154 et 9155) puis on constate gr\u00e2ce aux affichages que le syst\u00e8me d'exploitation alloue le processeur aux deux programmes \u00e0 tour de r\u00f4le : Acc\u00e8s concurrents aux ressources \u2693\ufe0e Une ressource est une entit\u00e9 dont a besoin un processus pour s'ex\u00e9cuter. Les ressources peuvent \u00eatre mat\u00e9rielles (processeur, m\u00e9moire, p\u00e9riph\u00e9riques d'entr\u00e9e/sortie, ...) mais aussi logicielles (variables). Les diff\u00e9rents processus se partagent les ressources, on parle alors d' acc\u00e8s concurrents aux ressources . Par exemple, les processus se partagent tous l'acc\u00e8s \u00e0 la ressource \"processeur\" un traitement de texte et un IDE Python se partagent la ressource \"clavier\" ou encore la ressource \"disque dur\" (si on enregistre les fichiers), ... un navigateur et un logiciel de musique se partagent la ressource \"carte son\", ... C'est le syst\u00e8me d'exploitation qui est charg\u00e9 de g\u00e9rer les processus et les ressources qui leur sont n\u00e9cessaires, en partageant leur acc\u00e8s au processeur. Nous allons voir comment tout de suite ! \u00c9tats d'un processus \u2693\ufe0e Au cours de son existence, un processus peut se retrouver dans trois \u00e9tats : \u00e9tat \u00e9lu : lorsqu'il est en cours d'ex\u00e9cution, c'est-\u00e0-dire qu'il obtient l'acc\u00e8s au processeur \u00e9tat pr\u00eat : lorsqu'il attend de pouvoir acc\u00e9der au processeur \u00e9tat en bloqu\u00e9 : lorsque le processus est interrompu car il a besoin d'attendre une ressource quelconque (entr\u00e9e/sortie, allocation m\u00e9moire, etc.) Il est important de comprendre que le processeur ne peut g\u00e9rer qu'un seul processus \u00e0 la fois : le processus \u00e9lu . En pratique, lorsqu'un processus est cr\u00e9\u00e9 il est dans l'\u00e9tat pr\u00eat et attend de pouvoir acc\u00e9der au processeur (d'\u00eatre \u00e9lu ). Lorsqu'il est \u00e9lu, le processus est ex\u00e9cut\u00e9 par le processeur mais cette ex\u00e9cution peut \u00eatre interrompue : soit pour laisser la main \u00e0 un autre processus (qui a \u00e9t\u00e9 \u00e9lu) : dans ce cas, le processus de d\u00e9part repasse dans l'\u00e9tat pr\u00eat et doit attendre d'\u00eatre \u00e9lu pour reprendre son ex\u00e9cution soit parce que le processus en cours a besoin d'attendre une ressource : dans ce cas, le processus passe dans l'\u00e9tat bloqu\u00e9 . Lorsque le processus bloqu\u00e9 finit par obtenir la ressource attendue, il peut th\u00e9oriquement reprendre son ex\u00e9cution mais probablement qu'un autre processus a pris sa place et est pass\u00e9 dans l'\u00e9tat \u00e9lu. Auquel cas, le processus qui vient d'\u00eatre \"d\u00e9bloqu\u00e9\" repasse dans l'\u00e9tat pr\u00eat en attendant d'\u00eatre \u00e0 nouveau \u00e9lu. Ainsi, l'\u00e9tat d'un processus au cours de sa vie varie entre les \u00e9tats pr\u00eat , \u00e9lu et bloqu\u00e9 comme le r\u00e9sume le sch\u00e9ma suivant : Lorsqu'un processus est interrompu, il doit pouvoir reprendre \u00e0 l'endroit m\u00eame o\u00f9 il a \u00e9t\u00e9 interrompu. Pour cela, le syst\u00e8me d'exploitation conserve pour chaque processus cr\u00e9\u00e9 une zone m\u00e9moire (appel\u00e9e PCB, pour Process Control Bloc , ou bloc de contr\u00f4le du processus) dans laquelle sont stock\u00e9es les informations sur le processus : son PIB, son \u00e9tat, la valeur des registres lors de sa derni\u00e8re interruption, la zone m\u00e9moire allou\u00e9e par le processus lors de son ex\u00e9cution, les ressources utilis\u00e9es par le processus (fichiers ouverts, connexions r\u00e9seaux en cours d'utilisation, etc.). \u270d\ufe0f Faites les exercices 1 et 2. Ordonnancement \u2693\ufe0e C'est le syst\u00e8me d'exploitation qui attribue aux processus leurs \u00e9tats \u00e9lu , pr\u00eat et bloqu\u00e9 . Plus pr\u00e9cis\u00e9ment, c'est l' ordonnanceur (un des composants du syst\u00e8me d'exploitation) qui r\u00e9alise cette t\u00e2che appel\u00e9e ordonnancement des processus . L'objectif de l'ordonnanceur est de choisir le processus \u00e0 ex\u00e9cuter \u00e0 l'instant \\(t\\) (le processus \u00e9lu ) et d\u00e9terminer le temps durant lequel le processeur lui sera allou\u00e9. Ce choix est \u00e0 faire parmi tous les processus qui sont dans l'\u00e9tat pr\u00eat , mais lequel sera \u00e9lu ? et pour combien de temps ? Des algorithmes d'ordonnancement sont utilis\u00e9s et il en existe plusieurs selon la strat\u00e9gie utilis\u00e9e. On en pr\u00e9sente quelques-uns ci-dessous. Ordonnancement First Come First Served (FCFS) \u2693\ufe0e Principe : Les processus sont ordonnanc\u00e9s selon leur ordre d'arriv\u00e9e (\"premier arriv\u00e9, premier servi\" en fran\u00e7ais) Exemple : Les processus \\(P_1(53)\\) , \\(P_2(17)\\) , \\(P_3(68)\\) et \\(P_4(24)\\) arrivent dans cet ordre \u00e0 \\(t=0\\) : Cela signifie que \\(P_1\\) , \\(P_2\\) , \\(P_3\\) et \\(P_4\\) ont besoin de respectivement 53, 17, 68 et 24 unit\u00e9s de temps pour s'ex\u00e9cuter. Ordonnancement Shortest Job First (SJF) \u2693\ufe0e Principe : Le processus dont le temps d'ex\u00e9cution est le plus court est ordonnanc\u00e9 en premier. Exemple : \\(P_1\\) , \\(P_2\\) , \\(P_3\\) et \\(P_4\\) arrivent \u00e0 \\(t=0\\) : Ordonnancement Shortest Remaining Time (SRT) \u2693\ufe0e Principe : Le processus dont le temps d'ex\u00e9cution restant est le plus court parmi ceux qui restent \u00e0 ex\u00e9cuter est ordonnanc\u00e9 en premier. Exemple : \\(P_3\\) et \\(P_4\\) arrivent \u00e0 \\(t=0\\) ; \\(P_2\\) \u00e0 \\(t=20\\) ; \\(P_1\\) \u00e0 \\(t=50\\) : Ordonnancement temps-partag\u00e9 (Round-Robin) \u2693\ufe0e Principe : C'est la politique du tourniquet : allocation du processeur par tranche (= quantum \\(q\\) ) de temps. Exemple : quantum \\(q = 20\\) et \\(n = 4\\) processus Dans ce cas, s'il y a \\(n\\) processus, chacun d'eux obtient le processeur au bout de \\((n-1)\\times q\\) unit\u00e9s de temps au plus Ordonnancement \u00e0 priorit\u00e9s statiques \u2693\ufe0e Principe : Allocation du processeur selon des priorit\u00e9s statiques (= num\u00e9ros affect\u00e9s aux processus pour toute la vie de l'application) Exemple : priorit\u00e9s \\((P_1, P_2, P_3, P_4) = (3, 2, 0, 1)\\) o\u00f9 la priorit\u00e9 la plus forte est 0 (attention, dans certains syst\u00e8mes c'est l'inverse : 0 est alors la priorit\u00e9 la plus faible) \u270d\ufe0f Faites l'exercice 3. Probl\u00e8mes li\u00e9s \u00e0 l'acc\u00e8s concurrent aux ressources \u2693\ufe0e Les processus se partagent souvent une ou plusieurs ressources, et cela peut poser des probl\u00e8mes. Probl\u00e8mes de synchronisation : illustration avec Python \u2693\ufe0e Exemple d'une variable partag\u00e9e \u2693\ufe0e Prenons l'exemple d'une variable (= ressource logicielle) partag\u00e9e entre plusieurs processus. Plus pr\u00e9cis\u00e9ment, consid\u00e9rons un programme de jeu multi-joueur dans lequel une variable nb_pions repr\u00e9sente le nombre de pions disponibles pour tous les joueurs. Une fonction prendre_un_pion() permet de prendre un pion dans le tas commun de pions disponibles, s'il reste au moins un pion \u00e9videmment. On va se mettre dans la situation o\u00f9 il ne reste plus qu'un pion dans le tas commun et on suppose que deux joueurs utilisent la fonction prendre_un_pion() , ce qui conduit \u00e0 la cr\u00e9ation de deux processus p1 et p2 , chacun correspondant \u00e0 un joueur. Avec Python, on peut utiliser le module multiprocessing pour cr\u00e9er des processus. Le programme Python pions.py suivant permet de r\u00e9aliser la situation de jeu d\u00e9crite : \ud83d\udc0d Script Python from multiprocessing import Process , Value import time def prendre_un_pion ( nombre ): if nombre . value >= 1 : time . sleep ( 0.001 ) # pour simuler un traitement avec des calculs temp = nombre . value nombre . value = temp - 1 # on d\u00e9cr\u00e9mente le nombre de pions if __name__ == '__main__' : # cr\u00e9ation de la variable partag\u00e9e initialis\u00e9e \u00e0 1 nb_pions = Value ( 'i' , 1 ) # on cr\u00e9e deux processus p1 = Process ( target = prendre_un_pion , args = [ nb_pions ]) p2 = Process ( target = prendre_un_pion , args = [ nb_pions ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () print ( \"nombre final de pions :\" , nb_pions . value ) Explications : Le if __name__ = '__main'__: permet de ne cr\u00e9er qu'une seule fois les processus p1 et p2 qui suivent (c'est n\u00e9cessaire sous Windows, pas sous GNU/Linux car la cr\u00e9ation des processus ne se fait pas de la m\u00eame mani\u00e8re, mais cela reste conseill\u00e9 ne serait-ce que pour des raisons de compatibilit\u00e9), on n'en dira pas davantage ici car cela d\u00e9passe le niveau de ce cours. On a utilis\u00e9 la classe Process du module multiprocessing pour instancier deux processus p1 et p2 . L'argument target est le nom de la fonction qui sera ex\u00e9cut\u00e9e par le processus : ici les deux processus doivent ex\u00e9cuter la m\u00eame fonction prendre_un_pion() L'argument args est une liste des arguments pass\u00e9s \u00e0 la fonction cible : ici il s'agit de la variable nb_pions qui est partag\u00e9e par les deux processus. Par d\u00e9faut, deux processus ne partagent pas de donn\u00e9es en m\u00e9moire : on ne peut pas donc pas utiliser nb_pions comme une variable globale. Il faut utiliser la classe Value du module multiprocessing pour cr\u00e9er nb_pions dans une m\u00e9moire partag\u00e9e entre les processus. L'argument 'i' indique que nb_pions est un entier (sign\u00e9) et le deuxi\u00e8me argument est la valeur initiale de la variable, ici 1. La fonction prendre_un_pion() prend un nombre en param\u00e8tre et d\u00e9cr\u00e9mente sa valeur d'une unit\u00e9 si le nombre est au moins \u00e9gal \u00e0 1. Lors de l'ex\u00e9cution de la fonction par les deux processus, l'argument en question sera l'objet nb_pions de la classe Value et on acc\u00e8de \u00e0 sa valeur avec l'attribut value . On a ajout\u00e9 une temporisation permettant de simuler d'autres calculs qui pourraient avoir lieu (par exemple, des instructions de mise \u00e0 jour du nombre de pions des joueurs) Les derni\u00e8res lignes permettent de d\u00e9marrer les deux processus et attendre qu'ils soient termin\u00e9s pour afficher la valeur finale de nb_pions . Si on ex\u00e9cute ce programme, les deux processus p1 et p2 sont ex\u00e9cut\u00e9s et on s'attend au comportement suivant (en supposant qu'il ne reste qu'un seule pion dans le tas commun) : l'un des deux est \u00e9lu en premier, par exemple p1 , et ex\u00e9cute la fonction prendre_un_pion() , le nombre de pions est \u00e9gal \u00e0 1 donc nb_pions est d\u00e9cr\u00e9ment\u00e9 d'une unit\u00e9 et prend donc la valeur 0, le processus p1 est termin\u00e9 ; le processus p2 , qui \u00e9tait en attente, est ensuite \u00e9lu, et comme le nombre de pions est d\u00e9sormais \u00e9gal \u00e0 0 rien ne se passe et p2 termine. Ainsi, le premier joueur a pu prendre le pion restant et le second s'est retrouv\u00e9 coinc\u00e9, et la valeur finale de nb_pions vaut 0. Et pourtant, il est tout \u00e0 fait possible que les choses ne se passent pas ainsi ! En effet, en ex\u00e9cutant plusieurs fois le programme pions.py dans un terminal, on obtient parfois une valeur finale \u00e9gale \u00e0 0 et parfois \u00e9gale \u00e0 -1 : C'est un r\u00e9sultat tr\u00e8s perturbant non ? Expliquons pourquoi ! Pour cela, on peut ajouter quelques instructions d'affichage pour suivre ce qu'il se passe. On obtient le script pions_v2.py suivant : \ud83d\udc0d Script Python from multiprocessing import Process , Value import time def prendre_un_pion ( nombre , numero_processus ): print ( f \"d\u00e9but du processus { numero_processus } \" ) if nombre . value >= 1 : print ( f \"processus { numero_processus } : \u00e9tape A\" ) time . sleep ( 0.001 ) # pour simuler un traitement avec des calculs print ( f \"processus { numero_processus } : \u00e9tape B\" ) temp = nombre . value nombre . value = temp - 1 # on d\u00e9cr\u00e9mente le nombre de pions print ( f \"nombre de pions restants \u00e0 la fin du processus { numero_processus } : { nombre . value } \" ) if __name__ == '__main__' : # cr\u00e9ation de la variable partag\u00e9e initialis\u00e9e \u00e0 1 nb_pions = Value ( 'i' , 1 ) # on cr\u00e9e deux processus p1 = Process ( target = prendre_un_pion , args = [ nb_pions , 1 ]) p2 = Process ( target = prendre_un_pion , args = [ nb_pions , 2 ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () print ( \"nombre final de pions :\" , nb_pions . value ) Explications : Lors de la cr\u00e9ation des processus, on passe un deuxi\u00e8me argument \u00e0 la fonction prendre_un_pion() , le num\u00e9ro du processus : 1 pour p1 et 2 pour p2 . Cela permet d'afficher dans cette fonction le num\u00e9ro du processus \u00e0 des endroits strat\u00e9giques : au d\u00e9but, \u00e0 l'entr\u00e9e dans le if , juste avant de d\u00e9cr\u00e9menter le nombre de pions et \u00e0 la fin du processus. En ex\u00e9cutant pions_v2.py dans un terminal, on obtient ce genre de choses : Analysons la premi\u00e8re ex\u00e9cution du programme. le processus p1 est \u00e9lu en premier (affichage de \"d\u00e9but du processus 1\") mais est de suite interrompu par l'ordonnanceur qui \u00e9lit p2 (affichage de \"d\u00e9but du processus 2\") puis c'est de nouveau le processus p1 qui a la main et il rentre dans le if (affichage de \"processus 1 : \u00e9tape A\") mais est interrompu \u00e0 nouveau et l'ordonnanceur donne la main \u00e0 p2 qui rentre aussi dans le if (affichage de \"processus 2 : \u00e9tape A\") : en effet, \u00e0 ce stade le nombre de pions n'a pas encore \u00e9t\u00e9 d\u00e9cr\u00e9ment\u00e9 par p1 car il a \u00e9t\u00e9 interrompu avant l'\u00e9tape B, et donc p2 a pu entrer dans le if puisque la condition nombre.value >= 1 est toujours vraie \u00e0 ce moment l\u00e0 !! ensuite le processeur est allou\u00e9 alternativement \u00e0 p1 et p2 (voir les affichages restants) mais le mal est fait puisque les deux processus sont d\u00e9sormais chacun entr\u00e9s dans le if , ils vont chacun d\u00e9cr\u00e9menter le nombre de pions d'une unit\u00e9 et chacun des deux joueurs aura pioch\u00e9 un pion alors qu'il n'y en avait qu'un seul au d\u00e9part ! Vous remarquerez que la troisi\u00e8me ex\u00e9cution du programme met en \u00e9vidence le m\u00eame probl\u00e8me car les deux processus ont chacun pu entrer dans le if , m\u00eame si l'ordre des instructions ex\u00e9cut\u00e9es apr\u00e8s n'est pas tout \u00e0 fait le m\u00eame. Si on analyse la seconde ex\u00e9cution du programme qui donne le comportement souhait\u00e9, on constate que p1 a eu suffisamment de temps pour d\u00e9cr\u00e9menter le nombre de pions (qui vaut d\u00e9sormais 0) avant que p2 ne fasse le test nombre.value >= 1 et se rende compte que cette condition est fausse. Dans ce cas, seul le premier joueur a pas pu piocher un pion. Heureusement, on peut \u00e9viter le probl\u00e8me mis en \u00e9vidence dans l'exemple pr\u00e9c\u00e9dent. Comment \u00e9viter les probl\u00e8mes de synchronisation ? \u2693\ufe0e On va utiliser ce qu'on appelle un verrou : un verrou est objet partag\u00e9 entre plusieurs processus mais qui garantit qu'un seul processus acc\u00e8de \u00e0 une ressource \u00e0 un instant donn\u00e9. Concr\u00e8tement, un verrou peut \u00eatre acquis par les diff\u00e9rents processus, et le premier \u00e0 faire la demande acquiert le verrou. Si le verrou est d\u00e9tenu par un autre processus, alors tout autre processus souhaitant l'obtenir est bloqu\u00e9 jusqu'\u00e0 ce qu'il soit lib\u00e9r\u00e9. Le module multiprocessing de Python propose un objet Lock() correpondant \u00e0 un verrou. Deux m\u00e9thodes sont utilis\u00e9es : la m\u00e9thode .acquire() permet de demander le verrou (le processus faisant la demande est bloqu\u00e9 tant qu'il ne l'a pas obtenu) la m\u00e9thode .release() permet de lib\u00e9rer le verrou (il pourra alors \u00eatre obtenu par un autre processus qui en fait la demande) On peut alors r\u00e9gler le probl\u00e8me de l'exemple pr\u00e9c\u00e9dent avec le script pions_v3.py suivant dans lequel on a laiss\u00e9 les affichages pour bien suivre : \ud83d\udc0d Script Python from multiprocessing import Process , Value , Lock import time def prendre_un_pion ( v , nombre , numero_processus ): print ( f \"d\u00e9but du processus { numero_processus } \" ) v . acquire () # acquisition du verrou if nombre . value >= 1 : print ( f \"processus { numero_processus } : \u00e9tape A\" ) time . sleep ( 0.001 ) print ( f \"processus { numero_processus } : \u00e9tape B\" ) temp = nombre . value nombre . value = temp - 1 v . release () # verrou lib\u00e9r\u00e9 print ( f \"nombre de pions restants \u00e0 la fin du processus { numero_processus } : { nombre . value } \" ) if __name__ == '__main__' : # cr\u00e9ation de la variable partag\u00e9e initialis\u00e9e \u00e0 1 nb_pions = Value ( 'i' , 1 ) # verrou partag\u00e9 par les deux processus verrou = Lock () # on cr\u00e9e deux processus p1 = Process ( target = prendre_un_pion , args = [ verrou , nb_pions , 1 ]) p2 = Process ( target = prendre_un_pion , args = [ verrou , nb_pions , 2 ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () print ( \"nombre final de pions :\" , nb_pions . value ) En ex\u00e9cutant (plusieurs fois) ce script dans un terminal on constate que le nombre final de pions est toujours \u00e9gal \u00e0 0. Avant de faire le test du if , le processus essaye d'acqu\u00e9rir le verrou avec v.acquire() . D\u00e8s qu'il est acquis, le processus a la garantie qu'il est le seul \u00e0 pouvoir ex\u00e9cuter le code jusqu'\u00e0 l'instruction v.release() . Cette portion de code prot\u00e9g\u00e9e s'appelle une section critique . Cela ne veut pas dire que le processus d\u00e9tenant le verrou ne peut pas \u00eatre interrompu, mais il ne le sera pas par un processus qui est essaie d'acqu\u00e9rir le m\u00eame verrou. \ud83d\udc0d Script Python def prendre_un_pion ( v , nombre , numero_processus ): v . acquire () # d\u00e9but section critique if nombre . value >= 1 : time . sleep ( 0.001 ) temp = nombre . value nombre . value = temp - 1 # fin de la section critique v . release () Si vous analysez l'affichage pr\u00e9c\u00e9dent dans le terminal, on voit d'ailleurs que p1 est entr\u00e9 en section critique (affichage \"processus 1 : \u00e9tape A\") mais est interrompu, puis c'est p2 qui a la main (affichage \"d\u00e9but processus 2\") mais il va se retrouver bloquer \u00e0 l'instruction v.acquire() puisque c'est p1 qui d\u00e9tient le verrou. Lorsque p1 reprendra la main, il pourra ex\u00e9cuter ses instructions jusqu'\u00e0 v.release() sans \u00eatre interrompu par p2 (alors nb_pions sera d\u00e9cr\u00e9ment\u00e9 d'une unit\u00e9). Lorsque p1 lib\u00e8re le verrou, p2 pourra alors l'obtenir, ex\u00e9cuter sa section critique et constater que la condition nombre.value >= 1 est fausse : le deuxi\u00e8me joueur ne pourra alors pas prendre de pion. \u270d\ufe0f Faites l'exercice 4. Nous terminons en voyant que l'utilisation de verrous n'est pas sans risque car elle peut engendrer des probl\u00e8mes d'interblocage. Risque d'interblocage \u2693\ufe0e Les interblocages ( deadlock en anglais) sont des situations de la vie quotidienne. L'exemple classique est celui du carrefour avec priorit\u00e9 \u00e0 droite o\u00f9 chaque v\u00e9hicule est bloqu\u00e9 car il doit laisser le passage au v\u00e9hicule \u00e0 sa droite. En informatique l' interblocage peut \u00e9galement se produire lorsque plusieurs processus concurrents s'attendent mutuellement. Ce sc\u00e9nario peut se produire lorsque plusieurs ressources sont partag\u00e9es par plusieurs processus et l'un d'entre eux poss\u00e8de ind\u00e9finiment une ressource n\u00e9cessaire pour un autre. Ce ph\u00e9nom\u00e8ne d' attente circulaire , o\u00f9 chaque processus attend une ressource d\u00e9tenue par un autre processus, peut \u00eatre provoqu\u00e9e par l'utilisation de plusieurs verrous. Consid\u00e9rons le script interblocage.py suivant dans lequel on a cr\u00e9\u00e9 deux verrous v1 et v2 utilis\u00e9s par deux fonctions f1 et f2 ex\u00e9cut\u00e9es respectivement par deux processus p1 et p2 . Le processus p1 essaie d'acqu\u00e9rir d'abord v1 puis v2 tandis que le processus p2 essaie de les acqu\u00e9rir dans l'ordre inverse. \ud83d\udc0d Script Python from multiprocessing import Process , Lock import time import os def f1 ( v1 , v2 ): print ( \"PID du processus 1:\" , os . getpid ()) for i in range ( 100 ): time . sleep ( 0.001 ) v1 . acquire () v2 . acquire () print ( \"processus 1 en cours, it\u00e9ration \" , i ) v2 . release () v1 . release () def f2 ( v1 , v2 ): print ( \"PID du processus 2:\" , os . getpid ()) for i in range ( 100 ): time . sleep ( 0.001 ) v2 . acquire () v1 . acquire () print ( \"processus 2 en cours, it\u00e9ration \" , i ) v1 . release () v2 . release () if __name__ == '__main__' : # cr\u00e9ation de deux verrous v1 = Lock () v2 = Lock () # cr\u00e9ation de deux processus p1 = Process ( target = f1 , args = [ v1 , v2 ]) p2 = Process ( target = f2 , args = [ v1 , v2 ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () Si on ex\u00e9cute ce programme, il y a de grandes chances de se retrouver bloqu\u00e9. Par exemple, dans le cas de l'ex\u00e9cution suivante : le processus p1 est \u00e9lu : il s'ex\u00e9cute jusqu'\u00e0 l'acquisition de v1 mais avant la tentative d'acquisition de v2 , puis est interrompu le processus p2 est \u00e0 son tour \u00e9lu : il s'ex\u00e9cute et acquiert v2 qui est toujours libre, puis bloque sur l'acquisition de v1 (qui est d\u00e9tenu par p1 ). le processus p1 reprend la main et bloque sur l'acquisition de v2 (d\u00e9tenu par p2 ). Chaque processus d\u00e9tient un verrou et attend l'autre : ils sont en interblocage et l'attente est infinie. On peut lancer (plusieurs fois si n\u00e9cessaire) le script \u00e0 partir du terminal et constater que l'interblocage a lieu tr\u00e8s souvent. Il n'y a alors pas d'autres choix que d'interrompre les processus en interblocage, par exemple avec la commande kill . Cependant, ce probl\u00e8me a lieu ici car les deux processus essaie d'acqu\u00e9rir les verrous dans l'ordre contraire. Si l'ordre d'acquisition est le m\u00eame pour les processus, le probl\u00e8me n'a plus lieu (n'h\u00e9sitez pas \u00e0 tester !). De mani\u00e8re g\u00e9n\u00e9rale, dans des probl\u00e8mes complexes les situations d'interblocage sont difficiles \u00e0 d\u00e9tecter et il se peut tr\u00e8s bien que le programme se comporte bien pendant toute une phase de tests mais bloque lors d'une ex\u00e9cution ult\u00e9rieure puisque l'on ne peut pas pr\u00e9voir l'ordonnancement des processus. \u270d\ufe0f Faites les exercices 5 et 6. Et pour les syst\u00e8mes multiprocesseurs ? \u2693\ufe0e Les ordinateurs actuels poss\u00e8dent g\u00e9n\u00e9ralement plusieurs processeurs, ce qui permet \u00e0 plusieurs processus d'\u00eatre ex\u00e9cut\u00e9s parall\u00e8lement : un par processeur. Ce parall\u00e9lisme permet bien \u00e9videmment une plus grande puissance de calcul. Pour r\u00e9partir les diff\u00e9rents processus entre les diff\u00e9rents processeurs, on distingue deux approches : l'approche partitionn\u00e9e : chaque processeur poss\u00e8de un ordonnanceur particulier et les processus sont r\u00e9partis entre les diff\u00e9rents ordonnanceurs l'approche globale : un ordonnanceur global est charg\u00e9 de d\u00e9terminer la r\u00e9partition des processus entre les diff\u00e9rents processeurs L'ordonnancement des processus des syst\u00e8mes d'exploitation actuels est bien plus complexe que les quelques algorithmes \u00e9voqu\u00e9s dans ce cours, et cela d\u00e9passe largement le cadre du programme de NSI. Si vous souhaitez en savoir plus, voici n\u00e9anmoins une vid\u00e9o int\u00e9ressante (en fran\u00e7ais) sur l'ordonnancement du noyau Linux : https://www.youtube.com/watch?v=uCGe5WWd1OI&t=195s&ab_channel=Vitonimal . Bilan \u2693\ufe0e Un programme en cours d'ex\u00e9cution s'appelle un processus . Les syst\u00e8mes d'exploitation r\u00e9cents permettent d'ex\u00e9cuter plusieurs processus simultan\u00e9ment. En r\u00e9alit\u00e9, ces processus sont ex\u00e9cut\u00e9s \u00e0 tour de r\u00f4le par le syst\u00e8me d'exploitation qui est charg\u00e9 d'allouer \u00e0 chacun d'eux les ressources dont il a besoin en termes de m\u00e9moire, entr\u00e9es-sorties ou temps d'acc\u00e8s au processeur, et de s'assurer que les processus ne se g\u00eanent pas les uns les autres. Au cours de leur vie, les processus varient entre trois \u00e9tats : \u00e9lu si le processus est ex\u00e9cut\u00e9 par le processeur, pr\u00eat si le processus est pr\u00eat \u00e0 \u00eatre ex\u00e9cut\u00e9, et bloqu\u00e9 si le processus est en attente d'une ressource. C'est l' ordonnanceur qui est charg\u00e9 de d\u00e9finir l'ordre dans lequel les processus doivent \u00eatre ex\u00e9cut\u00e9s par le processeur. Ce choix se fait gr\u00e2ce \u00e0 des algorithmes d'ordonnancement. Les processus se partagent les diff\u00e9rentes ressources, on parle d' acc\u00e8s concurrent aux ressources. Ce partage des ressources n'est pas sans risque et peut conduire \u00e0 des probl\u00e8mes de synchronisation. Ces probl\u00e8mes peuvent \u00eatre \u00e9vit\u00e9s en utilisant un verrou , qui permet \u00e0 un processus de ne pas \u00eatre interrompu dans sa section critique par un autre processus demandant le m\u00eame verrou. L'utilisation de plusieurs verrous peut entra\u00eener des interblocages , c'est-\u00e0-dire des situations o\u00f9 chaque processus attend une ressource d\u00e9tenue par un autre, conduisant \u00e0 une attente cyclique infinie. L'ordre d'acquisition des verrous est important mais pas toujours \u00e9vident \u00e0 \u00e9crire dans le cas de probl\u00e8mes complexes. R\u00e9f\u00e9rences : - Equipe \u00e9ducative DIU EIL, cours sur le Partage des ressources et virtualisation , Audrey Queudet, Universit\u00e9 de Nantes. - Cours d'Olivier Lecluse sur la Gestion des ressources - Documentation officielle de la biblioth\u00e8que multiprocessing de Python. - Cours de David Roche sur les processus . - Livre Num\u00e9rique et Sciences Informatiques, 24 le\u00e7ons, Terminale , T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Ressource \u00e9ducative libre distribu\u00e9e sous Licence Creative Commons Attribution - Pas d\u2019Utilisation Commerciale - Partage dans les M\u00eames Conditions 4.0 International","title":"Introduction"},{"location":"Processus/Gestion_Processus_Cours/#introduction","text":"Dans les ann\u00e9es 1970 les ordinateurs personnels \u00e9taient incapables d'ex\u00e9cuter plusieurs t\u00e2ches \u00e0 la fois : il fallait attendre qu'un programme lanc\u00e9 se termine pour en ex\u00e9cuter un autre. Les syst\u00e8mes d'exploitations r\u00e9cents (GNU/Linux, macOS, iOS, Android, Windows...) permettent d'ex\u00e9cuter des t\u00e2ches \"simultan\u00e9ment\". En effet, la plupart du temps, lorsque l'on utilise un ordinateur, plusieurs programmes sont ex\u00e9cut\u00e9s \"en m\u00eame temps\" : par exemple, on peut tr\u00e8s bien ouvrir simultan\u00e9ment un navigateur Web, un traitement de texte, un IDE Python, un logiciel de musique (sans parler de tous les programmes ex\u00e9cut\u00e9s en arri\u00e8re-plan) ... Ces programmes en cours d'ex\u00e9cution s'appellent des processus . Une des t\u00e2ches du syst\u00e8me d'exploitation est d'allouer \u00e0 chacun des processus les ressources dont il a besoin en termes de m\u00e9moire, entr\u00e9es-sorties ou temps d'acc\u00e8s au processeur, et de s'assurer que les processus ne se g\u00eanent pas les uns les autres. Pourtant, on rappelle qu'un programme n'est qu'une suite d'instructions machine ex\u00e9cut\u00e9es l'une apr\u00e8s l'autre par le processeur (cf. cours de Premi\u00e8re sur le Mod\u00e8le d'architecture d'un ordinateur ) et qu'un processeur n'est capable d'ex\u00e9cuter qu'une seule instruction \u00e0 la fois. Comment est-il alors possible que plusieurs programmes soient ex\u00e9cut\u00e9s en m\u00eame temps ?","title":"Introduction"},{"location":"Processus/Gestion_Processus_Cours/#processus","text":"","title":"Processus"},{"location":"Processus/Gestion_Processus_Cours/#gestion-des-processus-et-des-ressources","text":"","title":"Gestion des processus et des ressources"},{"location":"Processus/Gestion_Processus_Cours/#problemes-lies-a-lacces-concurrent-aux-ressources","text":"Les processus se partagent souvent une ou plusieurs ressources, et cela peut poser des probl\u00e8mes.","title":"Probl\u00e8mes li\u00e9s \u00e0 l'acc\u00e8s concurrent aux ressources"},{"location":"Processus/Gestion_Processus_Cours/#et-pour-les-systemes-multiprocesseurs","text":"Les ordinateurs actuels poss\u00e8dent g\u00e9n\u00e9ralement plusieurs processeurs, ce qui permet \u00e0 plusieurs processus d'\u00eatre ex\u00e9cut\u00e9s parall\u00e8lement : un par processeur. Ce parall\u00e9lisme permet bien \u00e9videmment une plus grande puissance de calcul. Pour r\u00e9partir les diff\u00e9rents processus entre les diff\u00e9rents processeurs, on distingue deux approches : l'approche partitionn\u00e9e : chaque processeur poss\u00e8de un ordonnanceur particulier et les processus sont r\u00e9partis entre les diff\u00e9rents ordonnanceurs l'approche globale : un ordonnanceur global est charg\u00e9 de d\u00e9terminer la r\u00e9partition des processus entre les diff\u00e9rents processeurs L'ordonnancement des processus des syst\u00e8mes d'exploitation actuels est bien plus complexe que les quelques algorithmes \u00e9voqu\u00e9s dans ce cours, et cela d\u00e9passe largement le cadre du programme de NSI. Si vous souhaitez en savoir plus, voici n\u00e9anmoins une vid\u00e9o int\u00e9ressante (en fran\u00e7ais) sur l'ordonnancement du noyau Linux : https://www.youtube.com/watch?v=uCGe5WWd1OI&t=195s&ab_channel=Vitonimal .","title":"Et pour les syst\u00e8mes multiprocesseurs ?"},{"location":"Processus/Gestion_Processus_Cours/#bilan","text":"Un programme en cours d'ex\u00e9cution s'appelle un processus . Les syst\u00e8mes d'exploitation r\u00e9cents permettent d'ex\u00e9cuter plusieurs processus simultan\u00e9ment. En r\u00e9alit\u00e9, ces processus sont ex\u00e9cut\u00e9s \u00e0 tour de r\u00f4le par le syst\u00e8me d'exploitation qui est charg\u00e9 d'allouer \u00e0 chacun d'eux les ressources dont il a besoin en termes de m\u00e9moire, entr\u00e9es-sorties ou temps d'acc\u00e8s au processeur, et de s'assurer que les processus ne se g\u00eanent pas les uns les autres. Au cours de leur vie, les processus varient entre trois \u00e9tats : \u00e9lu si le processus est ex\u00e9cut\u00e9 par le processeur, pr\u00eat si le processus est pr\u00eat \u00e0 \u00eatre ex\u00e9cut\u00e9, et bloqu\u00e9 si le processus est en attente d'une ressource. C'est l' ordonnanceur qui est charg\u00e9 de d\u00e9finir l'ordre dans lequel les processus doivent \u00eatre ex\u00e9cut\u00e9s par le processeur. Ce choix se fait gr\u00e2ce \u00e0 des algorithmes d'ordonnancement. Les processus se partagent les diff\u00e9rentes ressources, on parle d' acc\u00e8s concurrent aux ressources. Ce partage des ressources n'est pas sans risque et peut conduire \u00e0 des probl\u00e8mes de synchronisation. Ces probl\u00e8mes peuvent \u00eatre \u00e9vit\u00e9s en utilisant un verrou , qui permet \u00e0 un processus de ne pas \u00eatre interrompu dans sa section critique par un autre processus demandant le m\u00eame verrou. L'utilisation de plusieurs verrous peut entra\u00eener des interblocages , c'est-\u00e0-dire des situations o\u00f9 chaque processus attend une ressource d\u00e9tenue par un autre, conduisant \u00e0 une attente cyclique infinie. L'ordre d'acquisition des verrous est important mais pas toujours \u00e9vident \u00e0 \u00e9crire dans le cas de probl\u00e8mes complexes. R\u00e9f\u00e9rences : - Equipe \u00e9ducative DIU EIL, cours sur le Partage des ressources et virtualisation , Audrey Queudet, Universit\u00e9 de Nantes. - Cours d'Olivier Lecluse sur la Gestion des ressources - Documentation officielle de la biblioth\u00e8que multiprocessing de Python. - Cours de David Roche sur les processus . - Livre Num\u00e9rique et Sciences Informatiques, 24 le\u00e7ons, Terminale , T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Ressource \u00e9ducative libre distribu\u00e9e sous Licence Creative Commons Attribution - Pas d\u2019Utilisation Commerciale - Partage dans les M\u00eames Conditions 4.0 International","title":"Bilan"},{"location":"Processus/TD_Gestion_Processus%20copy/","text":"Th\u00e8me 3 : Architecture mat\u00e9rielle 23 Cours : Gestion des processus - CORRECTION Introduction \u2693\ufe0e Dans les ann\u00e9es 1970 les ordinateurs personnels \u00e9taient incapables d'ex\u00e9cuter plusieurs t\u00e2ches \u00e0 la fois : il fallait attendre qu'un programme lanc\u00e9 se termine pour en ex\u00e9cuter un autre. Les syst\u00e8mes d'exploitations r\u00e9cents (GNU/Linux, macOS, iOS, Android, Windows...) permettent d'ex\u00e9cuter des t\u00e2ches \"simultan\u00e9ment\". En effet, la plupart du temps, lorsque l'on utilise un ordinateur, plusieurs programmes sont ex\u00e9cut\u00e9s \"en m\u00eame temps\" : par exemple, on peut tr\u00e8s bien ouvrir simultan\u00e9ment un navigateur Web, un traitement de texte, un IDE Python, un logiciel de musique (sans parler de tous les programmes ex\u00e9cut\u00e9s en arri\u00e8re-plan) ... Ces programmes en cours d'ex\u00e9cution s'appellent des processus . Une des t\u00e2ches du syst\u00e8me d'exploitation est d'allouer \u00e0 chacun des processus les ressources dont il a besoin en termes de m\u00e9moire, entr\u00e9es-sorties ou temps d'acc\u00e8s au processeur, et de s'assurer que les processus ne se g\u00eanent pas les uns les autres. Pourtant, on rappelle qu'un programme n'est qu'une suite d'instructions machine ex\u00e9cut\u00e9es l'une apr\u00e8s l'autre par le processeur et qu'un processeur n'est capable d'ex\u00e9cuter qu'une seule instruction \u00e0 la fois. Pour rappel, voici les \u00e9tapes d'ex\u00e9cution d'une instruction. l'instruction point\u00e9e par le pointeur d'instruction est charg\u00e9e en m\u00e9moire Le pointeur d'instruction est incr\u00e9ment\u00e9 vers l'adresse suivante l'instruction est d\u00e9cod\u00e9e l'instruction est ex\u00e9cut\u00e9e Comment est-il alors possible que plusieurs programmes soient ex\u00e9cut\u00e9s en m\u00eame temps ? Processus \u2693\ufe0e Qu'est-ce qu'un processus ? \u2693\ufe0e Il ne faut pas confondre programme et processus : Un programme est un fichier binaire (on dit aussi un ex\u00e9cutable ) contenant des instructions machines que seul le processeur peut comprendre. Un processus est un programme en cours d'ex\u00e9cution , autrement dit le ph\u00e9nom\u00e8ne dynamique li\u00e9 \u00e0 l'ex\u00e9cution d'un programme par l'ordinateur. Ainsi, lorsque nous cliquons sur l'ic\u00f4ne d'un programme (ou lorsque nous ex\u00e9cutons une instruction dans la console pour lancer un programme), nous provoquons la naissance d'un ou plusieurs processus li\u00e9s au programme que nous lan\u00e7ons. Un processus est donc une instance d'un programme auquel est associ\u00e9 : du code des donn\u00e9es/variables manipul\u00e9es des ressources : processeur, m\u00e9moire, p\u00e9riph\u00e9riques d'entr\u00e9e/sortie (voir paragraphe suivant) Il n'est d'ailleurs pas rare qu'un m\u00eame programme soit ex\u00e9cut\u00e9 plusieurs fois sur une machine au m\u00eame moment en occupant des espaces m\u00e9moires diff\u00e9rents : par exemple deux documents ouverts avec un traitement de texte, ou trois consoles distinctes... qui correspondent \u00e0 autant d'instances du m\u00eame programme et donc \u00e0 des processus diff\u00e9rents. Observer les processus \u2693\ufe0e Il est tr\u00e8s facile de voir les diff\u00e9rents processus s'ex\u00e9cutant sur une machine. Sous GNU/Linux, on peut utiliser la commande ps (comme p roces s , la traduction anglaise de processus ) pour afficher les informations sur les processus (sous windows : talklist). En passant des options \u00e0 cette commande on peut obtenir des choses int\u00e9ressantes. Par exemple, en ex\u00e9cutant dans un terminal la commande ps -aef , on peut visualiser tous les processus en cours sur notre ordinateur : Cr\u00e9ation d'un processus \u2693\ufe0e Un processus peut \u00eatre cr\u00e9\u00e9 : au d\u00e9marrage du syst\u00e8me par un autre processus par une action d'un utilisateur (lancement d'un programme) Sous GNU/Linux, un tout premier processus est cr\u00e9\u00e9 au d\u00e9marrage (c'est le processus 0 ou encore Swapper ). Ce processus cr\u00e9e un processus souvent appel\u00e9 init qui est le fils du processus 0. Ensuite, \u00e0 partir de init , les autres processus n\u00e9cessaires au fonctionnement du syst\u00e8me sont cr\u00e9\u00e9s. Ces processus cr\u00e9ent ensuite eux-m\u00eames d'autres processus, etc. Un processus peut cr\u00e9er un ou plusieurs processus, ce qui aboutit \u00e0 une structure arborescente comme nous allons le voir maintenant. PID et PPID \u2693\ufe0e La commande pr\u00e9c\u00e9dente permet de voir que chaque processus est identifi\u00e9 par un num\u00e9ro : son PID (pour Process Identifier ). Ce num\u00e9ro est donn\u00e9 \u00e0 chaque processus par le syst\u00e8me d'exploitation. On constate \u00e9galement que chaque processus poss\u00e8de un PPID (pour Parent Process Identifier ), il s'agit du PID du processus parent, c'est-\u00e0-dire celui qui a d\u00e9clench\u00e9 la cr\u00e9ation du processus. En effet, un processus peut cr\u00e9er lui m\u00eame un ou plusieurs autres processus, appel\u00e9s processus fils . Observation des processus\u2693\ufe0e \u2693\ufe0e Sous Linux, on peut observer les processus et leur \u00e9tat en ligne de commande. Pour tester, cela on peut utiliser : terminal linux en ligne Voici quelques commandes utiles pour observer les processus : ps |: elle permet d'afficher la liste des processus en cours. (Pour avoir des informations sur les options taper man ps) Pour lister tous les processus : ps - ef top : Pour observer en temps r\u00e9els les diff\u00e9rents processus.(penser \u00e0 utiliser man top) la commande f permet de g\u00e9rer les colonnes affich\u00e9es. kill : elle permet de tuer un processus en lui envoyant un signal de fin. 15 pour arr\u00eater le processus proprement 9 pour arr\u00eater imm\u00e9diatement le processus. exemple d'utilisation : kill -15 7654 pour tuer proprement le processus de PID 7564 Exercice Dans un nouvel onglet ouvrir : terminal linux en ligne cr\u00e9er un premier terminal : utiliser les commandes de l'ann\u00e9e pr\u00e9c\u00e9dentes : ls, cd, touch, cat pour d\u00e9terminer le nom d'utilisateur : whoami cr\u00e9er un fichier vide test.py : touch test.py \u00e9diter le fichier test.py avec la commande : nano test.py y \u00e9crire le code suivant : python for a in range(100000): print(a) pour sortir de l'\u00e9diteur : Ctrl+X, puis Y, puis Enter pour confirmer le nom lancer le programme avec : python3 test.py cr\u00e9er un second fichier p2.py avec le code suivant : \ud83d\udc0d Script Python while True : pass le lancer Il tourne sans fin. Pour l'arr\u00eater : Ctrl+C v\u00e9rifier la pr\u00e9sence dans le dossier des fichiers cr\u00e9\u00e9s, avec ls ouvrir un second terminal puis : dans ce second terminal lancer python3 sans nom de fichier dans le premier terminal taper ps -ef rep\u00e9rer le PID du processus python3 et le tuer avec la commande kill -9 (voir syntaxe au dessus) ouvrir un troisi\u00e8me terminal dans ce troisi\u00e8me terminal lancer la commande top modifier l'affichage pour faire appara\u00eetre le PPID (taper f, puis s\u00e9lectionner/ d\u00e9placer avec les touches curseur. Revenir \u00e0 l'affichage avec Esc) Enfin ouvrir des terminaux suppl\u00e9mentaires pour en avoir au moins 5 et lancer dans les terminaux : 1 aucun processus 1 avec nano 1 avec python3 1 avec python3 lan\u00e7ant p2.py 1 avec top observer les processus et essayer de les tuer avec la commande kill \u00e0 partir du premier terminal recommencer en relan\u00e7ant les processus et tuer les processus avec le terminal lan\u00e7ant top(puis commande k) Gestion des processus et des ressources \u2693\ufe0e Ex\u00e9cution concurrente \u2693\ufe0e Les syst\u00e8mes d'exploitation modernes sont capable d'ex\u00e9cuter plusieurs processus \"en m\u00eame temps\". En r\u00e9alit\u00e9 ces processus ne sont pas toujours ex\u00e9cut\u00e9s \"en m\u00eame temps\" mais plut\u00f4t \"\u00e0 tour de r\u00f4le\". On parle d'ex\u00e9cution concurrente car les processus sont en concurrence pour obtenir l'acc\u00e8s au processeur charg\u00e9 de les ex\u00e9cuter. Remarque : Sur un syst\u00e8me multiprocesseur, il est possible d'ex\u00e9cuter de mani\u00e8re parall\u00e8le plusieurs processus, autant qu'il y a de processeurs. Mais sur un m\u00eame processeur, un seul processus ne peut \u00eatre ex\u00e9cut\u00e9 \u00e0 la fois. On peut voir assez facilement cette ex\u00e9cution concurrente. Consid\u00e9rons les deux programmes Python suivants : progA.py \ud83d\udc0d Script Python import time for i in range ( 100 ): print ( \"programme A en cours, it\u00e9ration\" , i ) time . sleep ( 0.01 ) # pour simuler un traitement avec des calculs progB.py \ud83d\udc0d Script Python import time for i in range ( 100 ): print ( \"programme B en cours, it\u00e9ration\" , i ) time . sleep ( 0.01 ) # pour simuler un traitement avec des calculs En ouvrant un Terminal, on peut lancer simultan\u00e9ment ces deux programmes avec la commande Bash $ python progA.py & python progB.py & Le caract\u00e8re & qui suit une commande permet de lancer l'ex\u00e9cution en arri\u00e8re plan et de rendre la main au terminal. Le shell indique alors dans la console les PID des processus correspondant \u00e0 l'ex\u00e9cution de ces deux programmes (ici 9154 et 9155) puis on constate gr\u00e2ce aux affichages que le syst\u00e8me d'exploitation alloue le processeur aux deux programmes \u00e0 tour de r\u00f4le : Acc\u00e8s concurrents aux ressources \u2693\ufe0e Une ressource est une entit\u00e9 dont a besoin un processus pour s'ex\u00e9cuter. Les ressources peuvent \u00eatre mat\u00e9rielles (processeur, m\u00e9moire, p\u00e9riph\u00e9riques d'entr\u00e9e/sortie, ...) mais aussi logicielles (variables). Les diff\u00e9rents processus se partagent les ressources, on parle alors d' acc\u00e8s concurrents aux ressources . Par exemple, les processus se partagent tous l'acc\u00e8s \u00e0 la ressource \"processeur\" un traitement de texte et un IDE Python se partagent la ressource \"clavier\" ou encore la ressource \"disque dur\" (si on enregistre les fichiers), ... un navigateur et un logiciel de musique se partagent la ressource \"carte son\", ... C'est le syst\u00e8me d'exploitation qui est charg\u00e9 de g\u00e9rer les processus et les ressources qui leur sont n\u00e9cessaires, en partageant leur acc\u00e8s au processeur. Nous allons voir comment tout de suite ! \u00c9tats d'un processus \u2693\ufe0e Au cours de son existence, un processus peut se retrouver dans trois \u00e9tats : \u00e9tat \u00e9lu : lorsqu'il est en cours d'ex\u00e9cution, c'est-\u00e0-dire qu'il obtient l'acc\u00e8s au processeur \u00e9tat pr\u00eat : lorsqu'il attend de pouvoir acc\u00e9der au processeur \u00e9tat en bloqu\u00e9 : lorsque le processus est interrompu car il a besoin d'attendre une ressource quelconque (entr\u00e9e/sortie, allocation m\u00e9moire, etc.) Il est important de comprendre que le processeur ne peut g\u00e9rer qu'un seul processus \u00e0 la fois : le processus \u00e9lu . En pratique, lorsqu'un processus est cr\u00e9\u00e9 il est dans l'\u00e9tat pr\u00eat et attend de pouvoir acc\u00e9der au processeur (d'\u00eatre \u00e9lu ). Lorsqu'il est \u00e9lu, le processus est ex\u00e9cut\u00e9 par le processeur mais cette ex\u00e9cution peut \u00eatre interrompue : soit pour laisser la main \u00e0 un autre processus (qui a \u00e9t\u00e9 \u00e9lu) : dans ce cas, le processus de d\u00e9part repasse dans l'\u00e9tat pr\u00eat et doit attendre d'\u00eatre \u00e9lu pour reprendre son ex\u00e9cution soit parce que le processus en cours a besoin d'attendre une ressource : dans ce cas, le processus passe dans l'\u00e9tat bloqu\u00e9 . Lorsque le processus bloqu\u00e9 finit par obtenir la ressource attendue, il peut th\u00e9oriquement reprendre son ex\u00e9cution mais probablement qu'un autre processus a pris sa place et est pass\u00e9 dans l'\u00e9tat \u00e9lu. Auquel cas, le processus qui vient d'\u00eatre \"d\u00e9bloqu\u00e9\" repasse dans l'\u00e9tat pr\u00eat en attendant d'\u00eatre \u00e0 nouveau \u00e9lu. Ainsi, l'\u00e9tat d'un processus au cours de sa vie varie entre les \u00e9tats pr\u00eat , \u00e9lu et bloqu\u00e9 comme le r\u00e9sume le sch\u00e9ma suivant : Lorsqu'un processus est interrompu, il doit pouvoir reprendre \u00e0 l'endroit m\u00eame o\u00f9 il a \u00e9t\u00e9 interrompu. Pour cela, le syst\u00e8me d'exploitation conserve pour chaque processus cr\u00e9\u00e9 une zone m\u00e9moire (appel\u00e9e PCB, pour Process Control Bloc , ou bloc de contr\u00f4le du processus) dans laquelle sont stock\u00e9es les informations sur le processus : son PIB, son \u00e9tat, la valeur des registres lors de sa derni\u00e8re interruption, la zone m\u00e9moire allou\u00e9e par le processus lors de son ex\u00e9cution, les ressources utilis\u00e9es par le processus (fichiers ouverts, connexions r\u00e9seaux en cours d'utilisation, etc.). Ordonnancement \u2693\ufe0e C'est le syst\u00e8me d'exploitation qui attribue aux processus leurs \u00e9tats \u00e9lu , pr\u00eat et bloqu\u00e9 . Plus pr\u00e9cis\u00e9ment, c'est l' ordonnanceur (un des composants du syst\u00e8me d'exploitation) qui r\u00e9alise cette t\u00e2che appel\u00e9e ordonnancement des processus . L'objectif de l'ordonnanceur est de choisir le processus \u00e0 ex\u00e9cuter \u00e0 l'instant \\(t\\) (le processus \u00e9lu ) et d\u00e9terminer le temps durant lequel le processeur lui sera allou\u00e9. Ce choix est \u00e0 faire parmi tous les processus qui sont dans l'\u00e9tat pr\u00eat , mais lequel sera \u00e9lu ? et pour combien de temps ? Des algorithmes d'ordonnancement sont utilis\u00e9s et il en existe plusieurs selon la strat\u00e9gie utilis\u00e9e. On en pr\u00e9sente quelques-uns ci-dessous. Ordonnancement First Come First Served (FCFS) \u2693\ufe0e Principe : Les processus sont ordonnanc\u00e9s selon leur ordre d'arriv\u00e9e (\"premier arriv\u00e9, premier servi\" en fran\u00e7ais) Exemple : Les processus \\(P_1(53)\\) , \\(P_2(17)\\) , \\(P_3(68)\\) et \\(P_4(24)\\) arrivent dans cet ordre \u00e0 \\(t=0\\) : Cela signifie que \\(P_1\\) , \\(P_2\\) , \\(P_3\\) et \\(P_4\\) ont besoin de respectivement 53, 17, 68 et 24 unit\u00e9s de temps pour s'ex\u00e9cuter. Ordonnancement Shortest Job First (SJF) \u2693\ufe0e Principe : Le processus dont le temps d'ex\u00e9cution est le plus court est ordonnanc\u00e9 en premier. Exemple : \\(P_1\\) , \\(P_2\\) , \\(P_3\\) et \\(P_4\\) arrivent \u00e0 \\(t=0\\) : Ordonnancement Shortest Remaining Time (SRT) \u2693\ufe0e Principe : Le processus dont le temps d'ex\u00e9cution restant est le plus court parmi ceux qui restent \u00e0 ex\u00e9cuter est ordonnanc\u00e9 en premier. Exemple : \\(P_3\\) et \\(P_4\\) arrivent \u00e0 \\(t=0\\) ; \\(P_2\\) \u00e0 \\(t=20\\) ; \\(P_1\\) \u00e0 \\(t=50\\) : Ordonnancement temps-partag\u00e9 (Round-Robin) \u2693\ufe0e Principe : C'est la politique du tourniquet : allocation du processeur par tranche (= quantum \\(q\\) ) de temps. Exemple : quantum \\(q = 20\\) et \\(n = 4\\) processus Dans ce cas, s'il y a \\(n\\) processus, chacun d'eux obtient le processeur au bout de \\((n-1)\\times q\\) unit\u00e9s de temps au plus Ordonnancement \u00e0 priorit\u00e9s statiques \u2693\ufe0e Principe : Allocation du processeur selon des priorit\u00e9s statiques (= num\u00e9ros affect\u00e9s aux processus pour toute la vie de l'application) Exemple : priorit\u00e9s \\((P_1, P_2, P_3, P_4) = (3, 2, 0, 1)\\) o\u00f9 la priorit\u00e9 la plus forte est 0 (attention, dans certains syst\u00e8mes c'est l'inverse : 0 est alors la priorit\u00e9 la plus faible) Probl\u00e8mes li\u00e9s \u00e0 l'acc\u00e8s concurrent aux ressources \u2693\ufe0e Les processus se partagent souvent une ou plusieurs ressources, et cela peut poser des probl\u00e8mes. Probl\u00e8mes de synchronisation : illustration avec Python \u2693\ufe0e Exemple d'une variable partag\u00e9e \u2693\ufe0e Prenons l'exemple d'une variable (= ressource logicielle) partag\u00e9e entre plusieurs processus. Plus pr\u00e9cis\u00e9ment, consid\u00e9rons un programme de jeu multi-joueur dans lequel une variable nb_pions repr\u00e9sente le nombre de pions disponibles pour tous les joueurs. Une fonction prendre_un_pion() permet de prendre un pion dans le tas commun de pions disponibles, s'il reste au moins un pion \u00e9videmment. On va se mettre dans la situation o\u00f9 il ne reste plus qu'un pion dans le tas commun et on suppose que deux joueurs utilisent la fonction prendre_un_pion() , ce qui conduit \u00e0 la cr\u00e9ation de deux processus p1 et p2 , chacun correspondant \u00e0 un joueur. Avec Python, on peut utiliser le module multiprocessing pour cr\u00e9er des processus. Le programme Python pions.py suivant permet de r\u00e9aliser la situation de jeu d\u00e9crite : \ud83d\udc0d Script Python from multiprocessing import Process , Value import time def prendre_un_pion ( nombre ): if nombre . value >= 1 : time . sleep ( 0.001 ) # pour simuler un traitement avec des calculs temp = nombre . value nombre . value = temp - 1 # on d\u00e9cr\u00e9mente le nombre de pions if __name__ == '__main__' : # cr\u00e9ation de la variable partag\u00e9e initialis\u00e9e \u00e0 1 nb_pions = Value ( 'i' , 1 ) # on cr\u00e9e deux processus p1 = Process ( target = prendre_un_pion , args = [ nb_pions ]) p2 = Process ( target = prendre_un_pion , args = [ nb_pions ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () print ( \"nombre final de pions :\" , nb_pions . value ) Explications : Le if __name__ = '__main'__: permet de ne cr\u00e9er qu'une seule fois les processus p1 et p2 qui suivent (c'est n\u00e9cessaire sous Windows, pas sous GNU/Linux car la cr\u00e9ation des processus ne se fait pas de la m\u00eame mani\u00e8re, mais cela reste conseill\u00e9 ne serait-ce que pour des raisons de compatibilit\u00e9), on n'en dira pas davantage ici car cela d\u00e9passe le niveau de ce cours. On a utilis\u00e9 la classe Process du module multiprocessing pour instancier deux processus p1 et p2 . L'argument target est le nom de la fonction qui sera ex\u00e9cut\u00e9e par le processus : ici les deux processus doivent ex\u00e9cuter la m\u00eame fonction prendre_un_pion() L'argument args est une liste des arguments pass\u00e9s \u00e0 la fonction cible : ici il s'agit de la variable nb_pions qui est partag\u00e9e par les deux processus. Par d\u00e9faut, deux processus ne partagent pas de donn\u00e9es en m\u00e9moire : on ne peut pas donc pas utiliser nb_pions comme une variable globale. Il faut utiliser la classe Value du module multiprocessing pour cr\u00e9er nb_pions dans une m\u00e9moire partag\u00e9e entre les processus. L'argument 'i' indique que nb_pions est un entier (sign\u00e9) et le deuxi\u00e8me argument est la valeur initiale de la variable, ici 1. La fonction prendre_un_pion() prend un nombre en param\u00e8tre et d\u00e9cr\u00e9mente sa valeur d'une unit\u00e9 si le nombre est au moins \u00e9gal \u00e0 1. Lors de l'ex\u00e9cution de la fonction par les deux processus, l'argument en question sera l'objet nb_pions de la classe Value et on acc\u00e8de \u00e0 sa valeur avec l'attribut value . On a ajout\u00e9 une temporisation permettant de simuler d'autres calculs qui pourraient avoir lieu (par exemple, des instructions de mise \u00e0 jour du nombre de pions des joueurs) Les derni\u00e8res lignes permettent de d\u00e9marrer les deux processus et attendre qu'ils soient termin\u00e9s pour afficher la valeur finale de nb_pions . Si on ex\u00e9cute ce programme, les deux processus p1 et p2 sont ex\u00e9cut\u00e9s et on s'attend au comportement suivant (en supposant qu'il ne reste qu'un seule pion dans le tas commun) : l'un des deux est \u00e9lu en premier, par exemple p1 , et ex\u00e9cute la fonction prendre_un_pion() , le nombre de pions est \u00e9gal \u00e0 1 donc nb_pions est d\u00e9cr\u00e9ment\u00e9 d'une unit\u00e9 et prend donc la valeur 0, le processus p1 est termin\u00e9 ; le processus p2 , qui \u00e9tait en attente, est ensuite \u00e9lu, et comme le nombre de pions est d\u00e9sormais \u00e9gal \u00e0 0 rien ne se passe et p2 termine. Ainsi, le premier joueur a pu prendre le pion restant et le second s'est retrouv\u00e9 coinc\u00e9, et la valeur finale de nb_pions vaut 0. Et pourtant, il est tout \u00e0 fait possible que les choses ne se passent pas ainsi ! En effet, en ex\u00e9cutant plusieurs fois le programme pions.py dans un terminal, on obtient parfois une valeur finale \u00e9gale \u00e0 0 et parfois \u00e9gale \u00e0 -1 : C'est un r\u00e9sultat tr\u00e8s perturbant non ? Expliquons pourquoi ! Pour cela, on peut ajouter quelques instructions d'affichage pour suivre ce qu'il se passe. On obtient le script pions_v2.py suivant : \ud83d\udc0d Script Python from multiprocessing import Process , Value import time def prendre_un_pion ( nombre , numero_processus ): print ( f \"d\u00e9but du processus { numero_processus } \" ) if nombre . value >= 1 : print ( f \"processus { numero_processus } : \u00e9tape A\" ) time . sleep ( 0.001 ) # pour simuler un traitement avec des calculs print ( f \"processus { numero_processus } : \u00e9tape B\" ) temp = nombre . value nombre . value = temp - 1 # on d\u00e9cr\u00e9mente le nombre de pions print ( f \"nombre de pions restants \u00e0 la fin du processus { numero_processus } : { nombre . value } \" ) if __name__ == '__main__' : # cr\u00e9ation de la variable partag\u00e9e initialis\u00e9e \u00e0 1 nb_pions = Value ( 'i' , 1 ) # on cr\u00e9e deux processus p1 = Process ( target = prendre_un_pion , args = [ nb_pions , 1 ]) p2 = Process ( target = prendre_un_pion , args = [ nb_pions , 2 ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () print ( \"nombre final de pions :\" , nb_pions . value ) Explications : Lors de la cr\u00e9ation des processus, on passe un deuxi\u00e8me argument \u00e0 la fonction prendre_un_pion() , le num\u00e9ro du processus : 1 pour p1 et 2 pour p2 . Cela permet d'afficher dans cette fonction le num\u00e9ro du processus \u00e0 des endroits strat\u00e9giques : au d\u00e9but, \u00e0 l'entr\u00e9e dans le if , juste avant de d\u00e9cr\u00e9menter le nombre de pions et \u00e0 la fin du processus. En ex\u00e9cutant pions_v2.py dans un terminal, on obtient ce genre de choses : Analysons la premi\u00e8re ex\u00e9cution du programme. le processus p1 est \u00e9lu en premier (affichage de \"d\u00e9but du processus 1\") mais est de suite interrompu par l'ordonnanceur qui \u00e9lit p2 (affichage de \"d\u00e9but du processus 2\") puis c'est de nouveau le processus p1 qui a la main et il rentre dans le if (affichage de \"processus 1 : \u00e9tape A\") mais est interrompu \u00e0 nouveau et l'ordonnanceur donne la main \u00e0 p2 qui rentre aussi dans le if (affichage de \"processus 2 : \u00e9tape A\") : en effet, \u00e0 ce stade le nombre de pions n'a pas encore \u00e9t\u00e9 d\u00e9cr\u00e9ment\u00e9 par p1 car il a \u00e9t\u00e9 interrompu avant l'\u00e9tape B, et donc p2 a pu entrer dans le if puisque la condition nombre.value >= 1 est toujours vraie \u00e0 ce moment l\u00e0 !! ensuite le processeur est allou\u00e9 alternativement \u00e0 p1 et p2 (voir les affichages restants) mais le mal est fait puisque les deux processus sont d\u00e9sormais chacun entr\u00e9s dans le if , ils vont chacun d\u00e9cr\u00e9menter le nombre de pions d'une unit\u00e9 et chacun des deux joueurs aura pioch\u00e9 un pion alors qu'il n'y en avait qu'un seul au d\u00e9part ! Vous remarquerez que la troisi\u00e8me ex\u00e9cution du programme met en \u00e9vidence le m\u00eame probl\u00e8me car les deux processus ont chacun pu entrer dans le if , m\u00eame si l'ordre des instructions ex\u00e9cut\u00e9es apr\u00e8s n'est pas tout \u00e0 fait le m\u00eame. Si on analyse la seconde ex\u00e9cution du programme qui donne le comportement souhait\u00e9, on constate que p1 a eu suffisamment de temps pour d\u00e9cr\u00e9menter le nombre de pions (qui vaut d\u00e9sormais 0) avant que p2 ne fasse le test nombre.value >= 1 et se rende compte que cette condition est fausse. Dans ce cas, seul le premier joueur a pas pu piocher un pion. Heureusement, on peut \u00e9viter le probl\u00e8me mis en \u00e9vidence dans l'exemple pr\u00e9c\u00e9dent. Comment \u00e9viter les probl\u00e8mes de synchronisation ? \u2693\ufe0e On va utiliser ce qu'on appelle un verrou : un verrou est objet partag\u00e9 entre plusieurs processus mais qui garantit qu'un seul processus acc\u00e8de \u00e0 une ressource \u00e0 un instant donn\u00e9. Concr\u00e8tement, un verrou peut \u00eatre acquis par les diff\u00e9rents processus, et le premier \u00e0 faire la demande acquiert le verrou. Si le verrou est d\u00e9tenu par un autre processus, alors tout autre processus souhaitant l'obtenir est bloqu\u00e9 jusqu'\u00e0 ce qu'il soit lib\u00e9r\u00e9. Le module multiprocessing de Python propose un objet Lock() correpondant \u00e0 un verrou. Deux m\u00e9thodes sont utilis\u00e9es : la m\u00e9thode .acquire() permet de demander le verrou (le processus faisant la demande est bloqu\u00e9 tant qu'il ne l'a pas obtenu) la m\u00e9thode .release() permet de lib\u00e9rer le verrou (il pourra alors \u00eatre obtenu par un autre processus qui en fait la demande) On peut alors r\u00e9gler le probl\u00e8me de l'exemple pr\u00e9c\u00e9dent avec le script pions_v3.py suivant dans lequel on a laiss\u00e9 les affichages pour bien suivre : \ud83d\udc0d Script Python from multiprocessing import Process , Value , Lock import time def prendre_un_pion ( v , nombre , numero_processus ): print ( f \"d\u00e9but du processus { numero_processus } \" ) v . acquire () # acquisition du verrou if nombre . value >= 1 : print ( f \"processus { numero_processus } : \u00e9tape A\" ) time . sleep ( 0.001 ) print ( f \"processus { numero_processus } : \u00e9tape B\" ) temp = nombre . value nombre . value = temp - 1 v . release () # verrou lib\u00e9r\u00e9 print ( f \"nombre de pions restants \u00e0 la fin du processus { numero_processus } : { nombre . value } \" ) if __name__ == '__main__' : # cr\u00e9ation de la variable partag\u00e9e initialis\u00e9e \u00e0 1 nb_pions = Value ( 'i' , 1 ) # verrou partag\u00e9 par les deux processus verrou = Lock () # on cr\u00e9e deux processus p1 = Process ( target = prendre_un_pion , args = [ verrou , nb_pions , 1 ]) p2 = Process ( target = prendre_un_pion , args = [ verrou , nb_pions , 2 ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () print ( \"nombre final de pions :\" , nb_pions . value ) En ex\u00e9cutant (plusieurs fois) ce script dans un terminal on constate que le nombre final de pions est toujours \u00e9gal \u00e0 0. Avant de faire le test du if , le processus essaye d'acqu\u00e9rir le verrou avec v.acquire() . D\u00e8s qu'il est acquis, le processus a la garantie qu'il est le seul \u00e0 pouvoir ex\u00e9cuter le code jusqu'\u00e0 l'instruction v.release() . Cette portion de code prot\u00e9g\u00e9e s'appelle une section critique . Cela ne veut pas dire que le processus d\u00e9tenant le verrou ne peut pas \u00eatre interrompu, mais il ne le sera pas par un processus qui est essaie d'acqu\u00e9rir le m\u00eame verrou. \ud83d\udc0d Script Python def prendre_un_pion ( v , nombre , numero_processus ): v . acquire () # d\u00e9but section critique if nombre . value >= 1 : time . sleep ( 0.001 ) temp = nombre . value nombre . value = temp - 1 # fin de la section critique v . release () Si vous analysez l'affichage pr\u00e9c\u00e9dent dans le terminal, on voit d'ailleurs que p1 est entr\u00e9 en section critique (affichage \"processus 1 : \u00e9tape A\") mais est interrompu, puis c'est p2 qui a la main (affichage \"d\u00e9but processus 2\") mais il va se retrouver bloquer \u00e0 l'instruction v.acquire() puisque c'est p1 qui d\u00e9tient le verrou. Lorsque p1 reprendra la main, il pourra ex\u00e9cuter ses instructions jusqu'\u00e0 v.release() sans \u00eatre interrompu par p2 (alors nb_pions sera d\u00e9cr\u00e9ment\u00e9 d'une unit\u00e9). Lorsque p1 lib\u00e8re le verrou, p2 pourra alors l'obtenir, ex\u00e9cuter sa section critique et constater que la condition nombre.value >= 1 est fausse : le deuxi\u00e8me joueur ne pourra alors pas prendre de pion. Nous terminons en voyant que l'utilisation de verrous n'est pas sans risque car elle peut engendrer des probl\u00e8mes d'interblocage. Risque d'interblocage \u2693\ufe0e Les interblocages ( deadlock en anglais) sont des situations de la vie quotidienne. L'exemple classique est celui du carrefour avec priorit\u00e9 \u00e0 droite o\u00f9 chaque v\u00e9hicule est bloqu\u00e9 car il doit laisser le passage au v\u00e9hicule \u00e0 sa droite. En informatique l' interblocage peut \u00e9galement se produire lorsque plusieurs processus concurrents s'attendent mutuellement. Ce sc\u00e9nario peut se produire lorsque plusieurs ressources sont partag\u00e9es par plusieurs processus et l'un d'entre eux poss\u00e8de ind\u00e9finiment une ressource n\u00e9cessaire pour un autre. Ce ph\u00e9nom\u00e8ne d' attente circulaire , o\u00f9 chaque processus attend une ressource d\u00e9tenue par un autre processus, peut \u00eatre provoqu\u00e9e par l'utilisation de plusieurs verrous. Consid\u00e9rons le script interblocage.py suivant dans lequel on a cr\u00e9\u00e9 deux verrous v1 et v2 utilis\u00e9s par deux fonctions f1 et f2 ex\u00e9cut\u00e9es respectivement par deux processus p1 et p2 . Le processus p1 essaie d'acqu\u00e9rir d'abord v1 puis v2 tandis que le processus p2 essaie de les acqu\u00e9rir dans l'ordre inverse. \ud83d\udc0d Script Python from multiprocessing import Process , Lock import time import os def f1 ( v1 , v2 ): print ( \"PID du processus 1:\" , os . getpid ()) for i in range ( 100 ): time . sleep ( 0.001 ) v1 . acquire () v2 . acquire () print ( \"processus 1 en cours, it\u00e9ration \" , i ) v2 . release () v1 . release () def f2 ( v1 , v2 ): print ( \"PID du processus 2:\" , os . getpid ()) for i in range ( 100 ): time . sleep ( 0.001 ) v2 . acquire () v1 . acquire () print ( \"processus 2 en cours, it\u00e9ration \" , i ) v1 . release () v2 . release () if __name__ == '__main__' : # cr\u00e9ation de deux verrous v1 = Lock () v2 = Lock () # cr\u00e9ation de deux processus p1 = Process ( target = f1 , args = [ v1 , v2 ]) p2 = Process ( target = f2 , args = [ v1 , v2 ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () Si on ex\u00e9cute ce programme, il y a de grandes chances de se retrouver bloqu\u00e9. Par exemple, dans le cas de l'ex\u00e9cution suivante : le processus p1 est \u00e9lu : il s'ex\u00e9cute jusqu'\u00e0 l'acquisition de v1 mais avant la tentative d'acquisition de v2 , puis est interrompu le processus p2 est \u00e0 son tour \u00e9lu : il s'ex\u00e9cute et acquiert v2 qui est toujours libre, puis bloque sur l'acquisition de v1 (qui est d\u00e9tenu par p1 ). le processus p1 reprend la main et bloque sur l'acquisition de v2 (d\u00e9tenu par p2 ). Chaque processus d\u00e9tient un verrou et attend l'autre : ils sont en interblocage et l'attente est infinie. On peut lancer (plusieurs fois si n\u00e9cessaire) le script \u00e0 partir du terminal et constater que l'interblocage a lieu tr\u00e8s souvent. Il n'y a alors pas d'autres choix que d'interrompre les processus en interblocage, par exemple avec la commande kill . Cependant, ce probl\u00e8me a lieu ici car les deux processus essaie d'acqu\u00e9rir les verrous dans l'ordre contraire. Si l'ordre d'acquisition est le m\u00eame pour les processus, le probl\u00e8me n'a plus lieu (n'h\u00e9sitez pas \u00e0 tester !). De mani\u00e8re g\u00e9n\u00e9rale, dans des probl\u00e8mes complexes les situations d'interblocage sont difficiles \u00e0 d\u00e9tecter et il se peut tr\u00e8s bien que le programme se comporte bien pendant toute une phase de tests mais bloque lors d'une ex\u00e9cution ult\u00e9rieure puisque l'on ne peut pas pr\u00e9voir l'ordonnancement des processus. Simulation d'interblocage\u2693\ufe0e \u2693\ufe0e Robosomes cr\u00e9\u00e9 par Alain BUSSER , S\u00e9bastien HOARAU (Voir ici : Robosomes - IREM de la r\u00e9union Le jeu robosomes se joue \u00e0 un seul joueur sur une grille rectangulaire. Chaque case peut \u00eatre soit vide soit couverte par un obstacle fixe (en noir comme aux mots crois\u00e9s) soit couverte d\u2019un pion pouvant bouger, appel\u00e9 robot Chaque robot peut \u00eatre tourn\u00e9 dans l\u2019une des quatre directions cardinales \u25c0\u25b2\u25b6\u25bc. Les robots peuvent bouger tous en m\u00eame temps de l\u2019une des fa\u00e7ons suivantes : G : tous les robots tournent vers leur gauche (de 90\u00b0) en m\u00eame temps D : tous les robots tournent vers leur droite (de 90\u00b0) en m\u00eame temps A : les robots qui peuvent avancer d\u2019une case, le font. Un robot peut avancer d\u2019une case s\u2019il n\u2019y a pas d\u2019obstacle sur cette case et si aucun robot ne s\u2019appr\u00eate \u00e0 aller sur cette case. Les cases du bord de la grille sont toutes couvertes d\u2019obstacles fixes, \u00e0 l\u2019exception de l\u2019une d\u2019entre elles appel\u00e9e \u00ab sortie \u00bb. Lorsqu\u2019un robot est sur la case de sortie, tourn\u00e9 vers l\u2019ext\u00e9rieur de la grille, il quitte le jeu et n\u2019est plus soumis aux ordres donn\u00e9s. Le but du jeu est de faire sortir tous les robots de la grille, en \u00e9crivant un mot dans l\u2019alphabet A,G,D, appel\u00e9 programme et que les robots interpr\u00e9teront comme d\u00e9crit ci-dessus. Voici quelques exemples : Un premier exemple pour se mettre en route. Interblocage Interblocage 1 Interblocage 2 Interblocage 3 Interblocage 4 Interblocage perp\u00e9tuel ou pas Interblocage 8 Et pour les syst\u00e8mes multiprocesseurs ? \u2693\ufe0e Les ordinateurs actuels poss\u00e8dent g\u00e9n\u00e9ralement plusieurs processeurs, ce qui permet \u00e0 plusieurs processus d'\u00eatre ex\u00e9cut\u00e9s parall\u00e8lement : un par processeur. Ce parall\u00e9lisme permet bien \u00e9videmment une plus grande puissance de calcul. Pour r\u00e9partir les diff\u00e9rents processus entre les diff\u00e9rents processeurs, on distingue deux approches : l'approche partitionn\u00e9e : chaque processeur poss\u00e8de un ordonnanceur particulier et les processus sont r\u00e9partis entre les diff\u00e9rents ordonnanceurs l'approche globale : un ordonnanceur global est charg\u00e9 de d\u00e9terminer la r\u00e9partition des processus entre les diff\u00e9rents processeurs L'ordonnancement des processus des syst\u00e8mes d'exploitation actuels est bien plus complexe que les quelques algorithmes \u00e9voqu\u00e9s dans ce cours, et cela d\u00e9passe largement le cadre du programme de NSI. Si vous souhaitez en savoir plus, voici n\u00e9anmoins une vid\u00e9o int\u00e9ressante (en fran\u00e7ais) sur l'ordonnancement du noyau Linux : https://www.youtube.com/watch?v=uCGe5WWd1OI&t=195s&ab_channel=Vitonimal . Bilan \u2693\ufe0e Un programme en cours d'ex\u00e9cution s'appelle un processus . Les syst\u00e8mes d'exploitation r\u00e9cents permettent d'ex\u00e9cuter plusieurs processus simultan\u00e9ment. En r\u00e9alit\u00e9, ces processus sont ex\u00e9cut\u00e9s \u00e0 tour de r\u00f4le par le syst\u00e8me d'exploitation qui est charg\u00e9 d'allouer \u00e0 chacun d'eux les ressources dont il a besoin en termes de m\u00e9moire, entr\u00e9es-sorties ou temps d'acc\u00e8s au processeur, et de s'assurer que les processus ne se g\u00eanent pas les uns les autres. Au cours de leur vie, les processus varient entre trois \u00e9tats : \u00e9lu si le processus est ex\u00e9cut\u00e9 par le processeur, pr\u00eat si le processus est pr\u00eat \u00e0 \u00eatre ex\u00e9cut\u00e9, et bloqu\u00e9 si le processus est en attente d'une ressource. C'est l' ordonnanceur qui est charg\u00e9 de d\u00e9finir l'ordre dans lequel les processus doivent \u00eatre ex\u00e9cut\u00e9s par le processeur. Ce choix se fait gr\u00e2ce \u00e0 des algorithmes d'ordonnancement. Les processus se partagent les diff\u00e9rentes ressources, on parle d' acc\u00e8s concurrent aux ressources. Ce partage des ressources n'est pas sans risque et peut conduire \u00e0 des probl\u00e8mes de synchronisation. Ces probl\u00e8mes peuvent \u00eatre \u00e9vit\u00e9s en utilisant un verrou , qui permet \u00e0 un processus de ne pas \u00eatre interrompu dans sa section critique par un autre processus demandant le m\u00eame verrou. L'utilisation de plusieurs verrous peut entra\u00eener des interblocages , c'est-\u00e0-dire des situations o\u00f9 chaque processus attend une ressource d\u00e9tenue par un autre, conduisant \u00e0 une attente cyclique infinie. L'ordre d'acquisition des verrous est important mais pas toujours \u00e9vident \u00e0 \u00e9crire dans le cas de probl\u00e8mes complexes. Exercices \u2693\ufe0e Exercice 1 : Algorithmes d'ordonnancement \u2693\ufe0e Soient les diff\u00e9rents processus suivants : Processus Date d'arriv\u00e9e Dur\u00e9e de traitement \\(P_1\\) 0 3 \\(P_2\\) 1 6 \\(P_3\\) 3 4 \\(P_4\\) 6 5 \\(P_5\\) 8 2 Application de plusieurs algorithmes \u2693\ufe0e Q1 : Donnez le diagramme de Gantt pour l'ex\u00e9cution de ces diff\u00e9rents processus en utilisant successivement les algorithmes FCFS, RR (quantum = 2 unit\u00e9s de temps) et SRT. Performances des algorithmes d'ordonnancement \u2693\ufe0e On d\u00e9finit les m\u00e9triques suivantes : le temps de s\u00e9jour (ou d'ex\u00e9cution) (ou de rotation) d'un processus : c'est la diff\u00e9rence entre la date de fin d'ex\u00e9cution et la date d'arriv\u00e9e : \\(T_{\\text{sej}} = \\text{date fin d'ex\u00e9cution} - \\text{date d'arriv\u00e9e}\\) le temps d'attente d'un processus : c'est la diff\u00e9rence entre le temps de s\u00e9jour et la dur\u00e9e du processus : \\(T_{\\text{att}} = T_{\\text{sej}} - \\text{dur\u00e9e du processus}\\) le rendement d'un processus : c'est le quotient entre la dur\u00e9e du processus et le temps de s\u00e9jour : \\(\\text{rendement} = \\dfrac{\\text{dur\u00e9e du processus}}{T_{\\text{sej}}}\\) Q2 : Pour chacun des trois algorithmes, calculez le temps de s\u00e9jour, le temps d'attente et le rendement de chaque processus. Q3 : Quel vous semble \u00eatre le meilleur des trois algorithmes dans notre exemple ? Expliquer. Solution Exercice 2 \u2693\ufe0e cet exercice est issu du sujet 2021 du bac NSI Partie A Cette partie est un questionnaire \u00e0 choix multiples (QCM). Pour chacune des questions, une seule des quatre r\u00e9ponses est exacte. Le candidat indiquera sur sa copie le num\u00e9ro de la question et la lettre correspondant \u00e0 la r\u00e9ponse exacte. Aucune justification n\u2019est demand\u00e9e. Une r\u00e9ponse fausse ou une absence de r\u00e9ponse n\u2019enl\u00e8ve aucun point. 1) Parmi les commandes ci-dessous, laquelle permet d\u2019afficher les processus en cours d\u2019ex\u00e9cution ? \ud83d\udccb Texte a. dir b. ps c. man d. ls 2) Quelle abr\u00e9viation d\u00e9signe l\u2019identifiant d\u2019un processus dans un syst\u00e8me d\u2019exploitation de type UNIX ? \ud83d\udccb Texte a. PIX b. SIG c. PID d. SID 3) Comment s\u2019appelle la gestion du partage du processeur entre diff\u00e9rents processus ? \ud83d\udccb Texte a. L\u2019interblocage b. L\u2019ordonnancement c. La planification d. La priorisation 4) Quelle commande permet d\u2019interrompre un processus dans un syst\u00e8me d\u2019exploitation de type UNIX ? \ud83d\udccb Texte a. stop b. interrupt c. end d. kill Solution 1.b - 2.c - 3.b -4.d Partie B 1) Un processeur choisit \u00e0 chaque cycle d\u2019ex\u00e9cution le processus qui doit \u00eatre ex\u00e9cut\u00e9. Le tableau ci-dessous donne pour trois processus P1, P2, P3 : la dur\u00e9e d\u2019ex\u00e9cution (en nombre de cycles), l\u2019instant d\u2019arriv\u00e9e sur le processeur (exprim\u00e9 en nombre de cycles \u00e0 partir de 0), le num\u00e9ro de priorit\u00e9. Le num\u00e9ro de priorit\u00e9 est d\u2019autant plus petit que la priorit\u00e9 est grande. On suppose qu\u2019\u00e0 chaque instant, c\u2019est le processus qui a le plus petit num\u00e9ro de priorit\u00e9 qui est ex\u00e9cut\u00e9, ce qui peut provoquer la suspension d\u2019un autre processus, lequel reprendra lorsqu\u2019il sera le plus prioritaire. Reproduire le tableau ci-dessous sur la copie et indiquer dans chacune des cases le processus ex\u00e9cut\u00e9 \u00e0 chaque cycle. Correction P3 - P3 - P2 - P1 - P1 - P1 - P2 - P2 - P3 - P3 2) On suppose maintenant que les trois processus pr\u00e9c\u00e9dents s\u2019ex\u00e9cutent et utilisent une ou plusieurs ressources parmi R1, R2 et R3. Parmi les sc\u00e9narios suivants, lequel provoque un interblocage ? Justifier. Correction Il s\u2019agit du sc\u00e9nario 2 car nous nous retrouvons dans la situation o\u00f9 P1 poss\u00e8de R1 et attend R2 avant de pouvoir continuer et P3 poss\u00e8de R2 et attend R1 avant de pouvoir continuer. Partie C Dans cette partie, pour une meilleure lisibilit\u00e9, des espaces sont plac\u00e9es dans les \u00e9critures binaires des nombres. Il ne faut pas les prendre en compte dans les calculs. Pour chiffrer un message, une m\u00e9thode, dite du masque jetable, consiste \u00e0 le combiner avec une cha\u00eene de caract\u00e8res de longueur comparable. Une impl\u00e9mentation possible utilise l\u2019op\u00e9rateur XOR (ou exclusif) dont voici la table de v\u00e9rit\u00e9 : a b a XOR b 0 0 0 0 1 1 1 0 1 1 1 0 Dans la suite, les nombres \u00e9crits en binaire seront pr\u00e9c\u00e9d\u00e9s du pr\u00e9fixe 0b. Q1. Pour chiffrer un message, on convertit chacun de ses caract\u00e8res en binaire (\u00e0 l\u2019aide du format Unicode), et on r\u00e9alise l\u2019op\u00e9ration XOR bit \u00e0 bit avec la cl\u00e9. Apr\u00e8s conversion en binaire, et avant que l\u2019op\u00e9ration XOR bit \u00e0 bit avec la cl\u00e9 n\u2019ait \u00e9t\u00e9 effectu\u00e9e, Alice obtient le message suivant : m = 0b 0110 0011 0100 0110 a. Le message m correspond \u00e0 deux caract\u00e8res cod\u00e9s chacun sur 8 bits : d\u00e9terminer quels sont ces caract\u00e8res. On fournit pour cela la table ci-dessous qui associe \u00e0 l\u2019\u00e9criture hexad\u00e9cimale d\u2019un octet le caract\u00e8re correspondant (figure 2). Exemple de lecture : le caract\u00e8re correspondant \u00e0 l\u2019octet cod\u00e9 4A en hexad\u00e9cimal est la lettre J. Pour chiffrer le message d\u2019Alice, on r\u00e9alise l\u2019op\u00e9ration XOR bit \u00e0 bit avec la cl\u00e9 suivante : k = 0b 1110 1110 1111 0000 Donner l\u2019\u00e9criture binaire du message obtenu. Correction 0b 1000 1101 1011 0110 Q2. a. Dresser la table de v\u00e9rit\u00e9 de l\u2019expression bool\u00e9enne suivante : (a XOR b) XOR b Correction a b (a xor b) xor b 0 0 0 0 1 0 1 0 1 1 1 1 b. Bob conna\u00eet la cha\u00eene de caract\u00e8res utilis\u00e9e par Alice pour chiffrer le message. Quelle op\u00e9ration doit-il r\u00e9aliser pour d\u00e9chiffrer son message ? Correction On peut remarquer que (a xor b) xor b permet de retrouver a, donc si a correspond au message non chiffr\u00e9 et a xor b correspond au message chiffr\u00e9, un (a xor b) xor b permet donc de retrouver le message non chiffr\u00e9. Si on appelle m le message non chiffr\u00e9, m\u2019 le message chiffr\u00e9 et k la cl\u00e9 de chiffrement, un m\u2019 xor k permettra de retrouver m Exercice 3 \u2693\ufe0e d'apr\u00e8s le sujet du bac NSI 2021 Cet exercice porte sur les syst\u00e8mes d\u2019exploitation : gestion des processus et des ressources. Les parties A et B peuvent \u00eatre trait\u00e9es ind\u00e9pendamment Partie A : Dans un bureau d\u2019architectes, on dispose de certaines ressources qui ne peuvent \u00eatre utilis\u00e9es simultan\u00e9ment par plus d\u2019un processus, comme l\u2019imprimante, la table tra\u00e7ante, le modem. Chaque programme, lorsqu\u2019il s\u2019ex\u00e9cute, demande l\u2019allocation des ressources qui lui sont n\u00e9cessaires. Lorsqu\u2019il a fini de s\u2019ex\u00e9cuter, il lib\u00e8re ses ressources. On appelle p1, p2 et p3 les processus associ\u00e9s respectivement aux programmes 1, 2 et 3. Q.1. Justifier qu'une situation d'interblocage peut se produire. Correction Pour passer \u00e0 l\u2019ex\u00e9cution, le Programme 1 a besoin du modem, mais le modem est d\u00e9j\u00e0 utilis\u00e9 par le Programme 2. Le processus p1 est donc bloqu\u00e9. Pour passer \u00e0 l\u2019ex\u00e9cution, le Programme 2 a besoin de l\u2019imprimante, mais l\u2019imprimante est d\u00e9j\u00e0 utilis\u00e9e par le Programme 3. Le processus p2 est donc bloqu\u00e9. Pour passer \u00e0 l\u2019ex\u00e9cution, le Programme 3 a besoin de la table tra\u00e7ante, mais la table tra\u00e7ante est d\u00e9j\u00e0 utilis\u00e9e par le Programme 1. Le processus p3 est donc bloqu\u00e9. Les 3 processus sont bloqu\u00e9s et ne pourront pas lib\u00e9rer les ressources attendues par les autres processus (la lib\u00e9ration des ressources se faisant apr\u00e8s l\u2019ex\u00e9cution), nous sommes bien en situation d\u2019interblocage. Q.2. Modifier l'ordre des instructions du programme 3 pour qu'une telle situation ne puisse pas se produire. Correction Programme 3 demander (table tra\u00e7ante) demander (imprimante) ex\u00e9cution lib\u00e9rer (imprimante) lib\u00e9rer (table tra\u00e7ante)bb Q.3 Supposons que le processus p1 demande la table tra\u00e7ante alors qu'elle est en cours d'utilisation par le processus p3. Parmi les \u00e9tats suivants, quel sera l'\u00e9tat du processus p1 tant que la table tra\u00e7ante n'est pas disponible : a) \u00e9lu b) bloqu\u00e9 c) pr\u00eat d) termin\u00e9 Correction bloqu\u00e9 Partie B Avec une ligne de commande dans un terminal sous Linux, on obtient l'affichage suivant : La documentation Linux donne la signification des diff\u00e9rents champs : UID : identifiant utilisateur effectif ; PID : identifiant de processus ; PPID : PID du processus parent ; C : partie enti\u00e8re du pourcentage d'utilisation du processeur par rapport au temps de vie des processus ; STIME : l'heure de lancement du processus ; TTY : terminal de contr\u00f4le TIME : temps d'ex\u00e9cution CMD : nom de la commande du processus Q.1. Parmi les quatre commandes suivantes, laquelle a permis cet affichage ? a) ls -l b) ps \u2013ef c) cd .. d) chmod 741 processus.txt Correction ps -ef Q.2. Quel est l'identifiant du processus parent \u00e0 l'origine de tous les processus concernant le navigateur Web (chromium-browser) ? Correction L\u2019identifiant du processus parent \u00e0 l\u2019origine de tous les processus concernant le navigateur Web est 831 Q.3. Quel est l'identifiant du processus dont le temps d'ex\u00e9cution est le plus long ? Correction L\u2019identifiant du processus dont le temps d\u2019ex\u00e9cution est le plus long est 6211 (00:01:16) Exercice 4 \u2693\ufe0e Extrait sujet BAC 2021 Cet exercice porte sur la gestion des processus par un syst\u00e8me d\u2019exploitation. Partie A : Processus La commande UNIX ps pr\u00e9sente un clich\u00e9 instantan\u00e9 des processus en cours d'ex\u00e9cution. Avec l\u2019option \u2212eo pid,ppid,stat,command, cette commande affiche dans l\u2019ordre l\u2019identifiant du processus PID (process identifier), le PPID (parent process identifier), l\u2019\u00e9tat STAT et le nom de la commande \u00e0 l\u2019origine du processus. Les valeurs du champ STAT indique l\u2019\u00e9tat des processus : - R : processus en cours d\u2019ex\u00e9cution - S : processus endormi Sur un ordinateur, on ex\u00e9cute la commande ps \u2212eo pid,ppid,stat,command et on obtient un affichage dont on donne ci-dessous un extrait. \u00c0 l'aide de cet affichage, r\u00e9pondre aux questions ci-dessous. Q.1. Quel est le nom de la premi\u00e8re commande ex\u00e9cut\u00e9e par le syst\u00e8me d'exploitation lors du d\u00e9marrage ? Correction La premi\u00e8re commande ex\u00e9cut\u00e9e par le syst\u00e8me d\u2019exploitation lors du d\u00e9marrage est la commande init Q.2. Quels sont les identifiants des processus actifs sur cet ordinateur au moment de l\u2019appel de la commande ps ? Justifier la r\u00e9ponse. Correction Les processus actifs sont les processus ayant pour PID 5440 et 5450 (pr\u00e9sence de l\u2019indicateur R dans la colonne STAT pour ces 2 processus). Q.3. Depuis quelle application a-t-on ex\u00e9cut\u00e9 la commande ps ? Donner les autres commandes qui ont \u00e9t\u00e9 ex\u00e9cut\u00e9es \u00e0 partir de cette application. Correction La commande ps a \u00e9t\u00e9 ex\u00e9cut\u00e9e depuis l\u2019application Bash (car le processus ps a pour PPID 1912 qui correspond au PID de Bash). Deux autres processus Bash (PID 2014 et PID 2013) et un processus python programme1.py (PID 5437) ont \u00e9t\u00e9 lanc\u00e9s depuis le processus Bash de PID 1912 Q.4. Expliquer l'ordre dans lequel les deux commandes python programme1.py et python programme2.py ont \u00e9t\u00e9 ex\u00e9cut\u00e9es. Correction Le processus python programme1.py a un PID de 5437 alors que le processus python programme2.py a un PID de 5440. python programme1.py a \u00e9t\u00e9 ex\u00e9cut\u00e9 avant python programme2.py. Q.5. Peut-on pr\u00e9dire que l'une des deux commandes python programme1.py et python programme2.py finira avant l\u2019autre ? Correction Non, aucune pr\u00e9diction n\u2019est possible.","title":"TD Gestion Processus copy"},{"location":"Processus/TD_Gestion_Processus%20copy/#introduction","text":"Dans les ann\u00e9es 1970 les ordinateurs personnels \u00e9taient incapables d'ex\u00e9cuter plusieurs t\u00e2ches \u00e0 la fois : il fallait attendre qu'un programme lanc\u00e9 se termine pour en ex\u00e9cuter un autre. Les syst\u00e8mes d'exploitations r\u00e9cents (GNU/Linux, macOS, iOS, Android, Windows...) permettent d'ex\u00e9cuter des t\u00e2ches \"simultan\u00e9ment\". En effet, la plupart du temps, lorsque l'on utilise un ordinateur, plusieurs programmes sont ex\u00e9cut\u00e9s \"en m\u00eame temps\" : par exemple, on peut tr\u00e8s bien ouvrir simultan\u00e9ment un navigateur Web, un traitement de texte, un IDE Python, un logiciel de musique (sans parler de tous les programmes ex\u00e9cut\u00e9s en arri\u00e8re-plan) ... Ces programmes en cours d'ex\u00e9cution s'appellent des processus . Une des t\u00e2ches du syst\u00e8me d'exploitation est d'allouer \u00e0 chacun des processus les ressources dont il a besoin en termes de m\u00e9moire, entr\u00e9es-sorties ou temps d'acc\u00e8s au processeur, et de s'assurer que les processus ne se g\u00eanent pas les uns les autres. Pourtant, on rappelle qu'un programme n'est qu'une suite d'instructions machine ex\u00e9cut\u00e9es l'une apr\u00e8s l'autre par le processeur et qu'un processeur n'est capable d'ex\u00e9cuter qu'une seule instruction \u00e0 la fois. Pour rappel, voici les \u00e9tapes d'ex\u00e9cution d'une instruction. l'instruction point\u00e9e par le pointeur d'instruction est charg\u00e9e en m\u00e9moire Le pointeur d'instruction est incr\u00e9ment\u00e9 vers l'adresse suivante l'instruction est d\u00e9cod\u00e9e l'instruction est ex\u00e9cut\u00e9e Comment est-il alors possible que plusieurs programmes soient ex\u00e9cut\u00e9s en m\u00eame temps ?","title":"Introduction"},{"location":"Processus/TD_Gestion_Processus%20copy/#processus","text":"","title":"Processus"},{"location":"Processus/TD_Gestion_Processus%20copy/#gestion-des-processus-et-des-ressources","text":"","title":"Gestion des processus et des ressources"},{"location":"Processus/TD_Gestion_Processus%20copy/#problemes-lies-a-lacces-concurrent-aux-ressources","text":"Les processus se partagent souvent une ou plusieurs ressources, et cela peut poser des probl\u00e8mes.","title":"Probl\u00e8mes li\u00e9s \u00e0 l'acc\u00e8s concurrent aux ressources"},{"location":"Processus/TD_Gestion_Processus%20copy/#et-pour-les-systemes-multiprocesseurs","text":"Les ordinateurs actuels poss\u00e8dent g\u00e9n\u00e9ralement plusieurs processeurs, ce qui permet \u00e0 plusieurs processus d'\u00eatre ex\u00e9cut\u00e9s parall\u00e8lement : un par processeur. Ce parall\u00e9lisme permet bien \u00e9videmment une plus grande puissance de calcul. Pour r\u00e9partir les diff\u00e9rents processus entre les diff\u00e9rents processeurs, on distingue deux approches : l'approche partitionn\u00e9e : chaque processeur poss\u00e8de un ordonnanceur particulier et les processus sont r\u00e9partis entre les diff\u00e9rents ordonnanceurs l'approche globale : un ordonnanceur global est charg\u00e9 de d\u00e9terminer la r\u00e9partition des processus entre les diff\u00e9rents processeurs L'ordonnancement des processus des syst\u00e8mes d'exploitation actuels est bien plus complexe que les quelques algorithmes \u00e9voqu\u00e9s dans ce cours, et cela d\u00e9passe largement le cadre du programme de NSI. Si vous souhaitez en savoir plus, voici n\u00e9anmoins une vid\u00e9o int\u00e9ressante (en fran\u00e7ais) sur l'ordonnancement du noyau Linux : https://www.youtube.com/watch?v=uCGe5WWd1OI&t=195s&ab_channel=Vitonimal .","title":"Et pour les syst\u00e8mes multiprocesseurs ?"},{"location":"Processus/TD_Gestion_Processus%20copy/#bilan","text":"Un programme en cours d'ex\u00e9cution s'appelle un processus . Les syst\u00e8mes d'exploitation r\u00e9cents permettent d'ex\u00e9cuter plusieurs processus simultan\u00e9ment. En r\u00e9alit\u00e9, ces processus sont ex\u00e9cut\u00e9s \u00e0 tour de r\u00f4le par le syst\u00e8me d'exploitation qui est charg\u00e9 d'allouer \u00e0 chacun d'eux les ressources dont il a besoin en termes de m\u00e9moire, entr\u00e9es-sorties ou temps d'acc\u00e8s au processeur, et de s'assurer que les processus ne se g\u00eanent pas les uns les autres. Au cours de leur vie, les processus varient entre trois \u00e9tats : \u00e9lu si le processus est ex\u00e9cut\u00e9 par le processeur, pr\u00eat si le processus est pr\u00eat \u00e0 \u00eatre ex\u00e9cut\u00e9, et bloqu\u00e9 si le processus est en attente d'une ressource. C'est l' ordonnanceur qui est charg\u00e9 de d\u00e9finir l'ordre dans lequel les processus doivent \u00eatre ex\u00e9cut\u00e9s par le processeur. Ce choix se fait gr\u00e2ce \u00e0 des algorithmes d'ordonnancement. Les processus se partagent les diff\u00e9rentes ressources, on parle d' acc\u00e8s concurrent aux ressources. Ce partage des ressources n'est pas sans risque et peut conduire \u00e0 des probl\u00e8mes de synchronisation. Ces probl\u00e8mes peuvent \u00eatre \u00e9vit\u00e9s en utilisant un verrou , qui permet \u00e0 un processus de ne pas \u00eatre interrompu dans sa section critique par un autre processus demandant le m\u00eame verrou. L'utilisation de plusieurs verrous peut entra\u00eener des interblocages , c'est-\u00e0-dire des situations o\u00f9 chaque processus attend une ressource d\u00e9tenue par un autre, conduisant \u00e0 une attente cyclique infinie. L'ordre d'acquisition des verrous est important mais pas toujours \u00e9vident \u00e0 \u00e9crire dans le cas de probl\u00e8mes complexes.","title":"Bilan"},{"location":"Processus/TD_Gestion_Processus%20copy/#exercices","text":"","title":"Exercices"},{"location":"Processus/TD_Gestion_Processus/","text":"Th\u00e8me 3 : Architecture mat\u00e9rielle 23 Cours : Gestion des processus Introduction \u2693\ufe0e Dans les ann\u00e9es 1970 les ordinateurs personnels \u00e9taient incapables d'ex\u00e9cuter plusieurs t\u00e2ches \u00e0 la fois : il fallait attendre qu'un programme lanc\u00e9 se termine pour en ex\u00e9cuter un autre. Les syst\u00e8mes d'exploitations r\u00e9cents (GNU/Linux, macOS, iOS, Android, Windows...) permettent d'ex\u00e9cuter des t\u00e2ches \"simultan\u00e9ment\". En effet, la plupart du temps, lorsque l'on utilise un ordinateur, plusieurs programmes sont ex\u00e9cut\u00e9s \"en m\u00eame temps\" : par exemple, on peut tr\u00e8s bien ouvrir simultan\u00e9ment un navigateur Web, un traitement de texte, un IDE Python, un logiciel de musique (sans parler de tous les programmes ex\u00e9cut\u00e9s en arri\u00e8re-plan) ... Ces programmes en cours d'ex\u00e9cution s'appellent des processus . Une des t\u00e2ches du syst\u00e8me d'exploitation est d'allouer \u00e0 chacun des processus les ressources dont il a besoin en termes de m\u00e9moire, entr\u00e9es-sorties ou temps d'acc\u00e8s au processeur, et de s'assurer que les processus ne se g\u00eanent pas les uns les autres. Pourtant, on rappelle qu'un programme n'est qu'une suite d'instructions machine ex\u00e9cut\u00e9es l'une apr\u00e8s l'autre par le processeur et qu'un processeur n'est capable d'ex\u00e9cuter qu'une seule instruction \u00e0 la fois. Pour rappel, voici les \u00e9tapes d'ex\u00e9cution d'une instruction. l'instruction point\u00e9e par le pointeur d'instruction est charg\u00e9e en m\u00e9moire Le pointeur d'instruction est incr\u00e9ment\u00e9 vers l'adresse suivante l'instruction est d\u00e9cod\u00e9e l'instruction est ex\u00e9cut\u00e9e Comment est-il alors possible que plusieurs programmes soient ex\u00e9cut\u00e9s en m\u00eame temps ? Processus \u2693\ufe0e Qu'est-ce qu'un processus ? \u2693\ufe0e Il ne faut pas confondre programme et processus : Un programme est un fichier binaire (on dit aussi un ex\u00e9cutable ) contenant des instructions machines que seul le processeur peut comprendre. Un processus est un programme en cours d'ex\u00e9cution , autrement dit le ph\u00e9nom\u00e8ne dynamique li\u00e9 \u00e0 l'ex\u00e9cution d'un programme par l'ordinateur. Ainsi, lorsque nous cliquons sur l'ic\u00f4ne d'un programme (ou lorsque nous ex\u00e9cutons une instruction dans la console pour lancer un programme), nous provoquons la naissance d'un ou plusieurs processus li\u00e9s au programme que nous lan\u00e7ons. Un processus est donc une instance d'un programme auquel est associ\u00e9 : du code des donn\u00e9es/variables manipul\u00e9es des ressources : processeur, m\u00e9moire, p\u00e9riph\u00e9riques d'entr\u00e9e/sortie (voir paragraphe suivant) Il n'est d'ailleurs pas rare qu'un m\u00eame programme soit ex\u00e9cut\u00e9 plusieurs fois sur une machine au m\u00eame moment en occupant des espaces m\u00e9moires diff\u00e9rents : par exemple deux documents ouverts avec un traitement de texte, ou trois consoles distinctes... qui correspondent \u00e0 autant d'instances du m\u00eame programme et donc \u00e0 des processus diff\u00e9rents. Observer les processus \u2693\ufe0e Il est tr\u00e8s facile de voir les diff\u00e9rents processus s'ex\u00e9cutant sur une machine. Sous GNU/Linux, on peut utiliser la commande ps (comme p roces s , la traduction anglaise de processus ) pour afficher les informations sur les processus (sous windows : talklist). En passant des options \u00e0 cette commande on peut obtenir des choses int\u00e9ressantes. Par exemple, en ex\u00e9cutant dans un terminal la commande ps -aef , on peut visualiser tous les processus en cours sur notre ordinateur : Cr\u00e9ation d'un processus \u2693\ufe0e Un processus peut \u00eatre cr\u00e9\u00e9 : au d\u00e9marrage du syst\u00e8me par un autre processus par une action d'un utilisateur (lancement d'un programme) Sous GNU/Linux, un tout premier processus est cr\u00e9\u00e9 au d\u00e9marrage (c'est le processus 0 ou encore Swapper ). Ce processus cr\u00e9e un processus souvent appel\u00e9 init qui est le fils du processus 0. Ensuite, \u00e0 partir de init , les autres processus n\u00e9cessaires au fonctionnement du syst\u00e8me sont cr\u00e9\u00e9s. Ces processus cr\u00e9ent ensuite eux-m\u00eames d'autres processus, etc. Un processus peut cr\u00e9er un ou plusieurs processus, ce qui aboutit \u00e0 une structure arborescente comme nous allons le voir maintenant. PID et PPID \u2693\ufe0e La commande pr\u00e9c\u00e9dente permet de voir que chaque processus est identifi\u00e9 par un num\u00e9ro : son PID (pour Process Identifier ). Ce num\u00e9ro est donn\u00e9 \u00e0 chaque processus par le syst\u00e8me d'exploitation. On constate \u00e9galement que chaque processus poss\u00e8de un PPID (pour Parent Process Identifier ), il s'agit du PID du processus parent, c'est-\u00e0-dire celui qui a d\u00e9clench\u00e9 la cr\u00e9ation du processus. En effet, un processus peut cr\u00e9er lui m\u00eame un ou plusieurs autres processus, appel\u00e9s processus fils . Observation des processus\u2693\ufe0e \u2693\ufe0e Sous Linux, on peut observer les processus et leur \u00e9tat en ligne de commande. Pour tester, cela on peut utiliser : terminal linux en ligne Voici quelques commandes utiles pour observer les processus : ps |: elle permet d'afficher la liste des processus en cours. (Pour avoir des informations sur les options taper man ps) Pour lister tous les processus : ps - ef top : Pour observer en temps r\u00e9els les diff\u00e9rents processus.(penser \u00e0 utiliser man top) la commande f permet de g\u00e9rer les colonnes affich\u00e9es. kill : elle permet de tuer un processus en lui envoyant un signal de fin. 15 pour arr\u00eater le processus proprement 9 pour arr\u00eater imm\u00e9diatement le processus. exemple d'utilisation : kill -15 7654 pour tuer proprement le processus de PID 7564 Exercice Dans un nouvel onglet ouvrir : terminal linux en ligne cr\u00e9er un premier terminal : utiliser les commandes de l'ann\u00e9e pr\u00e9c\u00e9dentes : ls, cd, touch, cat pour d\u00e9terminer le nom d'utilisateur : whoami cr\u00e9er un fichier vide test.py : touch test.py \u00e9diter le fichier test.py avec la commande : nano test.py y \u00e9crire le code suivant : python for a in range(100000): print(a) pour sortir de l'\u00e9diteur : Ctrl+X, puis Y, puis Enter pour confirmer le nom lancer le programme avec : python3 test.py cr\u00e9er un second fichier p2.py avec le code suivant : \ud83d\udc0d Script Python while True : pass le lancer Il tourne sans fin. Pour l'arr\u00eater : Ctrl+C v\u00e9rifier la pr\u00e9sence dans le dossier des fichiers cr\u00e9\u00e9s, avec ls ouvrir un second terminal puis : dans ce second terminal lancer python3 sans nom de fichier dans le premier terminal taper ps -ef rep\u00e9rer le PID du processus python3 et le tuer avec la commande kill -9 (voir syntaxe au dessus) ouvrir un troisi\u00e8me terminal dans ce troisi\u00e8me terminal lancer la commande top modifier l'affichage pour faire appara\u00eetre le PPID (taper f, puis s\u00e9lectionner/ d\u00e9placer avec les touches curseur. Revenir \u00e0 l'affichage avec Esc) Enfin ouvrir des terminaux suppl\u00e9mentaires pour en avoir au moins 5 et lancer dans les terminaux : 1 aucun processus 1 avec nano 1 avec python3 1 avec python3 lan\u00e7ant p2.py 1 avec top observer les processus et essayer de les tuer avec la commande kill \u00e0 partir du premier terminal recommencer en relan\u00e7ant les processus et tuer les processus avec le terminal lan\u00e7ant top(puis commande k) Gestion des processus et des ressources \u2693\ufe0e Ex\u00e9cution concurrente \u2693\ufe0e Les syst\u00e8mes d'exploitation modernes sont capable d'ex\u00e9cuter plusieurs processus \"en m\u00eame temps\". En r\u00e9alit\u00e9 ces processus ne sont pas toujours ex\u00e9cut\u00e9s \"en m\u00eame temps\" mais plut\u00f4t \"\u00e0 tour de r\u00f4le\". On parle d'ex\u00e9cution concurrente car les processus sont en concurrence pour obtenir l'acc\u00e8s au processeur charg\u00e9 de les ex\u00e9cuter. Remarque : Sur un syst\u00e8me multiprocesseur, il est possible d'ex\u00e9cuter de mani\u00e8re parall\u00e8le plusieurs processus, autant qu'il y a de processeurs. Mais sur un m\u00eame processeur, un seul processus ne peut \u00eatre ex\u00e9cut\u00e9 \u00e0 la fois. On peut voir assez facilement cette ex\u00e9cution concurrente. Consid\u00e9rons les deux programmes Python suivants : progA.py \ud83d\udc0d Script Python import time for i in range ( 100 ): print ( \"programme A en cours, it\u00e9ration\" , i ) time . sleep ( 0.01 ) # pour simuler un traitement avec des calculs progB.py \ud83d\udc0d Script Python import time for i in range ( 100 ): print ( \"programme B en cours, it\u00e9ration\" , i ) time . sleep ( 0.01 ) # pour simuler un traitement avec des calculs En ouvrant un Terminal, on peut lancer simultan\u00e9ment ces deux programmes avec la commande Bash $ python progA.py & python progB.py & Le caract\u00e8re & qui suit une commande permet de lancer l'ex\u00e9cution en arri\u00e8re plan et de rendre la main au terminal. Le shell indique alors dans la console les PID des processus correspondant \u00e0 l'ex\u00e9cution de ces deux programmes (ici 9154 et 9155) puis on constate gr\u00e2ce aux affichages que le syst\u00e8me d'exploitation alloue le processeur aux deux programmes \u00e0 tour de r\u00f4le : Acc\u00e8s concurrents aux ressources \u2693\ufe0e Une ressource est une entit\u00e9 dont a besoin un processus pour s'ex\u00e9cuter. Les ressources peuvent \u00eatre mat\u00e9rielles (processeur, m\u00e9moire, p\u00e9riph\u00e9riques d'entr\u00e9e/sortie, ...) mais aussi logicielles (variables). Les diff\u00e9rents processus se partagent les ressources, on parle alors d' acc\u00e8s concurrents aux ressources . Par exemple, les processus se partagent tous l'acc\u00e8s \u00e0 la ressource \"processeur\" un traitement de texte et un IDE Python se partagent la ressource \"clavier\" ou encore la ressource \"disque dur\" (si on enregistre les fichiers), ... un navigateur et un logiciel de musique se partagent la ressource \"carte son\", ... C'est le syst\u00e8me d'exploitation qui est charg\u00e9 de g\u00e9rer les processus et les ressources qui leur sont n\u00e9cessaires, en partageant leur acc\u00e8s au processeur. Nous allons voir comment tout de suite ! \u00c9tats d'un processus \u2693\ufe0e Au cours de son existence, un processus peut se retrouver dans trois \u00e9tats : \u00e9tat \u00e9lu : lorsqu'il est en cours d'ex\u00e9cution, c'est-\u00e0-dire qu'il obtient l'acc\u00e8s au processeur \u00e9tat pr\u00eat : lorsqu'il attend de pouvoir acc\u00e9der au processeur \u00e9tat en bloqu\u00e9 : lorsque le processus est interrompu car il a besoin d'attendre une ressource quelconque (entr\u00e9e/sortie, allocation m\u00e9moire, etc.) Il est important de comprendre que le processeur ne peut g\u00e9rer qu'un seul processus \u00e0 la fois : le processus \u00e9lu . En pratique, lorsqu'un processus est cr\u00e9\u00e9 il est dans l'\u00e9tat pr\u00eat et attend de pouvoir acc\u00e9der au processeur (d'\u00eatre \u00e9lu ). Lorsqu'il est \u00e9lu, le processus est ex\u00e9cut\u00e9 par le processeur mais cette ex\u00e9cution peut \u00eatre interrompue : soit pour laisser la main \u00e0 un autre processus (qui a \u00e9t\u00e9 \u00e9lu) : dans ce cas, le processus de d\u00e9part repasse dans l'\u00e9tat pr\u00eat et doit attendre d'\u00eatre \u00e9lu pour reprendre son ex\u00e9cution soit parce que le processus en cours a besoin d'attendre une ressource : dans ce cas, le processus passe dans l'\u00e9tat bloqu\u00e9 . Lorsque le processus bloqu\u00e9 finit par obtenir la ressource attendue, il peut th\u00e9oriquement reprendre son ex\u00e9cution mais probablement qu'un autre processus a pris sa place et est pass\u00e9 dans l'\u00e9tat \u00e9lu. Auquel cas, le processus qui vient d'\u00eatre \"d\u00e9bloqu\u00e9\" repasse dans l'\u00e9tat pr\u00eat en attendant d'\u00eatre \u00e0 nouveau \u00e9lu. Ainsi, l'\u00e9tat d'un processus au cours de sa vie varie entre les \u00e9tats pr\u00eat , \u00e9lu et bloqu\u00e9 comme le r\u00e9sume le sch\u00e9ma suivant : Lorsqu'un processus est interrompu, il doit pouvoir reprendre \u00e0 l'endroit m\u00eame o\u00f9 il a \u00e9t\u00e9 interrompu. Pour cela, le syst\u00e8me d'exploitation conserve pour chaque processus cr\u00e9\u00e9 une zone m\u00e9moire (appel\u00e9e PCB, pour Process Control Bloc , ou bloc de contr\u00f4le du processus) dans laquelle sont stock\u00e9es les informations sur le processus : son PIB, son \u00e9tat, la valeur des registres lors de sa derni\u00e8re interruption, la zone m\u00e9moire allou\u00e9e par le processus lors de son ex\u00e9cution, les ressources utilis\u00e9es par le processus (fichiers ouverts, connexions r\u00e9seaux en cours d'utilisation, etc.). Ordonnancement \u2693\ufe0e C'est le syst\u00e8me d'exploitation qui attribue aux processus leurs \u00e9tats \u00e9lu , pr\u00eat et bloqu\u00e9 . Plus pr\u00e9cis\u00e9ment, c'est l' ordonnanceur (un des composants du syst\u00e8me d'exploitation) qui r\u00e9alise cette t\u00e2che appel\u00e9e ordonnancement des processus . L'objectif de l'ordonnanceur est de choisir le processus \u00e0 ex\u00e9cuter \u00e0 l'instant \\(t\\) (le processus \u00e9lu ) et d\u00e9terminer le temps durant lequel le processeur lui sera allou\u00e9. Ce choix est \u00e0 faire parmi tous les processus qui sont dans l'\u00e9tat pr\u00eat , mais lequel sera \u00e9lu ? et pour combien de temps ? Des algorithmes d'ordonnancement sont utilis\u00e9s et il en existe plusieurs selon la strat\u00e9gie utilis\u00e9e. On en pr\u00e9sente quelques-uns ci-dessous. Ordonnancement First Come First Served (FCFS) \u2693\ufe0e Principe : Les processus sont ordonnanc\u00e9s selon leur ordre d'arriv\u00e9e (\"premier arriv\u00e9, premier servi\" en fran\u00e7ais) Exemple : Les processus \\(P_1(53)\\) , \\(P_2(17)\\) , \\(P_3(68)\\) et \\(P_4(24)\\) arrivent dans cet ordre \u00e0 \\(t=0\\) : Cela signifie que \\(P_1\\) , \\(P_2\\) , \\(P_3\\) et \\(P_4\\) ont besoin de respectivement 53, 17, 68 et 24 unit\u00e9s de temps pour s'ex\u00e9cuter. Ordonnancement Shortest Job First (SJF) \u2693\ufe0e Principe : Le processus dont le temps d'ex\u00e9cution est le plus court est ordonnanc\u00e9 en premier. Exemple : \\(P_1\\) , \\(P_2\\) , \\(P_3\\) et \\(P_4\\) arrivent \u00e0 \\(t=0\\) : Ordonnancement Shortest Remaining Time (SRT) \u2693\ufe0e Principe : Le processus dont le temps d'ex\u00e9cution restant est le plus court parmi ceux qui restent \u00e0 ex\u00e9cuter est ordonnanc\u00e9 en premier. Exemple : \\(P_3\\) et \\(P_4\\) arrivent \u00e0 \\(t=0\\) ; \\(P_2\\) \u00e0 \\(t=20\\) ; \\(P_1\\) \u00e0 \\(t=50\\) : Ordonnancement temps-partag\u00e9 (Round-Robin) \u2693\ufe0e Principe : C'est la politique du tourniquet : allocation du processeur par tranche (= quantum \\(q\\) ) de temps. Exemple : quantum \\(q = 20\\) et \\(n = 4\\) processus Dans ce cas, s'il y a \\(n\\) processus, chacun d'eux obtient le processeur au bout de \\((n-1)\\times q\\) unit\u00e9s de temps au plus Ordonnancement \u00e0 priorit\u00e9s statiques \u2693\ufe0e Principe : Allocation du processeur selon des priorit\u00e9s statiques (= num\u00e9ros affect\u00e9s aux processus pour toute la vie de l'application) Exemple : priorit\u00e9s \\((P_1, P_2, P_3, P_4) = (3, 2, 0, 1)\\) o\u00f9 la priorit\u00e9 la plus forte est 0 (attention, dans certains syst\u00e8mes c'est l'inverse : 0 est alors la priorit\u00e9 la plus faible) Probl\u00e8mes li\u00e9s \u00e0 l'acc\u00e8s concurrent aux ressources \u2693\ufe0e Les processus se partagent souvent une ou plusieurs ressources, et cela peut poser des probl\u00e8mes. Probl\u00e8mes de synchronisation : illustration avec Python \u2693\ufe0e Exemple d'une variable partag\u00e9e \u2693\ufe0e Prenons l'exemple d'une variable (= ressource logicielle) partag\u00e9e entre plusieurs processus. Plus pr\u00e9cis\u00e9ment, consid\u00e9rons un programme de jeu multi-joueur dans lequel une variable nb_pions repr\u00e9sente le nombre de pions disponibles pour tous les joueurs. Une fonction prendre_un_pion() permet de prendre un pion dans le tas commun de pions disponibles, s'il reste au moins un pion \u00e9videmment. On va se mettre dans la situation o\u00f9 il ne reste plus qu'un pion dans le tas commun et on suppose que deux joueurs utilisent la fonction prendre_un_pion() , ce qui conduit \u00e0 la cr\u00e9ation de deux processus p1 et p2 , chacun correspondant \u00e0 un joueur. Avec Python, on peut utiliser le module multiprocessing pour cr\u00e9er des processus. Le programme Python pions.py suivant permet de r\u00e9aliser la situation de jeu d\u00e9crite : \ud83d\udc0d Script Python from multiprocessing import Process , Value import time def prendre_un_pion ( nombre ): if nombre . value >= 1 : time . sleep ( 0.001 ) # pour simuler un traitement avec des calculs temp = nombre . value nombre . value = temp - 1 # on d\u00e9cr\u00e9mente le nombre de pions if __name__ == '__main__' : # cr\u00e9ation de la variable partag\u00e9e initialis\u00e9e \u00e0 1 nb_pions = Value ( 'i' , 1 ) # on cr\u00e9e deux processus p1 = Process ( target = prendre_un_pion , args = [ nb_pions ]) p2 = Process ( target = prendre_un_pion , args = [ nb_pions ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () print ( \"nombre final de pions :\" , nb_pions . value ) Explications : Le if __name__ = '__main'__: permet de ne cr\u00e9er qu'une seule fois les processus p1 et p2 qui suivent (c'est n\u00e9cessaire sous Windows, pas sous GNU/Linux car la cr\u00e9ation des processus ne se fait pas de la m\u00eame mani\u00e8re, mais cela reste conseill\u00e9 ne serait-ce que pour des raisons de compatibilit\u00e9), on n'en dira pas davantage ici car cela d\u00e9passe le niveau de ce cours. On a utilis\u00e9 la classe Process du module multiprocessing pour instancier deux processus p1 et p2 . L'argument target est le nom de la fonction qui sera ex\u00e9cut\u00e9e par le processus : ici les deux processus doivent ex\u00e9cuter la m\u00eame fonction prendre_un_pion() L'argument args est une liste des arguments pass\u00e9s \u00e0 la fonction cible : ici il s'agit de la variable nb_pions qui est partag\u00e9e par les deux processus. Par d\u00e9faut, deux processus ne partagent pas de donn\u00e9es en m\u00e9moire : on ne peut pas donc pas utiliser nb_pions comme une variable globale. Il faut utiliser la classe Value du module multiprocessing pour cr\u00e9er nb_pions dans une m\u00e9moire partag\u00e9e entre les processus. L'argument 'i' indique que nb_pions est un entier (sign\u00e9) et le deuxi\u00e8me argument est la valeur initiale de la variable, ici 1. La fonction prendre_un_pion() prend un nombre en param\u00e8tre et d\u00e9cr\u00e9mente sa valeur d'une unit\u00e9 si le nombre est au moins \u00e9gal \u00e0 1. Lors de l'ex\u00e9cution de la fonction par les deux processus, l'argument en question sera l'objet nb_pions de la classe Value et on acc\u00e8de \u00e0 sa valeur avec l'attribut value . On a ajout\u00e9 une temporisation permettant de simuler d'autres calculs qui pourraient avoir lieu (par exemple, des instructions de mise \u00e0 jour du nombre de pions des joueurs) Les derni\u00e8res lignes permettent de d\u00e9marrer les deux processus et attendre qu'ils soient termin\u00e9s pour afficher la valeur finale de nb_pions . Si on ex\u00e9cute ce programme, les deux processus p1 et p2 sont ex\u00e9cut\u00e9s et on s'attend au comportement suivant (en supposant qu'il ne reste qu'un seule pion dans le tas commun) : l'un des deux est \u00e9lu en premier, par exemple p1 , et ex\u00e9cute la fonction prendre_un_pion() , le nombre de pions est \u00e9gal \u00e0 1 donc nb_pions est d\u00e9cr\u00e9ment\u00e9 d'une unit\u00e9 et prend donc la valeur 0, le processus p1 est termin\u00e9 ; le processus p2 , qui \u00e9tait en attente, est ensuite \u00e9lu, et comme le nombre de pions est d\u00e9sormais \u00e9gal \u00e0 0 rien ne se passe et p2 termine. Ainsi, le premier joueur a pu prendre le pion restant et le second s'est retrouv\u00e9 coinc\u00e9, et la valeur finale de nb_pions vaut 0. Et pourtant, il est tout \u00e0 fait possible que les choses ne se passent pas ainsi ! En effet, en ex\u00e9cutant plusieurs fois le programme pions.py dans un terminal, on obtient parfois une valeur finale \u00e9gale \u00e0 0 et parfois \u00e9gale \u00e0 -1 : C'est un r\u00e9sultat tr\u00e8s perturbant non ? Expliquons pourquoi ! Pour cela, on peut ajouter quelques instructions d'affichage pour suivre ce qu'il se passe. On obtient le script pions_v2.py suivant : \ud83d\udc0d Script Python from multiprocessing import Process , Value import time def prendre_un_pion ( nombre , numero_processus ): print ( f \"d\u00e9but du processus { numero_processus } \" ) if nombre . value >= 1 : print ( f \"processus { numero_processus } : \u00e9tape A\" ) time . sleep ( 0.001 ) # pour simuler un traitement avec des calculs print ( f \"processus { numero_processus } : \u00e9tape B\" ) temp = nombre . value nombre . value = temp - 1 # on d\u00e9cr\u00e9mente le nombre de pions print ( f \"nombre de pions restants \u00e0 la fin du processus { numero_processus } : { nombre . value } \" ) if __name__ == '__main__' : # cr\u00e9ation de la variable partag\u00e9e initialis\u00e9e \u00e0 1 nb_pions = Value ( 'i' , 1 ) # on cr\u00e9e deux processus p1 = Process ( target = prendre_un_pion , args = [ nb_pions , 1 ]) p2 = Process ( target = prendre_un_pion , args = [ nb_pions , 2 ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () print ( \"nombre final de pions :\" , nb_pions . value ) Explications : Lors de la cr\u00e9ation des processus, on passe un deuxi\u00e8me argument \u00e0 la fonction prendre_un_pion() , le num\u00e9ro du processus : 1 pour p1 et 2 pour p2 . Cela permet d'afficher dans cette fonction le num\u00e9ro du processus \u00e0 des endroits strat\u00e9giques : au d\u00e9but, \u00e0 l'entr\u00e9e dans le if , juste avant de d\u00e9cr\u00e9menter le nombre de pions et \u00e0 la fin du processus. En ex\u00e9cutant pions_v2.py dans un terminal, on obtient ce genre de choses : Analysons la premi\u00e8re ex\u00e9cution du programme. le processus p1 est \u00e9lu en premier (affichage de \"d\u00e9but du processus 1\") mais est de suite interrompu par l'ordonnanceur qui \u00e9lit p2 (affichage de \"d\u00e9but du processus 2\") puis c'est de nouveau le processus p1 qui a la main et il rentre dans le if (affichage de \"processus 1 : \u00e9tape A\") mais est interrompu \u00e0 nouveau et l'ordonnanceur donne la main \u00e0 p2 qui rentre aussi dans le if (affichage de \"processus 2 : \u00e9tape A\") : en effet, \u00e0 ce stade le nombre de pions n'a pas encore \u00e9t\u00e9 d\u00e9cr\u00e9ment\u00e9 par p1 car il a \u00e9t\u00e9 interrompu avant l'\u00e9tape B, et donc p2 a pu entrer dans le if puisque la condition nombre.value >= 1 est toujours vraie \u00e0 ce moment l\u00e0 !! ensuite le processeur est allou\u00e9 alternativement \u00e0 p1 et p2 (voir les affichages restants) mais le mal est fait puisque les deux processus sont d\u00e9sormais chacun entr\u00e9s dans le if , ils vont chacun d\u00e9cr\u00e9menter le nombre de pions d'une unit\u00e9 et chacun des deux joueurs aura pioch\u00e9 un pion alors qu'il n'y en avait qu'un seul au d\u00e9part ! Vous remarquerez que la troisi\u00e8me ex\u00e9cution du programme met en \u00e9vidence le m\u00eame probl\u00e8me car les deux processus ont chacun pu entrer dans le if , m\u00eame si l'ordre des instructions ex\u00e9cut\u00e9es apr\u00e8s n'est pas tout \u00e0 fait le m\u00eame. Si on analyse la seconde ex\u00e9cution du programme qui donne le comportement souhait\u00e9, on constate que p1 a eu suffisamment de temps pour d\u00e9cr\u00e9menter le nombre de pions (qui vaut d\u00e9sormais 0) avant que p2 ne fasse le test nombre.value >= 1 et se rende compte que cette condition est fausse. Dans ce cas, seul le premier joueur a pas pu piocher un pion. Heureusement, on peut \u00e9viter le probl\u00e8me mis en \u00e9vidence dans l'exemple pr\u00e9c\u00e9dent. Comment \u00e9viter les probl\u00e8mes de synchronisation ? \u2693\ufe0e On va utiliser ce qu'on appelle un verrou : un verrou est objet partag\u00e9 entre plusieurs processus mais qui garantit qu'un seul processus acc\u00e8de \u00e0 une ressource \u00e0 un instant donn\u00e9. Concr\u00e8tement, un verrou peut \u00eatre acquis par les diff\u00e9rents processus, et le premier \u00e0 faire la demande acquiert le verrou. Si le verrou est d\u00e9tenu par un autre processus, alors tout autre processus souhaitant l'obtenir est bloqu\u00e9 jusqu'\u00e0 ce qu'il soit lib\u00e9r\u00e9. Le module multiprocessing de Python propose un objet Lock() correpondant \u00e0 un verrou. Deux m\u00e9thodes sont utilis\u00e9es : la m\u00e9thode .acquire() permet de demander le verrou (le processus faisant la demande est bloqu\u00e9 tant qu'il ne l'a pas obtenu) la m\u00e9thode .release() permet de lib\u00e9rer le verrou (il pourra alors \u00eatre obtenu par un autre processus qui en fait la demande) On peut alors r\u00e9gler le probl\u00e8me de l'exemple pr\u00e9c\u00e9dent avec le script pions_v3.py suivant dans lequel on a laiss\u00e9 les affichages pour bien suivre : \ud83d\udc0d Script Python from multiprocessing import Process , Value , Lock import time def prendre_un_pion ( v , nombre , numero_processus ): print ( f \"d\u00e9but du processus { numero_processus } \" ) v . acquire () # acquisition du verrou if nombre . value >= 1 : print ( f \"processus { numero_processus } : \u00e9tape A\" ) time . sleep ( 0.001 ) print ( f \"processus { numero_processus } : \u00e9tape B\" ) temp = nombre . value nombre . value = temp - 1 v . release () # verrou lib\u00e9r\u00e9 print ( f \"nombre de pions restants \u00e0 la fin du processus { numero_processus } : { nombre . value } \" ) if __name__ == '__main__' : # cr\u00e9ation de la variable partag\u00e9e initialis\u00e9e \u00e0 1 nb_pions = Value ( 'i' , 1 ) # verrou partag\u00e9 par les deux processus verrou = Lock () # on cr\u00e9e deux processus p1 = Process ( target = prendre_un_pion , args = [ verrou , nb_pions , 1 ]) p2 = Process ( target = prendre_un_pion , args = [ verrou , nb_pions , 2 ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () print ( \"nombre final de pions :\" , nb_pions . value ) En ex\u00e9cutant (plusieurs fois) ce script dans un terminal on constate que le nombre final de pions est toujours \u00e9gal \u00e0 0. Avant de faire le test du if , le processus essaye d'acqu\u00e9rir le verrou avec v.acquire() . D\u00e8s qu'il est acquis, le processus a la garantie qu'il est le seul \u00e0 pouvoir ex\u00e9cuter le code jusqu'\u00e0 l'instruction v.release() . Cette portion de code prot\u00e9g\u00e9e s'appelle une section critique . Cela ne veut pas dire que le processus d\u00e9tenant le verrou ne peut pas \u00eatre interrompu, mais il ne le sera pas par un processus qui est essaie d'acqu\u00e9rir le m\u00eame verrou. \ud83d\udc0d Script Python def prendre_un_pion ( v , nombre , numero_processus ): v . acquire () # d\u00e9but section critique if nombre . value >= 1 : time . sleep ( 0.001 ) temp = nombre . value nombre . value = temp - 1 # fin de la section critique v . release () Si vous analysez l'affichage pr\u00e9c\u00e9dent dans le terminal, on voit d'ailleurs que p1 est entr\u00e9 en section critique (affichage \"processus 1 : \u00e9tape A\") mais est interrompu, puis c'est p2 qui a la main (affichage \"d\u00e9but processus 2\") mais il va se retrouver bloquer \u00e0 l'instruction v.acquire() puisque c'est p1 qui d\u00e9tient le verrou. Lorsque p1 reprendra la main, il pourra ex\u00e9cuter ses instructions jusqu'\u00e0 v.release() sans \u00eatre interrompu par p2 (alors nb_pions sera d\u00e9cr\u00e9ment\u00e9 d'une unit\u00e9). Lorsque p1 lib\u00e8re le verrou, p2 pourra alors l'obtenir, ex\u00e9cuter sa section critique et constater que la condition nombre.value >= 1 est fausse : le deuxi\u00e8me joueur ne pourra alors pas prendre de pion. Nous terminons en voyant que l'utilisation de verrous n'est pas sans risque car elle peut engendrer des probl\u00e8mes d'interblocage. Risque d'interblocage \u2693\ufe0e Les interblocages ( deadlock en anglais) sont des situations de la vie quotidienne. L'exemple classique est celui du carrefour avec priorit\u00e9 \u00e0 droite o\u00f9 chaque v\u00e9hicule est bloqu\u00e9 car il doit laisser le passage au v\u00e9hicule \u00e0 sa droite. En informatique l' interblocage peut \u00e9galement se produire lorsque plusieurs processus concurrents s'attendent mutuellement. Ce sc\u00e9nario peut se produire lorsque plusieurs ressources sont partag\u00e9es par plusieurs processus et l'un d'entre eux poss\u00e8de ind\u00e9finiment une ressource n\u00e9cessaire pour un autre. Ce ph\u00e9nom\u00e8ne d' attente circulaire , o\u00f9 chaque processus attend une ressource d\u00e9tenue par un autre processus, peut \u00eatre provoqu\u00e9e par l'utilisation de plusieurs verrous. Consid\u00e9rons le script interblocage.py suivant dans lequel on a cr\u00e9\u00e9 deux verrous v1 et v2 utilis\u00e9s par deux fonctions f1 et f2 ex\u00e9cut\u00e9es respectivement par deux processus p1 et p2 . Le processus p1 essaie d'acqu\u00e9rir d'abord v1 puis v2 tandis que le processus p2 essaie de les acqu\u00e9rir dans l'ordre inverse. \ud83d\udc0d Script Python from multiprocessing import Process , Lock import time import os def f1 ( v1 , v2 ): print ( \"PID du processus 1:\" , os . getpid ()) for i in range ( 100 ): time . sleep ( 0.001 ) v1 . acquire () v2 . acquire () print ( \"processus 1 en cours, it\u00e9ration \" , i ) v2 . release () v1 . release () def f2 ( v1 , v2 ): print ( \"PID du processus 2:\" , os . getpid ()) for i in range ( 100 ): time . sleep ( 0.001 ) v2 . acquire () v1 . acquire () print ( \"processus 2 en cours, it\u00e9ration \" , i ) v1 . release () v2 . release () if __name__ == '__main__' : # cr\u00e9ation de deux verrous v1 = Lock () v2 = Lock () # cr\u00e9ation de deux processus p1 = Process ( target = f1 , args = [ v1 , v2 ]) p2 = Process ( target = f2 , args = [ v1 , v2 ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () Si on ex\u00e9cute ce programme, il y a de grandes chances de se retrouver bloqu\u00e9. Par exemple, dans le cas de l'ex\u00e9cution suivante : le processus p1 est \u00e9lu : il s'ex\u00e9cute jusqu'\u00e0 l'acquisition de v1 mais avant la tentative d'acquisition de v2 , puis est interrompu le processus p2 est \u00e0 son tour \u00e9lu : il s'ex\u00e9cute et acquiert v2 qui est toujours libre, puis bloque sur l'acquisition de v1 (qui est d\u00e9tenu par p1 ). le processus p1 reprend la main et bloque sur l'acquisition de v2 (d\u00e9tenu par p2 ). Chaque processus d\u00e9tient un verrou et attend l'autre : ils sont en interblocage et l'attente est infinie. On peut lancer (plusieurs fois si n\u00e9cessaire) le script \u00e0 partir du terminal et constater que l'interblocage a lieu tr\u00e8s souvent. Il n'y a alors pas d'autres choix que d'interrompre les processus en interblocage, par exemple avec la commande kill . Cependant, ce probl\u00e8me a lieu ici car les deux processus essaie d'acqu\u00e9rir les verrous dans l'ordre contraire. Si l'ordre d'acquisition est le m\u00eame pour les processus, le probl\u00e8me n'a plus lieu (n'h\u00e9sitez pas \u00e0 tester !). De mani\u00e8re g\u00e9n\u00e9rale, dans des probl\u00e8mes complexes les situations d'interblocage sont difficiles \u00e0 d\u00e9tecter et il se peut tr\u00e8s bien que le programme se comporte bien pendant toute une phase de tests mais bloque lors d'une ex\u00e9cution ult\u00e9rieure puisque l'on ne peut pas pr\u00e9voir l'ordonnancement des processus. Simulation d'interblocage\u2693\ufe0e \u2693\ufe0e Robosomes cr\u00e9\u00e9 par Alain BUSSER , S\u00e9bastien HOARAU (Voir ici : Robosomes - IREM de la r\u00e9union Le jeu robosomes se joue \u00e0 un seul joueur sur une grille rectangulaire. Chaque case peut \u00eatre soit vide soit couverte par un obstacle fixe (en noir comme aux mots crois\u00e9s) soit couverte d\u2019un pion pouvant bouger, appel\u00e9 robot Chaque robot peut \u00eatre tourn\u00e9 dans l\u2019une des quatre directions cardinales \u25c0\u25b2\u25b6\u25bc. Les robots peuvent bouger tous en m\u00eame temps de l\u2019une des fa\u00e7ons suivantes : G : tous les robots tournent vers leur gauche (de 90\u00b0) en m\u00eame temps D : tous les robots tournent vers leur droite (de 90\u00b0) en m\u00eame temps A : les robots qui peuvent avancer d\u2019une case, le font. Un robot peut avancer d\u2019une case s\u2019il n\u2019y a pas d\u2019obstacle sur cette case et si aucun robot ne s\u2019appr\u00eate \u00e0 aller sur cette case. Les cases du bord de la grille sont toutes couvertes d\u2019obstacles fixes, \u00e0 l\u2019exception de l\u2019une d\u2019entre elles appel\u00e9e \u00ab sortie \u00bb. Lorsqu\u2019un robot est sur la case de sortie, tourn\u00e9 vers l\u2019ext\u00e9rieur de la grille, il quitte le jeu et n\u2019est plus soumis aux ordres donn\u00e9s. Le but du jeu est de faire sortir tous les robots de la grille, en \u00e9crivant un mot dans l\u2019alphabet A,G,D, appel\u00e9 programme et que les robots interpr\u00e9teront comme d\u00e9crit ci-dessus. Voici quelques exemples : Un premier exemple pour se mettre en route. Interblocage Interblocage 1 Interblocage 2 Interblocage 3 Interblocage 4 Interblocage perp\u00e9tuel ou pas Interblocage 8 Et pour les syst\u00e8mes multiprocesseurs ? \u2693\ufe0e Les ordinateurs actuels poss\u00e8dent g\u00e9n\u00e9ralement plusieurs processeurs, ce qui permet \u00e0 plusieurs processus d'\u00eatre ex\u00e9cut\u00e9s parall\u00e8lement : un par processeur. Ce parall\u00e9lisme permet bien \u00e9videmment une plus grande puissance de calcul. Pour r\u00e9partir les diff\u00e9rents processus entre les diff\u00e9rents processeurs, on distingue deux approches : l'approche partitionn\u00e9e : chaque processeur poss\u00e8de un ordonnanceur particulier et les processus sont r\u00e9partis entre les diff\u00e9rents ordonnanceurs l'approche globale : un ordonnanceur global est charg\u00e9 de d\u00e9terminer la r\u00e9partition des processus entre les diff\u00e9rents processeurs L'ordonnancement des processus des syst\u00e8mes d'exploitation actuels est bien plus complexe que les quelques algorithmes \u00e9voqu\u00e9s dans ce cours, et cela d\u00e9passe largement le cadre du programme de NSI. Si vous souhaitez en savoir plus, voici n\u00e9anmoins une vid\u00e9o int\u00e9ressante (en fran\u00e7ais) sur l'ordonnancement du noyau Linux : https://www.youtube.com/watch?v=uCGe5WWd1OI&t=195s&ab_channel=Vitonimal . Bilan \u2693\ufe0e Un programme en cours d'ex\u00e9cution s'appelle un processus . Les syst\u00e8mes d'exploitation r\u00e9cents permettent d'ex\u00e9cuter plusieurs processus simultan\u00e9ment. En r\u00e9alit\u00e9, ces processus sont ex\u00e9cut\u00e9s \u00e0 tour de r\u00f4le par le syst\u00e8me d'exploitation qui est charg\u00e9 d'allouer \u00e0 chacun d'eux les ressources dont il a besoin en termes de m\u00e9moire, entr\u00e9es-sorties ou temps d'acc\u00e8s au processeur, et de s'assurer que les processus ne se g\u00eanent pas les uns les autres. Au cours de leur vie, les processus varient entre trois \u00e9tats : \u00e9lu si le processus est ex\u00e9cut\u00e9 par le processeur, pr\u00eat si le processus est pr\u00eat \u00e0 \u00eatre ex\u00e9cut\u00e9, et bloqu\u00e9 si le processus est en attente d'une ressource. C'est l' ordonnanceur qui est charg\u00e9 de d\u00e9finir l'ordre dans lequel les processus doivent \u00eatre ex\u00e9cut\u00e9s par le processeur. Ce choix se fait gr\u00e2ce \u00e0 des algorithmes d'ordonnancement. Les processus se partagent les diff\u00e9rentes ressources, on parle d' acc\u00e8s concurrent aux ressources. Ce partage des ressources n'est pas sans risque et peut conduire \u00e0 des probl\u00e8mes de synchronisation. Ces probl\u00e8mes peuvent \u00eatre \u00e9vit\u00e9s en utilisant un verrou , qui permet \u00e0 un processus de ne pas \u00eatre interrompu dans sa section critique par un autre processus demandant le m\u00eame verrou. L'utilisation de plusieurs verrous peut entra\u00eener des interblocages , c'est-\u00e0-dire des situations o\u00f9 chaque processus attend une ressource d\u00e9tenue par un autre, conduisant \u00e0 une attente cyclique infinie. L'ordre d'acquisition des verrous est important mais pas toujours \u00e9vident \u00e0 \u00e9crire dans le cas de probl\u00e8mes complexes. Exercices \u2693\ufe0e Exercice 1 : Algorithmes d'ordonnancement \u2693\ufe0e Soient les diff\u00e9rents processus suivants : Processus Date d'arriv\u00e9e Dur\u00e9e de traitement \\(P_1\\) 0 3 \\(P_2\\) 1 6 \\(P_3\\) 3 4 \\(P_4\\) 6 5 \\(P_5\\) 8 2 Application de plusieurs algorithmes \u2693\ufe0e Q1 : Donnez le diagramme de Gantt pour l'ex\u00e9cution de ces diff\u00e9rents processus en utilisant successivement les algorithmes FCFS, RR (quantum = 2 unit\u00e9s de temps) et SRT. Performances des algorithmes d'ordonnancement \u2693\ufe0e On d\u00e9finit les m\u00e9triques suivantes : le temps de s\u00e9jour (ou d'ex\u00e9cution) (ou de rotation) d'un processus : c'est la diff\u00e9rence entre la date de fin d'ex\u00e9cution et la date d'arriv\u00e9e : \\(T_{\\text{sej}} = \\text{date fin d'ex\u00e9cution} - \\text{date d'arriv\u00e9e}\\) le temps d'attente d'un processus : c'est la diff\u00e9rence entre le temps de s\u00e9jour et la dur\u00e9e du processus : \\(T_{\\text{att}} = T_{\\text{sej}} - \\text{dur\u00e9e du processus}\\) le rendement d'un processus : c'est le quotient entre la dur\u00e9e du processus et le temps de s\u00e9jour : \\(\\text{rendement} = \\dfrac{\\text{dur\u00e9e du processus}}{T_{\\text{sej}}}\\) Q2 : Pour chacun des trois algorithmes, calculez le temps de s\u00e9jour, le temps d'attente et le rendement de chaque processus. Q3 : Quel vous semble \u00eatre le meilleur des trois algorithmes dans notre exemple ? Expliquer. Exercice 2 \u2693\ufe0e cet exercice est issu du sujet 2021 du bac NSI Partie A Cette partie est un questionnaire \u00e0 choix multiples (QCM). Pour chacune des questions, une seule des quatre r\u00e9ponses est exacte. Le candidat indiquera sur sa copie le num\u00e9ro de la question et la lettre correspondant \u00e0 la r\u00e9ponse exacte. Aucune justification n\u2019est demand\u00e9e. Une r\u00e9ponse fausse ou une absence de r\u00e9ponse n\u2019enl\u00e8ve aucun point. 1) Parmi les commandes ci-dessous, laquelle permet d\u2019afficher les processus en cours d\u2019ex\u00e9cution ? \ud83d\udccb Texte a. dir b. ps c. man d. ls 2) Quelle abr\u00e9viation d\u00e9signe l\u2019identifiant d\u2019un processus dans un syst\u00e8me d\u2019exploitation de type UNIX ? \ud83d\udccb Texte a. PIX b. SIG c. PID d. SID 3) Comment s\u2019appelle la gestion du partage du processeur entre diff\u00e9rents processus ? \ud83d\udccb Texte a. L\u2019interblocage b. L\u2019ordonnancement c. La planification d. La priorisation 4) Quelle commande permet d\u2019interrompre un processus dans un syst\u00e8me d\u2019exploitation de type UNIX ? \ud83d\udccb Texte a. stop b. interrupt c. end d. kill Partie B 1) Un processeur choisit \u00e0 chaque cycle d\u2019ex\u00e9cution le processus qui doit \u00eatre ex\u00e9cut\u00e9. Le tableau ci-dessous donne pour trois processus P1, P2, P3 : la dur\u00e9e d\u2019ex\u00e9cution (en nombre de cycles), l\u2019instant d\u2019arriv\u00e9e sur le processeur (exprim\u00e9 en nombre de cycles \u00e0 partir de 0), le num\u00e9ro de priorit\u00e9. Le num\u00e9ro de priorit\u00e9 est d\u2019autant plus petit que la priorit\u00e9 est grande. On suppose qu\u2019\u00e0 chaque instant, c\u2019est le processus qui a le plus petit num\u00e9ro de priorit\u00e9 qui est ex\u00e9cut\u00e9, ce qui peut provoquer la suspension d\u2019un autre processus, lequel reprendra lorsqu\u2019il sera le plus prioritaire. Reproduire le tableau ci-dessous sur la copie et indiquer dans chacune des cases le processus ex\u00e9cut\u00e9 \u00e0 chaque cycle. 2) On suppose maintenant que les trois processus pr\u00e9c\u00e9dents s\u2019ex\u00e9cutent et utilisent une ou plusieurs ressources parmi R1, R2 et R3. Parmi les sc\u00e9narios suivants, lequel provoque un interblocage ? Justifier. Partie C Dans cette partie, pour une meilleure lisibilit\u00e9, des espaces sont plac\u00e9es dans les \u00e9critures binaires des nombres. Il ne faut pas les prendre en compte dans les calculs. Pour chiffrer un message, une m\u00e9thode, dite du masque jetable, consiste \u00e0 le combiner avec une cha\u00eene de caract\u00e8res de longueur comparable. Une impl\u00e9mentation possible utilise l\u2019op\u00e9rateur XOR (ou exclusif) dont voici la table de v\u00e9rit\u00e9 : a b a XOR b 0 0 0 0 1 1 1 0 1 1 1 0 Dans la suite, les nombres \u00e9crits en binaire seront pr\u00e9c\u00e9d\u00e9s du pr\u00e9fixe 0b. Q1. Pour chiffrer un message, on convertit chacun de ses caract\u00e8res en binaire (\u00e0 l\u2019aide du format Unicode), et on r\u00e9alise l\u2019op\u00e9ration XOR bit \u00e0 bit avec la cl\u00e9. Apr\u00e8s conversion en binaire, et avant que l\u2019op\u00e9ration XOR bit \u00e0 bit avec la cl\u00e9 n\u2019ait \u00e9t\u00e9 effectu\u00e9e, Alice obtient le message suivant : m = 0b 0110 0011 0100 0110 a. Le message m correspond \u00e0 deux caract\u00e8res cod\u00e9s chacun sur 8 bits : d\u00e9terminer quels sont ces caract\u00e8res. On fournit pour cela la table ci-dessous qui associe \u00e0 l\u2019\u00e9criture hexad\u00e9cimale d\u2019un octet le caract\u00e8re correspondant (figure 2). Exemple de lecture : le caract\u00e8re correspondant \u00e0 l\u2019octet cod\u00e9 4A en hexad\u00e9cimal est la lettre J. Pour chiffrer le message d\u2019Alice, on r\u00e9alise l\u2019op\u00e9ration XOR bit \u00e0 bit avec la cl\u00e9 suivante : k = 0b 1110 1110 1111 0000 Donner l\u2019\u00e9criture binaire du message obtenu. Q2. a. Dresser la table de v\u00e9rit\u00e9 de l\u2019expression bool\u00e9enne suivante : (a XOR b) XOR b b. Bob conna\u00eet la cha\u00eene de caract\u00e8res utilis\u00e9e par Alice pour chiffrer le message. Quelle op\u00e9ration doit-il r\u00e9aliser pour d\u00e9chiffrer son message ? Exercice 3 \u2693\ufe0e d'apr\u00e8s le sujet du bac NSI 2021 Cet exercice porte sur les syst\u00e8mes d\u2019exploitation : gestion des processus et des ressources. Les parties A et B peuvent \u00eatre trait\u00e9es ind\u00e9pendamment Partie A : Dans un bureau d\u2019architectes, on dispose de certaines ressources qui ne peuvent \u00eatre utilis\u00e9es simultan\u00e9ment par plus d\u2019un processus, comme l\u2019imprimante, la table tra\u00e7ante, le modem. Chaque programme, lorsqu\u2019il s\u2019ex\u00e9cute, demande l\u2019allocation des ressources qui lui sont n\u00e9cessaires. Lorsqu\u2019il a fini de s\u2019ex\u00e9cuter, il lib\u00e8re ses ressources. On appelle p1, p2 et p3 les processus associ\u00e9s respectivement aux programmes 1, 2 et 3. Q.1. Justifier qu'une situation d'interblocage peut se produire. Q.2. Modifier l'ordre des instructions du programme 3 pour qu'une telle situation ne puisse pas se produire. Q.3. Supposons que le processus p1 demande la table tra\u00e7ante alors qu'elle est en cours d'utilisation par le processus p3. Parmi les \u00e9tats suivants, quel sera l'\u00e9tat du processus p1 tant que la table tra\u00e7ante n'est pas disponible : a) \u00e9lu b) bloqu\u00e9 c) pr\u00eat d) termin\u00e9 Partie B Avec une ligne de commande dans un terminal sous Linux, on obtient l'affichage suivant : La documentation Linux donne la signification des diff\u00e9rents champs : UID : identifiant utilisateur effectif ; PID : identifiant de processus ; PPID : PID du processus parent ; C : partie enti\u00e8re du pourcentage d'utilisation du processeur par rapport au temps de vie des processus ; STIME : l'heure de lancement du processus ; TTY : terminal de contr\u00f4le TIME : temps d'ex\u00e9cution CMD : nom de la commande du processus Q.1. Parmi les quatre commandes suivantes, laquelle a permis cet affichage ? a) ls -l b) ps \u2013ef c) cd .. d) chmod 741 processus.txt Q.2. Quel est l'identifiant du processus parent \u00e0 l'origine de tous les processus concernant le navigateur Web (chromium-browser) ? Q.3. Quel est l'identifiant du processus dont le temps d'ex\u00e9cution est le plus long ? Exercice 4 \u2693\ufe0e Extrait sujet BAC 2021 Cet exercice porte sur la gestion des processus par un syst\u00e8me d\u2019exploitation. Partie A : Processus La commande UNIX ps pr\u00e9sente un clich\u00e9 instantan\u00e9 des processus en cours d'ex\u00e9cution. Avec l\u2019option \u2212eo pid,ppid,stat,command, cette commande affiche dans l\u2019ordre l\u2019identifiant du processus PID (process identifier), le PPID (parent process identifier), l\u2019\u00e9tat STAT et le nom de la commande \u00e0 l\u2019origine du processus. Les valeurs du champ STAT indique l\u2019\u00e9tat des processus : - R : processus en cours d\u2019ex\u00e9cution - S : processus endormi Sur un ordinateur, on ex\u00e9cute la commande ps \u2212eo pid,ppid,stat,command et on obtient un affichage dont on donne ci-dessous un extrait. \u00c0 l'aide de cet affichage, r\u00e9pondre aux questions ci-dessous. Q.1. Quel est le nom de la premi\u00e8re commande ex\u00e9cut\u00e9e par le syst\u00e8me d'exploitation lors du d\u00e9marrage ? Q.2. Quels sont les identifiants des processus actifs sur cet ordinateur au moment de l\u2019appel de la commande ps ? Justifier la r\u00e9ponse. Q.3. Depuis quelle application a-t-on ex\u00e9cut\u00e9 la commande ps ? Donner les autres commandes qui ont \u00e9t\u00e9 ex\u00e9cut\u00e9es \u00e0 partir de cette application. Q.4. Expliquer l'ordre dans lequel les deux commandes python programme1.py et python programme2.py ont \u00e9t\u00e9 ex\u00e9cut\u00e9es. Q.5. Peut-on pr\u00e9dire que l'une des deux commandes python programme1.py et python programme2.py finira avant l\u2019autre ?","title":"TD Gestion Processus"},{"location":"Processus/TD_Gestion_Processus/#introduction","text":"Dans les ann\u00e9es 1970 les ordinateurs personnels \u00e9taient incapables d'ex\u00e9cuter plusieurs t\u00e2ches \u00e0 la fois : il fallait attendre qu'un programme lanc\u00e9 se termine pour en ex\u00e9cuter un autre. Les syst\u00e8mes d'exploitations r\u00e9cents (GNU/Linux, macOS, iOS, Android, Windows...) permettent d'ex\u00e9cuter des t\u00e2ches \"simultan\u00e9ment\". En effet, la plupart du temps, lorsque l'on utilise un ordinateur, plusieurs programmes sont ex\u00e9cut\u00e9s \"en m\u00eame temps\" : par exemple, on peut tr\u00e8s bien ouvrir simultan\u00e9ment un navigateur Web, un traitement de texte, un IDE Python, un logiciel de musique (sans parler de tous les programmes ex\u00e9cut\u00e9s en arri\u00e8re-plan) ... Ces programmes en cours d'ex\u00e9cution s'appellent des processus . Une des t\u00e2ches du syst\u00e8me d'exploitation est d'allouer \u00e0 chacun des processus les ressources dont il a besoin en termes de m\u00e9moire, entr\u00e9es-sorties ou temps d'acc\u00e8s au processeur, et de s'assurer que les processus ne se g\u00eanent pas les uns les autres. Pourtant, on rappelle qu'un programme n'est qu'une suite d'instructions machine ex\u00e9cut\u00e9es l'une apr\u00e8s l'autre par le processeur et qu'un processeur n'est capable d'ex\u00e9cuter qu'une seule instruction \u00e0 la fois. Pour rappel, voici les \u00e9tapes d'ex\u00e9cution d'une instruction. l'instruction point\u00e9e par le pointeur d'instruction est charg\u00e9e en m\u00e9moire Le pointeur d'instruction est incr\u00e9ment\u00e9 vers l'adresse suivante l'instruction est d\u00e9cod\u00e9e l'instruction est ex\u00e9cut\u00e9e Comment est-il alors possible que plusieurs programmes soient ex\u00e9cut\u00e9s en m\u00eame temps ?","title":"Introduction"},{"location":"Processus/TD_Gestion_Processus/#processus","text":"","title":"Processus"},{"location":"Processus/TD_Gestion_Processus/#gestion-des-processus-et-des-ressources","text":"","title":"Gestion des processus et des ressources"},{"location":"Processus/TD_Gestion_Processus/#problemes-lies-a-lacces-concurrent-aux-ressources","text":"Les processus se partagent souvent une ou plusieurs ressources, et cela peut poser des probl\u00e8mes.","title":"Probl\u00e8mes li\u00e9s \u00e0 l'acc\u00e8s concurrent aux ressources"},{"location":"Processus/TD_Gestion_Processus/#et-pour-les-systemes-multiprocesseurs","text":"Les ordinateurs actuels poss\u00e8dent g\u00e9n\u00e9ralement plusieurs processeurs, ce qui permet \u00e0 plusieurs processus d'\u00eatre ex\u00e9cut\u00e9s parall\u00e8lement : un par processeur. Ce parall\u00e9lisme permet bien \u00e9videmment une plus grande puissance de calcul. Pour r\u00e9partir les diff\u00e9rents processus entre les diff\u00e9rents processeurs, on distingue deux approches : l'approche partitionn\u00e9e : chaque processeur poss\u00e8de un ordonnanceur particulier et les processus sont r\u00e9partis entre les diff\u00e9rents ordonnanceurs l'approche globale : un ordonnanceur global est charg\u00e9 de d\u00e9terminer la r\u00e9partition des processus entre les diff\u00e9rents processeurs L'ordonnancement des processus des syst\u00e8mes d'exploitation actuels est bien plus complexe que les quelques algorithmes \u00e9voqu\u00e9s dans ce cours, et cela d\u00e9passe largement le cadre du programme de NSI. Si vous souhaitez en savoir plus, voici n\u00e9anmoins une vid\u00e9o int\u00e9ressante (en fran\u00e7ais) sur l'ordonnancement du noyau Linux : https://www.youtube.com/watch?v=uCGe5WWd1OI&t=195s&ab_channel=Vitonimal .","title":"Et pour les syst\u00e8mes multiprocesseurs ?"},{"location":"Processus/TD_Gestion_Processus/#bilan","text":"Un programme en cours d'ex\u00e9cution s'appelle un processus . Les syst\u00e8mes d'exploitation r\u00e9cents permettent d'ex\u00e9cuter plusieurs processus simultan\u00e9ment. En r\u00e9alit\u00e9, ces processus sont ex\u00e9cut\u00e9s \u00e0 tour de r\u00f4le par le syst\u00e8me d'exploitation qui est charg\u00e9 d'allouer \u00e0 chacun d'eux les ressources dont il a besoin en termes de m\u00e9moire, entr\u00e9es-sorties ou temps d'acc\u00e8s au processeur, et de s'assurer que les processus ne se g\u00eanent pas les uns les autres. Au cours de leur vie, les processus varient entre trois \u00e9tats : \u00e9lu si le processus est ex\u00e9cut\u00e9 par le processeur, pr\u00eat si le processus est pr\u00eat \u00e0 \u00eatre ex\u00e9cut\u00e9, et bloqu\u00e9 si le processus est en attente d'une ressource. C'est l' ordonnanceur qui est charg\u00e9 de d\u00e9finir l'ordre dans lequel les processus doivent \u00eatre ex\u00e9cut\u00e9s par le processeur. Ce choix se fait gr\u00e2ce \u00e0 des algorithmes d'ordonnancement. Les processus se partagent les diff\u00e9rentes ressources, on parle d' acc\u00e8s concurrent aux ressources. Ce partage des ressources n'est pas sans risque et peut conduire \u00e0 des probl\u00e8mes de synchronisation. Ces probl\u00e8mes peuvent \u00eatre \u00e9vit\u00e9s en utilisant un verrou , qui permet \u00e0 un processus de ne pas \u00eatre interrompu dans sa section critique par un autre processus demandant le m\u00eame verrou. L'utilisation de plusieurs verrous peut entra\u00eener des interblocages , c'est-\u00e0-dire des situations o\u00f9 chaque processus attend une ressource d\u00e9tenue par un autre, conduisant \u00e0 une attente cyclique infinie. L'ordre d'acquisition des verrous est important mais pas toujours \u00e9vident \u00e0 \u00e9crire dans le cas de probl\u00e8mes complexes.","title":"Bilan"},{"location":"Processus/TD_Gestion_Processus/#exercices","text":"","title":"Exercices"},{"location":"Processus/TD_Gestion_Processus_Correction/","text":"Th\u00e8me 3 : Architecture mat\u00e9rielle 23 Cours : Gestion des processus Introduction \u2693\ufe0e Dans les ann\u00e9es 1970 les ordinateurs personnels \u00e9taient incapables d'ex\u00e9cuter plusieurs t\u00e2ches \u00e0 la fois : il fallait attendre qu'un programme lanc\u00e9 se termine pour en ex\u00e9cuter un autre. Les syst\u00e8mes d'exploitations r\u00e9cents (GNU/Linux, macOS, iOS, Android, Windows...) permettent d'ex\u00e9cuter des t\u00e2ches \"simultan\u00e9ment\". En effet, la plupart du temps, lorsque l'on utilise un ordinateur, plusieurs programmes sont ex\u00e9cut\u00e9s \"en m\u00eame temps\" : par exemple, on peut tr\u00e8s bien ouvrir simultan\u00e9ment un navigateur Web, un traitement de texte, un IDE Python, un logiciel de musique (sans parler de tous les programmes ex\u00e9cut\u00e9s en arri\u00e8re-plan) ... Ces programmes en cours d'ex\u00e9cution s'appellent des processus . Une des t\u00e2ches du syst\u00e8me d'exploitation est d'allouer \u00e0 chacun des processus les ressources dont il a besoin en termes de m\u00e9moire, entr\u00e9es-sorties ou temps d'acc\u00e8s au processeur, et de s'assurer que les processus ne se g\u00eanent pas les uns les autres. Pourtant, on rappelle qu'un programme n'est qu'une suite d'instructions machine ex\u00e9cut\u00e9es l'une apr\u00e8s l'autre par le processeur et qu'un processeur n'est capable d'ex\u00e9cuter qu'une seule instruction \u00e0 la fois. Pour rappel, voici les \u00e9tapes d'ex\u00e9cution d'une instruction. l'instruction point\u00e9e par le pointeur d'instruction est charg\u00e9e en m\u00e9moire Le pointeur d'instruction est incr\u00e9ment\u00e9 vers l'adresse suivante l'instruction est d\u00e9cod\u00e9e l'instruction est ex\u00e9cut\u00e9e Comment est-il alors possible que plusieurs programmes soient ex\u00e9cut\u00e9s en m\u00eame temps ? Processus \u2693\ufe0e Qu'est-ce qu'un processus ? \u2693\ufe0e Il ne faut pas confondre programme et processus : Un programme est un fichier binaire (on dit aussi un ex\u00e9cutable ) contenant des instructions machines que seul le processeur peut comprendre. Un processus est un programme en cours d'ex\u00e9cution , autrement dit le ph\u00e9nom\u00e8ne dynamique li\u00e9 \u00e0 l'ex\u00e9cution d'un programme par l'ordinateur. Ainsi, lorsque nous cliquons sur l'ic\u00f4ne d'un programme (ou lorsque nous ex\u00e9cutons une instruction dans la console pour lancer un programme), nous provoquons la naissance d'un ou plusieurs processus li\u00e9s au programme que nous lan\u00e7ons. Un processus est donc une instance d'un programme auquel est associ\u00e9 : du code des donn\u00e9es/variables manipul\u00e9es des ressources : processeur, m\u00e9moire, p\u00e9riph\u00e9riques d'entr\u00e9e/sortie (voir paragraphe suivant) Il n'est d'ailleurs pas rare qu'un m\u00eame programme soit ex\u00e9cut\u00e9 plusieurs fois sur une machine au m\u00eame moment en occupant des espaces m\u00e9moires diff\u00e9rents : par exemple deux documents ouverts avec un traitement de texte, ou trois consoles distinctes... qui correspondent \u00e0 autant d'instances du m\u00eame programme et donc \u00e0 des processus diff\u00e9rents. Observer les processus \u2693\ufe0e Il est tr\u00e8s facile de voir les diff\u00e9rents processus s'ex\u00e9cutant sur une machine. Sous GNU/Linux, on peut utiliser la commande ps (comme p roces s , la traduction anglaise de processus ) pour afficher les informations sur les processus (sous windows : talklist). En passant des options \u00e0 cette commande on peut obtenir des choses int\u00e9ressantes. Par exemple, en ex\u00e9cutant dans un terminal la commande ps -aef , on peut visualiser tous les processus en cours sur notre ordinateur : Cr\u00e9ation d'un processus \u2693\ufe0e Un processus peut \u00eatre cr\u00e9\u00e9 : au d\u00e9marrage du syst\u00e8me par un autre processus par une action d'un utilisateur (lancement d'un programme) Sous GNU/Linux, un tout premier processus est cr\u00e9\u00e9 au d\u00e9marrage (c'est le processus 0 ou encore Swapper ). Ce processus cr\u00e9e un processus souvent appel\u00e9 init qui est le fils du processus 0. Ensuite, \u00e0 partir de init , les autres processus n\u00e9cessaires au fonctionnement du syst\u00e8me sont cr\u00e9\u00e9s. Ces processus cr\u00e9ent ensuite eux-m\u00eames d'autres processus, etc. Un processus peut cr\u00e9er un ou plusieurs processus, ce qui aboutit \u00e0 une structure arborescente comme nous allons le voir maintenant. PID et PPID \u2693\ufe0e La commande pr\u00e9c\u00e9dente permet de voir que chaque processus est identifi\u00e9 par un num\u00e9ro : son PID (pour Process Identifier ). Ce num\u00e9ro est donn\u00e9 \u00e0 chaque processus par le syst\u00e8me d'exploitation. On constate \u00e9galement que chaque processus poss\u00e8de un PPID (pour Parent Process Identifier ), il s'agit du PID du processus parent, c'est-\u00e0-dire celui qui a d\u00e9clench\u00e9 la cr\u00e9ation du processus. En effet, un processus peut cr\u00e9er lui m\u00eame un ou plusieurs autres processus, appel\u00e9s processus fils . Observation des processus\u2693\ufe0e \u2693\ufe0e Sous Linux, on peut observer les processus et leur \u00e9tat en ligne de commande. Pour tester, cela on peut utiliser : terminal linux en ligne Voici quelques commandes utiles pour observer les processus : ps |: elle permet d'afficher la liste des processus en cours. (Pour avoir des informations sur les options taper man ps) Pour lister tous les processus : ps - ef top : Pour observer en temps r\u00e9els les diff\u00e9rents processus.(penser \u00e0 utiliser man top) la commande f permet de g\u00e9rer les colonnes affich\u00e9es. kill : elle permet de tuer un processus en lui envoyant un signal de fin. 15 pour arr\u00eater le processus proprement 9 pour arr\u00eater imm\u00e9diatement le processus. exemple d'utilisation : kill -15 7654 pour tuer proprement le processus de PID 7564 Exercice Dans un nouvel onglet ouvrir : terminal linux en ligne cr\u00e9er un premier terminal : utiliser les commandes de l'ann\u00e9e pr\u00e9c\u00e9dentes : ls, cd, touch, cat pour d\u00e9terminer le nom d'utilisateur : whoami cr\u00e9er un fichier vide test.py : touch test.py \u00e9diter le fichier test.py avec la commande : nano test.py y \u00e9crire le code suivant : python for a in range(100000): print(a) pour sortir de l'\u00e9diteur : Ctrl+X, puis Y, puis Enter pour confirmer le nom lancer le programme avec : python3 test.py cr\u00e9er un second fichier p2.py avec le code suivant : \ud83d\udc0d Script Python while True : pass le lancer Il tourne sans fin. Pour l'arr\u00eater : Ctrl+C v\u00e9rifier la pr\u00e9sence dans le dossier des fichiers cr\u00e9\u00e9s, avec ls ouvrir un second terminal puis : dans ce second terminal lancer python3 sans nom de fichier dans le premier terminal taper ps -ef rep\u00e9rer le PID du processus python3 et le tuer avec la commande kill -9 (voir syntaxe au dessus) ouvrir un troisi\u00e8me terminal dans ce troisi\u00e8me terminal lancer la commande top modifier l'affichage pour faire appara\u00eetre le PPID (taper f, puis s\u00e9lectionner/ d\u00e9placer avec les touches curseur. Revenir \u00e0 l'affichage avec Esc) Enfin ouvrir des terminaux suppl\u00e9mentaires pour en avoir au moins 5 et lancer dans les terminaux : 1 aucun processus 1 avec nano 1 avec python3 1 avec python3 lan\u00e7ant p2.py 1 avec top observer les processus et essayer de les tuer avec la commande kill \u00e0 partir du premier terminal recommencer en relan\u00e7ant les processus et tuer les processus avec le terminal lan\u00e7ant top(puis commande k) Gestion des processus et des ressources \u2693\ufe0e Ex\u00e9cution concurrente \u2693\ufe0e Les syst\u00e8mes d'exploitation modernes sont capable d'ex\u00e9cuter plusieurs processus \"en m\u00eame temps\". En r\u00e9alit\u00e9 ces processus ne sont pas toujours ex\u00e9cut\u00e9s \"en m\u00eame temps\" mais plut\u00f4t \"\u00e0 tour de r\u00f4le\". On parle d'ex\u00e9cution concurrente car les processus sont en concurrence pour obtenir l'acc\u00e8s au processeur charg\u00e9 de les ex\u00e9cuter. Remarque : Sur un syst\u00e8me multiprocesseur, il est possible d'ex\u00e9cuter de mani\u00e8re parall\u00e8le plusieurs processus, autant qu'il y a de processeurs. Mais sur un m\u00eame processeur, un seul processus ne peut \u00eatre ex\u00e9cut\u00e9 \u00e0 la fois. On peut voir assez facilement cette ex\u00e9cution concurrente. Consid\u00e9rons les deux programmes Python suivants : progA.py \ud83d\udc0d Script Python import time for i in range ( 100 ): print ( \"programme A en cours, it\u00e9ration\" , i ) time . sleep ( 0.01 ) # pour simuler un traitement avec des calculs progB.py \ud83d\udc0d Script Python import time for i in range ( 100 ): print ( \"programme B en cours, it\u00e9ration\" , i ) time . sleep ( 0.01 ) # pour simuler un traitement avec des calculs En ouvrant un Terminal, on peut lancer simultan\u00e9ment ces deux programmes avec la commande Bash $ python progA.py & python progB.py & Le caract\u00e8re & qui suit une commande permet de lancer l'ex\u00e9cution en arri\u00e8re plan et de rendre la main au terminal. Le shell indique alors dans la console les PID des processus correspondant \u00e0 l'ex\u00e9cution de ces deux programmes (ici 9154 et 9155) puis on constate gr\u00e2ce aux affichages que le syst\u00e8me d'exploitation alloue le processeur aux deux programmes \u00e0 tour de r\u00f4le : Acc\u00e8s concurrents aux ressources \u2693\ufe0e Une ressource est une entit\u00e9 dont a besoin un processus pour s'ex\u00e9cuter. Les ressources peuvent \u00eatre mat\u00e9rielles (processeur, m\u00e9moire, p\u00e9riph\u00e9riques d'entr\u00e9e/sortie, ...) mais aussi logicielles (variables). Les diff\u00e9rents processus se partagent les ressources, on parle alors d' acc\u00e8s concurrents aux ressources . Par exemple, les processus se partagent tous l'acc\u00e8s \u00e0 la ressource \"processeur\" un traitement de texte et un IDE Python se partagent la ressource \"clavier\" ou encore la ressource \"disque dur\" (si on enregistre les fichiers), ... un navigateur et un logiciel de musique se partagent la ressource \"carte son\", ... C'est le syst\u00e8me d'exploitation qui est charg\u00e9 de g\u00e9rer les processus et les ressources qui leur sont n\u00e9cessaires, en partageant leur acc\u00e8s au processeur. Nous allons voir comment tout de suite ! \u00c9tats d'un processus \u2693\ufe0e Au cours de son existence, un processus peut se retrouver dans trois \u00e9tats : \u00e9tat \u00e9lu : lorsqu'il est en cours d'ex\u00e9cution, c'est-\u00e0-dire qu'il obtient l'acc\u00e8s au processeur \u00e9tat pr\u00eat : lorsqu'il attend de pouvoir acc\u00e9der au processeur \u00e9tat en bloqu\u00e9 : lorsque le processus est interrompu car il a besoin d'attendre une ressource quelconque (entr\u00e9e/sortie, allocation m\u00e9moire, etc.) Il est important de comprendre que le processeur ne peut g\u00e9rer qu'un seul processus \u00e0 la fois : le processus \u00e9lu . En pratique, lorsqu'un processus est cr\u00e9\u00e9 il est dans l'\u00e9tat pr\u00eat et attend de pouvoir acc\u00e9der au processeur (d'\u00eatre \u00e9lu ). Lorsqu'il est \u00e9lu, le processus est ex\u00e9cut\u00e9 par le processeur mais cette ex\u00e9cution peut \u00eatre interrompue : soit pour laisser la main \u00e0 un autre processus (qui a \u00e9t\u00e9 \u00e9lu) : dans ce cas, le processus de d\u00e9part repasse dans l'\u00e9tat pr\u00eat et doit attendre d'\u00eatre \u00e9lu pour reprendre son ex\u00e9cution soit parce que le processus en cours a besoin d'attendre une ressource : dans ce cas, le processus passe dans l'\u00e9tat bloqu\u00e9 . Lorsque le processus bloqu\u00e9 finit par obtenir la ressource attendue, il peut th\u00e9oriquement reprendre son ex\u00e9cution mais probablement qu'un autre processus a pris sa place et est pass\u00e9 dans l'\u00e9tat \u00e9lu. Auquel cas, le processus qui vient d'\u00eatre \"d\u00e9bloqu\u00e9\" repasse dans l'\u00e9tat pr\u00eat en attendant d'\u00eatre \u00e0 nouveau \u00e9lu. Ainsi, l'\u00e9tat d'un processus au cours de sa vie varie entre les \u00e9tats pr\u00eat , \u00e9lu et bloqu\u00e9 comme le r\u00e9sume le sch\u00e9ma suivant : Lorsqu'un processus est interrompu, il doit pouvoir reprendre \u00e0 l'endroit m\u00eame o\u00f9 il a \u00e9t\u00e9 interrompu. Pour cela, le syst\u00e8me d'exploitation conserve pour chaque processus cr\u00e9\u00e9 une zone m\u00e9moire (appel\u00e9e PCB, pour Process Control Bloc , ou bloc de contr\u00f4le du processus) dans laquelle sont stock\u00e9es les informations sur le processus : son PIB, son \u00e9tat, la valeur des registres lors de sa derni\u00e8re interruption, la zone m\u00e9moire allou\u00e9e par le processus lors de son ex\u00e9cution, les ressources utilis\u00e9es par le processus (fichiers ouverts, connexions r\u00e9seaux en cours d'utilisation, etc.). Ordonnancement \u2693\ufe0e C'est le syst\u00e8me d'exploitation qui attribue aux processus leurs \u00e9tats \u00e9lu , pr\u00eat et bloqu\u00e9 . Plus pr\u00e9cis\u00e9ment, c'est l' ordonnanceur (un des composants du syst\u00e8me d'exploitation) qui r\u00e9alise cette t\u00e2che appel\u00e9e ordonnancement des processus . L'objectif de l'ordonnanceur est de choisir le processus \u00e0 ex\u00e9cuter \u00e0 l'instant \\(t\\) (le processus \u00e9lu ) et d\u00e9terminer le temps durant lequel le processeur lui sera allou\u00e9. Ce choix est \u00e0 faire parmi tous les processus qui sont dans l'\u00e9tat pr\u00eat , mais lequel sera \u00e9lu ? et pour combien de temps ? Des algorithmes d'ordonnancement sont utilis\u00e9s et il en existe plusieurs selon la strat\u00e9gie utilis\u00e9e. On en pr\u00e9sente quelques-uns ci-dessous. Ordonnancement First Come First Served (FCFS) \u2693\ufe0e Principe : Les processus sont ordonnanc\u00e9s selon leur ordre d'arriv\u00e9e (\"premier arriv\u00e9, premier servi\" en fran\u00e7ais) Exemple : Les processus \\(P_1(53)\\) , \\(P_2(17)\\) , \\(P_3(68)\\) et \\(P_4(24)\\) arrivent dans cet ordre \u00e0 \\(t=0\\) : Cela signifie que \\(P_1\\) , \\(P_2\\) , \\(P_3\\) et \\(P_4\\) ont besoin de respectivement 53, 17, 68 et 24 unit\u00e9s de temps pour s'ex\u00e9cuter. Ordonnancement Shortest Job First (SJF) \u2693\ufe0e Principe : Le processus dont le temps d'ex\u00e9cution est le plus court est ordonnanc\u00e9 en premier. Exemple : \\(P_1\\) , \\(P_2\\) , \\(P_3\\) et \\(P_4\\) arrivent \u00e0 \\(t=0\\) : Ordonnancement Shortest Remaining Time (SRT) \u2693\ufe0e Principe : Le processus dont le temps d'ex\u00e9cution restant est le plus court parmi ceux qui restent \u00e0 ex\u00e9cuter est ordonnanc\u00e9 en premier. Exemple : \\(P_3\\) et \\(P_4\\) arrivent \u00e0 \\(t=0\\) ; \\(P_2\\) \u00e0 \\(t=20\\) ; \\(P_1\\) \u00e0 \\(t=50\\) : Ordonnancement temps-partag\u00e9 (Round-Robin) \u2693\ufe0e Principe : C'est la politique du tourniquet : allocation du processeur par tranche (= quantum \\(q\\) ) de temps. Exemple : quantum \\(q = 20\\) et \\(n = 4\\) processus Dans ce cas, s'il y a \\(n\\) processus, chacun d'eux obtient le processeur au bout de \\((n-1)\\times q\\) unit\u00e9s de temps au plus Ordonnancement \u00e0 priorit\u00e9s statiques \u2693\ufe0e Principe : Allocation du processeur selon des priorit\u00e9s statiques (= num\u00e9ros affect\u00e9s aux processus pour toute la vie de l'application) Exemple : priorit\u00e9s \\((P_1, P_2, P_3, P_4) = (3, 2, 0, 1)\\) o\u00f9 la priorit\u00e9 la plus forte est 0 (attention, dans certains syst\u00e8mes c'est l'inverse : 0 est alors la priorit\u00e9 la plus faible) Probl\u00e8mes li\u00e9s \u00e0 l'acc\u00e8s concurrent aux ressources \u2693\ufe0e Les processus se partagent souvent une ou plusieurs ressources, et cela peut poser des probl\u00e8mes. Probl\u00e8mes de synchronisation : illustration avec Python \u2693\ufe0e Exemple d'une variable partag\u00e9e \u2693\ufe0e Prenons l'exemple d'une variable (= ressource logicielle) partag\u00e9e entre plusieurs processus. Plus pr\u00e9cis\u00e9ment, consid\u00e9rons un programme de jeu multi-joueur dans lequel une variable nb_pions repr\u00e9sente le nombre de pions disponibles pour tous les joueurs. Une fonction prendre_un_pion() permet de prendre un pion dans le tas commun de pions disponibles, s'il reste au moins un pion \u00e9videmment. On va se mettre dans la situation o\u00f9 il ne reste plus qu'un pion dans le tas commun et on suppose que deux joueurs utilisent la fonction prendre_un_pion() , ce qui conduit \u00e0 la cr\u00e9ation de deux processus p1 et p2 , chacun correspondant \u00e0 un joueur. Avec Python, on peut utiliser le module multiprocessing pour cr\u00e9er des processus. Le programme Python pions.py suivant permet de r\u00e9aliser la situation de jeu d\u00e9crite : \ud83d\udc0d Script Python from multiprocessing import Process , Value import time def prendre_un_pion ( nombre ): if nombre . value >= 1 : time . sleep ( 0.001 ) # pour simuler un traitement avec des calculs temp = nombre . value nombre . value = temp - 1 # on d\u00e9cr\u00e9mente le nombre de pions if __name__ == '__main__' : # cr\u00e9ation de la variable partag\u00e9e initialis\u00e9e \u00e0 1 nb_pions = Value ( 'i' , 1 ) # on cr\u00e9e deux processus p1 = Process ( target = prendre_un_pion , args = [ nb_pions ]) p2 = Process ( target = prendre_un_pion , args = [ nb_pions ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () print ( \"nombre final de pions :\" , nb_pions . value ) Explications : Le if __name__ = '__main'__: permet de ne cr\u00e9er qu'une seule fois les processus p1 et p2 qui suivent (c'est n\u00e9cessaire sous Windows, pas sous GNU/Linux car la cr\u00e9ation des processus ne se fait pas de la m\u00eame mani\u00e8re, mais cela reste conseill\u00e9 ne serait-ce que pour des raisons de compatibilit\u00e9), on n'en dira pas davantage ici car cela d\u00e9passe le niveau de ce cours. On a utilis\u00e9 la classe Process du module multiprocessing pour instancier deux processus p1 et p2 . L'argument target est le nom de la fonction qui sera ex\u00e9cut\u00e9e par le processus : ici les deux processus doivent ex\u00e9cuter la m\u00eame fonction prendre_un_pion() L'argument args est une liste des arguments pass\u00e9s \u00e0 la fonction cible : ici il s'agit de la variable nb_pions qui est partag\u00e9e par les deux processus. Par d\u00e9faut, deux processus ne partagent pas de donn\u00e9es en m\u00e9moire : on ne peut pas donc pas utiliser nb_pions comme une variable globale. Il faut utiliser la classe Value du module multiprocessing pour cr\u00e9er nb_pions dans une m\u00e9moire partag\u00e9e entre les processus. L'argument 'i' indique que nb_pions est un entier (sign\u00e9) et le deuxi\u00e8me argument est la valeur initiale de la variable, ici 1. La fonction prendre_un_pion() prend un nombre en param\u00e8tre et d\u00e9cr\u00e9mente sa valeur d'une unit\u00e9 si le nombre est au moins \u00e9gal \u00e0 1. Lors de l'ex\u00e9cution de la fonction par les deux processus, l'argument en question sera l'objet nb_pions de la classe Value et on acc\u00e8de \u00e0 sa valeur avec l'attribut value . On a ajout\u00e9 une temporisation permettant de simuler d'autres calculs qui pourraient avoir lieu (par exemple, des instructions de mise \u00e0 jour du nombre de pions des joueurs) Les derni\u00e8res lignes permettent de d\u00e9marrer les deux processus et attendre qu'ils soient termin\u00e9s pour afficher la valeur finale de nb_pions . Si on ex\u00e9cute ce programme, les deux processus p1 et p2 sont ex\u00e9cut\u00e9s et on s'attend au comportement suivant (en supposant qu'il ne reste qu'un seule pion dans le tas commun) : l'un des deux est \u00e9lu en premier, par exemple p1 , et ex\u00e9cute la fonction prendre_un_pion() , le nombre de pions est \u00e9gal \u00e0 1 donc nb_pions est d\u00e9cr\u00e9ment\u00e9 d'une unit\u00e9 et prend donc la valeur 0, le processus p1 est termin\u00e9 ; le processus p2 , qui \u00e9tait en attente, est ensuite \u00e9lu, et comme le nombre de pions est d\u00e9sormais \u00e9gal \u00e0 0 rien ne se passe et p2 termine. Ainsi, le premier joueur a pu prendre le pion restant et le second s'est retrouv\u00e9 coinc\u00e9, et la valeur finale de nb_pions vaut 0. Et pourtant, il est tout \u00e0 fait possible que les choses ne se passent pas ainsi ! En effet, en ex\u00e9cutant plusieurs fois le programme pions.py dans un terminal, on obtient parfois une valeur finale \u00e9gale \u00e0 0 et parfois \u00e9gale \u00e0 -1 : C'est un r\u00e9sultat tr\u00e8s perturbant non ? Expliquons pourquoi ! Pour cela, on peut ajouter quelques instructions d'affichage pour suivre ce qu'il se passe. On obtient le script pions_v2.py suivant : \ud83d\udc0d Script Python from multiprocessing import Process , Value import time def prendre_un_pion ( nombre , numero_processus ): print ( f \"d\u00e9but du processus { numero_processus } \" ) if nombre . value >= 1 : print ( f \"processus { numero_processus } : \u00e9tape A\" ) time . sleep ( 0.001 ) # pour simuler un traitement avec des calculs print ( f \"processus { numero_processus } : \u00e9tape B\" ) temp = nombre . value nombre . value = temp - 1 # on d\u00e9cr\u00e9mente le nombre de pions print ( f \"nombre de pions restants \u00e0 la fin du processus { numero_processus } : { nombre . value } \" ) if __name__ == '__main__' : # cr\u00e9ation de la variable partag\u00e9e initialis\u00e9e \u00e0 1 nb_pions = Value ( 'i' , 1 ) # on cr\u00e9e deux processus p1 = Process ( target = prendre_un_pion , args = [ nb_pions , 1 ]) p2 = Process ( target = prendre_un_pion , args = [ nb_pions , 2 ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () print ( \"nombre final de pions :\" , nb_pions . value ) Explications : Lors de la cr\u00e9ation des processus, on passe un deuxi\u00e8me argument \u00e0 la fonction prendre_un_pion() , le num\u00e9ro du processus : 1 pour p1 et 2 pour p2 . Cela permet d'afficher dans cette fonction le num\u00e9ro du processus \u00e0 des endroits strat\u00e9giques : au d\u00e9but, \u00e0 l'entr\u00e9e dans le if , juste avant de d\u00e9cr\u00e9menter le nombre de pions et \u00e0 la fin du processus. En ex\u00e9cutant pions_v2.py dans un terminal, on obtient ce genre de choses : Analysons la premi\u00e8re ex\u00e9cution du programme. le processus p1 est \u00e9lu en premier (affichage de \"d\u00e9but du processus 1\") mais est de suite interrompu par l'ordonnanceur qui \u00e9lit p2 (affichage de \"d\u00e9but du processus 2\") puis c'est de nouveau le processus p1 qui a la main et il rentre dans le if (affichage de \"processus 1 : \u00e9tape A\") mais est interrompu \u00e0 nouveau et l'ordonnanceur donne la main \u00e0 p2 qui rentre aussi dans le if (affichage de \"processus 2 : \u00e9tape A\") : en effet, \u00e0 ce stade le nombre de pions n'a pas encore \u00e9t\u00e9 d\u00e9cr\u00e9ment\u00e9 par p1 car il a \u00e9t\u00e9 interrompu avant l'\u00e9tape B, et donc p2 a pu entrer dans le if puisque la condition nombre.value >= 1 est toujours vraie \u00e0 ce moment l\u00e0 !! ensuite le processeur est allou\u00e9 alternativement \u00e0 p1 et p2 (voir les affichages restants) mais le mal est fait puisque les deux processus sont d\u00e9sormais chacun entr\u00e9s dans le if , ils vont chacun d\u00e9cr\u00e9menter le nombre de pions d'une unit\u00e9 et chacun des deux joueurs aura pioch\u00e9 un pion alors qu'il n'y en avait qu'un seul au d\u00e9part ! Vous remarquerez que la troisi\u00e8me ex\u00e9cution du programme met en \u00e9vidence le m\u00eame probl\u00e8me car les deux processus ont chacun pu entrer dans le if , m\u00eame si l'ordre des instructions ex\u00e9cut\u00e9es apr\u00e8s n'est pas tout \u00e0 fait le m\u00eame. Si on analyse la seconde ex\u00e9cution du programme qui donne le comportement souhait\u00e9, on constate que p1 a eu suffisamment de temps pour d\u00e9cr\u00e9menter le nombre de pions (qui vaut d\u00e9sormais 0) avant que p2 ne fasse le test nombre.value >= 1 et se rende compte que cette condition est fausse. Dans ce cas, seul le premier joueur a pas pu piocher un pion. Heureusement, on peut \u00e9viter le probl\u00e8me mis en \u00e9vidence dans l'exemple pr\u00e9c\u00e9dent. Comment \u00e9viter les probl\u00e8mes de synchronisation ? \u2693\ufe0e On va utiliser ce qu'on appelle un verrou : un verrou est objet partag\u00e9 entre plusieurs processus mais qui garantit qu'un seul processus acc\u00e8de \u00e0 une ressource \u00e0 un instant donn\u00e9. Concr\u00e8tement, un verrou peut \u00eatre acquis par les diff\u00e9rents processus, et le premier \u00e0 faire la demande acquiert le verrou. Si le verrou est d\u00e9tenu par un autre processus, alors tout autre processus souhaitant l'obtenir est bloqu\u00e9 jusqu'\u00e0 ce qu'il soit lib\u00e9r\u00e9. Le module multiprocessing de Python propose un objet Lock() correpondant \u00e0 un verrou. Deux m\u00e9thodes sont utilis\u00e9es : la m\u00e9thode .acquire() permet de demander le verrou (le processus faisant la demande est bloqu\u00e9 tant qu'il ne l'a pas obtenu) la m\u00e9thode .release() permet de lib\u00e9rer le verrou (il pourra alors \u00eatre obtenu par un autre processus qui en fait la demande) On peut alors r\u00e9gler le probl\u00e8me de l'exemple pr\u00e9c\u00e9dent avec le script pions_v3.py suivant dans lequel on a laiss\u00e9 les affichages pour bien suivre : \ud83d\udc0d Script Python from multiprocessing import Process , Value , Lock import time def prendre_un_pion ( v , nombre , numero_processus ): print ( f \"d\u00e9but du processus { numero_processus } \" ) v . acquire () # acquisition du verrou if nombre . value >= 1 : print ( f \"processus { numero_processus } : \u00e9tape A\" ) time . sleep ( 0.001 ) print ( f \"processus { numero_processus } : \u00e9tape B\" ) temp = nombre . value nombre . value = temp - 1 v . release () # verrou lib\u00e9r\u00e9 print ( f \"nombre de pions restants \u00e0 la fin du processus { numero_processus } : { nombre . value } \" ) if __name__ == '__main__' : # cr\u00e9ation de la variable partag\u00e9e initialis\u00e9e \u00e0 1 nb_pions = Value ( 'i' , 1 ) # verrou partag\u00e9 par les deux processus verrou = Lock () # on cr\u00e9e deux processus p1 = Process ( target = prendre_un_pion , args = [ verrou , nb_pions , 1 ]) p2 = Process ( target = prendre_un_pion , args = [ verrou , nb_pions , 2 ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () print ( \"nombre final de pions :\" , nb_pions . value ) En ex\u00e9cutant (plusieurs fois) ce script dans un terminal on constate que le nombre final de pions est toujours \u00e9gal \u00e0 0. Avant de faire le test du if , le processus essaye d'acqu\u00e9rir le verrou avec v.acquire() . D\u00e8s qu'il est acquis, le processus a la garantie qu'il est le seul \u00e0 pouvoir ex\u00e9cuter le code jusqu'\u00e0 l'instruction v.release() . Cette portion de code prot\u00e9g\u00e9e s'appelle une section critique . Cela ne veut pas dire que le processus d\u00e9tenant le verrou ne peut pas \u00eatre interrompu, mais il ne le sera pas par un processus qui est essaie d'acqu\u00e9rir le m\u00eame verrou. \ud83d\udc0d Script Python def prendre_un_pion ( v , nombre , numero_processus ): v . acquire () # d\u00e9but section critique if nombre . value >= 1 : time . sleep ( 0.001 ) temp = nombre . value nombre . value = temp - 1 # fin de la section critique v . release () Si vous analysez l'affichage pr\u00e9c\u00e9dent dans le terminal, on voit d'ailleurs que p1 est entr\u00e9 en section critique (affichage \"processus 1 : \u00e9tape A\") mais est interrompu, puis c'est p2 qui a la main (affichage \"d\u00e9but processus 2\") mais il va se retrouver bloquer \u00e0 l'instruction v.acquire() puisque c'est p1 qui d\u00e9tient le verrou. Lorsque p1 reprendra la main, il pourra ex\u00e9cuter ses instructions jusqu'\u00e0 v.release() sans \u00eatre interrompu par p2 (alors nb_pions sera d\u00e9cr\u00e9ment\u00e9 d'une unit\u00e9). Lorsque p1 lib\u00e8re le verrou, p2 pourra alors l'obtenir, ex\u00e9cuter sa section critique et constater que la condition nombre.value >= 1 est fausse : le deuxi\u00e8me joueur ne pourra alors pas prendre de pion. Nous terminons en voyant que l'utilisation de verrous n'est pas sans risque car elle peut engendrer des probl\u00e8mes d'interblocage. Risque d'interblocage \u2693\ufe0e Les interblocages ( deadlock en anglais) sont des situations de la vie quotidienne. L'exemple classique est celui du carrefour avec priorit\u00e9 \u00e0 droite o\u00f9 chaque v\u00e9hicule est bloqu\u00e9 car il doit laisser le passage au v\u00e9hicule \u00e0 sa droite. En informatique l' interblocage peut \u00e9galement se produire lorsque plusieurs processus concurrents s'attendent mutuellement. Ce sc\u00e9nario peut se produire lorsque plusieurs ressources sont partag\u00e9es par plusieurs processus et l'un d'entre eux poss\u00e8de ind\u00e9finiment une ressource n\u00e9cessaire pour un autre. Ce ph\u00e9nom\u00e8ne d' attente circulaire , o\u00f9 chaque processus attend une ressource d\u00e9tenue par un autre processus, peut \u00eatre provoqu\u00e9e par l'utilisation de plusieurs verrous. Consid\u00e9rons le script interblocage.py suivant dans lequel on a cr\u00e9\u00e9 deux verrous v1 et v2 utilis\u00e9s par deux fonctions f1 et f2 ex\u00e9cut\u00e9es respectivement par deux processus p1 et p2 . Le processus p1 essaie d'acqu\u00e9rir d'abord v1 puis v2 tandis que le processus p2 essaie de les acqu\u00e9rir dans l'ordre inverse. \ud83d\udc0d Script Python from multiprocessing import Process , Lock import time import os def f1 ( v1 , v2 ): print ( \"PID du processus 1:\" , os . getpid ()) for i in range ( 100 ): time . sleep ( 0.001 ) v1 . acquire () v2 . acquire () print ( \"processus 1 en cours, it\u00e9ration \" , i ) v2 . release () v1 . release () def f2 ( v1 , v2 ): print ( \"PID du processus 2:\" , os . getpid ()) for i in range ( 100 ): time . sleep ( 0.001 ) v2 . acquire () v1 . acquire () print ( \"processus 2 en cours, it\u00e9ration \" , i ) v1 . release () v2 . release () if __name__ == '__main__' : # cr\u00e9ation de deux verrous v1 = Lock () v2 = Lock () # cr\u00e9ation de deux processus p1 = Process ( target = f1 , args = [ v1 , v2 ]) p2 = Process ( target = f2 , args = [ v1 , v2 ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () Si on ex\u00e9cute ce programme, il y a de grandes chances de se retrouver bloqu\u00e9. Par exemple, dans le cas de l'ex\u00e9cution suivante : le processus p1 est \u00e9lu : il s'ex\u00e9cute jusqu'\u00e0 l'acquisition de v1 mais avant la tentative d'acquisition de v2 , puis est interrompu le processus p2 est \u00e0 son tour \u00e9lu : il s'ex\u00e9cute et acquiert v2 qui est toujours libre, puis bloque sur l'acquisition de v1 (qui est d\u00e9tenu par p1 ). le processus p1 reprend la main et bloque sur l'acquisition de v2 (d\u00e9tenu par p2 ). Chaque processus d\u00e9tient un verrou et attend l'autre : ils sont en interblocage et l'attente est infinie. On peut lancer (plusieurs fois si n\u00e9cessaire) le script \u00e0 partir du terminal et constater que l'interblocage a lieu tr\u00e8s souvent. Il n'y a alors pas d'autres choix que d'interrompre les processus en interblocage, par exemple avec la commande kill . Cependant, ce probl\u00e8me a lieu ici car les deux processus essaie d'acqu\u00e9rir les verrous dans l'ordre contraire. Si l'ordre d'acquisition est le m\u00eame pour les processus, le probl\u00e8me n'a plus lieu (n'h\u00e9sitez pas \u00e0 tester !). De mani\u00e8re g\u00e9n\u00e9rale, dans des probl\u00e8mes complexes les situations d'interblocage sont difficiles \u00e0 d\u00e9tecter et il se peut tr\u00e8s bien que le programme se comporte bien pendant toute une phase de tests mais bloque lors d'une ex\u00e9cution ult\u00e9rieure puisque l'on ne peut pas pr\u00e9voir l'ordonnancement des processus. Simulation d'interblocage\u2693\ufe0e \u2693\ufe0e Robosomes cr\u00e9\u00e9 par Alain BUSSER , S\u00e9bastien HOARAU (Voir ici : Robosomes - IREM de la r\u00e9union Le jeu robosomes se joue \u00e0 un seul joueur sur une grille rectangulaire. Chaque case peut \u00eatre soit vide soit couverte par un obstacle fixe (en noir comme aux mots crois\u00e9s) soit couverte d\u2019un pion pouvant bouger, appel\u00e9 robot Chaque robot peut \u00eatre tourn\u00e9 dans l\u2019une des quatre directions cardinales \u25c0\u25b2\u25b6\u25bc. Les robots peuvent bouger tous en m\u00eame temps de l\u2019une des fa\u00e7ons suivantes : G : tous les robots tournent vers leur gauche (de 90\u00b0) en m\u00eame temps D : tous les robots tournent vers leur droite (de 90\u00b0) en m\u00eame temps A : les robots qui peuvent avancer d\u2019une case, le font. Un robot peut avancer d\u2019une case s\u2019il n\u2019y a pas d\u2019obstacle sur cette case et si aucun robot ne s\u2019appr\u00eate \u00e0 aller sur cette case. Les cases du bord de la grille sont toutes couvertes d\u2019obstacles fixes, \u00e0 l\u2019exception de l\u2019une d\u2019entre elles appel\u00e9e \u00ab sortie \u00bb. Lorsqu\u2019un robot est sur la case de sortie, tourn\u00e9 vers l\u2019ext\u00e9rieur de la grille, il quitte le jeu et n\u2019est plus soumis aux ordres donn\u00e9s. Le but du jeu est de faire sortir tous les robots de la grille, en \u00e9crivant un mot dans l\u2019alphabet A,G,D, appel\u00e9 programme et que les robots interpr\u00e9teront comme d\u00e9crit ci-dessus. Voici quelques exemples : Un premier exemple pour se mettre en route. Interblocage Interblocage 1 Interblocage 2 Interblocage 3 Interblocage 4 Interblocage perp\u00e9tuel ou pas Interblocage 8 Et pour les syst\u00e8mes multiprocesseurs ? \u2693\ufe0e Les ordinateurs actuels poss\u00e8dent g\u00e9n\u00e9ralement plusieurs processeurs, ce qui permet \u00e0 plusieurs processus d'\u00eatre ex\u00e9cut\u00e9s parall\u00e8lement : un par processeur. Ce parall\u00e9lisme permet bien \u00e9videmment une plus grande puissance de calcul. Pour r\u00e9partir les diff\u00e9rents processus entre les diff\u00e9rents processeurs, on distingue deux approches : l'approche partitionn\u00e9e : chaque processeur poss\u00e8de un ordonnanceur particulier et les processus sont r\u00e9partis entre les diff\u00e9rents ordonnanceurs l'approche globale : un ordonnanceur global est charg\u00e9 de d\u00e9terminer la r\u00e9partition des processus entre les diff\u00e9rents processeurs L'ordonnancement des processus des syst\u00e8mes d'exploitation actuels est bien plus complexe que les quelques algorithmes \u00e9voqu\u00e9s dans ce cours, et cela d\u00e9passe largement le cadre du programme de NSI. Si vous souhaitez en savoir plus, voici n\u00e9anmoins une vid\u00e9o int\u00e9ressante (en fran\u00e7ais) sur l'ordonnancement du noyau Linux : https://www.youtube.com/watch?v=uCGe5WWd1OI&t=195s&ab_channel=Vitonimal . Bilan \u2693\ufe0e Un programme en cours d'ex\u00e9cution s'appelle un processus . Les syst\u00e8mes d'exploitation r\u00e9cents permettent d'ex\u00e9cuter plusieurs processus simultan\u00e9ment. En r\u00e9alit\u00e9, ces processus sont ex\u00e9cut\u00e9s \u00e0 tour de r\u00f4le par le syst\u00e8me d'exploitation qui est charg\u00e9 d'allouer \u00e0 chacun d'eux les ressources dont il a besoin en termes de m\u00e9moire, entr\u00e9es-sorties ou temps d'acc\u00e8s au processeur, et de s'assurer que les processus ne se g\u00eanent pas les uns les autres. Au cours de leur vie, les processus varient entre trois \u00e9tats : \u00e9lu si le processus est ex\u00e9cut\u00e9 par le processeur, pr\u00eat si le processus est pr\u00eat \u00e0 \u00eatre ex\u00e9cut\u00e9, et bloqu\u00e9 si le processus est en attente d'une ressource. C'est l' ordonnanceur qui est charg\u00e9 de d\u00e9finir l'ordre dans lequel les processus doivent \u00eatre ex\u00e9cut\u00e9s par le processeur. Ce choix se fait gr\u00e2ce \u00e0 des algorithmes d'ordonnancement. Les processus se partagent les diff\u00e9rentes ressources, on parle d' acc\u00e8s concurrent aux ressources. Ce partage des ressources n'est pas sans risque et peut conduire \u00e0 des probl\u00e8mes de synchronisation. Ces probl\u00e8mes peuvent \u00eatre \u00e9vit\u00e9s en utilisant un verrou , qui permet \u00e0 un processus de ne pas \u00eatre interrompu dans sa section critique par un autre processus demandant le m\u00eame verrou. L'utilisation de plusieurs verrous peut entra\u00eener des interblocages , c'est-\u00e0-dire des situations o\u00f9 chaque processus attend une ressource d\u00e9tenue par un autre, conduisant \u00e0 une attente cyclique infinie. L'ordre d'acquisition des verrous est important mais pas toujours \u00e9vident \u00e0 \u00e9crire dans le cas de probl\u00e8mes complexes. Exercice 3 : Algorithmes d'ordonnancement \u2693\ufe0e Soient les diff\u00e9rents processus suivants : Processus Date d'arriv\u00e9e Dur\u00e9e de traitement \\(P_1\\) 0 3 \\(P_2\\) 1 6 \\(P_3\\) 3 4 \\(P_4\\) 6 5 \\(P_5\\) 8 2 Application de plusieurs algorithmes \u2693\ufe0e Q1 : Donnez le diagramme de Gantt pour l'ex\u00e9cution de ces diff\u00e9rents processus en utilisant successivement les algorithmes FCFS, RR (quantum = 2 unit\u00e9s de temps) et SRT. Performances des algorithmes d'ordonnancement \u2693\ufe0e On d\u00e9finit les m\u00e9triques suivantes : le temps de s\u00e9jour (ou d'ex\u00e9cution) (ou de rotation) d'un processus : c'est la diff\u00e9rence entre la date de fin d'ex\u00e9cution et la date d'arriv\u00e9e : \\( \\(T_{\\text{sej}} = \\text{date fin d'ex\u00e9cution} - \\text{date d'arriv\u00e9e}\\) \\) le temps d'attente d'un processus : c'est la diff\u00e9rence entre le temps de s\u00e9jour et la dur\u00e9e du processus : \\( \\(T_{\\text{att}} = T_{\\text{sej}} - \\text{dur\u00e9e du processus}\\) \\) le rendement d'un processus : c'est le quotient entre la dur\u00e9e du processus et le temps de s\u00e9jour : \\( \\(\\text{rendement} = \\dfrac{\\text{dur\u00e9e du processus}}{T_{\\text{sej}}}\\) \\) Q2 : Pour chacun des trois algorithmes, calculez le temps de s\u00e9jour, le temps d'attente et le rendement de chaque processus. Q3 : Quel vous semble \u00eatre le meilleur des trois algorithmes dans notre exemple ? Expliquer. Exercice 2 \u2693\ufe0e cet exercice est issu du sujet 2021 du bac NSI Partie A Cette partie est un questionnaire \u00e0 choix multiples (QCM). Pour chacune des questions, une seule des quatre r\u00e9ponses est exacte. Le candidat indiquera sur sa copie le num\u00e9ro de la question et la lettre correspondant \u00e0 la r\u00e9ponse exacte. Aucune justification n\u2019est demand\u00e9e. Une r\u00e9ponse fausse ou une absence de r\u00e9ponse n\u2019enl\u00e8ve aucun point. Question 1 Parmi les commandes ci-dessous, laquelle permet d\u2019afficher les processus en cours d\u2019ex\u00e9cution ? \ud83d\udccb Texte a. dir b. ps c. man d. ls Question 2 Quelle abr\u00e9viation d\u00e9signe l\u2019identifiant d\u2019un processus dans un syst\u00e8me d\u2019exploitation de type UNIX ? \ud83d\udccb Texte a. PIX b. SIG c. PID d. SID Question 3 Comment s\u2019appelle la gestion du partage du processeur entre diff\u00e9rents processus ? \ud83d\udccb Texte a. L\u2019interblocage b. L\u2019ordonnancement c. La planification d. La priorisation Question 4 Quelle commande permet d\u2019interrompre un processus dans un syst\u00e8me d\u2019exploitation de type UNIX ? \ud83d\udccb Texte a. stop b. interrupt c. end d. kill Correction 1.b 2.c 3.b 4.d Partie B Question 1 Un processeur choisit \u00e0 chaque cycle d\u2019ex\u00e9cution le processus qui doit \u00eatre ex\u00e9cut\u00e9. Le tableau ci-dessous donne pour trois processus P1, P2, P3 : la dur\u00e9e d\u2019ex\u00e9cution (en nombre de cycles), l\u2019instant d\u2019arriv\u00e9e sur le processeur (exprim\u00e9 en nombre de cycles \u00e0 partir de 0), le num\u00e9ro de priorit\u00e9. Le num\u00e9ro de priorit\u00e9 est d\u2019autant plus petit que la priorit\u00e9 est grande. On suppose qu\u2019\u00e0 chaque instant, c\u2019est le processus qui a le plus petit num\u00e9ro de priorit\u00e9 qui est ex\u00e9cut\u00e9, ce qui peut provoquer la suspension d\u2019un autre processus, lequel reprendra lorsqu\u2019il sera le plus prioritaire. Reproduire le tableau ci-dessous sur la copie et indiquer dans chacune des cases le processus ex\u00e9cut\u00e9 \u00e0 chaque cycle. Correction Question 1 On suppose maintenant que les trois processus pr\u00e9c\u00e9dents s\u2019ex\u00e9cutent et utilisent une ou plusieurs ressources parmi R1, R2 et R3. Parmi les sc\u00e9narios suivants, lequel provoque un interblocage ? Justifier. Correction Il s\u2019agit du sc\u00e9nario 2 car nous nous retrouvons dans la situation o\u00f9 P1 poss\u00e8de R1 et attend R2 avant de pouvoir continuer et P3 poss\u00e8de R2 et attend R1 avant de pouvoir continuer. Partie C Dans cette partie, pour une meilleure lisibilit\u00e9, des espaces sont plac\u00e9es dans les \u00e9critures binaires des nombres. Il ne faut pas les prendre en compte dans les calculs. Pour chiffrer un message, une m\u00e9thode, dite du masque jetable, consiste \u00e0 le combiner avec une cha\u00eene de caract\u00e8res de longueur comparable. Une impl\u00e9mentation possible utilise l\u2019op\u00e9rateur XOR (ou exclusif) dont voici la table de v\u00e9rit\u00e9 : a b a XOR b 0 0 0 0 1 1 1 0 1 1 1 0 Dans la suite, les nombres \u00e9crits en binaire seront pr\u00e9c\u00e9d\u00e9s du pr\u00e9fixe 0b. Question 1 Pour chiffrer un message, on convertit chacun de ses caract\u00e8res en binaire (\u00e0 l\u2019aide du format Unicode), et on r\u00e9alise l\u2019op\u00e9ration XOR bit \u00e0 bit avec la cl\u00e9. Apr\u00e8s conversion en binaire, et avant que l\u2019op\u00e9ration XOR bit \u00e0 bit avec la cl\u00e9 n\u2019ait \u00e9t\u00e9 effectu\u00e9e, Alice obtient le message suivant : m = 0b 0110 0011 0100 0110 a. Le message m correspond \u00e0 deux caract\u00e8res cod\u00e9s chacun sur 8 bits : d\u00e9terminer quels sont ces caract\u00e8res. On fournit pour cela la table ci-dessous qui associe \u00e0 l\u2019\u00e9criture hexad\u00e9cimale d\u2019un octet le caract\u00e8re correspondant (figure 2). Exemple de lecture : le caract\u00e8re correspondant \u00e0 l\u2019octet cod\u00e9 4A en hexad\u00e9cimal est la lettre J. Correction 0100 0110 => 46 en hexa => caract\u00e8re F 0110 0011 => 63 en hexa => caract\u00e8re c donc cF Question 1.b Pour chiffrer le message d\u2019Alice, on r\u00e9alise l\u2019op\u00e9ration XOR bit \u00e0 bit avec la cl\u00e9 suivante : k = 0b 1110 1110 1111 0000 Donner l\u2019\u00e9criture binaire du message obtenu. Correction 0b 1000 1101 1011 0110 Question 2.a Dresser la table de v\u00e9rit\u00e9 de l\u2019expression bool\u00e9enne suivante : (a XOR b) XOR b Correction a b (a XOR b) XOR b 0 0 0 0 1 0 1 0 1 1 1 1 Question 2.b Bob conna\u00eet la cha\u00eene de caract\u00e8res utilis\u00e9e par Alice pour chiffrer le message. Quelle op\u00e9ration doit-il r\u00e9aliser pour d\u00e9chiffrer son message ? Correction On peut remarquer que (a xor b) xor b permet de retrouver a, donc si a correspond au message non chiffr\u00e9 et a xor b correspond au message chiffr\u00e9, un (a xor b) xor b permet donc de retrouver le message non chiffr\u00e9. Si on appelle m le message non chiffr\u00e9, m\u2019 le message chiffr\u00e9 et k la cl\u00e9 de chiffrement, un m\u2019 xor k permettra de retrouver m. Exercice 3 \u2693\ufe0e d'apr\u00e8s le sujet du bac NSI 2021 Cet exercice porte sur les syst\u00e8mes d\u2019exploitation : gestion des processus et des ressources. Les parties A et B peuvent \u00eatre trait\u00e9es ind\u00e9pendamment Partie A Question 1 La commande ps suivie \u00e9ventuellement de diverses options permet de lister les processus actifs ou en attente sur une machine. Sur une machine \u00e9quip\u00e9e du syst\u00e8me d\u2019exploitation GNU/Linux, la commande \u201cps -aef\u201d permet d\u2019obtenir la sortie suivante (extrait) : a) Quelle est la particularit\u00e9 de l\u2019utilisateur \u201croot\u201d ? b) Quel est le processus parent du processus ayant pour PID 3383 Correction Dans un bureau d\u2019architectes, on dispose de certaines ressources qui ne peuvent \u00eatre utilis\u00e9es simultan\u00e9ment par plus d\u2019un processus, comme l\u2019imprimante, la table tra\u00e7ante, le modem. Chaque programme, lorsqu\u2019il s\u2019ex\u00e9cute, demande l\u2019allocation des ressources qui lui sont n\u00e9cessaires. Lorsqu\u2019il a fini de s\u2019ex\u00e9cuter, il lib\u00e8re ses ressources. Question 2 On appelle p1, p2 et p3 les processus associ\u00e9s respectivement aux programmes 1, 2 et 3. a) Justifier qu'une situation d'interblocage peut se produire. b) Modifier l'ordre des instructions du programme 3 pour qu'une telle situation ne puisse pas se produire. Correction 2.a Pour passer \u00e0 l\u2019ex\u00e9cution, le Programme 1 a besoin du modem, mais le modem est d\u00e9j\u00e0 utilis\u00e9 par le Programme 2. Le processus p1 est donc bloqu\u00e9. Pour passer \u00e0 l\u2019ex\u00e9cution, le Programme 2 a besoin de l\u2019imprimante, mais l\u2019imprimante est d\u00e9j\u00e0 utilis\u00e9e par le Programme 3. Le processus p2 est donc bloqu\u00e9. Pour passer \u00e0 l\u2019ex\u00e9cution, le Programme 3 a besoin de la table tra\u00e7ante, mais la table tra\u00e7ante est d\u00e9j\u00e0 utilis\u00e9e par le Programme 1. Le processus p3 est donc bloqu\u00e9. Les 3 processus sont bloqu\u00e9s et ne pourront pas lib\u00e9rer les ressources attendues par les autres processus (la lib\u00e9ration des ressources se faisant apr\u00e8s l\u2019ex\u00e9cution), nous sommes bien en situation d\u2019interblocage. 2.b Programme 3 demander (table tra\u00e7ante) demander (imprimante) ex\u00e9cution lib\u00e9rer (imprimante) lib\u00e9rer (table tra\u00e7ante) Question 3 Supposons que le processus p1 demande la table tra\u00e7ante alors qu'elle est en cours d'utilisation par le processus p3. Parmi les \u00e9tats suivants, quel sera l'\u00e9tat du processus p1 tant que la table tra\u00e7ante n'est pas disponible : a) \u00e9lu b) bloqu\u00e9 c) pr\u00eat d) termin\u00e9 Correction bloqu\u00e9 Partie B Avec une ligne de commande dans un terminal sous Linux, on obtient l'affichage suivant : La documentation Linux donne la signification des diff\u00e9rents champs : UID : identifiant utilisateur effectif ; PID : identifiant de processus ; PPID : PID du processus parent ; C : partie enti\u00e8re du pourcentage d'utilisation du processeur par rapport au temps de vie des processus ; STIME : l'heure de lancement du processus ; TTY : terminal de contr\u00f4le TIME : temps d'ex\u00e9cution CMD : nom de la commande du processus Question 1 Parmi les quatre commandes suivantes, laquelle a permis cet affichage ? a) ls -l b) ps \u2013ef c) cd .. d) chmod 741 processus.txt Correction ps -ef Question 2 Quel est l'identifiant du processus parent \u00e0 l'origine de tous les processus concernant le navigateur Web (chromium-browser) ? Correction L\u2019identifiant du processus parent \u00e0 l\u2019origine de tous les processus concernant le navigateur Web est 831 Question 3 Quel est l'identifiant du processus dont le temps d'ex\u00e9cution est le plus long ? Correction L\u2019identifiant du processus dont le temps d\u2019ex\u00e9cution est le plus long est 6211 (00:01:16) Exercice 4 \u2693\ufe0e Extrait sujet BAC 2021 Cet exercice porte sur la gestion des processus par un syst\u00e8me d\u2019exploitation. Partie A : Processus La commande UNIX ps pr\u00e9sente un clich\u00e9 instantan\u00e9 des processus en cours d'ex\u00e9cution. Avec l\u2019option \u2212eo pid,ppid,stat,command, cette commande affiche dans l\u2019ordre l\u2019identifiant du processus PID (process identifier), le PPID (parent process identifier), l\u2019\u00e9tat STAT et le nom de la commande \u00e0 l\u2019origine du processus. Les valeurs du champ STAT indique l\u2019\u00e9tat des processus : - R : processus en cours d\u2019ex\u00e9cution - S : processus endormi Sur un ordinateur, on ex\u00e9cute la commande ps \u2212eo pid,ppid,stat,command et on obtient un affichage dont on donne ci-dessous un extrait. \u00c0 l'aide de cet affichage, r\u00e9pondre aux questions ci-dessous. Question 1 Quel est le nom de la premi\u00e8re commande ex\u00e9cut\u00e9e par le syst\u00e8me d'exploitation lors du d\u00e9marrage ? Correction La premi\u00e8re commande ex\u00e9cut\u00e9e par le syst\u00e8me d\u2019exploitation lors du d\u00e9marrage est la commande init Question 2 Quels sont les identifiants des processus actifs sur cet ordinateur au moment de l\u2019appel de la commande ps ? Justifier la r\u00e9ponse. Correction Les processus actifs sont les processus ayant pour PID 5440 et 5450 (pr\u00e9sence de l\u2019indicateur R dans la colonne STAT pour ces 2 processus). Question 3 Depuis quelle application a-t-on ex\u00e9cut\u00e9 la commande ps ? Donner les autres commandes qui ont \u00e9t\u00e9 ex\u00e9cut\u00e9es \u00e0 partir de cette application. Correction La commande ps a \u00e9t\u00e9 ex\u00e9cut\u00e9e depuis l\u2019application Bash (car le processus ps a pour PPID 1912 qui correspond au PID de Bash). Deux autres processus Bash (PID 2014 et PID 2013) et un processus python programme1.py (PID 5437) ont \u00e9t\u00e9 lanc\u00e9s depuis le processus Bash de PID 1912. Question 4 Expliquer l'ordre dans lequel les deux commandes python programme1.py et python programme2.py ont \u00e9t\u00e9 ex\u00e9cut\u00e9es. Correction Le processus python programme1.py a un PID de 5437 alors que le processus python programme2.py a un PID de 5440. python programme1.py a \u00e9t\u00e9 ex\u00e9cut\u00e9 avant python programme2.py. Question 5 Peut-on pr\u00e9dire que l'une des deux commandes python programme1.py et python programme2.py finira avant l\u2019autre ? Correction Non, aucune pr\u00e9diction n\u2019est possible.","title":"TD n\u00b023 - gestion des processus"},{"location":"Processus/TD_Gestion_Processus_Diapo/","text":":root { --color-background: #91A3B0 !important; --color-foreground: black !important; --color-background-paginate : rgba(128,128,128,0.05); --color-highlight-hover : #FAF0E6 ; font-size: 1.75rem; border:10px; padding: 40px; } h1 { /* background-color: rgb(161, 161, 172); color:white;*/ font-family: @@font_name@@; font-size: 3rem; text-align:center; } h2 { background-color: rgb(70, 70, 77); color:white; font-family: @@font_name@@; font-size: 2.25rem; } h3 { color: brown; font-size: 1.75rem; } code { background: #778899; color:white; } blockquote { background: #ffedcc; border-left: 15px solid #d1bf9d; margin: 1.5em 15px; padding: 0.5em 15px; } blockquote:before{ content: unset; } blockquote:after{ content: unset; } img[alt~=\"center\"] { display: block; margin: 0 auto; } TD 23 - Cours : Gestion des processus \u2693\ufe0e Introduction \u2693\ufe0e Dans les ann\u00e9es 1970 les ordinateurs personnels \u00e9taient incapables d'ex\u00e9cuter plusieurs t\u00e2ches \u00e0 la fois : il fallait attendre qu'un programme lanc\u00e9 se termine pour en ex\u00e9cuter un autre. Les syst\u00e8mes d'exploitations r\u00e9cents (GNU/Linux, macOS, iOS, Android, Windows...) permettent d'ex\u00e9cuter des t\u00e2ches \"simultan\u00e9ment\". En effet, la plupart du temps, lorsque l'on utilise un ordinateur, plusieurs programmes sont ex\u00e9cut\u00e9s \"en m\u00eame temps\" : par exemple, on peut tr\u00e8s bien ouvrir simultan\u00e9ment un navigateur Web, un traitement de texte, un IDE Python, un logiciel de musique (sans parler de tous les programmes ex\u00e9cut\u00e9s en arri\u00e8re-plan) ... Ces programmes en cours d'ex\u00e9cution s'appellent des processus . Une des t\u00e2ches du syst\u00e8me d'exploitation est d'allouer \u00e0 chacun des processus les ressources dont il a besoin en termes de m\u00e9moire, entr\u00e9es-sorties ou temps d'acc\u00e8s au processeur, et de s'assurer que les processus ne se g\u00eanent pas les uns les autres. Pourtant, on rappelle qu'un programme n'est qu'une suite d'instructions machine ex\u00e9cut\u00e9es l'une apr\u00e8s l'autre par le processeur et qu'un processeur n'est capable d'ex\u00e9cuter qu'une seule instruction \u00e0 la fois. Pour rappel, voici les \u00e9tapes d'ex\u00e9cution d'une instruction. l'instruction point\u00e9e par le pointeur d'instruction est charg\u00e9e en m\u00e9moire Le pointeur d'instruction est incr\u00e9ment\u00e9 vers l'adresse suivante l'instruction est d\u00e9cod\u00e9e l'instruction est ex\u00e9cut\u00e9e Comment est-il alors possible que plusieurs programmes soient ex\u00e9cut\u00e9s en m\u00eame temps ? Processus \u2693\ufe0e Qu'est-ce qu'un processus ? \u2693\ufe0e Il ne faut pas confondre programme et processus : Un programme est un fichier binaire (on dit aussi un ex\u00e9cutable ) contenant des instructions machines que seul le processeur peut comprendre. Un processus est un programme en cours d'ex\u00e9cution , autrement dit le ph\u00e9nom\u00e8ne dynamique li\u00e9 \u00e0 l'ex\u00e9cution d'un programme par l'ordinateur. Ainsi, lorsque nous cliquons sur l'ic\u00f4ne d'un programme (ou lorsque nous ex\u00e9cutons une instruction dans la console pour lancer un programme), nous provoquons la naissance d'un ou plusieurs processus li\u00e9s au programme que nous lan\u00e7ons. Un processus est donc une instance d'un programme auquel est associ\u00e9 : du code des donn\u00e9es/variables manipul\u00e9es des ressources : processeur, m\u00e9moire, p\u00e9riph\u00e9riques d'entr\u00e9e/sortie (voir paragraphe suivant) Il n'est d'ailleurs pas rare qu'un m\u00eame programme soit ex\u00e9cut\u00e9 plusieurs fois sur une machine au m\u00eame moment en occupant des espaces m\u00e9moires diff\u00e9rents : par exemple deux documents ouverts avec un traitement de texte, ou trois consoles distinctes... qui correspondent \u00e0 autant d'instances du m\u00eame programme et donc \u00e0 des processus diff\u00e9rents. Observer les processus \u2693\ufe0e Il est tr\u00e8s facile de voir les diff\u00e9rents processus s'ex\u00e9cutant sur une machine. Sous GNU/Linux, on peut utiliser la commande ps (comme p roces s , la traduction anglaise de processus ) pour afficher les informations sur les processus (sous windows : talklist). En passant des options \u00e0 cette commande on peut obtenir des choses int\u00e9ressantes. Par exemple, en ex\u00e9cutant dans un terminal la commande ps -aef , on peut visualiser tous les processus en cours sur notre ordinateur : Cr\u00e9ation d'un processus \u2693\ufe0e Un processus peut \u00eatre cr\u00e9\u00e9 : au d\u00e9marrage du syst\u00e8me par un autre processus par une action d'un utilisateur (lancement d'un programme) Sous GNU/Linux, un tout premier processus est cr\u00e9\u00e9 au d\u00e9marrage (c'est le processus 0 ou encore Swapper ). Ce processus cr\u00e9e un processus souvent appel\u00e9 init qui est le fils du processus 0. Ensuite, \u00e0 partir de init , les autres processus n\u00e9cessaires au fonctionnement du syst\u00e8me sont cr\u00e9\u00e9s. Ces processus cr\u00e9ent ensuite eux-m\u00eames d'autres processus, etc. Un processus peut cr\u00e9er un ou plusieurs processus, ce qui aboutit \u00e0 une structure arborescente comme nous allons le voir maintenant. PID et PPID \u2693\ufe0e La commande pr\u00e9c\u00e9dente permet de voir que chaque processus est identifi\u00e9 par un num\u00e9ro : son PID (pour Process Identifier ). Ce num\u00e9ro est donn\u00e9 \u00e0 chaque processus par le syst\u00e8me d'exploitation. On constate \u00e9galement que chaque processus poss\u00e8de un PPID (pour Parent Process Identifier ), il s'agit du PID du processus parent, c'est-\u00e0-dire celui qui a d\u00e9clench\u00e9 la cr\u00e9ation du processus. En effet, un processus peut cr\u00e9er lui m\u00eame un ou plusieurs autres processus, appel\u00e9s processus fils . Observation des processus\u2693\ufe0e \u2693\ufe0e Sous Linux, on peut observer les processus et leur \u00e9tat en ligne de commande. Pour tester, cela on peut utiliser : terminal linux en ligne Voici quelques commandes utiles pour observer les processus : ps |: elle permet d'afficher la liste des processus en cours. (Pour avoir des informations sur les options taper man ps) Pour lister tous les processus : ps - ef top : Pour observer en temps r\u00e9els les diff\u00e9rents processus.(penser \u00e0 utiliser man top) la commande f permet de g\u00e9rer les colonnes affich\u00e9es. kill : elle permet de tuer un processus en lui envoyant un signal de fin. 15 pour arr\u00eater le processus proprement 9 pour arr\u00eater imm\u00e9diatement le processus. exemple d'utilisation : kill -15 7654 pour tuer proprement le processus de PID 7564 Exercice Dans un nouvel onglet ouvrir : terminal linux en ligne cr\u00e9er un premier terminal : utiliser les commandes de l'ann\u00e9e pr\u00e9c\u00e9dentes : ls, cd, touch, cat pour d\u00e9terminer le nom d'utilisateur : whoami cr\u00e9er un fichier vide test.py : touch test.py \u00e9diter le fichier test.py avec la commande : nano test.py y \u00e9crire le code suivant : \ud83d\udc0d Script Python for a in range ( 100000 ): print ( a ) pour sortir de l'\u00e9diteur : Ctrl+X, puis Y, puis Enter pour confirmer le nom lancer le programme avec : python3 test.py cr\u00e9er un second fichier p2.py avec le code suivant : \ud83d\udc0d Script Python while True : pass le lancer Il tourne sans fin. Pour l'arr\u00eater : Ctrl+C v\u00e9rifier la pr\u00e9sence dans le dossier des fichiers cr\u00e9\u00e9s, avec ls ouvrir un second terminal puis : dans ce second terminal lancer python3 sans nom de fichier dans le premier terminal taper ps -ef rep\u00e9rer le PID du processus python3 et le tuer avec la commande kill -9 (voir syntaxe au dessus) ouvrir un troisi\u00e8me terminal dans ce troisi\u00e8me terminal lancer la commande top modifier l'affichage pour faire appara\u00eetre le PPID (taper f, puis s\u00e9lectionner/ d\u00e9placer avec les touches curseur. Revenir \u00e0 l'affichage avec Esc) Enfin ouvrir des terminaux suppl\u00e9mentaires pour en avoir au moins 5 et lancer dans les terminaux : 1 aucun processus 1 avec nano 1 avec python3 1 avec python3 lan\u00e7ant p2.py 1 avec top observer les processus et essayer de les tuer avec la commande kill \u00e0 partir du premier terminal recommencer en relan\u00e7ant les processus et tuer les processus avec le terminal lan\u00e7ant top(puis commande k) Gestion des processus et des ressources \u2693\ufe0e Ex\u00e9cution concurrente \u2693\ufe0e Les syst\u00e8mes d'exploitation modernes sont capable d'ex\u00e9cuter plusieurs processus \"en m\u00eame temps\". En r\u00e9alit\u00e9 ces processus ne sont pas toujours ex\u00e9cut\u00e9s \"en m\u00eame temps\" mais plut\u00f4t \"\u00e0 tour de r\u00f4le\". On parle d'ex\u00e9cution concurrente car les processus sont en concurrence pour obtenir l'acc\u00e8s au processeur charg\u00e9 de les ex\u00e9cuter. Remarque : Sur un syst\u00e8me multiprocesseur, il est possible d'ex\u00e9cuter de mani\u00e8re parall\u00e8le plusieurs processus, autant qu'il y a de processeurs. Mais sur un m\u00eame processeur, un seul processus ne peut \u00eatre ex\u00e9cut\u00e9 \u00e0 la fois. On peut voir assez facilement cette ex\u00e9cution concurrente. Consid\u00e9rons les deux programmes Python suivants : progA.py \ud83d\udc0d Script Python import time for i in range ( 100 ): print ( \"programme A en cours, it\u00e9ration\" , i ) time . sleep ( 0.01 ) # pour simuler un traitement avec des calculs progB.py \ud83d\udc0d Script Python import time for i in range ( 100 ): print ( \"programme B en cours, it\u00e9ration\" , i ) time . sleep ( 0.01 ) # pour simuler un traitement avec des calculs \u2693\ufe0e En ouvrant un Terminal, on peut lancer simultan\u00e9ment ces deux programmes avec la commande Bash $ python progA.py & python progB.py & Le caract\u00e8re & qui suit une commande permet de lancer l'ex\u00e9cution en arri\u00e8re plan et de rendre la main au terminal. Le shell indique alors dans la console les PID des processus correspondant \u00e0 l'ex\u00e9cution de ces deux programmes (ici 9154 et 9155) puis on constate gr\u00e2ce aux affichages que le syst\u00e8me d'exploitation alloue le processeur aux deux programmes \u00e0 tour de r\u00f4le : Acc\u00e8s concurrents aux ressources \u2693\ufe0e Une ressource est une entit\u00e9 dont a besoin un processus pour s'ex\u00e9cuter. Les ressources peuvent \u00eatre mat\u00e9rielles (processeur, m\u00e9moire, p\u00e9riph\u00e9riques d'entr\u00e9e/sortie, ...) mais aussi logicielles (variables). Les diff\u00e9rents processus se partagent les ressources, on parle alors d' acc\u00e8s concurrents aux ressources . Par exemple, les processus se partagent tous l'acc\u00e8s \u00e0 la ressource \"processeur\" un traitement de texte et un IDE Python se partagent la ressource \"clavier\" ou encore la ressource \"disque dur\" (si on enregistre les fichiers), ... un navigateur et un logiciel de musique se partagent la ressource \"carte son\", ... C'est le syst\u00e8me d'exploitation qui est charg\u00e9 de g\u00e9rer les processus et les ressources qui leur sont n\u00e9cessaires, en partageant leur acc\u00e8s au processeur. Nous allons voir comment tout de suite ! \u00c9tats d'un processus \u2693\ufe0e Au cours de son existence, un processus peut se retrouver dans trois \u00e9tats : \u00e9tat \u00e9lu : lorsqu'il est en cours d'ex\u00e9cution, c'est-\u00e0-dire qu'il obtient l'acc\u00e8s au processeur \u00e9tat pr\u00eat : lorsqu'il attend de pouvoir acc\u00e9der au processeur \u00e9tat en bloqu\u00e9 : lorsque le processus est interrompu car il a besoin d'attendre une ressource quelconque (entr\u00e9e/sortie, allocation m\u00e9moire, etc.) Il est important de comprendre que le processeur ne peut g\u00e9rer qu'un seul processus \u00e0 la fois : le processus \u00e9lu . En pratique, lorsqu'un processus est cr\u00e9\u00e9 il est dans l'\u00e9tat pr\u00eat et attend de pouvoir acc\u00e9der au processeur (d'\u00eatre \u00e9lu ). Lorsqu'il est \u00e9lu, le processus est ex\u00e9cut\u00e9 par le processeur mais cette ex\u00e9cution peut \u00eatre interrompue : soit pour laisser la main \u00e0 un autre processus (qui a \u00e9t\u00e9 \u00e9lu) : dans ce cas, le processus de d\u00e9part repasse dans l'\u00e9tat pr\u00eat et doit attendre d'\u00eatre \u00e9lu pour reprendre son ex\u00e9cution soit parce que le processus en cours a besoin d'attendre une ressource : dans ce cas, le processus passe dans l'\u00e9tat bloqu\u00e9 . Lorsque le processus bloqu\u00e9 finit par obtenir la ressource attendue, il peut th\u00e9oriquement reprendre son ex\u00e9cution mais probablement qu'un autre processus a pris sa place et est pass\u00e9 dans l'\u00e9tat \u00e9lu. Auquel cas, le processus qui vient d'\u00eatre \"d\u00e9bloqu\u00e9\" repasse dans l'\u00e9tat pr\u00eat en attendant d'\u00eatre \u00e0 nouveau \u00e9lu. Ainsi, l'\u00e9tat d'un processus au cours de sa vie varie entre les \u00e9tats pr\u00eat , \u00e9lu et bloqu\u00e9 comme le r\u00e9sume le sch\u00e9ma suivant : Lorsqu'un processus est interrompu, il doit pouvoir reprendre \u00e0 l'endroit m\u00eame o\u00f9 il a \u00e9t\u00e9 interrompu. Pour cela, le syst\u00e8me d'exploitation conserve pour chaque processus cr\u00e9\u00e9 une zone m\u00e9moire (appel\u00e9e PCB, pour Process Control Bloc , ou bloc de contr\u00f4le du processus) dans laquelle sont stock\u00e9es les informations sur le processus : son PIB, son \u00e9tat, la valeur des registres lors de sa derni\u00e8re interruption, la zone m\u00e9moire allou\u00e9e par le processus lors de son ex\u00e9cution, les ressources utilis\u00e9es par le processus (fichiers ouverts, connexions r\u00e9seaux en cours d'utilisation, etc.). Ordonnancement \u2693\ufe0e C'est le syst\u00e8me d'exploitation qui attribue aux processus leurs \u00e9tats \u00e9lu , pr\u00eat et bloqu\u00e9 . Plus pr\u00e9cis\u00e9ment, c'est l' ordonnanceur (un des composants du syst\u00e8me d'exploitation) qui r\u00e9alise cette t\u00e2che appel\u00e9e ordonnancement des processus . L'objectif de l'ordonnanceur est de choisir le processus \u00e0 ex\u00e9cuter \u00e0 l'instant \\(t\\) (le processus \u00e9lu ) et d\u00e9terminer le temps durant lequel le processeur lui sera allou\u00e9. Ce choix est \u00e0 faire parmi tous les processus qui sont dans l'\u00e9tat pr\u00eat , mais lequel sera \u00e9lu ? et pour combien de temps ? Des algorithmes d'ordonnancement sont utilis\u00e9s et il en existe plusieurs selon la strat\u00e9gie utilis\u00e9e. On en pr\u00e9sente quelques-uns ci-dessous. Exemple : Les processus \\(P_1(53)\\) , \\(P_2(17)\\) , \\(P_3(68)\\) et \\(P_4(24)\\) arrivent dans cet ordre \u00e0 \\(t=0\\) : Ordonnancement First Come First Served (FCFS) \u2693\ufe0e Principe : Les processus sont ordonnanc\u00e9s selon leur ordre d'arriv\u00e9e (\"premier arriv\u00e9, premier servi\" en fran\u00e7ais) Cela signifie que \\(P_1\\) , \\(P_2\\) , \\(P_3\\) et \\(P_4\\) ont besoin de respectivement 53, 17, 68 et 24 unit\u00e9s de temps pour s'ex\u00e9cuter. Ordonnancement Shortest Job First (SJF) \u2693\ufe0e Principe : Le processus dont le temps d'ex\u00e9cution est le plus court est ordonnanc\u00e9 en premier. Exemple : \\(P_1\\) , \\(P_2\\) , \\(P_3\\) et \\(P_4\\) arrivent \u00e0 \\(t=0\\) : Ordonnancement Shortest Remaining Time (SRT) \u2693\ufe0e Principe : Le processus dont le temps d'ex\u00e9cution restant est le plus court parmi ceux qui restent \u00e0 ex\u00e9cuter est ordonnanc\u00e9 en premier. Exemple : \\(P_3\\) et \\(P_4\\) arrivent \u00e0 \\(t=0\\) ; \\(P_2\\) \u00e0 \\(t=20\\) ; \\(P_1\\) \u00e0 \\(t=50\\) : Ordonnancement temps-partag\u00e9 (Round-Robin) \u2693\ufe0e Principe : C'est la politique du tourniquet : allocation du processeur par tranche (= quantum \\(q\\) ) de temps. Exemple : quantum \\(q = 20\\) et \\(n = 4\\) processus Dans ce cas, s'il y a \\(n\\) processus, chacun d'eux obtient le processeur au bout de \\((n-1)\\times q\\) unit\u00e9s de temps au plus Ordonnancement \u00e0 priorit\u00e9s statiques \u2693\ufe0e Principe : Allocation du processeur selon des priorit\u00e9s statiques (= num\u00e9ros affect\u00e9s aux processus pour toute la vie de l'application) Exemple : priorit\u00e9s \\((P_1, P_2, P_3, P_4) = (3, 2, 0, 1)\\) o\u00f9 la priorit\u00e9 la plus forte est 0 (attention, dans certains syst\u00e8mes c'est l'inverse : 0 est alors la priorit\u00e9 la plus faible) Probl\u00e8mes li\u00e9s \u00e0 l'acc\u00e8s concurrent aux ressources \u2693\ufe0e Les processus se partagent souvent une ou plusieurs ressources, et cela peut poser des probl\u00e8mes. Probl\u00e8mes de synchronisation : illustration avec Python \u2693\ufe0e Exemple d'une variable partag\u00e9e \u2693\ufe0e Prenons l'exemple d'une variable (= ressource logicielle) partag\u00e9e entre plusieurs processus. Plus pr\u00e9cis\u00e9ment, consid\u00e9rons un programme de jeu multi-joueur dans lequel une variable nb_pions repr\u00e9sente le nombre de pions disponibles pour tous les joueurs. Une fonction prendre_un_pion() permet de prendre un pion dans le tas commun de pions disponibles, s'il reste au moins un pion \u00e9videmment. On va se mettre dans la situation o\u00f9 il ne reste plus qu'un pion dans le tas commun et on suppose que deux joueurs utilisent la fonction prendre_un_pion() , ce qui conduit \u00e0 la cr\u00e9ation de deux processus p1 et p2 , chacun correspondant \u00e0 un joueur. Avec Python, on peut utiliser le module multiprocessing pour cr\u00e9er des processus. Le programme Python pions.py suivant permet de r\u00e9aliser la situation de jeu d\u00e9crite : \ud83d\udc0d Script Python from multiprocessing import Process , Value import time def prendre_un_pion ( nombre ): if nombre . value >= 1 : time . sleep ( 0.001 ) # pour simuler un traitement avec des calculs temp = nombre . value nombre . value = temp - 1 # on d\u00e9cr\u00e9mente le nombre de pions if __name__ == '__main__' : # cr\u00e9ation de la variable partag\u00e9e initialis\u00e9e \u00e0 1 nb_pions = Value ( 'i' , 1 ) # on cr\u00e9e deux processus p1 = Process ( target = prendre_un_pion , args = [ nb_pions ]) p2 = Process ( target = prendre_un_pion , args = [ nb_pions ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () print ( \"nombre final de pions :\" , nb_pions . value ) Explications : Le if __name__ = '__main'__: permet de ne cr\u00e9er qu'une seule fois les processus p1 et p2 qui suivent (c'est n\u00e9cessaire sous Windows, pas sous GNU/Linux car la cr\u00e9ation des processus ne se fait pas de la m\u00eame mani\u00e8re, mais cela reste conseill\u00e9 ne serait-ce que pour des raisons de compatibilit\u00e9), on n'en dira pas davantage ici car cela d\u00e9passe le niveau de ce cours. On a utilis\u00e9 la classe Process du module multiprocessing pour instancier deux processus p1 et p2 . L'argument target est le nom de la fonction qui sera ex\u00e9cut\u00e9e par le processus : ici les deux processus doivent ex\u00e9cuter la m\u00eame fonction prendre_un_pion() L'argument args est une liste des arguments pass\u00e9s \u00e0 la fonction cible : ici il s'agit de la variable nb_pions qui est partag\u00e9e par les deux processus. Par d\u00e9faut, deux processus ne partagent pas de donn\u00e9es en m\u00e9moire : on ne peut pas donc pas utiliser nb_pions comme une variable globale. Il faut utiliser la classe Value du module multiprocessing pour cr\u00e9er nb_pions dans une m\u00e9moire partag\u00e9e entre les processus. L'argument 'i' indique que nb_pions est un entier (sign\u00e9) et le deuxi\u00e8me argument est la valeur initiale de la variable, ici 1. La fonction prendre_un_pion() prend un nombre en param\u00e8tre et d\u00e9cr\u00e9mente sa valeur d'une unit\u00e9 si le nombre est au moins \u00e9gal \u00e0 1. Lors de l'ex\u00e9cution de la fonction par les deux processus, l'argument en question sera l'objet nb_pions de la classe Value et on acc\u00e8de \u00e0 sa valeur avec l'attribut value . On a ajout\u00e9 une temporisation permettant de simuler d'autres calculs qui pourraient avoir lieu (par exemple, des instructions de mise \u00e0 jour du nombre de pions des joueurs) Les derni\u00e8res lignes permettent de d\u00e9marrer les deux processus et attendre qu'ils soient termin\u00e9s pour afficher la valeur finale de nb_pions . Si on ex\u00e9cute ce programme, les deux processus p1 et p2 sont ex\u00e9cut\u00e9s et on s'attend au comportement suivant (en supposant qu'il ne reste qu'un seule pion dans le tas commun) : l'un des deux est \u00e9lu en premier, par exemple p1 , et ex\u00e9cute la fonction prendre_un_pion() , le nombre de pions est \u00e9gal \u00e0 1 donc nb_pions est d\u00e9cr\u00e9ment\u00e9 d'une unit\u00e9 et prend donc la valeur 0, le processus p1 est termin\u00e9 ; le processus p2 , qui \u00e9tait en attente, est ensuite \u00e9lu, et comme le nombre de pions est d\u00e9sormais \u00e9gal \u00e0 0 rien ne se passe et p2 termine. Ainsi, le premier joueur a pu prendre le pion restant et le second s'est retrouv\u00e9 coinc\u00e9, et la valeur finale de nb_pions vaut 0. Et pourtant, il est tout \u00e0 fait possible que les choses ne se passent pas ainsi ! En effet, en ex\u00e9cutant plusieurs fois le programme pions.py dans un terminal, on obtient parfois une valeur finale \u00e9gale \u00e0 0 et parfois \u00e9gale \u00e0 -1 : C'est un r\u00e9sultat tr\u00e8s perturbant non ? Expliquons pourquoi ! Pour cela, on peut ajouter quelques instructions d'affichage pour suivre ce qu'il se passe. On obtient le script pions_v2.py suivant : \ud83d\udc0d Script Python from multiprocessing import Process , Value import time def prendre_un_pion ( nombre , numero_processus ): print ( f \"d\u00e9but du processus { numero_processus } \" ) if nombre . value >= 1 : print ( f \"processus { numero_processus } : \u00e9tape A\" ) time . sleep ( 0.001 ) # pour simuler un traitement avec des calculs print ( f \"processus { numero_processus } : \u00e9tape B\" ) temp = nombre . value nombre . value = temp - 1 # on d\u00e9cr\u00e9mente le nombre de pions print ( f \"nombre de pions restants \u00e0 la fin du processus { numero_processus } : { nombre . value } \" ) if __name__ == '__main__' : # cr\u00e9ation de la variable partag\u00e9e initialis\u00e9e \u00e0 1 nb_pions = Value ( 'i' , 1 ) # on cr\u00e9e deux processus p1 = Process ( target = prendre_un_pion , args = [ nb_pions , 1 ]) p2 = Process ( target = prendre_un_pion , args = [ nb_pions , 2 ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () print ( \"nombre final de pions :\" , nb_pions . value ) Explications : Lors de la cr\u00e9ation des processus, on passe un deuxi\u00e8me argument \u00e0 la fonction prendre_un_pion() , le num\u00e9ro du processus : 1 pour p1 et 2 pour p2 . Cela permet d'afficher dans cette fonction le num\u00e9ro du processus \u00e0 des endroits strat\u00e9giques : au d\u00e9but, \u00e0 l'entr\u00e9e dans le if , juste avant de d\u00e9cr\u00e9menter le nombre de pions et \u00e0 la fin du processus. En ex\u00e9cutant pions_v2.py dans un terminal, on obtient ce genre de choses : Analysons la premi\u00e8re ex\u00e9cution du programme. le processus p1 est \u00e9lu en premier (affichage de \"d\u00e9but du processus 1\") mais est de suite interrompu par l'ordonnanceur qui \u00e9lit p2 (affichage de \"d\u00e9but du processus 2\") puis c'est de nouveau le processus p1 qui a la main et il rentre dans le if (affichage de \"processus 1 : \u00e9tape A\") mais est interrompu \u00e0 nouveau et l'ordonnanceur donne la main \u00e0 p2 qui rentre aussi dans le if (affichage de \"processus 2 : \u00e9tape A\") : en effet, \u00e0 ce stade le nombre de pions n'a pas encore \u00e9t\u00e9 d\u00e9cr\u00e9ment\u00e9 par p1 car il a \u00e9t\u00e9 interrompu avant l'\u00e9tape B, et donc p2 a pu entrer dans le if puisque la condition nombre.value >= 1 est toujours vraie \u00e0 ce moment l\u00e0 !! ensuite le processeur est allou\u00e9 alternativement \u00e0 p1 et p2 (voir les affichages restants) mais le mal est fait puisque les deux processus sont d\u00e9sormais chacun entr\u00e9s dans le if , ils vont chacun d\u00e9cr\u00e9menter le nombre de pions d'une unit\u00e9 et chacun des deux joueurs aura pioch\u00e9 un pion alors qu'il n'y en avait qu'un seul au d\u00e9part ! Vous remarquerez que la troisi\u00e8me ex\u00e9cution du programme met en \u00e9vidence le m\u00eame probl\u00e8me car les deux processus ont chacun pu entrer dans le if , m\u00eame si l'ordre des instructions ex\u00e9cut\u00e9es apr\u00e8s n'est pas tout \u00e0 fait le m\u00eame. Si on analyse la seconde ex\u00e9cution du programme qui donne le comportement souhait\u00e9, on constate que p1 a eu suffisamment de temps pour d\u00e9cr\u00e9menter le nombre de pions (qui vaut d\u00e9sormais 0) avant que p2 ne fasse le test nombre.value >= 1 et se rende compte que cette condition est fausse. Dans ce cas, seul le premier joueur a pas pu piocher un pion. Heureusement, on peut \u00e9viter le probl\u00e8me mis en \u00e9vidence dans l'exemple pr\u00e9c\u00e9dent. Comment \u00e9viter les probl\u00e8mes de synchronisation ? \u2693\ufe0e On va utiliser ce qu'on appelle un verrou : un verrou est objet partag\u00e9 entre plusieurs processus mais qui garantit qu'un seul processus acc\u00e8de \u00e0 une ressource \u00e0 un instant donn\u00e9. Concr\u00e8tement, un verrou peut \u00eatre acquis par les diff\u00e9rents processus, et le premier \u00e0 faire la demande acquiert le verrou. Si le verrou est d\u00e9tenu par un autre processus, alors tout autre processus souhaitant l'obtenir est bloqu\u00e9 jusqu'\u00e0 ce qu'il soit lib\u00e9r\u00e9. Le module multiprocessing de Python propose un objet Lock() correpondant \u00e0 un verrou. Deux m\u00e9thodes sont utilis\u00e9es : la m\u00e9thode .acquire() permet de demander le verrou (le processus faisant la demande est bloqu\u00e9 tant qu'il ne l'a pas obtenu) la m\u00e9thode .release() permet de lib\u00e9rer le verrou (il pourra alors \u00eatre obtenu par un autre processus qui en fait la demande) On peut alors r\u00e9gler le probl\u00e8me de l'exemple pr\u00e9c\u00e9dent avec le script pions_v3.py suivant dans lequel on a laiss\u00e9 les affichages pour bien suivre : \ud83d\udc0d Script Python from multiprocessing import Process , Value , Lock import time def prendre_un_pion ( v , nombre , numero_processus ): print ( f \"d\u00e9but du processus { numero_processus } \" ) v . acquire () # acquisition du verrou if nombre . value >= 1 : print ( f \"processus { numero_processus } : \u00e9tape A\" ) time . sleep ( 0.001 ) print ( f \"processus { numero_processus } : \u00e9tape B\" ) temp = nombre . value nombre . value = temp - 1 v . release () # verrou lib\u00e9r\u00e9 print ( f \"nombre de pions restants \u00e0 la fin du processus { numero_processus } : { nombre . value } \" ) if __name__ == '__main__' : # cr\u00e9ation de la variable partag\u00e9e initialis\u00e9e \u00e0 1 nb_pions = Value ( 'i' , 1 ) # verrou partag\u00e9 par les deux processus verrou = Lock () # on cr\u00e9e deux processus p1 = Process ( target = prendre_un_pion , args = [ verrou , nb_pions , 1 ]) p2 = Process ( target = prendre_un_pion , args = [ verrou , nb_pions , 2 ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () print ( \"nombre final de pions :\" , nb_pions . value ) En ex\u00e9cutant (plusieurs fois) ce script dans un terminal on constate que le nombre final de pions est toujours \u00e9gal \u00e0 0. Avant de faire le test du if , le processus essaye d'acqu\u00e9rir le verrou avec v.acquire() . D\u00e8s qu'il est acquis, le processus a la garantie qu'il est le seul \u00e0 pouvoir ex\u00e9cuter le code jusqu'\u00e0 l'instruction v.release() . Cette portion de code prot\u00e9g\u00e9e s'appelle une section critique . Cela ne veut pas dire que le processus d\u00e9tenant le verrou ne peut pas \u00eatre interrompu, mais il ne le sera pas par un processus qui est essaie d'acqu\u00e9rir le m\u00eame verrou. \ud83d\udc0d Script Python def prendre_un_pion ( v , nombre , numero_processus ): v . acquire () # d\u00e9but section critique if nombre . value >= 1 : time . sleep ( 0.001 ) temp = nombre . value nombre . value = temp - 1 # fin de la section critique v . release () Si vous analysez l'affichage pr\u00e9c\u00e9dent dans le terminal, on voit d'ailleurs que p1 est entr\u00e9 en section critique (affichage \"processus 1 : \u00e9tape A\") mais est interrompu, puis c'est p2 qui a la main (affichage \"d\u00e9but processus 2\") mais il va se retrouver bloquer \u00e0 l'instruction v.acquire() puisque c'est p1 qui d\u00e9tient le verrou. Lorsque p1 reprendra la main, il pourra ex\u00e9cuter ses instructions jusqu'\u00e0 v.release() sans \u00eatre interrompu par p2 (alors nb_pions sera d\u00e9cr\u00e9ment\u00e9 d'une unit\u00e9). Lorsque p1 lib\u00e8re le verrou, p2 pourra alors l'obtenir, ex\u00e9cuter sa section critique et constater que la condition nombre.value >= 1 est fausse : le deuxi\u00e8me joueur ne pourra alors pas prendre de pion. Nous terminons en voyant que l'utilisation de verrous n'est pas sans risque car elle peut engendrer des probl\u00e8mes d'interblocage. Risque d'interblocage \u2693\ufe0e Les interblocages ( deadlock en anglais) sont des situations de la vie quotidienne. L'exemple classique est celui du carrefour avec priorit\u00e9 \u00e0 droite o\u00f9 chaque v\u00e9hicule est bloqu\u00e9 car il doit laisser le passage au v\u00e9hicule \u00e0 sa droite. En informatique l' interblocage peut \u00e9galement se produire lorsque plusieurs processus concurrents s'attendent mutuellement. Ce sc\u00e9nario peut se produire lorsque plusieurs ressources sont partag\u00e9es par plusieurs processus et l'un d'entre eux poss\u00e8de ind\u00e9finiment une ressource n\u00e9cessaire pour un autre. Ce ph\u00e9nom\u00e8ne d' attente circulaire , o\u00f9 chaque processus attend une ressource d\u00e9tenue par un autre processus, peut \u00eatre provoqu\u00e9e par l'utilisation de plusieurs verrous. Consid\u00e9rons le script interblocage.py suivant dans lequel on a cr\u00e9\u00e9 deux verrous v1 et v2 utilis\u00e9s par deux fonctions f1 et f2 ex\u00e9cut\u00e9es respectivement par deux processus p1 et p2 . Le processus p1 essaie d'acqu\u00e9rir d'abord v1 puis v2 tandis que le processus p2 essaie de les acqu\u00e9rir dans l'ordre inverse. \ud83d\udc0d Script Python from multiprocessing import Process , Lock import time import os def f1 ( v1 , v2 ): print ( \"PID du processus 1:\" , os . getpid ()) for i in range ( 100 ): time . sleep ( 0.001 ) v1 . acquire () v2 . acquire () print ( \"processus 1 en cours, it\u00e9ration \" , i ) v2 . release () v1 . release () def f2 ( v1 , v2 ): print ( \"PID du processus 2:\" , os . getpid ()) for i in range ( 100 ): time . sleep ( 0.001 ) v2 . acquire () v1 . acquire () print ( \"processus 2 en cours, it\u00e9ration \" , i ) v1 . release () v2 . release () if __name__ == '__main__' : # cr\u00e9ation de deux verrous v1 = Lock () v2 = Lock () # cr\u00e9ation de deux processus p1 = Process ( target = f1 , args = [ v1 , v2 ]) p2 = Process ( target = f2 , args = [ v1 , v2 ]) # on d\u00e9marre les deux processus p1 . start () p2 . start () # on attend la fin des deux processus p1 . join () p2 . join () Si on ex\u00e9cute ce programme, il y a de grandes chances de se retrouver bloqu\u00e9. Par exemple, dans le cas de l'ex\u00e9cution suivante : le processus p1 est \u00e9lu : il s'ex\u00e9cute jusqu'\u00e0 l'acquisition de v1 mais avant la tentative d'acquisition de v2 , puis est interrompu le processus p2 est \u00e0 son tour \u00e9lu : il s'ex\u00e9cute et acquiert v2 qui est toujours libre, puis bloque sur l'acquisition de v1 (qui est d\u00e9tenu par p1 ). le processus p1 reprend la main et bloque sur l'acquisition de v2 (d\u00e9tenu par p2 ). Chaque processus d\u00e9tient un verrou et attend l'autre : ils sont en interblocage et l'attente est infinie. On peut lancer (plusieurs fois si n\u00e9cessaire) le script \u00e0 partir du terminal et constater que l'interblocage a lieu tr\u00e8s souvent. Il n'y a alors pas d'autres choix que d'interrompre les processus en interblocage, par exemple avec la commande kill . Cependant, ce probl\u00e8me a lieu ici car les deux processus essaie d'acqu\u00e9rir les verrous dans l'ordre contraire. Si l'ordre d'acquisition est le m\u00eame pour les processus, le probl\u00e8me n'a plus lieu (n'h\u00e9sitez pas \u00e0 tester !). De mani\u00e8re g\u00e9n\u00e9rale, dans des probl\u00e8mes complexes les situations d'interblocage sont difficiles \u00e0 d\u00e9tecter et il se peut tr\u00e8s bien que le programme se comporte bien pendant toute une phase de tests mais bloque lors d'une ex\u00e9cution ult\u00e9rieure puisque l'on ne peut pas pr\u00e9voir l'ordonnancement des processus. Simulation d'interblocage\u2693\ufe0e \u2693\ufe0e Robosomes cr\u00e9\u00e9 par Alain BUSSER , S\u00e9bastien HOARAU (Voir ici : Robosomes - IREM de la r\u00e9union Le jeu robosomes se joue \u00e0 un seul joueur sur une grille rectangulaire. Chaque case peut \u00eatre soit vide soit couverte par un obstacle fixe (en noir comme aux mots crois\u00e9s) soit couverte d\u2019un pion pouvant bouger, appel\u00e9 robot Chaque robot peut \u00eatre tourn\u00e9 dans l\u2019une des quatre directions cardinales \u25c0\u25b2\u25b6\u25bc. Les robots peuvent bouger tous en m\u00eame temps de l\u2019une des fa\u00e7ons suivantes : G : tous les robots tournent vers leur gauche (de 90\u00b0) en m\u00eame temps D : tous les robots tournent vers leur droite (de 90\u00b0) en m\u00eame temps A : les robots qui peuvent avancer d\u2019une case, le font. Un robot peut avancer d\u2019une case s\u2019il n\u2019y a pas d\u2019obstacle sur cette case et si aucun robot ne s\u2019appr\u00eate \u00e0 aller sur cette case. Les cases du bord de la grille sont toutes couvertes d\u2019obstacles fixes, \u00e0 l\u2019exception de l\u2019une d\u2019entre elles appel\u00e9e \u00ab sortie \u00bb. Lorsqu\u2019un robot est sur la case de sortie, tourn\u00e9 vers l\u2019ext\u00e9rieur de la grille, il quitte le jeu et n\u2019est plus soumis aux ordres donn\u00e9s. Le but du jeu est de faire sortir tous les robots de la grille, en \u00e9crivant un mot dans l\u2019alphabet A,G,D, appel\u00e9 programme et que les robots interpr\u00e9teront comme d\u00e9crit ci-dessus. Voici quelques exemples : Un premier exemple pour se mettre en route. Interblocage Interblocage 1 Interblocage 2 Interblocage 3 Interblocage 4 Interblocage perp\u00e9tuel ou pas Interblocage 8 Et pour les syst\u00e8mes multiprocesseurs ? \u2693\ufe0e Les ordinateurs actuels poss\u00e8dent g\u00e9n\u00e9ralement plusieurs processeurs, ce qui permet \u00e0 plusieurs processus d'\u00eatre ex\u00e9cut\u00e9s parall\u00e8lement : un par processeur. Ce parall\u00e9lisme permet bien \u00e9videmment une plus grande puissance de calcul. Pour r\u00e9partir les diff\u00e9rents processus entre les diff\u00e9rents processeurs, on distingue deux approches : l'approche partitionn\u00e9e : chaque processeur poss\u00e8de un ordonnanceur particulier et les processus sont r\u00e9partis entre les diff\u00e9rents ordonnanceurs l'approche globale : un ordonnanceur global est charg\u00e9 de d\u00e9terminer la r\u00e9partition des processus entre les diff\u00e9rents processeurs L'ordonnancement des processus des syst\u00e8mes d'exploitation actuels est bien plus complexe que les quelques algorithmes \u00e9voqu\u00e9s dans ce cours, et cela d\u00e9passe largement le cadre du programme de NSI. Si vous souhaitez en savoir plus, voici n\u00e9anmoins une vid\u00e9o int\u00e9ressante (en fran\u00e7ais) sur l'ordonnancement du noyau Linux : https://www.youtube.com/watch?v=uCGe5WWd1OI&t=195s&ab_channel=Vitonimal . Bilan \u2693\ufe0e Un programme en cours d'ex\u00e9cution s'appelle un processus . Les syst\u00e8mes d'exploitation r\u00e9cents permettent d'ex\u00e9cuter plusieurs processus simultan\u00e9ment. En r\u00e9alit\u00e9, ces processus sont ex\u00e9cut\u00e9s \u00e0 tour de r\u00f4le par le syst\u00e8me d'exploitation qui est charg\u00e9 d'allouer \u00e0 chacun d'eux les ressources dont il a besoin en termes de m\u00e9moire, entr\u00e9es-sorties ou temps d'acc\u00e8s au processeur, et de s'assurer que les processus ne se g\u00eanent pas les uns les autres. Au cours de leur vie, les processus varient entre trois \u00e9tats : \u00e9lu si le processus est ex\u00e9cut\u00e9 par le processeur, pr\u00eat si le processus est pr\u00eat \u00e0 \u00eatre ex\u00e9cut\u00e9, et bloqu\u00e9 si le processus est en attente d'une ressource. C'est l' ordonnanceur qui est charg\u00e9 de d\u00e9finir l'ordre dans lequel les processus doivent \u00eatre ex\u00e9cut\u00e9s par le processeur. Ce choix se fait gr\u00e2ce \u00e0 des algorithmes d'ordonnancement. Les processus se partagent les diff\u00e9rentes ressources, on parle d' acc\u00e8s concurrent aux ressources. Ce partage des ressources n'est pas sans risque et peut conduire \u00e0 des probl\u00e8mes de synchronisation. Ces probl\u00e8mes peuvent \u00eatre \u00e9vit\u00e9s en utilisant un verrou , qui permet \u00e0 un processus de ne pas \u00eatre interrompu dans sa section critique par un autre processus demandant le m\u00eame verrou. L'utilisation de plusieurs verrous peut entra\u00eener des interblocages , c'est-\u00e0-dire des situations o\u00f9 chaque processus attend une ressource d\u00e9tenue par un autre, conduisant \u00e0 une attente cyclique infinie. L'ordre d'acquisition des verrous est important mais pas toujours \u00e9vident \u00e0 \u00e9crire dans le cas de probl\u00e8mes complexes. Exercice 1 : Algorithmes d'ordonnancement \u2693\ufe0e Soient les diff\u00e9rents processus suivants : Processus Date d'arriv\u00e9e Dur\u00e9e de traitement \\(P_1\\) 0 3 \\(P_2\\) 1 6 \\(P_3\\) 3 4 \\(P_4\\) 6 5 \\(P_5\\) 8 2 Application de plusieurs algorithmes \u2693\ufe0e Q1 : Donnez le diagramme de Gantt pour l'ex\u00e9cution de ces diff\u00e9rents processus en utilisant successivement les algorithmes FCFS, RR (quantum = 2 unit\u00e9s de temps) et SRT. Performances des algorithmes d'ordonnancement \u2693\ufe0e On d\u00e9finit les m\u00e9triques suivantes : le temps de s\u00e9jour (ou d'ex\u00e9cution) (ou de rotation) d'un processus : c'est la diff\u00e9rence entre la date de fin d'ex\u00e9cution et la date d'arriv\u00e9e : \\( \\(T_{\\text{sej}} = \\text{date fin d'ex\u00e9cution} - \\text{date d'arriv\u00e9e}\\) \\) le temps d'attente d'un processus : c'est la diff\u00e9rence entre le temps de s\u00e9jour et la dur\u00e9e du processus : \\( \\(T_{\\text{att}} = T_{\\text{sej}} - \\text{dur\u00e9e du processus}\\) \\) le rendement d'un processus : c'est le quotient entre la dur\u00e9e du processus et le temps de s\u00e9jour : \\( \\(\\text{rendement} = \\dfrac{\\text{dur\u00e9e du processus}}{T_{\\text{sej}}}\\) \\) Q2 : Pour chacun des trois algorithmes, calculez le temps de s\u00e9jour, le temps d'attente et le rendement de chaque processus. Q3 : Quel vous semble \u00eatre le meilleur des trois algorithmes dans notre exemple ? Expliquer. Exercice 2 \u2693\ufe0e cet exercice est issu du sujet 2021 du bac NSI Partie A Cette partie est un questionnaire \u00e0 choix multiples (QCM). Pour chacune des questions, une seule des quatre r\u00e9ponses est exacte. Le candidat indiquera sur sa copie le num\u00e9ro de la question et la lettre correspondant \u00e0 la r\u00e9ponse exacte. Aucune justification n\u2019est demand\u00e9e. Une r\u00e9ponse fausse ou une absence de r\u00e9ponse n\u2019enl\u00e8ve aucun point. 1) Parmi les commandes ci-dessous, laquelle permet d\u2019afficher les processus en cours d\u2019ex\u00e9cution ? \ud83d\udccb Texte a. dir b. ps c. man d. ls 2) Quelle abr\u00e9viation d\u00e9signe l\u2019identifiant d\u2019un processus dans un syst\u00e8me d\u2019exploitation de type UNIX ? \ud83d\udccb Texte a. PIX b. SIG c. PID d. SID 3) Comment s\u2019appelle la gestion du partage du processeur entre diff\u00e9rents processus ? \ud83d\udccb Texte a. L\u2019interblocage b. L\u2019ordonnancement c. La planification d. La priorisation 4) Quelle commande permet d\u2019interrompre un processus dans un syst\u00e8me d\u2019exploitation de type UNIX ? \ud83d\udccb Texte a. stop b. interrupt c. end d. kill Partie B 1) Un processeur choisit \u00e0 chaque cycle d\u2019ex\u00e9cution le processus qui doit \u00eatre ex\u00e9cut\u00e9. Le tableau ci-dessous donne pour trois processus P1, P2, P3 : la dur\u00e9e d\u2019ex\u00e9cution (en nombre de cycles), l\u2019instant d\u2019arriv\u00e9e sur le processeur (exprim\u00e9 en nombre de cycles \u00e0 partir de 0), le num\u00e9ro de priorit\u00e9. Le num\u00e9ro de priorit\u00e9 est d\u2019autant plus petit que la priorit\u00e9 est grande. On suppose qu\u2019\u00e0 chaque instant, c\u2019est le processus qui a le plus petit num\u00e9ro de priorit\u00e9 qui est ex\u00e9cut\u00e9, ce qui peut provoquer la suspension d\u2019un autre processus, lequel reprendra lorsqu\u2019il sera le plus prioritaire. Reproduire le tableau ci-dessous sur la copie et indiquer dans chacune des cases le processus ex\u00e9cut\u00e9 \u00e0 chaque cycle. 2) On suppose maintenant que les trois processus pr\u00e9c\u00e9dents s\u2019ex\u00e9cutent et utilisent une ou plusieurs ressources parmi R1, R2 et R3. Parmi les sc\u00e9narios suivants, lequel provoque un interblocage ? Justifier. Partie C Dans cette partie, pour une meilleure lisibilit\u00e9, des espaces sont plac\u00e9es dans les \u00e9critures binaires des nombres. Il ne faut pas les prendre en compte dans les calculs. Pour chiffrer un message, une m\u00e9thode, dite du masque jetable, consiste \u00e0 le combiner avec une cha\u00eene de caract\u00e8res de longueur comparable. Une impl\u00e9mentation possible utilise l\u2019op\u00e9rateur XOR (ou exclusif) dont voici la table de v\u00e9rit\u00e9 : a b a XOR b 0 0 0 0 1 1 1 0 1 1 1 0 Dans la suite, les nombres \u00e9crits en binaire seront pr\u00e9c\u00e9d\u00e9s du pr\u00e9fixe 0b. Q1. Pour chiffrer un message, on convertit chacun de ses caract\u00e8res en binaire (\u00e0 l\u2019aide du format Unicode), et on r\u00e9alise l\u2019op\u00e9ration XOR bit \u00e0 bit avec la cl\u00e9. Apr\u00e8s conversion en binaire, et avant que l\u2019op\u00e9ration XOR bit \u00e0 bit avec la cl\u00e9 n\u2019ait \u00e9t\u00e9 effectu\u00e9e, Alice obtient le message suivant : m = 0b 0110 0011 0100 0110 a. Le message m correspond \u00e0 deux caract\u00e8res cod\u00e9s chacun sur 8 bits : d\u00e9terminer quels sont ces caract\u00e8res. On fournit pour cela la table ci-dessous qui associe \u00e0 l\u2019\u00e9criture hexad\u00e9cimale d\u2019un octet le caract\u00e8re correspondant (figure 2). Exemple de lecture : le caract\u00e8re correspondant \u00e0 l\u2019octet cod\u00e9 4A en hexad\u00e9cimal est la lettre J. Pour chiffrer le message d\u2019Alice, on r\u00e9alise l\u2019op\u00e9ration XOR bit \u00e0 bit avec la cl\u00e9 suivante : k = 0b 1110 1110 1111 0000 Donner l\u2019\u00e9criture binaire du message obtenu. Q2. a. Dresser la table de v\u00e9rit\u00e9 de l\u2019expression bool\u00e9enne suivante : (a XOR b) XOR b b. Bob conna\u00eet la cha\u00eene de caract\u00e8res utilis\u00e9e par Alice pour chiffrer le message. Quelle op\u00e9ration doit-il r\u00e9aliser pour d\u00e9chiffrer son message ? Exercice 3 \u2693\ufe0e d'apr\u00e8s le sujet du bac NSI 2021 Cet exercice porte sur les syst\u00e8mes d\u2019exploitation : gestion des processus et des ressources. Les parties A et B peuvent \u00eatre trait\u00e9es ind\u00e9pendamment Partie A Q.1) La commande ps suivie \u00e9ventuellement de diverses options permet de lister les processus actifs ou en attente sur une machine. Sur une machine \u00e9quip\u00e9e du syst\u00e8me d\u2019exploitation GNU/Linux, la commande \u201cps -aef\u201d permet d\u2019obtenir la sortie suivante (extrait) : a) Quelle est la particularit\u00e9 de l\u2019utilisateur \u201croot\u201d ? b) Quel est le processus parent du processus ayant pour PID 3383 Dans un bureau d\u2019architectes, on dispose de certaines ressources qui ne peuvent \u00eatre utilis\u00e9es simultan\u00e9ment par plus d\u2019un processus, comme l\u2019imprimante, la table tra\u00e7ante, le modem. Chaque programme, lorsqu\u2019il s\u2019ex\u00e9cute, demande l\u2019allocation des ressources qui lui sont n\u00e9cessaires. Lorsqu\u2019il a fini de s\u2019ex\u00e9cuter, il lib\u00e8re ses ressources. Q.2 On appelle p1, p2 et p3 les processus associ\u00e9s respectivement aux programmes 1, 2 et 3. a) Justifier qu'une situation d'interblocage peut se produire. b) Modifier l'ordre des instructions du programme 3 pour qu'une telle situation ne puisse pas se produire. Q.3 Supposons que le processus p1 demande la table tra\u00e7ante alors qu'elle est en cours d'utilisation par le processus p3. Parmi les \u00e9tats suivants, quel sera l'\u00e9tat du processus p1 tant que la table tra\u00e7ante n'est pas disponible : a) \u00e9lu b) bloqu\u00e9 c) pr\u00eat d) termin\u00e9 Partie B Avec une ligne de commande dans un terminal sous Linux, on obtient l'affichage suivant : La documentation Linux donne la signification des diff\u00e9rents champs : UID : identifiant utilisateur effectif ; PID : identifiant de processus ; PPID : PID du processus parent ; C : partie enti\u00e8re du pourcentage d'utilisation du processeur par rapport au temps de vie des processus ; STIME : l'heure de lancement du processus ; TTY : terminal de contr\u00f4le TIME : temps d'ex\u00e9cution CMD : nom de la commande du processus Q.1. Parmi les quatre commandes suivantes, laquelle a permis cet affichage ? a) ls -l b) ps \u2013ef c) cd .. d) chmod 741 processus.txt Q.2. Quel est l'identifiant du processus parent \u00e0 l'origine de tous les processus concernant le navigateur Web (chromium-browser) ? Q.3. Quel est l'identifiant du processus dont le temps d'ex\u00e9cution est le plus long ? Exercice 4 \u2693\ufe0e Extrait sujet BAC 2021 Cet exercice porte sur la gestion des processus par un syst\u00e8me d\u2019exploitation. Partie A : Processus La commande UNIX ps pr\u00e9sente un clich\u00e9 instantan\u00e9 des processus en cours d'ex\u00e9cution. Avec l\u2019option \u2212eo pid,ppid,stat,command, cette commande affiche dans l\u2019ordre l\u2019identifiant du processus PID (process identifier), le PPID (parent process identifier), l\u2019\u00e9tat STAT et le nom de la commande \u00e0 l\u2019origine du processus. Les valeurs du champ STAT indique l\u2019\u00e9tat des processus : - R : processus en cours d\u2019ex\u00e9cution - S : processus endormi Sur un ordinateur, on ex\u00e9cute la commande ps \u2212eo pid,ppid,stat,command et on obtient un affichage dont on donne ci-dessous un extrait. \u00c0 l'aide de cet affichage, r\u00e9pondre aux questions ci-dessous. Q.1. Quel est le nom de la premi\u00e8re commande ex\u00e9cut\u00e9e par le syst\u00e8me d'exploitation lors du d\u00e9marrage ? Q.2. Quels sont les identifiants des processus actifs sur cet ordinateur au moment de l\u2019appel de la commande ps ? Justifier la r\u00e9ponse. Q.3. Depuis quelle application a-t-on ex\u00e9cut\u00e9 la commande ps ? Donner les autres commandes qui ont \u00e9t\u00e9 ex\u00e9cut\u00e9es \u00e0 partir de cette application. Q.4. Expliquer l'ordre dans lequel les deux commandes python programme1.py et python programme2.py ont \u00e9t\u00e9 ex\u00e9cut\u00e9es. Q.5. Peut-on pr\u00e9dire que l'une des deux commandes python programme1.py et python programme2.py finira avant l\u2019autre ?","title":"TD n\u00b023 - gestion des processus"},{"location":"Processus/TD_Gestion_Processus_Diapo/#td-23-cours-gestion-des-processus","text":"","title":"TD 23 - Cours : Gestion des processus"},{"location":"Programmation/Calculabilite_Decidabilite/","text":"Th\u00e8me : Programmation 23 Cours : Calculabilit\u00e9 et D\u00e9cidabilit\u00e9 Un programme comme param\u00e8tre d'un programme \u2693\ufe0e Les codes que nous manipulons ressemblent souvent \u00e0 cela : \ud83d\udc0d Script Python def accueil ( n ): for k in range ( n ): print ( \"bonjour\" ) Le programme s'appelle accueil , et pour fonctionner il a besoin d'un param\u00e8tre, qui sera ici un nombre entier n . Voici comment nous pouvons repr\u00e9senter notre machine accueil , son param\u00e8tre d'entr\u00e9e (5) et sa sortie (les 5 \u00abbonjour\u00bb) Maintenant, enregistrons le code suivant dans un fichier test.py : \ud83d\udc0d Script Python def accueil ( n ): for k in range ( n ): print ( \"bonjour\" ) accueil ( 5 ) Pour ex\u00e9cuter ce code, nous devons taper dans un terminal l'instruction suivante : python3 test.py , ce qui donnera Le programme utilis\u00e9 est alors python3 , qui prend comme param\u00e8tre le programme test.py . Ce param\u00e8tre test.py est un ensemble de caract\u00e8res qui contient les instructions que le programme python3 va interpr\u00e9ter. L'illustration correspondante sera donc : Mais nous pouvons aller encore plus loin : l'instruction python3 test.py est tap\u00e9e dans mon Terminal Linux, qui lui-m\u00eame est un programme appel\u00e9 Terminal . Et donc : Conclusion : Il n'y a donc aucun obstacle \u00e0 consid\u00e9rer un programme comme une simple donn\u00e9e, pouvant \u00eatre re\u00e7ue en param\u00e8tre par un autre programme. (voire par lui-m\u00eame !) \u00c0 titre anecdotique, on pourra ex\u00e9cuter avec int\u00e9r\u00eat cette instruction Python : a='a=%r;print(a%%a)';print(a%a) Ce type de code (magique !) existe dans tous les langages et s'appelle un quine . Mon programme va-t-il s'arr\u00eater ? \u2693\ufe0e Un exemple \u2693\ufe0e Consid\u00e9rons le programme suivant : \ud83d\udc0d Script Python def f ( n ): while n != 10 : print ( n ) n = n + 1 print ( \"fini\" ) En l'observant attentivement, je peux pr\u00e9voir que f(5) affichera les nombres de 5 \u00e0 9 avant d'\u00e9crire \"fini\". Puis le programme s'arr\u00eatera. Mais que va provoquer f(15) ? Comme la variable n ne sera jamais \u00e9gale \u00e0 10, le programme va rentrer dans une boucle infinie, il ne s'arr\u00eatera jamais. Mauvaise nouvelle. J'ai pu pr\u00e9voir ceci en regardant attentivement le code de mon programme. J'ai \u00abremarqu\u00e9\u00bb qu'une variable n non enti\u00e8re provoquerait une boucle infinie. Question : Est-ce qu'un programme d' analyse de programmes aurait pu faire cela \u00e0 ma place ? Une machine pour pr\u00e9dire l'arr\u00eat ou non d'un programme. \u2693\ufe0e Apr\u00e8s tout, un programme est une suite d'instructions (le code-source), et peut donc \u00eatre, comme on l'a vu, le param\u00e8tre d'entr\u00e9e d'un autre programme qui l'analyserait. Un tel programme (appelons-le arret ) prendrait en entr\u00e9es : un param\u00e8tre f (le code-source du programme) un param\u00e8tre n , qui serait le param\u00e8tre d'entr\u00e9e de f . L'instruction arret(f, n) renverrait True si f(n) s'arr\u00eate, et False si f(n) ne s'arr\u00eate pas. Exemple : arret(f, 5) renverrait True . arret(f, 15) renverrait False . ! fabquestion \"Existe-t-il une telle fonction ?\" Pas de suspens il n'existe pas une telle fonction. Pour le d\u00e9monter nous allons utiliser un raisonnement par l'absurde. On suppose qu'il est possible d'\u00e9crire une telle fonction Tentative d'\u00e9criture de arret en Python : \ud83d\udc0d Script Python def arret ( f , x ): if \"f(n) s'arr\u00eate\" : # instruction fictive return True else : return False Nous en resterons l\u00e0 pour l'instant dans l'\u00e9criture de ce programme. Nous allons nous en servir pour construire d'autres programmes. Amusons-nous avec ce programme arret . \u2693\ufe0e \u27a1 Consid\u00e9rons le programme : \ud83d\udc0d Script Python def etrange ( f , x ): if arret ( f , x ) == True : while True : pass Ce programme etrange teste si la fonction f(x) va s'arr\u00e9ter un jour gr\u00e2ce \u00e0 la fonction arret. si le calcul de f(x) s'arr\u00e8te alors la fonction etrange va rentrer dans une boucle infinie et donc elle ne s'arr\u00e8te jamais. si le calcul de f(x) alors la fonction etrange ne fait rien et s'arr\u00eate imm\u00e9diatement. Conclusion : etrange(f,x) s'arr\u00eate unniquement si f(x) ne s'arr\u00eate pas \u27a1 Consid\u00e8rons une deuxi\u00e8me fonction \ud83d\udc0d Script Python def paradox ( f ): etrange ( f , f ) paradox(f) s'arr\u00eate uniquement si f(f) ne s'arr\u00eate jamais. Question Est-ce que paradox(paradox) s'arr\u00eate un jour. On a : paradox(f) s'arr\u00eate uniquement si f(f) ne s'arr\u00eate jamais donc paradox(paradox) termine si et seulement si paradox(paradox) ne termine jamais. On arrive donc \u00e0 une contradiction. Conclusion \u2693\ufe0e Nous venons de prouver que notre programme arret , cens\u00e9 pr\u00e9dire si un programme prog peut s'arr\u00eater sur une entr\u00e9e x , NE PEUT PAS EXISTER . Ce r\u00e9sultat th\u00e9orique, d'une importance cruciale, s'appelle le probl\u00e8me de l'arr\u00eat . Probl\u00e8me de l'arr\u00eat Il ne peut pas exister de programme universel qui prendrait en entr\u00e9es : un programme P une entr\u00e9e E de ce programme P et qui d\u00e9terminerait si ce programme P, lanc\u00e9 avec l'entr\u00e9e E, va s'arr\u00eater ou non. Ce r\u00e9sultat a \u00e9t\u00e9 d\u00e9montr\u00e9 par Alan Turing en 1936, dans un article intitul\u00e9 \u00abOn computable numbers, with an application to the Entscheidungsproblem\u00bb . Pour sa d\u00e9monstration, il pr\u00e9sente un mod\u00e8le th\u00e9orique de machine capable d'ex\u00e9cuter des instructions basiques sur un ruban infini, les machines de Turing . \u00c0 la m\u00eame \u00e9poque, le math\u00e9maticien Alonzo Church d\u00e9montre lui aussi ce th\u00e9or\u00e8me de l'arr\u00eat, mais par un moyen totalement diff\u00e9rent, en inventant le lambda-calcul . Tous deux mettent ainsi un terme au r\u00eave du math\u00e9maticien allemand David Hilbert , qui avait en 1928 pos\u00e9 la question de l'existence d'un algorithme capable de r\u00e9pondre \u00aboui\u00bb ou \u00abnon\u00bb \u00e0 n'importe quel \u00e9nonc\u00e9 math\u00e9matique pos\u00e9 sous forme d\u00e9cisionnelle (\u00abun triangle rectangle peut-il \u00eatre isoc\u00e8le ?\u00bb, \u00abexiste-t-il un nombre premier pair ?\u00bb) Cette question, appel\u00e9e \u00abprobl\u00e8me de la d\u00e9cision\u00bb, ou Entscheidungsproblem en allemand, est d\u00e9finitivement tranch\u00e9e par le probl\u00e8me de l'arr\u00eat : un tel th\u00e9or\u00e8me ne peut pas exister, puisque par exemple, aucun algorithme ne peut r\u00e9pondre \u00aboui\u00bb ou \u00abnon\u00bb \u00e0 la question \u00abce programme va-t-il s'arr\u00eater ?\u00bb. Le th\u00e9or\u00e8me de l'arr\u00eat sera \u00e9tendu plus tard par le th\u00e9or\u00e8me de Rice . Ce r\u00e9sultat d\u00e9montre que toutes les questions s\u00e9mantiques (non \u00e9videntes) au sujet d'un programme sont ind\u00e9cidables : \u00abce programme va-t-il s'arr\u00eater ?\u00bb (le th\u00e9or\u00e8me de l'arr\u00eat) \u00abce programme va renvoyer la valeur 12 ?\u00bb \u00abce programme va-t-il un jour renvoyer un message d'erreur ?\u00bb ... Rice d\u00e9montre que toutes ces questions peuvent \u00eatre ramen\u00e9es (on dit r\u00e9duites ) au th\u00e9or\u00e8me de l'arr\u00eat, qui est ind\u00e9cidable. Video Calculabilit\u00e9 \u2693\ufe0e D\u00e9cidabilit\u00e9 et calculabilit\u00e9 Le probl\u00e8me de l'arr\u00eat est dit ind\u00e9cidable car la fonction qui le r\u00e9sout (notre brave programme halt ) n'est pas calculable . Notion de calculabilit\u00e9 \u2693\ufe0e Qu'y a-t-il derri\u00e8re cette notion de calculabilit\u00e9 ? Cette notion, qui jette un pont entre les math\u00e9matiques (la vision de Church, pour sch\u00e9matiser) et l'informatique (la vision de Turing) n'est pas simple \u00e0 d\u00e9finir ! Le calcul math\u00e9matique peut se r\u00e9duire \u00e0 une succession d'op\u00e9rations \u00e9l\u00e9mentaires (songez \u00e0 la multiplication enti\u00e8re comme une s\u00e9rie d'additions). Les nombres calculables sont les nombres qui sont g\u00e9n\u00e9rables en un nombre fini d'op\u00e9rations \u00e9l\u00e9mentaires. De la m\u00eame mani\u00e8re, une fonction math\u00e9matique sera dite calculable s'il existe une suite finie d'op\u00e9rations \u00e9l\u00e9mentaires permettant de passer d'un nombre x \u00e0 son image f(x). On retrouve cette notion d'op\u00e9rations \u00e9l\u00e9mentaires dans les machines de Turing . Cette machine (th\u00e9orique) permet de simuler tout ce qu'un programme informatique (une suite d'instructions) est capable d'ex\u00e9cuter. Un algorithme peut se r\u00e9duire \u00e0 une suite d'op\u00e9rations \u00e9lementaires, comme une fonction math\u00e9matique peut se r\u00e9duire \u00e0 une suite de calculs. D\u00e8s lors, on pourra consid\u00e9rer un algorithme comme une fonction. Turing a d\u00e9montr\u00e9 que l'ensemble des fonctions calculables, au sens de Church, \u00e9tait \u00e9quivalent \u00e0 l'ensemble des fonctions programmables sur sa machine. Certaines fonctions peuvent \u00eatre calculables, ou ne pas l'\u00eatre : c'est notamment le cas de notre fonction du probl\u00e8me de l'arr\u00eat. Langages Turing-complets \u2693\ufe0e Ce r\u00e9sultat ne d\u00e9pend pas du langage utilis\u00e9 : le fait que nous ayons utilis\u00e9 Python au paragraphe pr\u00e9c\u00e9dent n'a pas d'influence sur notre d\u00e9monstration. Nous savons depuis les machines de Turing que tous nos langages de programmation sont Turing-complets : ils sont tous capables de faire la m\u00eame chose (avec plus ou moins de facilit\u00e9 !). Scratch, C, Python, Java, Basic, Haskell, Brainfuck... tous ces langages sont th\u00e9oriquement \u00e9quivalents : la calculabilit\u00e9 ne d\u00e9pend pas du langage utilis\u00e9 . (HP) Calculable, oui, mais facilement ? -> 1 million de $ \u00e0 gagner ci-dessous. \u2693\ufe0e L'\u00e9tude de la calculabilit\u00e9 d'une fonction (\u00e0 prendre au sens le plus large, c'est-\u00e0-dire un algorithme) ne se limite pas \u00e0 un choix binaire : \u00abcalculable\u00bb vs \u00abnon calculable\u00bb. Parmi les fonctions calculables, certaines peuvent l'\u00eatre rapidement, et d'autre beaucoup moins. On retrouve alors la notion bien connue de complexit\u00e9 algorithmique, qui permet de classifier les algorithmes suivant leur d\u00e9pendance \u00e0 la taille de leurs donn\u00e9es d'entr\u00e9e (voir le cours de Premi\u00e8re). On peut regrouper les probl\u00e8mes suivant la complexit\u00e9 de l'algorithme qui permet de les r\u00e9soudre. la classe P \u2693\ufe0e D\u00e9finition de la classe P On dira que sont de \u00abclasse P\u00bb tous les probl\u00e8mes dont l'algorithme de recherche de solution est de complexit\u00e9 polynomiale . Que retrouve-t-on dans la classe P ? Tous les probl\u00e8mes dont la solution est un algorithme de complexit\u00e9 lin\u00e9raire, quadratique, logarithmique... Tout mais surtout pas un algorithme de complexit\u00e9 exponentielle. Pour le r\u00e9sumer tr\u00e8s grossi\u00e8rement, un probl\u00e8me de classe P est un probl\u00e8me que l'on sait r\u00e9soudre en temps raisonnable (m\u00eame grand). le probl\u00e8me du tri d'une liste est dans P. le probl\u00e8me de la factorisation d'un grand nombre (sur lequel repose la s\u00e9curit\u00e9 du RSA) n'est a priori pas dans P. le probl\u00e8me de la primalit\u00e9 (\u00abce nombre est-il premier ?\u00bb) a longtemps \u00e9t\u00e9 consid\u00e9r\u00e9 comme n'\u00e9tant pas dans P... jusqu'en 2002, o\u00f9 a \u00e9t\u00e9 d\u00e9couvert le test de primalit\u00e9 AKS , de complexit\u00e9 polynomiale (d'ordre 6). Ce test est donc maintenant dans P. la classe NP \u2693\ufe0e D\u00e9finition de la classe NP On dira que sont de \u00abclasse NP\u00bb tous les probl\u00e8mes dont l'algorithme de recherche de solution est Non-d\u00e9terministe Polynomial . Warning : NP ne signifie pas Non-Polynomial !!! Que veut dire la formulation \u00abnon-d\u00e9terministe polynomial\u00bb ? Cela fait r\u00e9f\u00e9rence \u00e0 ce que serait capable de faire une machine de Turing (donc, n'importe quel ordinateur) travaillant de mani\u00e8re non-d\u00e9terministe , donc capable d'explorer simultan\u00e9ment plusieurs solutions possibles. On peut imaginer un arbre dont le parcours se ferait simultan\u00e9ment dans toutes les branches, et non en largeur ou profondeur comme nous l'avons vu. Sur une machine non-d\u00e9terministe, si la solution \u00e0 un probl\u00e8me se trouve en temps polynomial, alors ce probl\u00e8me appartient \u00e0 la classe NP. Tr\u00e8s bien, mais les machines non-d\u00e9terministes... cela n'existe pas r\u00e9ellement. Comment caract\u00e9riser concr\u00e8tement cette classe de probl\u00e8me ? Si la solution peut \u00eatre trouv\u00e9e de mani\u00e8re polynomiale par une machine non-d\u00e9terministe, une machine d\u00e9terministe qui aurait de la chance en partant directement vers la bonne solution la trouverait elle aussi de mani\u00e8re polynomiale. On simplifie souvent cela en disant \u00abla v\u00e9rification de la solution est polynomiale\u00bb. Cela nous donnne cette d\u00e9finition plus accessible de la classe NP : D\u00e9finition (plus simple) de la classe NP On dira que sont de \u00abclasse NP\u00bb tous les probl\u00e8mes dont l'algorithme de v\u00e9rification de solution est polynomial . Pour le r\u00e9sumer tr\u00e8s grossi\u00e8rement, un probl\u00e8me de classe NP est un probl\u00e8me dont on sait v\u00e9rifier facilement si une solution propos\u00e9e marche ou pas : la r\u00e9solution d'un sudoku est dans NP : si quelqu'un vous montre un sudoku rempli, vous pouvez tr\u00e8s rapidement lui dire si sa solution est valable ou pas. la factorisation d'un nombre est dans NP : si quelqu'un vous propose 4567*6037 comme d\u00e9composition de 27570979, vous pouvez tr\u00e8s rapidement lui dire s'il a raison. (oui.) le probl\u00e8me du sac \u00e0 dos (en version d\u00e9cisionnelle) est dans NP. Une proposition de butin peut facilement \u00eatre examin\u00e9e pour savoir si elle est possible ou non. le probl\u00e8me du voyageur de commerce (ou TSP : Traveller Sales Problem), en version d\u00e9cisionnelle, est dans NP. Si on vous propose un trajet, vous pouvez facilement v\u00e9rifier que sa longueur est (par exemple) inf\u00e9rieure \u00e0 150 km. Malheureusement, aucun de ces probl\u00e8mes cit\u00e9s n'a (\u00e0 ce jour) d'algorithme de r\u00e9solution meilleur qu'exponentiel... P = NP, ou pas ? \u2693\ufe0e Tous les probl\u00e8mes de P ont une solution qui peut \u00eatre trouv\u00e9e de mani\u00e8re polynomiale. Donc \u00e9videmment, la v\u00e9rification de cette solution est aussi polynomiale. Donc tous les probl\u00e8mes de P sont dans NP. On dit que P est inclus dans NP, que l'on \u00e9crit P \u2282 NP . Voici une capture d'\u00e9cran de l'excellente vid\u00e9o Nos algorithmes pourraient-ils \u00eatre BEAUCOUP plus rapides ? (P=NP ?) de l'excellent David Louapre : On y retrouve (en vert) la classe P, qui contient les algorithmes de tri. En blanc, la classe NP, qui contient les probl\u00e8mes de factorisation, du sudoku, du sac-\u00e0-dos... Si quelqu'un trouve un jour un algorithme de polynomial de factorisation, alors le probl\u00e8me de factorisation viendra se ranger dans P. (accessoirement, le RSA sera sans doute d\u00e9truit par cette d\u00e9couverte, sauf si l'ordre de complexit\u00e9 est tr\u00e8s grand) Mais certains de ces probl\u00e8mes dans NP ont une propri\u00e9t\u00e9 remarquable : la r\u00e9solution polynomiale d'un seul d'entre eux ferait ramener la totalit\u00e9 des probl\u00e8mes NP dans P. On dit que ces probl\u00e8mes sont NP-complets (marqu\u00e9s en rouge ci-dessus) Concr\u00e8tement, si vous trouvez une solution polynomiale de r\u00e9solution du sudoku, vous entrainez avec lui dans P tous les autres probl\u00e8mes NP, et vous aurez ainsi prouv\u00e9 que P = NP. Accessoirement, vous gagnerez aussi le prix d' un million de dollars promis par la fondation Clay \u00e0 qui tranchera cette question... (prix que vous partagerez bien \u00e9videmment avec votre professeur de NSI) Actuellement, \u00e0 part le grand Donald Knuth , la plupart des chercheurs qui travaillent \u00e0 ce probl\u00e8me sont plut\u00f4t pessimistes, et pensent que P \u2260 NP. Cela signifie qu'ils pensent que certains probl\u00e8mes ne pourront jamais avoir une solution polynomiale. Alors, P = NP ou P \u2260 NP ? R\u00e9ponse peut-\u00eatre un jour... Bibliographie \u2693\ufe0e Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G. CONNAN, V. PETROV, G. ROZSAVOLGYI, L. SIGNAC, \u00e9ditions HATIER. https://interstices.info/pnp-elementaire-ma-chere-watson/ https://interstices.info/alan-turing-du-calculable-a-lindecidable/ https://www.labri.fr/perso/betrema/MC/MC8.html https://scienceetonnante.com/2020/07/17/est-ce-que-p-np/","title":"Calculabilite Decidabilite"},{"location":"Reseaux/02_Exercices/","text":"Exercice 1 \u2693\ufe0e Cr\u00e9er une fonction meme_sous_reseau(ip_a, ip_b, masque) qui renvoie un bool\u00e9en indiquant si A et B sont partie du m\u00eame sous-r\u00e9seau. Exercice \u00e0 r\u00e9aliser en Test Driven Developpement \u00e0 partir du squelette de code ci-dessous, en testant chaque fonction apr\u00e8s sa r\u00e9alisation, jusqu'\u00e0 la fonction finale. \ud83d\udc0d Script Python def convert_ip_to_list ( ip ): \"\"\" entr\u00e9e : ip (string) sortie : liste d'entiers \"\"\" # \u00e0 vous def test_convert_ip_to_list (): assert convert_ip_to_list ( '192.168.0.1' ) == [ 192 , 168 , 0 , 1 ] def nb_to_binary_word ( masque ): \"\"\" entr\u00e9e : masque (int) sortie : string \"\"\" # \u00e0 vous def test_nb_convert_to_binary_word (): assert nb_to_binary_word ( 24 ) == '11111111111111111111111100000000' def binary_word_to_list ( word ): \"\"\" entr\u00e9e : word (string de 32 caract\u00e8res) sortie : liste de 4 entiers \"\"\" # \u00e0 vous def test_binary_word_to_list (): assert binary_word_to_list ( '11111111111111111111111100000000' ) == [ 255 , 255 , 255 , 0 ] def meme_sous_reseau ( ip_a , ip_b , masque ): \"\"\" ip_a: string contenant une IP (ex \"192.168.0.1\") ip_b : string contenant une IP masque : entier du masque en notation CIDR (ex : 24) renvoie un bool\u00e9en indiquant si ip_a et ip_b sont dans le m\u00eame sous-r\u00e9seau \"\"\" # \u00e0 vous def test_meme_sous_reseau (): assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.1.3\" , 24 ) == False assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.1.3\" , 20 ) == True assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.0.3\" , 30 ) == True Exercice 2 \u2693\ufe0e On consid\u00e8re un r\u00e9seau compos\u00e9 de plusieurs routeurs reli\u00e9s de la fa\u00e7on suivante : Le protocole RIP permet de construire les tables de routage des diff\u00e9rents routeurs, en indiquant pour chaque routeur la distance, en nombre de sauts, qui le s\u00e9pare d\u2019un autre routeur. Pour le r\u00e9seau ci-dessus, on dispose des tables de routage suivantes : Question 1 Le routeur A doit transmettre un message au routeur G, en effectuant un nombre minimal de sauts. D\u00e9terminer le trajet parcouru. D\u00e9terminer une table de routage possible pour le routeur G obtenu \u00e0 l\u2019aide du protocole RIP. Question 2 Le routeur C tombe en panne. Reconstruire la table de routage du routeur A en suivant le protocole RIP. Exercice 3 \u2693\ufe0e On repr\u00e9sente ci-dessous un r\u00e9seau dans lequel R1, R2, R3, R4, R5 et R6 sont des routeurs. Le r\u00e9seau local L1 est reli\u00e9 au routeur R1 et le r\u00e9seau local L2 au routeur R6. Dans cet exercice, les adresses IP sont compos\u00e9es de 4 octets, soit 32 bits. Elles sont not\u00e9es X1.X2.X3.X4, o\u00f9 X1, X2, X3 et X4 sont les valeurs des 4 octets, convertis en notation d\u00e9cimale. La notation X1.X2.X3.X4/n signifie que les n premiers bits de poids forts de l\u2019adresse IP repr\u00e9sentent la partie \u00ab r\u00e9seau \u00bb, les bits suivants repr\u00e9sentent la partie \u00ab h\u00f4te \u00bb. Toutes les adresses des h\u00f4tes connect\u00e9s \u00e0 un r\u00e9seau local ont la m\u00eame partie r\u00e9seau et peuvent donc communiquer directement. L\u2019adresse IP dont tous les bits de la partie \u00ab h\u00f4te \u00bb sont \u00e0 0 est appel\u00e9e \u00ab adresse du r\u00e9seau \u00bb. On donne \u00e9galement des extraits de la table de routage des routeurs R1 \u00e0 R5 dans le tableau suivant : Un paquet part du r\u00e9seau local L1 \u00e0 destination du r\u00e9seau local L2. a. En utilisant l\u2019extrait de la table de routage de R1, vers quel routeur R1 envoie-t-il ce paquet : R2 ou R3 ? Justifier. b. A l\u2019aide des extraits de tables de routage ci-dessus, nommer les routeurs travers\u00e9s par ce paquet, lorsqu\u2019il va du r\u00e9seau L1 au r\u00e9seau L2. La liaison entre R1 et R2 est rompue. a. Sachant que ce r\u00e9seau utilise le protocole RIP (distance en nombre de sauts), donner l\u2019un des deux chemins possibles que pourra suivre un paquet allant de L1 vers L2. b. Dans les extraits de tables de routage ci-dessus, pour le chemin de la question 2.a, quelle(s) ligne(s) sera (seront) modifi\u00e9e(s) ? On a r\u00e9tabli la liaison entre R1 et R2. Par ailleurs, pour tenir compte du d\u00e9bit des liaisons, on d\u00e9cide d\u2019utiliser le protocole OSPF (distance li\u00e9e au co\u00fbt minimal des liaisons) pour effectuer le routage. Le co\u00fbt des liaisons entre les routeurs est donn\u00e9 par le tableau suivant : a. Le co\u00fbt C d\u2019une liaison est donn\u00e9 ici par la formule \\(C = \\dfrac{10^9}{BP}\\) o\u00f9 BP est la bande passante de la connexion en bps (bits par seconde). Sachant que la bande passante de la liaison R2-R3 est de 10 Mbps, calculer le co\u00fbt correspondant. b. D\u00e9terminer le chemin parcouru par un paquet partant du r\u00e9seau L1 et arrivant au r\u00e9seau L2, en utilisant le protocole OSPF. c. Indiquer pour quel(s) routeur(s) l\u2019extrait de la table de routage sera modifi\u00e9 pour un paquet \u00e0 destination de L2, avec la m\u00e9trique OSPF. Exercice 4 \u2693\ufe0e Figure 1 La figure 1 ci-dessus repr\u00e9sente le sch\u00e9ma d\u2019un r\u00e9seau d\u2019entreprise. Il y figure deux r\u00e9seaux locaux L1 et L2. Ces deux r\u00e9seaux locaux sont interconnect\u00e9s par les routeurs R2, R3, R4 et R5. Le r\u00e9seau local L1 est constitu\u00e9 des PC portables P1 et P2 connect\u00e9s \u00e0 la passerelle R1 par le switch Sw1. Les serveurs S1 et S2 sont connect\u00e9s \u00e0 la passerelle R6 par le switch Sw2. Le tableau 1 suivant indique les adresses IPv4 des machines constituants le r\u00e9seau de l\u2019entreprise. Tableau 1 : adresses IPv4 des machines Rappels et notations Rappelons qu\u2019une adresse IP est compos\u00e9e de 4 octets, soit 32 bits. Elle est not\u00e9e X1.X2.X3.X4, o\u00f9 X1, X2, X3 et X4 sont les valeurs des 4 octets. Dans le tableau 1, les valeurs des 4 octets ont \u00e9t\u00e9 converties en notation d\u00e9cimale. La notation X1.X2.X3.X4/n signifie que les n premiers bits de poids forts de l\u2019adresse IP repr\u00e9sentent la partie \u00ab r\u00e9seau \u00bb, les bits suivants de poids faibles repr\u00e9sentent la partie \u00ab machine \u00bb. Toutes les adresses des machines connect\u00e9es \u00e0 un r\u00e9seau local ont la m\u00eame partie r\u00e9seau. L\u2019adresse IP dont tous les bits de la partie \u00ab machine \u00bb sont \u00e0 0 est appel\u00e9e \u00ab adresse du r\u00e9seau \u00bb. L\u2019adresse IP dont tous les bits de la partie \u00ab machine \u00bb sont \u00e0 1 est appel\u00e9e \u00ab adresse de diffusion \u00bb. a. Quelles sont les adresses des r\u00e9seaux locaux L1 et L2 ? b. Donner la plus petite et la plus grande adresse IP valides pouvant \u00eatre attribu\u00e9es \u00e0 un ordinateur portable ou un serveur sur chacun des r\u00e9seaux L1 et L2 sachant que l\u2019adresse du r\u00e9seau et l\u2019adresse de diffusion ne peuvent pas \u00eatre attribu\u00e9es \u00e0 une machine. c. Combien de machines peut-on connecter au maximum \u00e0 chacun des r\u00e9seaux locaux L1 et L2 ? a. Expliquer l\u2019utilit\u00e9 d\u2019avoir plusieurs chemins possibles reliant les r\u00e9seaux L1 et L2. b. Quel est le chemin le plus court en nombre de sauts pour relier R1 et R6 ? Donner le nombre de sauts de ce chemin et pr\u00e9ciser les routeurs utilis\u00e9s. c. La bande passante d\u2019une liaison Ether (quantit\u00e9 d\u2019information qui peut \u00eatre transmise en bits/s) est de 10^7 bits/s et celle d\u2019une liaison FastEther est de 10^8 bits/s. Le co\u00fbt d\u2019une liaison est d\u00e9fini par 10^8 / d , o\u00f9 d est sa bande passante en bits/s. Tableau 2 : type des liaisons entre les routeurs Quel est le chemin reliant R1 et R6 qui a le plus petit co\u00fbt ? Donner le co\u00fbt de ce chemin et pr\u00e9ciser les routeurs utilis\u00e9s. Dans l\u2019annexe A figurent les tables de routages des routeurs R1, R2, R5 et R6 au d\u00e9marrage du r\u00e9seau. Indiquer sur votre copie ce qui doit figurer dans les lignes laiss\u00e9es vides des tables de routage des routeurs R5 et R6 pour que les \u00e9changes entre les ordinateurs des r\u00e9seaux L1 et L2 se fassent en empruntant le chemin le plus court en nombre de sauts.","title":"02 Exercices"},{"location":"Reseaux/TD19_Routage/","text":"TD n\u00b019 : Protocoles de routage Th\u00e8me 3 : Architecture, OS et r\u00e9seaux I. R\u00e9sum\u00e9 des \u00e9pisodes pr\u00e9c\u00e9dents \u23e9 Notion d'adressage \u2693\ufe0e Deux types d'adresses existent : Adresse MAC Une adresse mat\u00e9rielle, ou adresse MAC , parfois nomm\u00e9e adresse physique, est un identifiant physique stock\u00e9 dans une carte r\u00e9seau ou une interface r\u00e9seau similaire (Wifi par exemple). \u00c0 moins qu\u2019elle n\u2019ait \u00e9t\u00e9 modifi\u00e9e par l\u2019utilisateur, elle est unique au monde. Elle constitue la couche inf\u00e9rieure de la couche de liaison, c'est-\u00e0-dire la couche deux du mod\u00e8le OSI. Elle est constitu\u00e9e de six octets, il existe donc potentiellement \\(2^{48}\\) (environ 281 000 milliards) d'adresses MAC possibles. Adresse IP Une adresse IP (Internet Protocol) est un num\u00e9ro d'identification qui est attribu\u00e9 de fa\u00e7on permanente ou provisoire \u00e0 chaque p\u00e9riph\u00e9rique reli\u00e9 \u00e0 un r\u00e9seau informatique qui utilise l'Internet Protocol. L'adresse IP est \u00e0 la base du syst\u00e8me d'acheminement (le routage) des paquets de donn\u00e9es sur Internet. Notions essentielles : Lorsqu'une machine A, d'adresse IP_A veut discuter avec une machine B, d'adresse IP_B : La machine A calcule (gr\u00e2ce au masque de sous-r\u00e9seau) si B est dans le m\u00eame sous-r\u00e9seau qu'elle, ou pas. Si oui, elle peut donc conna\u00eetre l'adresse MAC de la carte r\u00e9seau de la machine B (soit elle la poss\u00e8de d\u00e9j\u00e0 dans sa table ARP, soit elle la demande en envoyant un message de broadcast \u00e0 tout le sous-r\u00e9seau : \u00abqui poss\u00e8de cette adresse IP_B ?\u00bb). Elle envoie donc dans le sous-r\u00e9seau une trame ayant pour ent\u00eate l'adresse MAC de B : le switch lit cette trame, sait sur quel port est branch\u00e9 la machine B et lui envoie sp\u00e9cifiquement donc le message. Si B n'est pas dans le m\u00eame sous-r\u00e9seau que A, A mettra en ent\u00eate de sa trame l'adresse MAC de la carte r\u00e9seau du routeur, qui joue le r\u00f4le de passerelle. Le routeur va ouvrir la trame et va observer l'IP_B, \u00e0 qui il doit remettre ce message. C'est maintenant que vont intervenir les protocoles de routage : est-ce que B est dans le m\u00eame sous-r\u00e9seau que le routeur ? est-ce que B est dans un autre sous-r\u00e9seau connu du routeur ? est-ce que B est totalement inconnu du routeur ? Ces questions trouveront des r\u00e9ponses gr\u00e2ce \u00e0 table de routage du routeur. II. Tables de routage Les tables de routage sont des informations stock\u00e9es dans le routeur permettant d'aiguiller intelligemment les donn\u00e9es qui lui sont transmises. Dans le r\u00e9seau ci-dessus, si l'ordinateur d'adresse 192.168.0.5 veut interroger le serveur 10.7.3.8 : l'adresse 10.7.3.8 n'\u00e9tant pas dans le sous-r\u00e9seau F (d'adresse 192.168.0.0 / 24 ), la requ\u00eate est confi\u00e9e au routeur via son adresse passerelle dans le r\u00e9seau F (ici 192.168.0.254 ). le routeur observe si l'IP recherch\u00e9e appartient \u00e0 un autre des sous-r\u00e9seaux auquel il est connect\u00e9. Ici, l'IP recherch\u00e9e 10.7.3.8 n'appartient ni au sous-r\u00e9seau A ou E. le routeur va donc regarder dans sa table de routage l'adresse passerelle d'un autre routeur vers qui elle doit rediriger les donn\u00e9es. Si le sous-r\u00e9seau C fait partie de sa table de routage, le routeur R1 saura alors que le meilleur chemin est (par exemple) de confier les donn\u00e9es au routeur R3. si le sous-r\u00e9seau C ne fait pas partie de la table de routage, le routeur R1 va alors le rediriger vers une route \u00abpar d\u00e9faut\u00bb (que l'on peut assimiler au panneau \u00abtoutes directions\u00bb sur les panneaux de signalisation). Par exemple, la table de routage du routeur R1 pourrait \u00eatre : Destination Passerelle 192.168.0.0 /24 192.168.0.254 172.17.1.0 /24 172.17.1.254 10.0.5.0 /24 10.0.5.152 10.5.2.0 /24 172.17.1.254 10.7.3.0 /24 10.0.5.135 \u23e9 Comment sont construites les tables de routage ? \u2693\ufe0e Soit \u00e0 la main par l'administrateur r\u00e9seau, quand le r\u00e9seau est petit : on parle alors de table statique . Soit de mani\u00e8re dynamique : les r\u00e9seaux s'envoient eux-m\u00eames des informations permettant de mettre \u00e0 jour leurs tables de routages respectives. Des algorithmes de d\u00e9termination de meilleur chemin sont alors utilis\u00e9s : nous allons en d\u00e9couvrir deux, le protocole RIP et le protocole OSPF. III. Le protocole RIP A connaitre RIP Le Routing Information Protocol est bas\u00e9 sur l'\u00e9change (toutes les 30 secondes) des tables de routage de chaque routeur. Au d\u00e9but, chaque routeur ne conna\u00eet que les r\u00e9seaux auquel il est directement connect\u00e9, associ\u00e9 \u00e0 la distance 1. Ensuite, chaque routeur re\u00e7oit p\u00e9riodiquement la table des r\u00e9seaux auquel il est connect\u00e9 : s'il d\u00e9couvre une route vers un nouveau r\u00e9seau inconnu, il l'ajoute \u00e0 sa table en augmentant de 1 la distance annonc\u00e9e par le routeur qui lui a transmis sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus courte (en rajoutant 1) que celle qu'il poss\u00e8de dans sa table, il actualise sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus longue que celle qu'il poss\u00e8de dans sa table, il ignore cette route. s'il re\u00e7oit une route vers un r\u00e9seau connu en provenance d'un routeur d\u00e9j\u00e0 existant dans sa table, s'il met \u00e0 jour sa table car la topologie du r\u00e9seau a \u00e9t\u00e9 modifi\u00e9e. si le r\u00e9seau n'\u00e9volue pas (panne ou ajout de nouveau mat\u00e9riel), les tables de routage convergent vers une valeur stable. Elles n'\u00e9voluent plus. si un routeur ne re\u00e7oit pas pendant 3 minutes d'information de la part d'un routeur qui lui avait auparavant communiqu\u00e9 sa table de routage, ce routeur est consid\u00e9r\u00e9 comme en panne, et toutes les routes passant par lui sont affect\u00e9es de la distance infinie : 16. Remarques et incov\u00e9nients: Le protocole RIP n'admet qu'une distance maximale \u00e9gale \u00e0 15 (ceci explique que 16 soit consid\u00e9r\u00e9 comme la distance infinie), ce qui le limite aux r\u00e9seaux de petite taille. Chaque routeur n'a jamais connaissance de la topologie du r\u00e9seau tout entier : il ne le conna\u00eet que par ce que les autres routeurs lui ont racont\u00e9. On dit que ce protocole de routage est du routing by rumor . La m\u00e9trique utilis\u00e9e (le nombre de sauts) ne tient pas compte de la qualit\u00e9 de la liaison, contrairement au protocole OSPF. IV. Le protocole OSPF OSPF OSPF : Open Shortest Path First Un inconv\u00e9nient majeur du protocole RIP pr\u00e9c\u00e9dent est la non-prise en compte de la bande passante reliant les routeurs. En voiture, le chemin le plus rapide n'est pas forc\u00e9ment le plus court. En gris, le chemin RIP. En bleu, l'OSPF. Dans le protocole OSPF, les tables de routage vont prendre en consid\u00e9ration la vitesse de communication entre les routeurs. Dans une premi\u00e8re phase d'initialisation, chaque routeur va acqu\u00e9rir (par succession de messages envoy\u00e9s et re\u00e7us) la connaissance totale du r\u00e9seau (diff\u00e9rence fondamentale avec RIP) et de la qualit\u00e9 technique de la liaison entre chaque routeur. \u23e9 Les diff\u00e9rents types de liaison et leur co\u00fbt \u2693\ufe0e On peut, approximativement, classer les types de liaison suivant ce tableau de d\u00e9bits th\u00e9oriques : Technologie BP descendante BP montante Modem 56 kbit/s 48 kbit/s Bluetooth 3 Mbit/s 3 Mbit/s Ethernet 10 Mbit/s 10 Mbit/s Wi-Fi 10 Mbit/s ~ 10 Gbits/s 10 Mbit/s ~ 10 Gbits/s ADSL 13 Mbit/s 1 Mbit/s 4G 100 Mbit/s 50 Mbit/s Satellite 50 Mbit/s 1 Mbit/s Fast Ethernet 100 Mbit/s 100 Mbit/s FFTH (fibre) 10 Gbit/s 10 Gbit/s 5G 20 Gbit/s 10 Gbit/s L'id\u00e9e du protocole OSPF est de pond\u00e9rer chaque trajet entre routeurs (comptant simplement pour \u00ab1\u00bb dans le protocole RIP) par une valeur de co\u00fbt inversement proportionnelle au d\u00e9bit de transfert. Par exemple, si le d\u00e9bit d est exprim\u00e9 en bits/s, on peut calculer le co\u00fbt de chaque liaison par la formule : A connaitre \\(\\text{co\u00fbt} = \\dfrac{10^8}{d}\\) Cette formule de calcul peut \u00eatre diff\u00e9rente suivant les exercices, et sera normalement redonn\u00e9e. N\u00e9anmoins la valeur d sera toujours au d\u00e9nominateur, pour assurer la proportionnalit\u00e9 inverse du d\u00e9bit. Avec cette convention, un route entre deux routeurs reli\u00e9s en Fast Ethernet (100 Mbits/s) aura a un poids de 1, une liaison satellite de 20 Mbits/s aura un poids de 5, etc. \u23e9 Exemple \u2693\ufe0e Reprenons le r\u00e9seau suivant : et simplifions-le en ne gardant que les liens entre routeurs, en indiquant leur d\u00e9bit : Notre r\u00e9seau est devenu un graphe . Nous allons pond\u00e9rer ses ar\u00eates avec la fonction co\u00fbt introduite pr\u00e9c\u00e9demment. L'unit\u00e9 \u00e9tant le Mbit/s, l'ar\u00eate entre R1 et R3 aura un poids de 100/20=5. Le graphe pond\u00e9r\u00e9 est donc : Le chemin le plus rapide pour aller de l'ordinateur au serveur est donc R1-R2-R4, et non plus R1-R3 comme l'aurait indiqu\u00e9 le protocole RIP. \u23e9 Trouver le plus court chemin dans un graphe pond\u00e9r\u00e9 \u2693\ufe0e L'exemple pr\u00e9c\u00e9dent \u00e9tait tr\u00e8s simple et de solution intuitive. Dans le cas d'un graphe pond\u00e9r\u00e9 complexe, existe-t-il un algorithme de d\u00e9termination du plus court chemin d'un point \u00e0 un autre ? La r\u00e9ponse est oui , depuis la d\u00e9couverte en 1959 par Edsger Dijkstra de l'algorithme qui porte son nom, l'algorithme de Dijkstra . Pour le comprendre, vous pouvez regarder la vid\u00e9o d'un c\u00e9l\u00e8bre YouTuber : Cet algorithme, ici ex\u00e9cut\u00e9 de mani\u00e8re manuelle, est bien s\u00fbr programmable. Et c'est donc gr\u00e2ce \u00e0 lui que chaque routeur calcule la route la plus rapide pour acheminer les donn\u00e9es qu'il re\u00e7oit. Exemple d'application de l'algorithme de Dijkstra : Donner le plus court chemin pour aller de A \u00e0 H. V. Exercices BAC Sujet n\u00b01 : sujet z\u00e9ro On consid\u00e8re un r\u00e9seau compos\u00e9 de plusieurs routeurs reli\u00e9s de la fa\u00e7on suivante : \u27a1 Le protocole RIP \u2693\ufe0e Le protocole RIP permet de construire les tables de routage des diff\u00e9rents routeurs, en indiquant pour chaque routeur la distance, en nombre de sauts, qui le s\u00e9pare d\u2019un autre routeur. Pour le r\u00e9seau ci-dessus, on dispose des tables de routage suivantes : Question 1 Le routeur A doit transmettre un message au routeur G, en effectuant un nombre minimal de sauts. D\u00e9terminer le trajet parcouru. D\u00e9terminer une table de routage possible pour le routeur G obtenu \u00e0 l\u2019aide du protocole RIP. Question 2 Le routeur C tombe en panne. Reconstruire la table de routage du routeur A en suivant le protocole RIP. \u27a1 Le protocole OSPF \u2693\ufe0e Contrairement au protocole RIP, l\u2019objectif n\u2019est plus de minimiser le nombre de routeurs travers\u00e9s par un paquet. La notion de distance utilis\u00e9e dans le protocole OSPF est uniquement li\u00e9e aux co\u00fbts des liaisons. L\u2019objectif est alors de minimiser la somme des co\u00fbts des liaisons travers\u00e9es. Le co\u00fbt d\u2019une liaison est donn\u00e9 par la formule suivante : \\(co\u00fbt = \\dfrac{10^8}{d}\\) o\u00f9 \\(d\\) est la bande passante en bits/s entre les deux routeurs. On a rajout\u00e9 sur le graphe repr\u00e9sentant le r\u00e9seau pr\u00e9c\u00e9dent les diff\u00e9rents d\u00e9bits des liaisons. On rappelle que 1 Gb/s = 1 000 Mb/s = \\(10^9\\) bits/s. Question 3 V\u00e9rifier que le co\u00fbt de la liaison entre les routeurs A et B est 0,01. La liaison entre le routeur B et D a un co\u00fbt de 5. Quel est le d\u00e9bit de cette liaison ? Question 4 Le routeur A doit transmettre un message au routeur G, en empruntant le chemin dont la somme des co\u00fbts sera la plus petite possible. D\u00e9terminer le chemin parcouru. On indiquera le raisonnement utilis\u00e9. Sujet n\u00b02 Cet exercice porte sur les r\u00e9seaux et les protocoles de routage. On repr\u00e9sente ci-dessous un r\u00e9seau dans lequel R1, R2, R3, R4, R5 et R6 sont des routeurs. Le r\u00e9seau local L1 est reli\u00e9 au routeur R1 et le r\u00e9seau local L2 au routeur R6. Rappels et notations Dans cet exercice, les adresses IP sont compos\u00e9es de 4 octets, soit 32 bits. Elles sont not\u00e9es X1.X2.X3.X4, o\u00f9 X1, X2, X3 et X4 sont les valeurs des 4 octets, convertis en notation d\u00e9cimale. La notation X1.X2.X3.X4/n signifie que les n premiers bits de poids forts de l\u2019adresse IP repr\u00e9sentent la partie \u00ab r\u00e9seau \u00bb, les bits suivants repr\u00e9sentent la partie \u00ab h\u00f4te \u00bb. Toutes les adresses des h\u00f4tes connect\u00e9s \u00e0 un r\u00e9seau local ont la m\u00eame partie r\u00e9seau et peuvent donc communiquer directement. L\u2019adresse IP dont tous les bits de la partie \u00ab h\u00f4te \u00bb sont \u00e0 0 est appel\u00e9e \u00ab adresse du r\u00e9seau \u00bb. On donne \u00e9galement des extraits de la table de routage des routeurs R1 \u00e0 R5 dans le tableau suivant : Routeur R\u00e9seau destinataire Passerelle Interface R1 54.37.122.0/24 86.154.10.1 86.154.10.56 R2 54.37.122.0/24 37.49.236.22 37.49.236.23 R3 54.37.122.0/24 62.34.2.8 62.34.2.9 R4 54.37.122.0/24 94.23.122.10 94.23.122.11 R5 54.37.122.0/24 218.32.15.1 218.32.15.2 Question 1 Un paquet part du r\u00e9seau local L1 \u00e0 destination du r\u00e9seau local L2. a. En utilisant l\u2019extrait de la table de routage de R1, vers quel routeur R1 envoie-t-il ce paquet : R2 ou R3 ? Justifier. b. A l\u2019aide des extraits de tables de routage ci-dessus, nommer les routeurs travers\u00e9s par ce paquet, lorsqu\u2019il va du r\u00e9seau L1 au r\u00e9seau L2. Question 2 La liaison entre R1 et R2 est rompue. a. Sachant que ce r\u00e9seau utilise le protocole RIP (distance en nombre de sauts), donner l\u2019un des deux chemins possibles que pourra suivre un paquet allant de L1 vers L2. b. Dans les extraits de tables de routage ci-dessus, pour le chemin de la question 2.a, quelle(s) ligne(s) sera (seront) modifi\u00e9e(s) ? Question 3 On a r\u00e9tabli la liaison entre R1 et R2. Par ailleurs, pour tenir compte du d\u00e9bit des liaisons, on d\u00e9cide d\u2019utiliser le protocole OSPF (distance li\u00e9e au co\u00fbt minimal des liaisons) pour effectuer le routage. Le co\u00fbt des liaisons entre les routeurs est donn\u00e9 par le tableau suivant : Liaison R1-R2 R1-R3 R2-R3 R2-R4 R2-R5 Co\u00fbt 100 100 ? 1 10 Liaison R2-R6 R3-R4 R4-R5 R4-R6 R5-R6 Co\u00fbt 10 10 1 10 1 a. Le co\u00fbt \\(C\\) d'une liaison est donn\u00e9 ici par la formule \u0b3d \\(C=\\dfrac{10^9}{BP}\\) o\u00f9 \\(BP\\) est la bande passante de la connexion en bps (bit par seconde). Sachant que la bande passante de la liaison R2-R3 est de 10 Mbps, calculer le co\u00fbt correspondant. b. D\u00e9terminer le chemin parcouru par un paquet partant du r\u00e9seau L1 et arrivant au r\u00e9seau L2, en utilisant le protocole OSPF. c. Indiquer pour quel(s) routeur(s) l\u2019extrait de la table de routage sera modifi\u00e9 pour un paquet \u00e0 destination de L2, avec la m\u00e9trique OSPF. Sujet n\u00b03 Cet exercice porte sur les r\u00e9seaux et les protocoles de routage. La figure 1 ci-dessus repr\u00e9sente le sch\u00e9ma d\u2019un r\u00e9seau d\u2019entreprise. Il y figure deux r\u00e9seaux locaux L1 et L2. Ces deux r\u00e9seaux locaux sont interconnect\u00e9s par les routeurs R2, R3, R4 et R5. Le r\u00e9seau local L1 est constitu\u00e9 des PC portables P1 et P2 connect\u00e9s \u00e0 la passerelle R1 par le switch Sw1. Les serveurs S1 et S2 sont connect\u00e9s \u00e0 la passerelle R6 par le switch Sw2. Le tableau 1 suivant indique les adresses IPv4 des machines constituants le r\u00e9seau de l\u2019entreprise. Nom Type Adresse IPv4 R1 routeur (passerelle) Interface 1 : 192.168.1.1/24 Interface 2 : 10.1.1.2/24 R2 routeur Interface 1 : 10.1.1.1/24 Interface 2 : 10.1.2.1/24 Interface 3 : 10.1.3.1/24 R3 routeur Interface 1 : 10.1.2.2/24 Interface 2 : 10.1.4.2/24 Interface 3 : 10.1.5.2/24 R4 routeur Interface 1 : 10.1.5.1/24 Interface 2 : 10.1.6.1/24 R5 routeur (passerelle) Interface 1 : 10.1.3.2/24 Interface 2 : 10.1.4.1/24 Interface 3 : 10.1.6.2/24 Interface 4 : 10.1.7.1/24 R6 routeur (passerelle) Interface 1 : 172.16.0.1/16 Interface 2 : 10.1.7.2/24 P1 ordinateur portable 192.168.1.40/24 P2 ordinateur portable 192.168.1.46/24 S1 serveur 172.16.8.10/16 S2 serveur 172.16.9.12/16 Rappels et notations Rappelons qu\u2019une adresse IP est compos\u00e9e de 4 octets, soit 32 bits. Elle est not\u00e9e X1.X2.X3.X4, o\u00f9 X1, X2, X3 et X4 sont les valeurs des 4 octets. Dans le tableau 1, les valeurs des 4 octets ont \u00e9t\u00e9 converties en notation d\u00e9cimale. La notation X1.X2.X3.X4/n signifie que les n premiers bits de poids forts de l\u2019adresse IP repr\u00e9sentent la partie \u00ab r\u00e9seau \u00bb, les bits suivants de poids faibles repr\u00e9sentent la partie \u00ab machine \u00bb. Toutes les adresses des machines connect\u00e9es \u00e0 un r\u00e9seau local ont la m\u00eame partie r\u00e9seau. L\u2019adresse IP dont tous les bits de la partie \u00ab machine \u00bb sont \u00e0 0 est appel\u00e9e \u00ab adresse du r\u00e9seau \u00bb. L\u2019adresse IP dont tous les bits de la partie \u00ab machine \u00bb sont \u00e0 1 est appel\u00e9e \u00ab adresse de diffusion \u00bb. Question 1 a. Quelles sont les adresses des r\u00e9seaux locaux L1 et L2 ? b. Donner la plus petite et la plus grande adresse IP valides pouvant \u00eatre attribu\u00e9es \u00e0 un ordinateur portable ou un serveur sur chacun des r\u00e9seaux L1 et L2 sachant que l\u2019adresse du r\u00e9seau et l\u2019adresse de diffusion ne peuvent pas \u00eatre attribu\u00e9es \u00e0 une machine. c. Combien de machines peut-on connecter au maximum \u00e0 chacun des r\u00e9seaux locaux L1 et L2 ? On donne ci-dessous les valeurs de quelques puissances de 2 ? \\(2^6\\) \\(2^7\\) \\(2^8\\) \\(2^9\\) \\(2^{10}\\) \\(2^{11}\\) 64 128 256 512 1024 2048 \\(2^{12}\\) \\(2^{13}\\) \\(2^{14}\\) \\(2^{15}\\) \\(2^{16}\\) \\(2^{17}\\) 4096 8192 16384 32768 65536 131072 Question 2 a. Expliquer l\u2019utilit\u00e9 d\u2019avoir plusieurs chemins possibles reliant les r\u00e9seaux L1 et L2. b. Quel est le chemin le plus court en nombre de sauts pour relier R1 et R6 ? Donner le nombre de sauts de ce chemin et pr\u00e9ciser les routeurs utilis\u00e9s. c. La bande passante d\u2019une liaison Ether (quantit\u00e9 d\u2019information qui peut \u00eatre transmise en bits/s) est de \\(10^7\\) bits/s et celle d\u2019une liaison FastEther est de \\(10^8\\) bits/s. Le co\u00fbt d\u2019une liaison est d\u00e9fini par \\(\\dfrac{10^8}{d}\\) , o\u00f9 d est sa bande passante en bits/s. Liaison R1-R2 R2-R5 R5-R6 R2-R3 R3-R4 Type Ether Ether Ether FastEther FastEther Liaison R4-R5 R3-R5 Type FastEther Ether Quel est le chemin reliant R1 et R6 qui a le plus petit co\u00fbt ? Donner le co\u00fbt de ce chemin et pr\u00e9ciser les routeurs utilis\u00e9s. Question 3 Dans l\u2019annexe A figurent les tables de routages des routeurs R1, R2, R5 et R6 au d\u00e9marrage du r\u00e9seau. Indiquer sur votre copie ce qui doit figurer dans les lignes laiss\u00e9es vides des tables de routage des routeurs R5 et R6 pour que les \u00e9changes entre les ordinateurs des r\u00e9seaux L1 et L2 se fassent en empruntant le chemin le plus court en nombre de sauts. Annexe","title":"TD19 Routage"},{"location":"Reseaux/TD19_Routage_Correction/","text":"TD n\u00b019 : Protocoles de routage Th\u00e8me 3 : Architecture, OS et r\u00e9seaux COURS et EXERCICES R\u00e9sum\u00e9 des \u00e9pisodes pr\u00e9c\u00e9dents \u2693\ufe0e Notion d'adressage \u2693\ufe0e Deux types d'adresses existent : Adresse MAC Une adresse mat\u00e9rielle, ou adresse MAC , parfois nomm\u00e9e adresse physique, est un identifiant physique stock\u00e9 dans une carte r\u00e9seau ou une interface r\u00e9seau similaire (Wifi par exemple). \u00c0 moins qu\u2019elle n\u2019ait \u00e9t\u00e9 modifi\u00e9e par l\u2019utilisateur, elle est unique au monde. Elle constitue la couche inf\u00e9rieure de la couche de liaison, c'est-\u00e0-dire la couche deux du mod\u00e8le OSI. Elle est constitu\u00e9e de six octets, il existe donc potentiellement \\(2^{48}\\) (environ 281 000 milliards) d'adresses MAC possibles. Adresse IP Une adresse IP (Internet Protocol) est un num\u00e9ro d'identification qui est attribu\u00e9 de fa\u00e7on permanente ou provisoire \u00e0 chaque p\u00e9riph\u00e9rique reli\u00e9 \u00e0 un r\u00e9seau informatique qui utilise l'Internet Protocol. L'adresse IP est \u00e0 la base du syst\u00e8me d'acheminement (le routage) des paquets de donn\u00e9es sur Internet. Notions essentielles : Lorsqu'une machine A, d'adresse IP_A veut discuter avec une machine B, d'adresse IP_B : La machine A calcule (gr\u00e2ce au masque de sous-r\u00e9seau) si B est dans le m\u00eame sous-r\u00e9seau qu'elle, ou pas. Si oui, elle peut donc conna\u00eetre l'adresse MAC de la carte r\u00e9seau de la machine B (soit elle la poss\u00e8de d\u00e9j\u00e0 dans sa table ARP, soit elle la demande en envoyant un message de broadcast \u00e0 tout le sous-r\u00e9seau : \u00abqui poss\u00e8de cette adresse IP_B ?\u00bb). Elle envoie donc dans le sous-r\u00e9seau une trame ayant pour ent\u00eate l'adresse MAC de B : le switch lit cette trame, sait sur quel port est branch\u00e9 la machine B et lui envoie sp\u00e9cifiquement donc le message. Si B n'est pas dans le m\u00eame sous-r\u00e9seau que A, A mettra en ent\u00eate de sa trame l'adresse MAC de la carte r\u00e9seau du routeur, qui joue le r\u00f4le de passerelle. Le routeur va ouvrir la trame et va observer l'IP_B, \u00e0 qui il doit remettre ce message. C'est maintenant que vont intervenir les protocoles de routage : est-ce que B est dans le m\u00eame sous-r\u00e9seau que le routeur ? est-ce que B est dans un autre sous-r\u00e9seau connu du routeur ? est-ce que B est totalement inconnu du routeur ? Ces questions trouveront des r\u00e9ponses gr\u00e2ce \u00e0 table de routage du routeur. Tables de routage \u2693\ufe0e Les tables de routage sont des informations stock\u00e9es dans le routeur permettant d'aiguiller intelligemment les donn\u00e9es qui lui sont transmises. Dans le r\u00e9seau ci-dessus, si l'ordinateur d'adresse 192.168.0.5 veut interroger le serveur 10.7.3.8 : l'adresse 10.7.3.8 n'\u00e9tant pas dans le sous-r\u00e9seau F (d'adresse 192.168.0.0 / 24 ), la requ\u00eate est confi\u00e9e au routeur via son adresse passerelle dans le r\u00e9seau F (ici 192.168.0.254 ). le routeur observe si l'IP recherch\u00e9e appartient \u00e0 un autre des sous-r\u00e9seaux auquel il est connect\u00e9. Ici, l'IP recherch\u00e9e 10.7.3.8 n'appartient ni au sous-r\u00e9seau A ou E. le routeur va donc regarder dans sa table de routage l'adresse passerelle d'un autre routeur vers qui elle doit rediriger les donn\u00e9es. Si le sous-r\u00e9seau C fait partie de sa table de routage, le routeur R1 saura alors que le meilleur chemin est (par exemple) de confier les donn\u00e9es au routeur R3. si le sous-r\u00e9seau C ne fait pas partie de la table de routage, le routeur R1 va alors le rediriger vers une route \u00abpar d\u00e9faut\u00bb (que l'on peut assimiler au panneau \u00abtoutes directions\u00bb sur les panneaux de signalisation). Par exemple, la table de routage du routeur R1 pourrait \u00eatre : Destination Passerelle 192.168.0.0 /24 192.168.0.254 172.17.1.0 /24 172.17.1.254 10.0.5.0 /24 10.0.5.152 10.5.2.0 /24 172.17.1.254 10.7.3.0 /24 10.0.5.135 Comment sont construites les tables de routage ? \u2693\ufe0e Soit \u00e0 la main par l'administrateur r\u00e9seau, quand le r\u00e9seau est petit : on parle alors de table statique . Soit de mani\u00e8re dynamique : les r\u00e9seaux s'envoient eux-m\u00eames des informations permettant de mettre \u00e0 jour leurs tables de routages respectives. Des algorithmes de d\u00e9termination de meilleur chemin sont alors utilis\u00e9s : nous allons en d\u00e9couvrir deux, le protocole RIP et le protocole OSPF. Le protocole RIP \u2693\ufe0e RIP Le Routing Information Protocol est bas\u00e9 sur l'\u00e9change (toutes les 30 secondes) des tables de routage de chaque routeur. Au d\u00e9but, chaque routeur ne conna\u00eet que les r\u00e9seaux auquel il est directement connect\u00e9, associ\u00e9 \u00e0 la distance 1. Ensuite, chaque routeur re\u00e7oit p\u00e9riodiquement la table des r\u00e9seaux auquel il est connect\u00e9 : s'il d\u00e9couvre une route vers un nouveau r\u00e9seau inconnu, il l'ajoute \u00e0 sa table en augmentant de 1 la distance annonc\u00e9e par le routeur qui lui a transmis sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus courte (en rajoutant 1) que celle qu'il poss\u00e8de dans sa table, il actualise sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus longue que celle qu'il poss\u00e8de dans sa table, il ignore cette route. s'il re\u00e7oit une route vers un r\u00e9seau connu en provenance d'un routeur d\u00e9j\u00e0 existant dans sa table, s'il met \u00e0 jour sa table car la topologie du r\u00e9seau a \u00e9t\u00e9 modifi\u00e9e. si le r\u00e9seau n'\u00e9volue pas (panne ou ajout de nouveau mat\u00e9riel), les tables de routage convergent vers une valeur stable. Elles n'\u00e9voluent plus. si un routeur ne re\u00e7oit pas pendant 3 minutes d'information de la part d'un routeur qui lui avait auparavant communiqu\u00e9 sa table de routage, ce routeur est consid\u00e9r\u00e9 comme en panne, et toutes les routes passant par lui sont affect\u00e9es de la distance infinie : 16. Remarques et incov\u00e9nients: Le protocole RIP n'admet qu'une distance maximale \u00e9gale \u00e0 15 (ceci explique que 16 soit consid\u00e9r\u00e9 comme la distance infinie), ce qui le limite aux r\u00e9seaux de petite taille. Chaque routeur n'a jamais connaissance de la topologie du r\u00e9seau tout entier : il ne le conna\u00eet que par ce que les autres routeurs lui ont racont\u00e9. On dit que ce protocole de routage est du routing by rumor . La m\u00e9trique utilis\u00e9e (le nombre de sauts) ne tient pas compte de la qualit\u00e9 de la liaison, contrairement au protocole OSPF. Le protocole OSPF \u2693\ufe0e OSPF OSPF : Open Shortest Path First Un inconv\u00e9nient majeur du protocole RIP pr\u00e9c\u00e9dent est la non-prise en compte de la bande passante reliant les routeurs. En voiture, le chemin le plus rapide n'est pas forc\u00e9ment le plus court. En gris, le chemin RIP. En bleu, l'OSPF. Dans le protocole OSPF, les tables de routage vont prendre en consid\u00e9ration la vitesse de communication entre les routeurs. Dans une premi\u00e8re phase d'initialisation, chaque routeur va acqu\u00e9rir (par succession de messages envoy\u00e9s et re\u00e7us) la connaissance totale du r\u00e9seau (diff\u00e9rence fondamentale avec RIP) et de la qualit\u00e9 technique de la liaison entre chaque routeur. Les diff\u00e9rents types de liaison et leur co\u00fbt \u2693\ufe0e On peut, approximativement, classer les types de liaison suivant ce tableau de d\u00e9bits th\u00e9oriques : Technologie BP descendante BP montante Modem 56 kbit/s 48 kbit/s Bluetooth 3 Mbit/s 3 Mbit/s Ethernet 10 Mbit/s 10 Mbit/s Wi-Fi 10 Mbit/s ~ 10 Gbits/s 10 Mbit/s ~ 10 Gbits/s ADSL 13 Mbit/s 1 Mbit/s 4G 100 Mbit/s 50 Mbit/s Satellite 50 Mbit/s 1 Mbit/s Fast Ethernet 100 Mbit/s 100 Mbit/s FFTH (fibre) 10 Gbit/s 10 Gbit/s 5G 20 Gbit/s 10 Gbit/s L'id\u00e9e du protocole OSPF est de pond\u00e9rer chaque trajet entre routeurs (comptant simplement pour \u00ab1\u00bb dans le protocole RIP) par une valeur de co\u00fbt inversement proportionnelle au d\u00e9bit de transfert. Par exemple, si le d\u00e9bit d est exprim\u00e9 en bits/s, on peut calculer le co\u00fbt de chaque liaison par la formule : A connaitre \\(\\text{co\u00fbt} = \\dfrac{10^8}{d}\\) Cette formule de calcul peut \u00eatre diff\u00e9rente suivant les exercices, et sera normalement redonn\u00e9e. N\u00e9anmoins la valeur d sera toujours au d\u00e9nominateur, pour assurer la proportionnalit\u00e9 inverse du d\u00e9bit. Avec cette convention, un route entre deux routeurs reli\u00e9s en Fast Ethernet (100 Mbits/s) aura a un poids de 1, une liaison satellite de 20 Mbits/s aura un poids de 5, etc. Exemple \u2693\ufe0e Reprenons le r\u00e9seau suivant : et simplifions-le en ne gardant que les liens entre routeurs, en indiquant leur d\u00e9bit : Notre r\u00e9seau est devenu un graphe . Nous allons pond\u00e9rer ses ar\u00eates avec la fonction co\u00fbt introduite pr\u00e9c\u00e9demment. L'unit\u00e9 \u00e9tant le Mbit/s, l'ar\u00eate entre R1 et R3 aura un poids de 100/20=5. Le graphe pond\u00e9r\u00e9 est donc : Le chemin le plus rapide pour aller de l'ordinateur au serveur est donc R1-R2-R4, et non plus R1-R3 comme l'aurait indiqu\u00e9 le protocole RIP. Trouver le plus court chemin dans un graphe pond\u00e9r\u00e9 \u2693\ufe0e L'exemple pr\u00e9c\u00e9dent \u00e9tait tr\u00e8s simple et de solution intuitive. Dans le cas d'un graphe pond\u00e9r\u00e9 complexe, existe-t-il un algorithme de d\u00e9termination du plus court chemin d'un point \u00e0 un autre ? La r\u00e9ponse est oui , depuis la d\u00e9couverte en 1959 par Edsger Dijkstra de l'algorithme qui porte son nom, l'algorithme de Dijkstra . Pour le comprendre, vous pouvez regarder la vid\u00e9o d'un c\u00e9l\u00e8bre YouTuber : Cet algorithme, ici ex\u00e9cut\u00e9 de mani\u00e8re manuelle, est bien s\u00fbr programmable. Et c'est donc gr\u00e2ce \u00e0 lui que chaque routeur calcule la route la plus rapide pour acheminer les donn\u00e9es qu'il re\u00e7oit. Exemple d'application de l'algorithme de Dijkstra : Donner le plus court chemin pour aller de A \u00e0 H. Exercices BAC \u2693\ufe0e Sujet n\u00b01 : sujet z\u00e9ro \u2693\ufe0e On consid\u00e8re un r\u00e9seau compos\u00e9 de plusieurs routeurs reli\u00e9s de la fa\u00e7on suivante : \u27a1 Le protocole RIP \u2693\ufe0e Le protocole RIP permet de construire les tables de routage des diff\u00e9rents routeurs, en indiquant pour chaque routeur la distance, en nombre de sauts, qui le s\u00e9pare d\u2019un autre routeur. Pour le r\u00e9seau ci-dessus, on dispose des tables de routage suivantes : Question 1 Enonc\u00e9 Solution Le routeur A doit transmettre un message au routeur G, en effectuant un nombre minimal de sauts. D\u00e9terminer le trajet parcouru. D\u00e9terminer une table de routage possible pour le routeur G obtenu \u00e0 l\u2019aide du protocole RIP. trajet possible ACFG 'Lecture des table de routage. La distance est de 3. Question 2 Enonc\u00e9 Solution Le routeur C tombe en panne. Reconstruire la table de routage du routeur A en suivant le protocole RIP. \u27a1 Le protocole OSPF \u2693\ufe0e Contrairement au protocole RIP, l\u2019objectif n\u2019est plus de minimiser le nombre de routeurs travers\u00e9s par un paquet. La notion de distance utilis\u00e9e dans le protocole OSPF est uniquement li\u00e9e aux co\u00fbts des liaisons. L\u2019objectif est alors de minimiser la somme des co\u00fbts des liaisons travers\u00e9es. Le co\u00fbt d\u2019une liaison est donn\u00e9 par la formule suivante : \\(co\u00fbt = \\dfrac{10^8}{d}\\) o\u00f9 \\(d\\) est la bande passante en bits/s entre les deux routeurs. On a rajout\u00e9 sur le graphe repr\u00e9sentant le r\u00e9seau pr\u00e9c\u00e9dent les diff\u00e9rents d\u00e9bits des liaisons. On rappelle que 1 Gb/s = 1 000 Mb/s = \\(10^9\\) bits/s. Question 3 Enonc\u00e9 Solution 3.1 Solution 3.2 V\u00e9rifier que le co\u00fbt de la liaison entre les routeurs A et B est 0,01. La liaison entre le routeur B et D a un co\u00fbt de 5. Quel est le d\u00e9bit de cette liaison ? A -> B : 10 Gb/s soit un co\u00fbt : \\(\\dfrac{10^8}{10 \\times 10^9}=0.01\\) \\(\\dfrac{10^8}{d}=5 \\rightarrow d=\\dfrac{10^8}{5} = 2 \\times 10^7\\) b/s soit 20 Mb/s Question 4 Enonc\u00e9 Solution Le routeur A doit transmettre un message au routeur G, en empruntant le chemin dont la somme des co\u00fbts sera la plus petite possible. D\u00e9terminer le chemin parcouru. On indiquera le raisonnement utilis\u00e9. Le parcourt avec un co\u00fbt minimal pour aller de A \u00e0 G est donc ADEG dont le co\u00fbt est 1,011. Correction du tableau de l'algorithme de Dijkstra Sujet n\u00b02 \u2693\ufe0e Cet exercice porte sur les r\u00e9seaux et les protocoles de routage. On repr\u00e9sente ci-dessous un r\u00e9seau dans lequel R1, R2, R3, R4, R5 et R6 sont des routeurs. Le r\u00e9seau local L1 est reli\u00e9 au routeur R1 et le r\u00e9seau local L2 au routeur R6. Rappels et notations Dans cet exercice, les adresses IP sont compos\u00e9es de 4 octets, soit 32 bits. Elles sont not\u00e9es X1.X2.X3.X4, o\u00f9 X1, X2, X3 et X4 sont les valeurs des 4 octets, convertis en notation d\u00e9cimale. La notation X1.X2.X3.X4/n signifie que les n premiers bits de poids forts de l\u2019adresse IP repr\u00e9sentent la partie \u00ab r\u00e9seau \u00bb, les bits suivants repr\u00e9sentent la partie \u00ab h\u00f4te \u00bb. Toutes les adresses des h\u00f4tes connect\u00e9s \u00e0 un r\u00e9seau local ont la m\u00eame partie r\u00e9seau et peuvent donc communiquer directement. L\u2019adresse IP dont tous les bits de la partie \u00ab h\u00f4te \u00bb sont \u00e0 0 est appel\u00e9e \u00ab adresse du r\u00e9seau \u00bb. On donne \u00e9galement des extraits de la table de routage des routeurs R1 \u00e0 R5 dans le tableau suivant : Routeur R\u00e9seau destinataire Passerelle Interface R1 54.37.122.0/24 86.154.10.1 86.154.10.56 R2 54.37.122.0/24 37.49.236.22 37.49.236.23 R3 54.37.122.0/24 62.34.2.8 62.34.2.9 R4 54.37.122.0/24 94.23.122.10 94.23.122.11 R5 54.37.122.0/24 218.32.15.1 218.32.15.2 Question 1 Enonc\u00e9 Solution 1.a Solution 1.b Un paquet part du r\u00e9seau local L1 \u00e0 destination du r\u00e9seau local L2. a. En utilisant l\u2019extrait de la table de routage de R1, vers quel routeur R1 envoie-t-il ce paquet : R2 ou R3 ? Justifier. b. A l\u2019aide des extraits de tables de routage ci-dessus, nommer les routeurs travers\u00e9s par ce paquet, lorsqu\u2019il va du r\u00e9seau L1 au r\u00e9seau L2. L\u2019extrait de la table de routage de R1 montre que pour atteindre le r\u00e9seau L2 (57.37.122.0/24) les paquets doivent \u00eatre envoy\u00e9s via l\u2019interface 86.154.10.56. Cette interface fait partie du r\u00e9seau 86.154.10.0/24. Le routeur R2 fait aussi partie de ce r\u00e9seau. On peut donc affirmer que depuis R1, les paquets seront dirig\u00e9s vers R2. L1 -> R1 -> R2 -> R6 -> L2 Question 2 Enonc\u00e9 Solution 2.a Solution 2.b La liaison entre R1 et R2 est rompue. a. Sachant que ce r\u00e9seau utilise le protocole RIP (distance en nombre de sauts), donner l\u2019un des deux chemins possibles que pourra suivre un paquet allant de L1 vers L2. b. Dans les extraits de tables de routage ci-dessus, pour le chemin de la question 2.a, quelle(s) ligne(s) sera (seront) modifi\u00e9e(s) ? L1 -> R1 -> R3 -> R4 -> R6 -> L2 Vu le chemin choisi \u00e0 la question 2a, seule la ligne R1 sera modifi\u00e9e (r\u00e9seau 112.44.65.0 \u00e0 la place du r\u00e9seau 86.154.10.0). Question 3 Enonc\u00e9 Solution 2.b Solution 2.b Solution 2.b On a r\u00e9tabli la liaison entre R1 et R2. Par ailleurs, pour tenir compte du d\u00e9bit des liaisons, on d\u00e9cide d\u2019utiliser le protocole OSPF (distance li\u00e9e au co\u00fbt minimal des liaisons) pour effectuer le routage. Le co\u00fbt des liaisons entre les routeurs est donn\u00e9 par le tableau suivant : Liaison R1-R2 R1-R3 R2-R3 R2-R4 R2-R5 R2-R6 R3-R4 R4-R5 R4-R6 R5-R6 Co\u00fbt 100 100 ? 1 10 10 10 1 10 1 a. Le co\u00fbt \\(C\\) d'une liaison est donn\u00e9 ici par la formule \u0b3d \\(C=\\dfrac{10^9}{BP}\\) o\u00f9 \\(BP\\) est la bande passante de la connexion en bps (bit par seconde). Sachant que la bande passante de la liaison R2-R3 est de 10 Mbps, calculer le co\u00fbt correspondant. b. D\u00e9terminer le chemin parcouru par un paquet partant du r\u00e9seau L1 et arrivant au r\u00e9seau L2, en utilisant le protocole OSPF. c. Indiquer pour quel(s) routeur(s) l\u2019extrait de la table de routage sera modifi\u00e9 pour un paquet \u00e0 destination de L2, avec la m\u00e9trique OSPF. \\(C = \\dfrac{10^9}{10^7} = 100\\) La route avec le co\u00fbt minimum (103) est la suivante : L1 -> R1 -> R2 -> R4 -> R5 -> R6 -> L2 Les tables de routage R2 et R4 seront modifi\u00e9es. Sujet n\u00b03 \u2693\ufe0e Cet exercice porte sur les r\u00e9seaux et les protocoles de routage. La figure 1 ci-dessus repr\u00e9sente le sch\u00e9ma d\u2019un r\u00e9seau d\u2019entreprise. Il y figure deux r\u00e9seaux locaux L1 et L2. Ces deux r\u00e9seaux locaux sont interconnect\u00e9s par les routeurs R2, R3, R4 et R5. Le r\u00e9seau local L1 est constitu\u00e9 des PC portables P1 et P2 connect\u00e9s \u00e0 la passerelle R1 par le switch Sw1. Les serveurs S1 et S2 sont connect\u00e9s \u00e0 la passerelle R6 par le switch Sw2. Le tableau 1 suivant indique les adresses IPv4 des machines constituants le r\u00e9seau de l\u2019entreprise. Nom Type Adresse IPv4 R1 routeur (passerelle) Interface 1 : 192.168.1.1/24 Interface 2 : 10.1.1.2/24 R2 routeur Interface 1 : 10.1.1.1/24 Interface 2 : 10.1.2.1/24 Interface 3 : 10.1.3.1/24 R3 routeur Interface 1 : 10.1.2.2/24 Interface 2 : 10.1.4.2/24 Interface 3 : 10.1.5.2/24 R4 routeur Interface 1 : 10.1.5.1/24 Interface 2 : 10.1.6.1/24 R5 routeur (passerelle) Interface 1 : 10.1.3.2/24 Interface 2 : 10.1.4.1/24 Interface 3 : 10.1.6.2/24 Interface 4 : 10.1.7.1/24 R6 routeur (passerelle) Interface 1 : 172.16.0.1/16 Interface 2 : 10.1.7.2/24 P1 ordinateur portable 192.168.1.40/24 P2 ordinateur portable 192.168.1.46/24 S1 serveur 172.16.8.10/16 S2 serveur 172.16.9.12/16 Rappels et notations Rappelons qu\u2019une adresse IP est compos\u00e9e de 4 octets, soit 32 bits. Elle est not\u00e9e X1.X2.X3.X4, o\u00f9 X1, X2, X3 et X4 sont les valeurs des 4 octets. Dans le tableau 1, les valeurs des 4 octets ont \u00e9t\u00e9 converties en notation d\u00e9cimale. La notation X1.X2.X3.X4/n signifie que les n premiers bits de poids forts de l\u2019adresse IP repr\u00e9sentent la partie \u00ab r\u00e9seau \u00bb, les bits suivants de poids faibles repr\u00e9sentent la partie \u00ab machine \u00bb. Toutes les adresses des machines connect\u00e9es \u00e0 un r\u00e9seau local ont la m\u00eame partie r\u00e9seau. L\u2019adresse IP dont tous les bits de la partie \u00ab machine \u00bb sont \u00e0 0 est appel\u00e9e \u00ab adresse du r\u00e9seau \u00bb. L\u2019adresse IP dont tous les bits de la partie \u00ab machine \u00bb sont \u00e0 1 est appel\u00e9e \u00ab adresse de diffusion \u00bb. Question 1 Enonc\u00e9 Solution 1.a Solution 1.b Solution 1.c a. Quelles sont les adresses des r\u00e9seaux locaux L1 et L2 ? b. Donner la plus petite et la plus grande adresse IP valides pouvant \u00eatre attribu\u00e9es \u00e0 un ordinateur portable ou un serveur sur chacun des r\u00e9seaux L1 et L2 sachant que l\u2019adresse du r\u00e9seau et l\u2019adresse de diffusion ne peuvent pas \u00eatre attribu\u00e9es \u00e0 une machine. c. Combien de machines peut-on connecter au maximum \u00e0 chacun des r\u00e9seaux locaux L1 et L2 ? On donne ci-dessous les valeurs de quelques puissances de 2 ? \\(2^6\\) \\(2^7\\) \\(2^8\\) \\(2^9\\) \\(2^{10}\\) \\(2^{11}\\) \\(2^{12}\\) \\(2^{13}\\) \\(2^{14}\\) \\(2^{15}\\) \\(2^{16}\\) \\(2^{17}\\) 64 128 256 512 1024 2048 4096 8192 16384 32768 65536 131072 L1 : 192.168.1.0/24 L2 : 172.16.0.0/16 r\u00e9seau L1 : plus \u201cpetite : 192.168.1.1 ; plus \u201cgrande\u201d : 192.168.1.254 r\u00e9seau L2 : plus \u201cpetite\u201d : 172.16.0.1 ; plus \u201cgrande\u201d : 172.16.255.254 r\u00e9seau L1 : 256 - 2 = 254 adresses r\u00e9seau L2 : \\(256^2 - 2 = 2^{16} - 2 = 65534\\) adresses Question 2 Enonc\u00e9 Solution 2.a Solution 2.b Solution 3.c a. Expliquer l\u2019utilit\u00e9 d\u2019avoir plusieurs chemins possibles reliant les r\u00e9seaux L1 et L2. b. Quel est le chemin le plus court en nombre de sauts pour relier R1 et R6 ? Donner le nombre de sauts de ce chemin et pr\u00e9ciser les routeurs utilis\u00e9s. c. La bande passante d\u2019une liaison Ether (quantit\u00e9 d\u2019information qui peut \u00eatre transmise en bits/s) est de 107 bits/s et celle d\u2019une liaison FastEther est de 108 bits/s. Le co\u00fbt d\u2019une liaison est d\u00e9fini par 10\u0b3c \u2044d, o\u00f9 d est sa bande passante en bits/s. Liaison R1-R2 R2-R5 R5-R6 R2-R3 R3-R4 R4-R5 R3-R5 Type Ether Ether Ether FastEther FastEther FastEther Ether Quel est le chemin reliant R1 et R6 qui a le plus petit co\u00fbt ? Donner le co\u00fbt de ce chemin et pr\u00e9ciser les routeurs utilis\u00e9s. Il est utile d\u2019avoir plusieurs chemins possibles en cas de panne (routeur ou connexion entre routeurs) ou encore en cas de trafic r\u00e9seau trop important au niveau d\u2019un routeur. Pour relier R1 \u00e0 R6 il est possible d\u2019effectuer seulement 2 sauts : R1 -> R2 -> R5 -> R6 Liaison R1-R2 R2-R5 R5-R6 R2-R3 R3-R4 R4-R5 R3-R5 co\u00fbt 10 10 10 1 1 1 10 Le chemin reliant R1 \u00e0 R6 ayant le plus petit co\u00fbt est R1 -> R2 -> R3 -> R4 -> R5 -> R6 avec un co\u00fbt de : 10 (R1-R2) + 1 (R2-R3) + 1 (R3-R4) + 1 (R4-R5) + 10 (R5-R6) = 23 Question 3 Enonc\u00e9 Solution 3 Dans l\u2019annexe A figurent les tables de routages des routeurs R1, R2, R5 et R6 au d\u00e9marrage du r\u00e9seau. Indiquer sur votre copie ce qui doit figurer dans les lignes laiss\u00e9es vides des tables de routage des routeurs R5 et R6 pour que les \u00e9changes entre les ordinateurs des r\u00e9seaux L1 et L2 se fassent en empruntant le chemin le plus court en nombre de sauts. Il est utile d\u2019avoir plusieurs chemins possibles en cas de panne (routeur ou connexion entre routeurs) ou encore en cas de trafic r\u00e9seau trop important au niveau d\u2019un routeur. Annexe","title":"TD19 Routage Correction"},{"location":"Reseaux/TD19_Routage_Correction/#resume-des-episodes-precedents","text":"","title":"R\u00e9sum\u00e9 des \u00e9pisodes pr\u00e9c\u00e9dents"},{"location":"Reseaux/TD19_Routage_Correction/#le-protocole-rip","text":"RIP Le Routing Information Protocol est bas\u00e9 sur l'\u00e9change (toutes les 30 secondes) des tables de routage de chaque routeur. Au d\u00e9but, chaque routeur ne conna\u00eet que les r\u00e9seaux auquel il est directement connect\u00e9, associ\u00e9 \u00e0 la distance 1. Ensuite, chaque routeur re\u00e7oit p\u00e9riodiquement la table des r\u00e9seaux auquel il est connect\u00e9 : s'il d\u00e9couvre une route vers un nouveau r\u00e9seau inconnu, il l'ajoute \u00e0 sa table en augmentant de 1 la distance annonc\u00e9e par le routeur qui lui a transmis sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus courte (en rajoutant 1) que celle qu'il poss\u00e8de dans sa table, il actualise sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus longue que celle qu'il poss\u00e8de dans sa table, il ignore cette route. s'il re\u00e7oit une route vers un r\u00e9seau connu en provenance d'un routeur d\u00e9j\u00e0 existant dans sa table, s'il met \u00e0 jour sa table car la topologie du r\u00e9seau a \u00e9t\u00e9 modifi\u00e9e. si le r\u00e9seau n'\u00e9volue pas (panne ou ajout de nouveau mat\u00e9riel), les tables de routage convergent vers une valeur stable. Elles n'\u00e9voluent plus. si un routeur ne re\u00e7oit pas pendant 3 minutes d'information de la part d'un routeur qui lui avait auparavant communiqu\u00e9 sa table de routage, ce routeur est consid\u00e9r\u00e9 comme en panne, et toutes les routes passant par lui sont affect\u00e9es de la distance infinie : 16. Remarques et incov\u00e9nients: Le protocole RIP n'admet qu'une distance maximale \u00e9gale \u00e0 15 (ceci explique que 16 soit consid\u00e9r\u00e9 comme la distance infinie), ce qui le limite aux r\u00e9seaux de petite taille. Chaque routeur n'a jamais connaissance de la topologie du r\u00e9seau tout entier : il ne le conna\u00eet que par ce que les autres routeurs lui ont racont\u00e9. On dit que ce protocole de routage est du routing by rumor . La m\u00e9trique utilis\u00e9e (le nombre de sauts) ne tient pas compte de la qualit\u00e9 de la liaison, contrairement au protocole OSPF.","title":"Le protocole RIP"},{"location":"Reseaux/TD19_Routage_Correction/#le-protocole-ospf","text":"OSPF OSPF : Open Shortest Path First Un inconv\u00e9nient majeur du protocole RIP pr\u00e9c\u00e9dent est la non-prise en compte de la bande passante reliant les routeurs. En voiture, le chemin le plus rapide n'est pas forc\u00e9ment le plus court. En gris, le chemin RIP. En bleu, l'OSPF. Dans le protocole OSPF, les tables de routage vont prendre en consid\u00e9ration la vitesse de communication entre les routeurs. Dans une premi\u00e8re phase d'initialisation, chaque routeur va acqu\u00e9rir (par succession de messages envoy\u00e9s et re\u00e7us) la connaissance totale du r\u00e9seau (diff\u00e9rence fondamentale avec RIP) et de la qualit\u00e9 technique de la liaison entre chaque routeur.","title":"Le protocole OSPF"},{"location":"Reseaux/TD19_Routage_Correction/#exercices-bac","text":"","title":"Exercices BAC"},{"location":"Reseaux/TD19_Routage_Correction/#sujet-n3","text":"Cet exercice porte sur les r\u00e9seaux et les protocoles de routage. La figure 1 ci-dessus repr\u00e9sente le sch\u00e9ma d\u2019un r\u00e9seau d\u2019entreprise. Il y figure deux r\u00e9seaux locaux L1 et L2. Ces deux r\u00e9seaux locaux sont interconnect\u00e9s par les routeurs R2, R3, R4 et R5. Le r\u00e9seau local L1 est constitu\u00e9 des PC portables P1 et P2 connect\u00e9s \u00e0 la passerelle R1 par le switch Sw1. Les serveurs S1 et S2 sont connect\u00e9s \u00e0 la passerelle R6 par le switch Sw2. Le tableau 1 suivant indique les adresses IPv4 des machines constituants le r\u00e9seau de l\u2019entreprise. Nom Type Adresse IPv4 R1 routeur (passerelle) Interface 1 : 192.168.1.1/24 Interface 2 : 10.1.1.2/24 R2 routeur Interface 1 : 10.1.1.1/24 Interface 2 : 10.1.2.1/24 Interface 3 : 10.1.3.1/24 R3 routeur Interface 1 : 10.1.2.2/24 Interface 2 : 10.1.4.2/24 Interface 3 : 10.1.5.2/24 R4 routeur Interface 1 : 10.1.5.1/24 Interface 2 : 10.1.6.1/24 R5 routeur (passerelle) Interface 1 : 10.1.3.2/24 Interface 2 : 10.1.4.1/24 Interface 3 : 10.1.6.2/24 Interface 4 : 10.1.7.1/24 R6 routeur (passerelle) Interface 1 : 172.16.0.1/16 Interface 2 : 10.1.7.2/24 P1 ordinateur portable 192.168.1.40/24 P2 ordinateur portable 192.168.1.46/24 S1 serveur 172.16.8.10/16 S2 serveur 172.16.9.12/16 Rappels et notations Rappelons qu\u2019une adresse IP est compos\u00e9e de 4 octets, soit 32 bits. Elle est not\u00e9e X1.X2.X3.X4, o\u00f9 X1, X2, X3 et X4 sont les valeurs des 4 octets. Dans le tableau 1, les valeurs des 4 octets ont \u00e9t\u00e9 converties en notation d\u00e9cimale. La notation X1.X2.X3.X4/n signifie que les n premiers bits de poids forts de l\u2019adresse IP repr\u00e9sentent la partie \u00ab r\u00e9seau \u00bb, les bits suivants de poids faibles repr\u00e9sentent la partie \u00ab machine \u00bb. Toutes les adresses des machines connect\u00e9es \u00e0 un r\u00e9seau local ont la m\u00eame partie r\u00e9seau. L\u2019adresse IP dont tous les bits de la partie \u00ab machine \u00bb sont \u00e0 0 est appel\u00e9e \u00ab adresse du r\u00e9seau \u00bb. L\u2019adresse IP dont tous les bits de la partie \u00ab machine \u00bb sont \u00e0 1 est appel\u00e9e \u00ab adresse de diffusion \u00bb. Question 1 Enonc\u00e9 Solution 1.a Solution 1.b Solution 1.c a. Quelles sont les adresses des r\u00e9seaux locaux L1 et L2 ? b. Donner la plus petite et la plus grande adresse IP valides pouvant \u00eatre attribu\u00e9es \u00e0 un ordinateur portable ou un serveur sur chacun des r\u00e9seaux L1 et L2 sachant que l\u2019adresse du r\u00e9seau et l\u2019adresse de diffusion ne peuvent pas \u00eatre attribu\u00e9es \u00e0 une machine. c. Combien de machines peut-on connecter au maximum \u00e0 chacun des r\u00e9seaux locaux L1 et L2 ? On donne ci-dessous les valeurs de quelques puissances de 2 ? \\(2^6\\) \\(2^7\\) \\(2^8\\) \\(2^9\\) \\(2^{10}\\) \\(2^{11}\\) \\(2^{12}\\) \\(2^{13}\\) \\(2^{14}\\) \\(2^{15}\\) \\(2^{16}\\) \\(2^{17}\\) 64 128 256 512 1024 2048 4096 8192 16384 32768 65536 131072 L1 : 192.168.1.0/24 L2 : 172.16.0.0/16 r\u00e9seau L1 : plus \u201cpetite : 192.168.1.1 ; plus \u201cgrande\u201d : 192.168.1.254 r\u00e9seau L2 : plus \u201cpetite\u201d : 172.16.0.1 ; plus \u201cgrande\u201d : 172.16.255.254 r\u00e9seau L1 : 256 - 2 = 254 adresses r\u00e9seau L2 : \\(256^2 - 2 = 2^{16} - 2 = 65534\\) adresses Question 2 Enonc\u00e9 Solution 2.a Solution 2.b Solution 3.c a. Expliquer l\u2019utilit\u00e9 d\u2019avoir plusieurs chemins possibles reliant les r\u00e9seaux L1 et L2. b. Quel est le chemin le plus court en nombre de sauts pour relier R1 et R6 ? Donner le nombre de sauts de ce chemin et pr\u00e9ciser les routeurs utilis\u00e9s. c. La bande passante d\u2019une liaison Ether (quantit\u00e9 d\u2019information qui peut \u00eatre transmise en bits/s) est de 107 bits/s et celle d\u2019une liaison FastEther est de 108 bits/s. Le co\u00fbt d\u2019une liaison est d\u00e9fini par 10\u0b3c \u2044d, o\u00f9 d est sa bande passante en bits/s. Liaison R1-R2 R2-R5 R5-R6 R2-R3 R3-R4 R4-R5 R3-R5 Type Ether Ether Ether FastEther FastEther FastEther Ether Quel est le chemin reliant R1 et R6 qui a le plus petit co\u00fbt ? Donner le co\u00fbt de ce chemin et pr\u00e9ciser les routeurs utilis\u00e9s. Il est utile d\u2019avoir plusieurs chemins possibles en cas de panne (routeur ou connexion entre routeurs) ou encore en cas de trafic r\u00e9seau trop important au niveau d\u2019un routeur. Pour relier R1 \u00e0 R6 il est possible d\u2019effectuer seulement 2 sauts : R1 -> R2 -> R5 -> R6 Liaison R1-R2 R2-R5 R5-R6 R2-R3 R3-R4 R4-R5 R3-R5 co\u00fbt 10 10 10 1 1 1 10 Le chemin reliant R1 \u00e0 R6 ayant le plus petit co\u00fbt est R1 -> R2 -> R3 -> R4 -> R5 -> R6 avec un co\u00fbt de : 10 (R1-R2) + 1 (R2-R3) + 1 (R3-R4) + 1 (R4-R5) + 10 (R5-R6) = 23 Question 3 Enonc\u00e9 Solution 3 Dans l\u2019annexe A figurent les tables de routages des routeurs R1, R2, R5 et R6 au d\u00e9marrage du r\u00e9seau. Indiquer sur votre copie ce qui doit figurer dans les lignes laiss\u00e9es vides des tables de routage des routeurs R5 et R6 pour que les \u00e9changes entre les ordinateurs des r\u00e9seaux L1 et L2 se fassent en empruntant le chemin le plus court en nombre de sauts. Il est utile d\u2019avoir plusieurs chemins possibles en cas de panne (routeur ou connexion entre routeurs) ou encore en cas de trafic r\u00e9seau trop important au niveau d\u2019un routeur. Annexe","title":"Sujet n\u00b03"},{"location":"Reseaux/TD19_Routage_Diapo/","text":":root { --color-background: #101010 !important; --color-foreground: #FFFFFF !important; font-size: 1.25rem; } blockquote { background: #C3B091; border-left: 15px solid #CC0000; margin: 1.5em 10px; color: black; padding: 0.5em 10px; } TD n\u00b019 : Protocoles de routage \u2693\ufe0e Programme officiel \u2693\ufe0e I. R\u00e9sum\u00e9 des \u00e9pisodes pr\u00e9c\u00e9dents \u2693\ufe0e \u23e9 Notion d'adressage \u2693\ufe0e Deux types d'adresses existent : Adresse MAC Une adresse mat\u00e9rielle, ou adresse MAC , parfois nomm\u00e9e adresse physique, est un identifiant physique stock\u00e9 dans une carte r\u00e9seau ou une interface r\u00e9seau similaire (Wifi par exemple). \u00c0 moins qu\u2019elle n\u2019ait \u00e9t\u00e9 modifi\u00e9e par l\u2019utilisateur, elle est unique au monde. Elle constitue la couche inf\u00e9rieure de la couche de liaison, c'est-\u00e0-dire la couche deux du mod\u00e8le OSI. Elle est constitu\u00e9e de six octets, il existe donc potentiellement \\(2^{48}\\) (environ 281 000 milliards) d'adresses MAC possibles. Adresse IP Une adresse IP (Internet Protocol) est un num\u00e9ro d'identification qui est attribu\u00e9 de fa\u00e7on permanente ou provisoire \u00e0 chaque p\u00e9riph\u00e9rique reli\u00e9 \u00e0 un r\u00e9seau informatique qui utilise l'Internet Protocol. L'adresse IP est \u00e0 la base du syst\u00e8me d'acheminement (le routage) des paquets de donn\u00e9es sur Internet. Notions essentielles : Lorsqu'une machine A, d'adresse IP_A veut discuter avec une machine B, d'adresse IP_B : La machine A calcule (gr\u00e2ce au masque de sous-r\u00e9seau) si B est dans le m\u00eame sous-r\u00e9seau qu'elle, ou pas. Si oui, elle peut donc conna\u00eetre l'adresse MAC de la carte r\u00e9seau de la machine B (soit elle la poss\u00e8de d\u00e9j\u00e0 dans sa table ARP, soit elle la demande en envoyant un message de broadcast \u00e0 tout le sous-r\u00e9seau : \u00abqui poss\u00e8de cette adresse IP_B ?\u00bb). Elle envoie donc dans le sous-r\u00e9seau une trame ayant pour ent\u00eate l'adresse MAC de B : le switch lit cette trame, sait sur quel port est branch\u00e9 la machine B et lui envoie sp\u00e9cifiquement donc le message. Si B n'est pas dans le m\u00eame sous-r\u00e9seau que A, A mettra en ent\u00eate de sa trame l'adresse MAC de la carte r\u00e9seau du routeur, qui joue le r\u00f4le de passerelle. Le routeur va ouvrir la trame et va observer l'IP_B, \u00e0 qui il doit remettre ce message. C'est maintenant que vont intervenir les protocoles de routage : est-ce que B est dans le m\u00eame sous-r\u00e9seau que le routeur ? est-ce que B est dans un autre sous-r\u00e9seau connu du routeur ? est-ce que B est totalement inconnu du routeur ? Ces questions trouveront des r\u00e9ponses gr\u00e2ce \u00e0 table de routage du routeur. II. Tables de routage \u2693\ufe0e Les tables de routage sont des informations stock\u00e9es dans le routeur permettant d'aiguiller intelligemment les donn\u00e9es qui lui sont transmises. Dans le r\u00e9seau ci-dessus, si l'ordinateur d'adresse 192.168.0.5 veut interroger le serveur 10.7.3.8 : l'adresse 10.7.3.8 n'\u00e9tant pas dans le sous-r\u00e9seau F (d'adresse 192.168.0.0 / 24 ), la requ\u00eate est confi\u00e9e au routeur via son adresse passerelle dans le r\u00e9seau F (ici 192.168.0.254 ). le routeur observe si l'IP recherch\u00e9e appartient \u00e0 un autre des sous-r\u00e9seaux auquel il est connect\u00e9. Ici, l'IP recherch\u00e9e 10.7.3.8 n'appartient ni au sous-r\u00e9seau A ou E. le routeur va donc regarder dans sa table de routage l'adresse passerelle d'un autre routeur vers qui elle doit rediriger les donn\u00e9es. Si le sous-r\u00e9seau C fait partie de sa table de routage, le routeur R1 saura alors que le meilleur chemin est (par exemple) de confier les donn\u00e9es au routeur R3. si le sous-r\u00e9seau C ne fait pas partie de la table de routage, le routeur R1 va alors le rediriger vers une route \u00abpar d\u00e9faut\u00bb (que l'on peut assimiler au panneau \u00abtoutes directions\u00bb sur les panneaux de signalisation). Par exemple, la table de routage du routeur R1 pourrait \u00eatre : Destination Passerelle 192.168.0.0 /24 192.168.0.254 172.17.1.0 /24 172.17.1.254 10.0.5.0 /24 10.0.5.152 10.5.2.0 /24 172.17.1.254 10.7.3.0 /24 10.0.5.135 \u23e9 Comment sont construites les tables de routage ? \u2693\ufe0e Soit \u00e0 la main par l'administrateur r\u00e9seau, quand le r\u00e9seau est petit : on parle alors de table statique . Soit de mani\u00e8re dynamique : les r\u00e9seaux s'envoient eux-m\u00eames des informations permettant de mettre \u00e0 jour leurs tables de routages respectives. Des algorithmes de d\u00e9termination de meilleur chemin sont alors utilis\u00e9s : nous allons en d\u00e9couvrir deux, le protocole RIP et le protocole OSPF. III. Le protocole RIP \u2693\ufe0e A connaitre RIP Le Routing Information Protocol est bas\u00e9 sur l'\u00e9change (toutes les 30 secondes) des tables de routage de chaque routeur. Au d\u00e9but, chaque routeur ne conna\u00eet que les r\u00e9seaux auquel il est directement connect\u00e9, associ\u00e9 \u00e0 la distance 1. Ensuite, chaque routeur re\u00e7oit p\u00e9riodiquement la table des r\u00e9seaux auquel il est connect\u00e9 : s'il d\u00e9couvre une route vers un nouveau r\u00e9seau inconnu, il l'ajoute \u00e0 sa table en augmentant de 1 la distance annonc\u00e9e par le routeur qui lui a transmis sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus courte (en rajoutant 1) que celle qu'il poss\u00e8de dans sa table, il actualise sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus longue que celle qu'il poss\u00e8de dans sa table, il ignore cette route. s'il re\u00e7oit une route vers un r\u00e9seau connu en provenance d'un routeur d\u00e9j\u00e0 existant dans sa table, s'il met \u00e0 jour sa table car la topologie du r\u00e9seau a \u00e9t\u00e9 modifi\u00e9e. si le r\u00e9seau n'\u00e9volue pas (panne ou ajout de nouveau mat\u00e9riel), les tables de routage convergent vers une valeur stable. Elles n'\u00e9voluent plus. si un routeur ne re\u00e7oit pas pendant 3 minutes d'information de la part d'un routeur qui lui avait auparavant communiqu\u00e9 sa table de routage, ce routeur est consid\u00e9r\u00e9 comme en panne, et toutes les routes passant par lui sont affect\u00e9es de la distance infinie : 16. Remarques et incov\u00e9nients: Le protocole RIP n'admet qu'une distance maximale \u00e9gale \u00e0 15 (ceci explique que 16 soit consid\u00e9r\u00e9 comme la distance infinie), ce qui le limite aux r\u00e9seaux de petite taille. Chaque routeur n'a jamais connaissance de la topologie du r\u00e9seau tout entier : il ne le conna\u00eet que par ce que les autres routeurs lui ont racont\u00e9. On dit que ce protocole de routage est du routing by rumor . La m\u00e9trique utilis\u00e9e (le nombre de sauts) ne tient pas compte de la qualit\u00e9 de la liaison, contrairement au protocole OSPF. IV. Le protocole OSPF \u2693\ufe0e OSPF OSPF : Open Shortest Path First Un inconv\u00e9nient majeur du protocole RIP pr\u00e9c\u00e9dent est la non-prise en compte de la bande passante reliant les routeurs. En voiture, le chemin le plus rapide n'est pas forc\u00e9ment le plus court. { En gris, le chemin RIP. En bleu, l'OSPF. Dans le protocole OSPF, les tables de routage vont prendre en consid\u00e9ration la vitesse de communication entre les routeurs. Dans une premi\u00e8re phase d'initialisation, chaque routeur va acqu\u00e9rir (par succession de messages envoy\u00e9s et re\u00e7us) la connaissance totale du r\u00e9seau (diff\u00e9rence fondamentale avec RIP) et de la qualit\u00e9 technique de la liaison entre chaque routeur. \u23e9 Les diff\u00e9rents types de liaison et leur co\u00fbt \u2693\ufe0e On peut, approximativement, classer les types de liaison suivant ce tableau de d\u00e9bits th\u00e9oriques : Technologie BP descendante BP montante Modem 56 kbit/s 48 kbit/s Bluetooth 3 Mbit/s 3 Mbit/s Ethernet 10 Mbit/s 10 Mbit/s Wi-Fi 10 Mbit/s ~ 10 Gbits/s 10 Mbit/s ~ 10 Gbits/s ADSL 13 Mbit/s 1 Mbit/s 4G 100 Mbit/s 50 Mbit/s Satellite 50 Mbit/s 1 Mbit/s Fast Ethernet 100 Mbit/s 100 Mbit/s FFTH (fibre) 10 Gbit/s 10 Gbit/s 5G 20 Gbit/s 10 Gbit/s L'id\u00e9e du protocole OSPF est de pond\u00e9rer chaque trajet entre routeurs (comptant simplement pour \u00ab1\u00bb dans le protocole RIP) par une valeur de co\u00fbt inversement proportionnelle au d\u00e9bit de transfert. Par exemple, si le d\u00e9bit d est exprim\u00e9 en bits/s, on peut calculer le co\u00fbt de chaque liaison par la formule : A connaitre \\(\\text{co\u00fbt} = \\dfrac{10^8}{d}\\) Cette formule de calcul peut \u00eatre diff\u00e9rente suivant les exercices, et sera normalement redonn\u00e9e. N\u00e9anmoins la valeur d sera toujours au d\u00e9nominateur, pour assurer la proportionnalit\u00e9 inverse du d\u00e9bit. Avec cette convention, un route entre deux routeurs reli\u00e9s en Fast Ethernet (100 Mbits/s) aura a un poids de 1, une liaison satellite de 20 Mbits/s aura un poids de 5, etc. \u23e9 Exemple \u2693\ufe0e Reprenons le r\u00e9seau suivant : et simplifions-le en ne gardant que les liens entre routeurs, en indiquant leur d\u00e9bit : Notre r\u00e9seau est devenu un graphe . Nous allons pond\u00e9rer ses ar\u00eates avec la fonction co\u00fbt introduite pr\u00e9c\u00e9demment. L'unit\u00e9 \u00e9tant le Mbit/s, l'ar\u00eate entre R1 et R3 aura un poids de 100/20=5. Le graphe pond\u00e9r\u00e9 est donc : Le chemin le plus rapide pour aller de l'ordinateur au serveur est donc R1-R2-R4, et non plus R1-R3 comme l'aurait indiqu\u00e9 le protocole RIP. \u23e9 Trouver le plus court chemin dans un graphe pond\u00e9r\u00e9 \u2693\ufe0e L'exemple pr\u00e9c\u00e9dent \u00e9tait tr\u00e8s simple et de solution intuitive. Dans le cas d'un graphe pond\u00e9r\u00e9 complexe, existe-t-il un algorithme de d\u00e9termination du plus court chemin d'un point \u00e0 un autre ? La r\u00e9ponse est oui , depuis la d\u00e9couverte en 1959 par Edsger Dijkstra de l'algorithme qui porte son nom, l'algorithme de Dijkstra . Pour le comprendre, vous pouvez regarder la vid\u00e9o d'un c\u00e9l\u00e8bre YouTuber : video youtube Cet algorithme, ici ex\u00e9cut\u00e9 de mani\u00e8re manuelle, est bien s\u00fbr programmable. Et c'est donc gr\u00e2ce \u00e0 lui que chaque routeur calcule la route la plus rapide pour acheminer les donn\u00e9es qu'il re\u00e7oit. Exemple d'application de l'algorithme de Dijkstra : Donner le plus court chemin pour aller de A \u00e0 H.","title":"TD19 Routage Diapo"},{"location":"Reseaux/TD19_Routage_Diapo/#td-n19-protocoles-de-routage","text":"","title":"TD n\u00b019 : Protocoles de routage"},{"location":"Reseaux/TD19_Routage_Diapo/#i-resume-des-episodes-precedents","text":"","title":"I. R\u00e9sum\u00e9 des \u00e9pisodes pr\u00e9c\u00e9dents"},{"location":"Reseaux/TD19_Routage_Diapo/#ii-tables-de-routage","text":"Les tables de routage sont des informations stock\u00e9es dans le routeur permettant d'aiguiller intelligemment les donn\u00e9es qui lui sont transmises. Dans le r\u00e9seau ci-dessus, si l'ordinateur d'adresse 192.168.0.5 veut interroger le serveur 10.7.3.8 : l'adresse 10.7.3.8 n'\u00e9tant pas dans le sous-r\u00e9seau F (d'adresse 192.168.0.0 / 24 ), la requ\u00eate est confi\u00e9e au routeur via son adresse passerelle dans le r\u00e9seau F (ici 192.168.0.254 ). le routeur observe si l'IP recherch\u00e9e appartient \u00e0 un autre des sous-r\u00e9seaux auquel il est connect\u00e9. Ici, l'IP recherch\u00e9e 10.7.3.8 n'appartient ni au sous-r\u00e9seau A ou E. le routeur va donc regarder dans sa table de routage l'adresse passerelle d'un autre routeur vers qui elle doit rediriger les donn\u00e9es. Si le sous-r\u00e9seau C fait partie de sa table de routage, le routeur R1 saura alors que le meilleur chemin est (par exemple) de confier les donn\u00e9es au routeur R3. si le sous-r\u00e9seau C ne fait pas partie de la table de routage, le routeur R1 va alors le rediriger vers une route \u00abpar d\u00e9faut\u00bb (que l'on peut assimiler au panneau \u00abtoutes directions\u00bb sur les panneaux de signalisation). Par exemple, la table de routage du routeur R1 pourrait \u00eatre : Destination Passerelle 192.168.0.0 /24 192.168.0.254 172.17.1.0 /24 172.17.1.254 10.0.5.0 /24 10.0.5.152 10.5.2.0 /24 172.17.1.254 10.7.3.0 /24 10.0.5.135","title":"II. Tables de routage"},{"location":"Reseaux/TD19_Routage_Diapo/#iii-le-protocole-rip","text":"A connaitre RIP Le Routing Information Protocol est bas\u00e9 sur l'\u00e9change (toutes les 30 secondes) des tables de routage de chaque routeur. Au d\u00e9but, chaque routeur ne conna\u00eet que les r\u00e9seaux auquel il est directement connect\u00e9, associ\u00e9 \u00e0 la distance 1. Ensuite, chaque routeur re\u00e7oit p\u00e9riodiquement la table des r\u00e9seaux auquel il est connect\u00e9 : s'il d\u00e9couvre une route vers un nouveau r\u00e9seau inconnu, il l'ajoute \u00e0 sa table en augmentant de 1 la distance annonc\u00e9e par le routeur qui lui a transmis sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus courte (en rajoutant 1) que celle qu'il poss\u00e8de dans sa table, il actualise sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus longue que celle qu'il poss\u00e8de dans sa table, il ignore cette route. s'il re\u00e7oit une route vers un r\u00e9seau connu en provenance d'un routeur d\u00e9j\u00e0 existant dans sa table, s'il met \u00e0 jour sa table car la topologie du r\u00e9seau a \u00e9t\u00e9 modifi\u00e9e. si le r\u00e9seau n'\u00e9volue pas (panne ou ajout de nouveau mat\u00e9riel), les tables de routage convergent vers une valeur stable. Elles n'\u00e9voluent plus. si un routeur ne re\u00e7oit pas pendant 3 minutes d'information de la part d'un routeur qui lui avait auparavant communiqu\u00e9 sa table de routage, ce routeur est consid\u00e9r\u00e9 comme en panne, et toutes les routes passant par lui sont affect\u00e9es de la distance infinie : 16. Remarques et incov\u00e9nients: Le protocole RIP n'admet qu'une distance maximale \u00e9gale \u00e0 15 (ceci explique que 16 soit consid\u00e9r\u00e9 comme la distance infinie), ce qui le limite aux r\u00e9seaux de petite taille. Chaque routeur n'a jamais connaissance de la topologie du r\u00e9seau tout entier : il ne le conna\u00eet que par ce que les autres routeurs lui ont racont\u00e9. On dit que ce protocole de routage est du routing by rumor . La m\u00e9trique utilis\u00e9e (le nombre de sauts) ne tient pas compte de la qualit\u00e9 de la liaison, contrairement au protocole OSPF.","title":"III. Le protocole RIP"},{"location":"Reseaux/TD19_Routage_Diapo/#iv-le-protocole-ospf","text":"OSPF OSPF : Open Shortest Path First Un inconv\u00e9nient majeur du protocole RIP pr\u00e9c\u00e9dent est la non-prise en compte de la bande passante reliant les routeurs. En voiture, le chemin le plus rapide n'est pas forc\u00e9ment le plus court. { En gris, le chemin RIP. En bleu, l'OSPF. Dans le protocole OSPF, les tables de routage vont prendre en consid\u00e9ration la vitesse de communication entre les routeurs. Dans une premi\u00e8re phase d'initialisation, chaque routeur va acqu\u00e9rir (par succession de messages envoy\u00e9s et re\u00e7us) la connaissance totale du r\u00e9seau (diff\u00e9rence fondamentale avec RIP) et de la qualit\u00e9 technique de la liaison entre chaque routeur.","title":"IV. Le protocole OSPF"},{"location":"Reseaux/cours/","text":"Protocoles de routage \u2693\ufe0e 0. R\u00e9sum\u00e9 des \u00e9pisodes pr\u00e9c\u00e9dents \u2693\ufe0e cours de 1\u00e8re sur l'architecture d'un r\u00e9seau cours de 1\u00e8re sur les diff\u00e9rents protocoles de communication dans un r\u00e9seau. Notions essentielles : Lorsqu'une machine A, d'adresse IP_A veut discuter avec une machine B, d'adresse IP_B : La machine A calcule (gr\u00e2ce au masque de sous-r\u00e9seau) si B est dans le m\u00eame sous-r\u00e9seau qu'elle, ou pas. Si oui, elle peut donc conna\u00eetre l'adresse MAC de la carte r\u00e9seau de la machine B (soit elle la poss\u00e8de d\u00e9j\u00e0 dans sa table ARP, soit elle la demande en envoyant un message de broadcast \u00e0 tout le sous-r\u00e9seau : \u00abqui poss\u00e8de cette adresse IP_B ?\u00bb). Elle envoie donc dans le sous-r\u00e9seau une trame ayant pour ent\u00eate l'adresse MAC de B : le switch lit cette trame, sait sur quel port est branch\u00e9 la machine B et lui envoie sp\u00e9cifiquement donc le message. Si B n'est pas dans le m\u00eame sous-r\u00e9seau que A, A mettra en ent\u00eate de sa trame l'adresse MAC de la carte r\u00e9seau du routeur, qui joue le r\u00f4le de passerelle. Le routeur va ouvrir la trame et va observer l'IP_B, \u00e0 qui il doit remettre ce message. C'est maintenant que vont intervenir les protocoles de routage : est-ce que B est dans le m\u00eame sous-r\u00e9seau que le routeur ? est-ce que B est dans un autre sous-r\u00e9seau connu du routeur ? est-ce que B est totalement inconnu du routeur ? Ces questions trouveront des r\u00e9ponses gr\u00e2ce \u00e0 table de routage du routeur. 1. Tables de routage \u2693\ufe0e Les tables de routage sont des informations stock\u00e9es dans le routeur permettant d'aiguiller intelligemment les donn\u00e9es qui lui sont transmises. Dans le r\u00e9seau ci-dessus, si l'ordinateur d'adresse 192.168.0.5 veut interroger le serveur 10.7.3.8 : l'adresse 10.7.3.8 n'\u00e9tant pas dans le sous-r\u00e9seau F (d'adresse 192.168.0.0 / 24 ), la requ\u00eate est confi\u00e9e au routeur via son adresse passerelle dans le r\u00e9seau F (ici 192.168.0.254 ). le routeur observe si l'IP recherch\u00e9e appartient \u00e0 un autre des sous-r\u00e9seaux auquel il est connect\u00e9. Ici, l'IP recherch\u00e9e 10.7.3.8 n'appartient ni au sous-r\u00e9seau A ou E. le routeur va donc regarder dans sa table de routage l'adresse passerelle d'un autre routeur vers qui elle doit rediriger les donn\u00e9es. Si le sous-r\u00e9seau C fait partie de sa table de routage, le routeur R1 saura alors que le meilleur chemin est (par exemple) de confier les donn\u00e9es au routeur R3. si le sous-r\u00e9seau C ne fait pas partie de la table de routage, le routeur R1 va alors le rediriger vers une route \u00abpar d\u00e9faut\u00bb (que l'on peut assimiler au panneau \u00abtoutes directions\u00bb sur les panneaux de signalisation). Par exemple, la table de routage du routeur R1 pourrait \u00eatre : Destination Passerelle 192.168.0.0 /24 192.168.0.254 172.17.1.0 /24 172.17.1.254 10.0.5.0 /24 10.0.5.152 10.5.2.0 /24 172.17.1.254 10.7.3.0 /24 10.0.5.135 Comment sont construites les tables de routage ? \u2693\ufe0e Soit \u00e0 la main par l'administrateur r\u00e9seau, quand le r\u00e9seau est petit : on parle alors de table statique . Soit de mani\u00e8re dynamique : les r\u00e9seaux s'envoient eux-m\u00eames des informations permettant de mettre \u00e0 jour leurs tables de routages respectives. Des algorithmes de d\u00e9termination de meilleur chemin sont alors utilis\u00e9s : nous allons en d\u00e9couvrir deux, le protocole RIP et le protocole OSPF. 2. Le protocole RIP \u2693\ufe0e voir le TP d\u00e9branch\u00e9 : le jeu dont vous \u00eates le routeur Le Routing Information Protocol est bas\u00e9 sur l'\u00e9change (toutes les 30 secondes) des tables de routage de chaque routeur. Au d\u00e9but, chaque routeur ne conna\u00eet que les r\u00e9seaux auquel il est directement connect\u00e9, associ\u00e9 \u00e0 la distance 1. Ensuite, chaque routeur re\u00e7oit p\u00e9riodiquement la table des r\u00e9seaux auquel il est connect\u00e9 : s'il d\u00e9couvre une route vers un nouveau r\u00e9seau inconnu, il l'ajoute \u00e0 sa table en augmentant de 1 la distance annonc\u00e9e par le routeur qui lui a transmis sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus courte (en rajoutant 1) que celle qu'il poss\u00e8de dans sa table, il actualise sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus longue que celle qu'il poss\u00e8de dans sa table, il ignore cette route. s'il re\u00e7oit une route vers un r\u00e9seau connu en provenance d'un routeur d\u00e9j\u00e0 existant dans sa table, s'il met \u00e0 jour sa table car la topologie du r\u00e9seau a \u00e9t\u00e9 modifi\u00e9e. si le r\u00e9seau n'\u00e9volue pas (panne ou ajout de nouveau mat\u00e9riel), les tables de routage convergent vers une valeur stable. Elles n'\u00e9voluent plus. si un routeur ne re\u00e7oit pas pendant 3 minutes d'information de la part d'un routeur qui lui avait auparavant communiqu\u00e9 sa table de routage, ce routeur est consid\u00e9r\u00e9 comme en panne, et toutes les routes passant par lui sont affect\u00e9es de la distance infinie : 16. Remarques et incov\u00e9nients: - Le protocole RIP n'admet qu'une distance maximale \u00e9gale \u00e0 15 (ceci explique que 16 soit consid\u00e9r\u00e9 comme la distance infinie), ce qui le limite aux r\u00e9seaux de petite taille. Chaque routeur n'a jamais connaissance de la topologie du r\u00e9seau tout entier : il ne le conna\u00eet que par ce que les autres routeurs lui ont racont\u00e9. On dit que ce protocole de routage est du routing by rumor . La m\u00e9trique utilis\u00e9e (le nombre de sauts) ne tient pas compte de la qualit\u00e9 de la liaison, contrairement au protocole OSPF. 3. Le protocole OSPF \u2693\ufe0e OSPF : Open Shortest Path First Un inconv\u00e9nient majeur du protocole pr\u00e9c\u00e9dent est la non-prise en compte de la bande passante reliant les routeurs. En voiture, le chemin le plus rapide n'est pas forc\u00e9ment le plus court. En gris, le chemin RIP. En bleu, l'OSPF. Dans le protocole OSPF, les tables de routage vont prendre en consid\u00e9ration la vitesse de communication entre les routeurs. Dans une premi\u00e8re phase d'initialisation, chaque routeur va acqu\u00e9rir (par succession de messages envoy\u00e9s et re\u00e7us) la connaissance totale du r\u00e9seau (diff\u00e9rence fondamentale avec RIP) et de la qualit\u00e9 technique de la liaison entre chaque routeur. 3.1 Les diff\u00e9rents types de liaison et leur co\u00fbt \u2693\ufe0e On peut, approximativement, classer les types de liaison suivant ce tableau de d\u00e9bits th\u00e9oriques : Technologie BP descendante BP montante Modem 56 kbit/s 48 kbit/s Bluetooth 3 Mbit/s 3 Mbit/s Ethernet 10 Mbit/s 10 Mbit/s Wi-Fi 10 Mbit/s ~ 10 Gbits/s 10 Mbit/s ~ 10 Gbits/s ADSL 13 Mbit/s 1 Mbit/s 4G 100 Mbit/s 50 Mbit/s Satellite 50 Mbit/s 1 Mbit/s Fast Ethernet 100 Mbit/s 100 Mbit/s FFTH (fibre) 10 Gbit/s 10 Gbit/s 5G 20 Gbit/s 10 Gbit/s L'id\u00e9e du protocole OSPF est de pond\u00e9rer chaque trajet entre routeurs (comptant simplement pour \u00ab1\u00bb dans le protocole RIP) par une valeur de co\u00fbt inversement proportionnelle au d\u00e9bit de transfert. Par exemple, si le d\u00e9bit d est exprim\u00e9 en bits/s, on peut calculer le co\u00fbt de chaque liaison par la formule : \\(\\text{co\u00fbt} = \\dfrac{10^8}{d}\\) Cette formule de calcul peut \u00eatre diff\u00e9rente suivant les exercices, et sera syst\u00e9matiquement redonn\u00e9e. N\u00e9anmoins la valeur d sera toujours au d\u00e9nominateur, pour assurer la proportionnalit\u00e9 inverse du d\u00e9bit. Avec cette convention, un route entre deux routeurs reli\u00e9s en Fast Ethernet (100 Mbits/s) aura a un poids de 1, une liaison satellite de 20 Mbits/s aura un poids de 5, etc. 3.2 Exemple \u2693\ufe0e Reprenons le r\u00e9seau suivant : et simplifions-le en ne gardant que les liens entre routeurs, en indiquant leur d\u00e9bit : Notre r\u00e9seau est devenu un graphe . Nous allons pond\u00e9rer ses ar\u00eates avec la fonction co\u00fbt introduite pr\u00e9c\u00e9demment. L'unit\u00e9 \u00e9tant le Mbit/s, l'ar\u00eate entre R1 et R3 aura un poids de 100/20=5. Le graphe pond\u00e9r\u00e9 est donc : Le chemin le plus rapide pour aller de l'ordinateur au serveur est donc R1-R2-R4, et non plus R1-R3 comme l'aurait indiqu\u00e9 le protocole RIP. 3.3 Trouver le plus court chemin dans un graphe pond\u00e9r\u00e9 \u2693\ufe0e L'exemple pr\u00e9c\u00e9dent \u00e9tait tr\u00e8s simple et de solution intuitive. Dans le cas d'un graphe pond\u00e9r\u00e9 complexe, existe-t-il un algorithme de d\u00e9termination du plus court chemin d'un point \u00e0 un autre ? La r\u00e9ponse est oui , depuis la d\u00e9couverte en 1959 par Edsger Dijkstra de l'algorithme qui porte son nom, l'algorithme de Dijkstra . Pour le comprendre, vous pouvez regarder la vid\u00e9o d'un c\u00e9l\u00e8bre YouTuber : Cet algorithme, ici ex\u00e9cut\u00e9 de mani\u00e8re manuelle, est bien s\u00fbr programmable. Et c'est donc gr\u00e2ce \u00e0 lui que chaque routeur calcule la route la plus rapide pour acheminer les donn\u00e9es qu'il re\u00e7oit. Exemple d'application de l'algorithme de Dijkstra : Donner le plus court chemin pour aller de E \u00e0 F. 3.4 Exercice \u2693\ufe0e (extrait du sujet 0) On consid\u00e8re le r\u00e9seau suivant : On rappelle que le co\u00fbt d\u2019une liaison est donn\u00e9 par la formule suivante : \\(\\text{co\u00fbt} = \\dfrac{10^8}{d}\\) Question 1 V\u00e9rifier que le co\u00fbt de la liaison entre les routeurs A et B est 0,01. La liaison entre le routeur B et D a un co\u00fbt de 5. Quel est le d\u00e9bit de cette liaison ? Question 2 Le routeur A doit transmettre un message au routeur G, en empruntant le chemin dont la somme des co\u00fbts sera la plus petite possible. D\u00e9terminer le chemin parcouru. On indiquera le raisonnement utilis\u00e9. Correction du tableau de l'algorithme de Dijkstra Bibliographie \u2693\ufe0e Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G. CONNAN, V. PETROV, G. ROZSAVOLGYI, L. SIGNAC, \u00e9ditions HATIER. Site d'Olivier L\u00e9cluse https://www.lecluse.fr/nsi/NSI_T/archi/routage/","title":"Protocoles de routage"},{"location":"Reseaux/cours/#protocoles-de-routage","text":"","title":"Protocoles de routage"},{"location":"Revision1ere/TD_Glouton/","text":"TD n\u00b016 : Les algorithmes gloutons - R\u00e9vision 1\u00e8re Th\u00e8me 4 : Algorithmique COURS et EXERCICES I. Probl\u00e8me d\u2019optimisation : Le voyageur Enonc\u00e9 du probl\u00e8me Imaginons le probl\u00e8me suivant : vous devez organiser la tourn\u00e9e de votre commercial. Il doit passer dans toutes les villes sous sa responsabilit\u00e9 (une fois uniquement) et revenir \u00e0 son point de d\u00e9part (Lille pour notre exemple). Pour limiter les frais, il faut d\u00e9finir le trajet le moins long au total. Nous allons nous limiter \u00e0 5 villes uniquement ici. Voici le tableau des distances : Brest Bordeaux Lille Lyon Paris Brest - 598 708 872 572 Bordeaux 598 - 802 520 554 Lille 708 802 - 650 225 Lyon 872 520 650 - 465 Paris 572 554 225 465 - Question 1 : Partons de Lille. Combien de destinations diff\u00e9rentes peut-on choisir ? Combien de \"chemin\" possible ? Le probl\u00e8me se ram\u00e8ne \u00e0 trouver un ordre de visite des quatre villes pour lequel la somme des distance donn\u00e9es par ce tableau est aussi petite que possible. Une mani\u00e8re simple d'aborder le probl\u00e8me consiste \u00e0 \u00e9num\u00e9rer tous les cas possibles et calculer la distance correspondante pour chacun des cas. R\u00e9ponse : Question 2 : R\u00e9solution par force brute Traiter le probl\u00e8me en faisant tous les cas de figure, \u00e0 r\u00e9sumer dans un tableau et donner l'itin\u00e9raire le plus court Afficher tous les chemin avec la distance totale 1. Lille -> ... -> ...-> ...-> ...-> Lille avec une distance totale de ... km 2. Lille -> ... -> ...-> ...-> ...-> Lille avec une distance totale de ... km 3. Lille -> ... -> ...-> ...-> ...-> Lille avec une distance totale de ... km 4. Lille -> ... -> ...-> ...-> ...-> Lille avec une distance totale de ... km 5. Lille -> ... -> ...-> ...-> ...-> Lille avec une distance totale de ... km 6. Lille -> ... -> ...-> ...-> ...-> Lille avec une distance totale de ... km 7. Lille -> ... -> ...-> ...-> ...-> Lille avec une distance totale de ... km 8. Lille -> ... -> ...-> ...-> ...-> Lille avec une distance totale de ... km 9. Lille -> ... -> ...-> ...-> ...-> Lille avec une distance totale de ... km 10. Lille -> ... -> ...-> ...-> ...-> Lille avec une distance totale de ... km 11. Lille -> ... -> ...-> ...-> ...-> Lille avec une distance totale de ... km 12. Lille -> ... -> ...-> ...-> ...-> Lille avec une distance totale de ... km Remarque Les douze itin\u00e9raires correspondent chacun \u00e0 l'un des douze itin\u00e9raire emprunt\u00e9 dans le sens inverse. Question 3 : R\u00e9pondre au probl\u00e8me : quel est le trajet optimal. ? R\u00e9ponse Question 4 : Reprenons le m\u00eame probl\u00e8me en rajoutant Marseille. Question 5 : Dans ce cas, avec 6 villes, combien de cas faut-il \u00e9tudier ? Qu'en pensez-vous ? R\u00e9ponse : R\u00e9ponse au probl\u00e8me : Le plus petit trajet sera r\u00e9alis\u00e9 avec le parcours suivant (dans un sens ou dans l'autre) : Lille -> Paris -> Lyon -> Marseille -> Bordeaux -> Brest -> Lille en 3 000 km Cette technique (r\u00e9pertorier tous les cas de figure et faire une \u00e9tude exhaustive) n'est pas possible \u00e0 grande \u00e9chelle. D\u00e9terminer le nombre d'itin\u00e9raires possibles : * 4 villes (hors ville de d\u00e9part) on a : \\(\\dfrac{4 \\times 3 \\times 2 \\times 1}{2}= 12\\) itin\u00e9raires possibles. * 10 villes (hors ville de d\u00e9part), nombre d'itin\u00e9raires \u00e0 tester : \\(\\dfrac{10 \\times 9 \\times 8 \\times 7 \\cdots \\times 2 \\times, 1}{2}=\\) 1 714 400 * 13 villes (hors ville de d\u00e9part), nombre d'itin\u00e9raires \u00e0 tester : \\(\\dfrac{13 \\times 12 \\cdots \\times 2 \\times, 1}{2}=\\) 3 113 510 400 * 20 villes (hors ville de d\u00e9part), nombre de parcours \u00e0 tester : \\(\\dfrac{20 \\times 19 \\times 18 \\times 17 \\cdots \\times 2 \\times, 1}{2}=\\) 1 216 451 004 088 320 000 Face \u00e0 de tels probl\u00e8mes d'optimisation impossible \u00e0 explorer exhaustivement, il peut \u00eatre utile de conna\u00eetre des algorithmes donnant rapidement une r\u00e9ponse qui, sans \u00eatre n\u00e9cessairement optimale, resterait bonne. La m\u00e9thode gloutonne que l'on va abord\u00e9e dans ce TP donne une approche simple pour concevoir de tels algorithmes souvent approximatifs mais rapides. II. Algorithmes Gloutons Nous avons vu que la force brute ne permet pas de r\u00e9soudre (en un temps raisonnable) le probl\u00e8me du voyageur de commerce lorsqu'on augmente le nombre de villes. Maintenant que vous avez manipul\u00e9 ce probl\u00e8me et vu \u00e0 quel point il est complexe \u00e0 r\u00e9soudre, nous allons voir comment faire autrement. Remarque : greedy algorithms en anglais, l'adjectif \"greedy\" signifiant avare/glouton. Les algorithmes gloutons sont utilis\u00e9s pour r\u00e9pondre \u00e0 des probl\u00e8mes d'optimisation , c'est-\u00e0-dire des probl\u00e8mes algorithmiques dans lesquels l'objectif est de trouver une solution \" la meilleure possible \" selon un crit\u00e8re, parmi un ensemble de solutions \u00e9galement valides mais potentiellement moins avantageuses. Le contexte g\u00e9n\u00e9ral d'un tel probl\u00e8me d'optimisation est donc le suivant : * on consid\u00e8re un probl\u00e8me poss\u00e9dant un tr\u00e8s grand nombre de solutions * on dispose d'une fonction math\u00e9matique \u00e9valuant la qualit\u00e9 de chaque solution * on cherche une solution qui soit bonne, voire meilleure. Les algorithmes gloutons s'appliquent lorsque de plus : * la recherche d'une solution peut se ramener \u00e0 une succession de choix qui produisent et pr\u00e9cisent petit \u00e0 petit une solution partielle * on dispose d'une fonction math\u00e9matique \u00e9valuant la qualit\u00e9 de chaque solution partielle (dont on attend qu'elle soit coh\u00e9rente avec la fonction d'\u00e9valuation des solutions compl\u00e8tes). Le principe d'un algorithme glouton est le suivant : * r\u00e9soudre un probl\u00e8me \u00e9tape par \u00e9tape * \u00e0 chaque \u00e9tape, faire le choix optimal de moindre co\u00fbt (de meilleur gain) Le choix effectu\u00e9 \u00e0 chaque \u00e9tape n'est jamais remis en cause, ce qui fait que cette strat\u00e9gie permet d'aboutir rapidement \u00e0 une solution au probl\u00e8me de d\u00e9part. C'est en ce sens que l'adjectif greedy (glouton/avare) caract\u00e9rise ces algorithmes : ils terminent rapidement (glouton) sans fournir beaucoup d'efforts (avare). III. R\u00e9solution approch\u00e9e du probl\u00e8me du voyageur III.1. Appliquons la m\u00e9thode gloutonne \u00e0 notre probl\u00e8me de voyageur \u2693\ufe0e Le probl\u00e8me peut se r\u00e9sumer \u00e0 \u00ab quelle sera ma prochaine \u00e9tape \u00bb. M\u00e9thode gloutonne : partant de la ville de d\u00e9part, aller \u00e0 la ville la plus proche, puis la ville la plus proche non visit\u00e9e etc... Question 6 : Mettez en oeuvre cette m\u00e9thode en partant de Lille. R\u00e9ponse : Notre voyage fera donc ......... kilom\u00e8tres. L\u2019itin\u00e9raire ainsi obtenu est plus long que le circuit minimal de ........ kilom\u00e8tres vu en introduction, mais reste loin des assez nombreuses mauvaises solution qui demandaient plus de mille kilom\u00e8tres. Et surtout, nous n\u2019avons analyse qu\u2019un unique itin\u00e9raire ! Mise en oeuvre : Python \u2693\ufe0e Principe du Programme : + Les villes sont individuellement sous forme de dictionnaires avec les autres villes en cl\u00e9 et les dis- tances correspondantes en valeurs. Un autre dictionnaire est cr\u00e9\u00e9 pour regrouper l\u2019ensemble des villes : \ud83d\udc0d Script Python ''' Nous cr\u00e9ons un dictionnaire les_villes qui va contenir des dictionnaires pour stocker les distances entre villes ''' brest = { 'Bordeaux' : 598 , 'Lille' : 708 , 'Lyon' : 872 , 'Marseille' : 1130 , 'Paris' : 572 } bordeaux = { 'Brest' : 598 , 'Lille' : 802 , 'Lyon' : 520 , 'Marseille' : 637 , 'Paris' : 554 } lille = { 'Brest' : 708 , 'Bordeaux' : 802 , 'Lyon' : 650 , 'Marseille' : 1002 , 'Paris' : 225 } lyon = { 'Brest' : 872 , 'Bordeaux' : 520 , 'Lille' : 650 , 'Marseille' : 367 , 'Paris' : 465 } marseille = { 'Brest' : 1130 , 'Bordeaux' : 637 , 'Lille' : 1002 , 'Lyon' : 367 , 'Paris' : 777 } paris = { 'Brest' : 572 , 'Bordeaux' : 554 , 'Lille' : 225 , 'Lyon' : 465 , 'Marseille' : 777 } les_villes = { 'Brest' : brest , 'Bordeaux' : bordeaux , 'Lille' : lille , 'Lyon' : lyon , 'Marseille' : marseille , 'Paris' : paris } Une fonction plus_proche_voisin(ville,les_villes_voisines,Non_Visitees) , qui renvoie le nom de la ville non encore visit\u00e9e la plus proche ainsi que la distance correspondante. \ud83d\udc0d Script Python def plus_proche_voisin ( ville , les_villes_voisines , Non_Visitees ): pass ville = 'Lille' print ( plus_proche_voisin ( ville , les_villes [ ville ], les_villes . keys ())) Une fonction principal trajet qui prend en param\u00e8tre la ville de d\u00e9part,le dictionnaire des villes \u00e0 visiter. \ud83d\udc0d Script Python def trajet ( depart , avisitees ): Nvisitees =.... #on cr\u00e9e un tableau avec les villes \u00e0 visiter taille = len ( avisitees ) ville = depart parcours = [ depart ] # le parcours d\u00e9bute par la ville choisie distance = 0 # au d\u00e9part la distance aprcourue est 0 for i in range ( ..... ): ........... #on enleve la ville d\u00e9ja visit\u00e9e de la liste ville , dist = plus_proche_voisin ( ville , avisitees [ ville ], Nvisitees ) #on appelle la fonction plus proche voisin distance .... #la distance parcourue augment de la distance entre les deux villes parcours . append ( ville ) # On ajoute la ville ainsi visit\u00e9e dans le tableau parcours print ( f \"ville suivante { ville } avec une distance de { dist } km soit une distance totale { distance } km\" ) ..... #la boucle est finie, on rajoute la ville de d\u00e9part qui devient la ville de fin pour terminer la boucle. distance += les_villes [ ville ][ depart ] #on ajoute la derni\u00e8re distance \u00e0 parcourir pour retourner \u00e0 la ville de d\u00e9part print ( f \"ville suivante { ville } avec une distance de { dist } km soit une distance totale { distance } km\" ) return parcours , distance print ( trajet ( 'Lyon' , les_villes )) Tester ce code avec d'autres villes de d\u00e9part. Qualit\u00e9 de l\u2019approximation \u2693\ufe0e La solution donn\u00e9e par l\u2019algorithme glouton n\u2019est pas n\u00e9cessairement optimale. Peut-on n\u00e9anmoins s\u2019attendre \u00e0 un certain niveau de qualit\u00e9 ? Si oui, ce niveau de qualit\u00e9 attendu est-il garanti, c\u2019est-\u00e0-dire respecte m\u00eame dans le pire des sc\u00e9narios ? Ou bien est-il seulement hautement probable, c\u2019est-\u00e0-dire g\u00e9n\u00e9ralement respect\u00e9 mais avec des exceptions ? Les r\u00e9ponses \u00e0 ces questions d\u00e9pendent fortement du probl\u00e8me consid\u00e9r\u00e9. Pour notre probl\u00e8me du voyageur, ii a \u00e9t\u00e9 d\u00e9montr\u00e9 que lorsque le nombre de villes devient grand, le rapport entre la. solution gloutonne et la solution optimale est dans le pire des cas proportionnel au logarithme du nombre de villes . Voir une simulation IV Probl\u00e8me : Rendu de monnaie Nous allons \u00e9tudier un probl\u00e8me d'optimisation classique : le probl\u00e8me du rendu de monnaie de mani\u00e8re optimale. On cherche \u00e0 rendre la monnaie avec un nombre minimal de pi\u00e8ces et billets. Voici notre syst\u00e8me de monnaie (exprim\u00e9 en euros) : * Pi\u00e8ces : 0,01 ; 0,02 ; 0,05 ; 0,1 ; 0,2 ; 1 ; 2 * Billets : 5 ; 10 ; 20 ; 50 ; 100 ; 200; 500 On cherche par exemple \u00e0 rendre 53 euros. On peut dans un tableau \u00e9num\u00e9rer quelques solutions possibles et choisir celle qui minimise le nombre de pi\u00e8ces et de billets. Rendus de monnaie Nombre de pi\u00e8ces et de billets 5 300 \\(\\times\\) 0.01 5 300 53 \\(\\times\\) 1 53 5 \\(\\times\\) 10 + 1 \\(\\times\\) 2 + 1 \\(\\times\\) 1 7 2 \\(\\times\\) 20 + 3 \\(\\times\\) 5 + 1 \\(\\times\\) 2 6 1 \\(\\times\\) 50 + 1 \\(\\times\\) 2 + 1 \\(\\times\\) 1 3 L'utilisation de ce type de m\u00e9thode est tr\u00e8s co\u00fbteux en temps de calcul car il faut explorer toutes les possibilit\u00e9s. IV.1. L'algorithme glouton \u2693\ufe0e On proc\u00e8de \u00e9tape par \u00e9tape en faisant, \u00e0 chaque \u00e9tape, le meilleur choix possible. On ne remet jamais en cause les choix faits aux \u00e9tapes pass\u00e9es. Dans notre cas nous allons rendre la monnaie en commen\u00e7ant par la pi\u00e8ce ou le billet avec la plus grande valeur possible (en restant inf\u00e9rieur \u00e0 la somme \u00e0 rendre). Cela correspond \u00e0 notre derni\u00e8re ligne de tableau ( \\(1 \\times 50 + 1 \\times 1 + 1 \\times 2\\) \u20ac). On recommence ainsi jusqu'\u00e0 obtenir une valeur nulle. On note : * systeme : liste des pi\u00e8ces et des billets * somme : montant \u00e0 obtenir * somme_restante : montant qui reste \u00e0 rendre * monnaie : liste qui contient les valeurs rendues \ud83d\udccb Texte 1. initialiser monnaie \u00e0 une liste vide 2. initialiser la somme_restante \u00e0 somme 3. tant que somme_restante >0 : * On choisit la plus grande valeur dans systeme inf\u00e9rieure \u00e0 somme_restante * on ajoute cette valeur \u00e0 monnaie * on ajoute cette valeur \u00e0 somme_restante 4. renvoyer monnaie Reprenons notre exemple avec somme= 53 et systeme= \\([0.01,0.02,0.05,0.1,0.2,1,2,5,10,20,50]\\) . Voici la liste des \u00e9tapes : Initialisation monnaie=[] somme_restante=53 \u00e9tape 1 monnaie= \\([50]\\) somme_restante=3 \u00e9tape 2 monnaie= \\([50,2]\\) somme_restante=1 \u00e9tape 3 monnaie= \\([50,2,1]\\) somme_restante=0 Notre solution d\u00e9pend du nombre de pi\u00e8ces et de billets disponibles. Si nous sommes limit\u00e9s sur certaines pi\u00e8ces et/ou certains billets, les r\u00e9sultats seront diff\u00e9rents. Exercice 1 : \u2693\ufe0e Traiter l'exercice pr\u00e9c\u00e9dent avec pour syst\u00e8me code S = \\([1,2,5,50,100]\\) et pour somme : 27 \u20ac . R\u00e9ponse : IV.2. Solution et solution optimale \u2693\ufe0e Pourquoi notre syst\u00e8me mon\u00e9taire ne poss\u00e8de pas de pi\u00e8ces ou de billets de 7 \u20ac ? Si notre syst\u00e8me poss\u00e9dait un billet ou une pi\u00e8ce de 7 \u20ac, l'algorithme glouton ne serait plus optimal. Prenons un montant de 14 \u20ac. L'algorithme glouton donne le rendu suivant 14=10+2+2 alors que le rendu optimal est 14=7\u00d72. Il existe des conditions sur le syst\u00e8me pour que l'algorithme glouton soit optimal. Si le sujet vous int\u00e9resse, vous pouvez faire des recherches. IV.3. Une solution optimale locale \u2693\ufe0e Un algorithme glouton permet de trouver solution optimale locale mais pas toujours une solution optimale globale. Reprenons notre exemple de rendu monnaie avec : S = \\([1,2,20,50,100]\\) et somme= 63. L'algorithme glouton donne comme r\u00e9sultat : monnaie= \\([50,2,2,2,2,2,2,1]\\) La solution optimale globale est pourtant : monnaie = \\([20,20,20,2,1]\\) Prenons maintenant l'exemple suivant : S= \\([2,5,10,20,50,100]\\) et somme=21. L'algorithme glouton ne va pas trouver de solution, alors qu'il existe au moins une solution locale : monnaie= \\([5,5,5,2,2,2]\\) Exercice 2 : \u2693\ufe0e Chercher une autre solution optimale locale meilleure que la pr\u00e9c\u00e9dente. Faire une trace d'ex\u00e9cution de ces exemples. R\u00e9ponse : Remarque : Dans le syst\u00e8me de pi\u00e8ces Europ\u00e9en, l'algorithme glouton donne toujours une solution optimale. IV.4 Impl\u00e9mentation de l'algorithme glouton \u2693\ufe0e Exercice 4 : \u2693\ufe0e Programmer cet algorithme en langage python. Programmer une fonction rendu_monnaie_glouton(systeme,somme) qui poss\u00e8de comme param\u00e8tres un syst\u00e8me de pi\u00e8ces et de billets sous forme de liste de nombres ; une somme \u00e0 rendre Cette fonction renvoie une liste de nombres qui caract\u00e9rise la monnaie \u00e0 rendre. Vous pouvez prendre comme jeu de test l'exemple de pr\u00e9sentation. Il faudra penser \u00e0 g\u00e9rer le fait que l'algorithme ne trouve pas de solution dans certains cas. Quelques aides : * penser \u00e0 trier par ordre d\u00e9croissant la liste des pi\u00e8ces et billets. * penser \u00e0 g\u00e9rer l'absence de solution globale. \ud83d\udc0d Script Python V EXERCICE **Objectifs** : - impl\u00e9menter un algorithme glouton pour trouver une solution \u00e0 un probl\u00e8me - impl\u00e9menter l'algorithme de *force brute* pour d\u00e9terminer la solution optimale et la comparer \u00e0 la solution gloutonne ### Introduction Nous disposons d\u2019une cl\u00e9 USB qui est d\u00e9j\u00e0 bien remplie et sur laquelle il ne reste que 5 Go de libre. Nous souhaitons copier sur cette cl\u00e9 des fichiers vid\u00e9os pour l\u2019emporter en voyage. Chaque fichier a un poids et chaque vid\u00e9o a une dur\u00e9e. La dur\u00e9e n\u2019est pas proportionnelle \u00e0 la taille car les fichiers sont de format diff\u00e9rents, certaines vid\u00e9os sont de grande qualit\u00e9, d\u2019autres sont tr\u00e8s compress\u00e9es. Le tableau qui suit pr\u00e9sente les 7 fichiers disponibles avec les dur\u00e9es donn\u00e9es en minutes. | Nom | Dur\u00e9e en min (valeur) | Poids | |--------- |------- |--------- | | Vid\u00e9o A | 114 | 4.57 Go | | Vid\u00e9o B | 32 | 630 Mo | | Vid\u00e9o C | 20 | 1.65 Go | | Vid\u00e9o D | 4 | 85 Mo | | Vid\u00e9o E | 18 | 2,15 Go | | Vid\u00e9o F | 80 | 2,71 Go | | Vid\u00e9o G | 5 | 320 Mo | >**Probl\u00e8me** : Quelles vid\u00e9os copier sur la cl\u00e9 USB pour que la dur\u00e9e des vid\u00e9os soient la plus grande possible tout en ne d\u00e9passant pas 5 Go ? **Question 1** : Quelle est la valeur que l'on cherche \u00e0 maximiser/minimiser ? Quelle est la contrainte ? R\u00e9ponse : **Question 2** : Quel probl\u00e8me reconnaissez-vous ici ? R\u00e9ponse : Vous allez impl\u00e9menter (= programmer) une solution gloutonne pour r\u00e9soudre ce probl\u00e8me, puis vous impl\u00e9menterez l'algorithme de *force brute* qui donnera la solution optimale au probl\u00e8me. La **strat\u00e9gie gloutonne retenue sera de toujours prendre la vid\u00e9o de plus grande dur\u00e9e** n'exc\u00e9dant pas la capacit\u00e9 restante de poids. ### Repr\u00e9sentation des donn\u00e9es Dans la suite, on utilisera des dictionnaires de la forme suivante pour repr\u00e9senter chaque vid\u00e9o, la dur\u00e9e \u00e9tant donn\u00e9e minute et le poids \u00e9tant donn\u00e9 en Go. \ud83d\udc0d Script Python { 'nom' : 'Vid\u00e9o A' , 'duree' : 114 , 'poids' : 4.57 } On peut alors m\u00e9moriser les 7 vid\u00e9os dans le tableau `table_videos` suivant. \ud83d\udc0d Script Python table_videos = [{ 'nom' : 'video A' , 'duree' : 114 , 'poids' : 4.57 }, { 'nom' : 'video B' , 'duree' : 32 , 'poids' : 0.63 }, { 'nom' : 'video C' , 'duree' : 20 , 'poids' : 1.65 }, { 'nom' : 'video D' , 'duree' : 4 , 'poids' : 0.085 }, { 'nom' : 'video E' , 'duree' : 18 , 'poids' : 2.15 }, { 'nom' : 'video F' , 'duree' : 80 , 'poids' : 2.71 }, { 'nom' : 'video G' , 'duree' : 5 , 'poids' : 0.32 }] On peut alors acc\u00e9der aux \u00e9l\u00e9ments de cette table. \ud83d\udc0d Script Python table_videos [ 0 ][ 'nom' ] \ud83d\udc0d Script Python table_videos [ 3 ][ 'duree' ] \ud83d\udc0d Script Python table_videos [ 6 ][ 'poids' ] ### Ecriture des fonctions utiles #### Acc\u00e8s au poids d'une vid\u00e9o Pour r\u00e9soudre le probl\u00e8me, on a besoin d'acc\u00e9der au poids des vid\u00e9os pour v\u00e9rifier la contrainte du poids maximal. La fonction suivante permet de renvoyer le poids d'une vid\u00e9o entr\u00e9e en param\u00e8tre (sous la forme d'un dictionnaire comme vu pr\u00e9c\u00e9demment). Quelques assertions devant \u00eatre v\u00e9rifi\u00e9es par la fonction ont \u00e9t\u00e9 \u00e9crites. \ud83d\udc0d Script Python def poids ( video ): pass assert poids ({ 'nom' : 'video A' , 'duree' : 114 , 'poids' : 4.57 }) == 4.57 assert poids ({ 'nom' : 'video D' , 'duree' : 4 , 'poids' : 0.085 }) == 0.085 assert poids ({ 'nom' : 'video G' , 'duree' : 5 , 'poids' : 0.32 }) == 0.32 #### Acc\u00e8s \u00e0 la dur\u00e9e d'une vid\u00e9o De m\u00eame, comme la strat\u00e9gie gloutonne choisie pr\u00e9voit de prendre la vid\u00e9o de plus grande dur\u00e9e (valeur) n'exc\u00e9dant pas la capacit\u00e9 restante de poids, il est n\u00e9cessaire de pouvoir acc\u00e9der aux dur\u00e9es de chacune des vid\u00e9os retenues. **Question 2** : Ecrivez une fonction `duree(video)` qui renvoie la dur\u00e9e (= valeur) d'une video entr\u00e9e en param\u00e8tre (sous la forme d'un dictionnaire vu pr\u00e9c\u00e9demment). Quelques assertions devant \u00eatre v\u00e9rifi\u00e9es par votre fonction sont donn\u00e9es ci-dessous. \ud83d\udc0d Script Python def duree ( video ): # \u00e0 compl\u00e9ter \ud83d\udc0d Script Python assert duree ({ 'nom' : 'video A' , 'duree' : 114 , 'poids' : 4.57 }) == 114 assert duree ({ 'nom' : 'video D' , 'duree' : 4 , 'poids' : 0.085 }) == 4 assert duree ({ 'nom' : 'video G' , 'duree' : 5 , 'poids' : 0.32 }) == 5 #### Calculer le poids total et la dur\u00e9e totale d'une table de vid\u00e9os Enfin, il sera n\u00e9cessaire de pouvoir calculer le poids et la dur\u00e9e totale d'une table de vid\u00e9os pour savoir si la contrainte de capacit\u00e9 maximale est respect\u00e9e d'une part, et pour conna\u00eetre la dur\u00e9e totale qui est la valeur \u00e0 maximiser. **Question 3** : Ecrivez une fonction `poids_total(table_videos)` qui renvoie le poids total `poids_t` des vid\u00e9os pr\u00e9sentes dans `table_videos`. Quelques assertions devant \u00eatre v\u00e9rifi\u00e9es par votre fonction sont donn\u00e9es ci-dessous. \ud83d\udc0d Script Python def poids_total ( table_videos ): poids_t = 0 # \u00e0 compl\u00e9ter return poids_t \ud83d\udc0d Script Python table1 = [{ 'nom' : 'video C' , 'duree' : 20 , 'poids' : 1.65 }] table2 = [{ 'nom' : 'video A' , 'duree' : 114 , 'poids' : 4.57 }, { 'nom' : 'video B' , 'duree' : 32 , 'poids' : 0.63 }] table3 = [{ 'nom' : 'video A' , 'duree' : 114 , 'poids' : 4.57 }, { 'nom' : 'video B' , 'duree' : 32 , 'poids' : 0.63 }, { 'nom' : 'video C' , 'duree' : 20 , 'poids' : 1.65 }] assert poids_total ( table1 ) == 1.65 # on compare des nombres r\u00e9els mais on a pris soin de bien choisir les exemples assert poids_total ( table2 ) == 5.2 assert poids_total ( table3 ) == 6.85 assert poids_total ([]) == 0 # table vide test\u00e9e **Question 4** : Ecrivez une fonction `duree_totale(table_videos)` qui renvoie la dur\u00e9e totale `duree_t` des vid\u00e9os pr\u00e9sentes dans `table_videos`. Quelques assertions devant \u00eatre v\u00e9rifi\u00e9es par votre fonction sont donn\u00e9es ci-dessous. \ud83d\udc0d Script Python def duree_totale ( table_videos ): duree_t = 0 # \u00e0 compl\u00e9ter return duree_t \ud83d\udc0d Script Python table1 = [{ 'nom' : 'video C' , 'duree' : 20 , 'poids' : 1.65 }] table2 = [{ 'nom' : 'video A' , 'duree' : 114 , 'poids' : 4.57 }, { 'nom' : 'video B' , 'duree' : 32 , 'poids' : 0.63 }] table3 = [{ 'nom' : 'video A' , 'duree' : 114 , 'poids' : 4.57 }, { 'nom' : 'video B' , 'duree' : 32 , 'poids' : 0.63 }, { 'nom' : 'video C' , 'duree' : 20 , 'poids' : 1.65 }] assert duree_totale ( table1 ) == 20 assert duree_totale ( table2 ) == 146 assert duree_totale ( table3 ) == 166 assert duree_totale ([]) == 0 # table vide test\u00e9e assert duree_totale ( table_videos ) == 273 # table avec toutes les vid\u00e9os ### Impl\u00e9mentation de l'algorithme glouton #### Tri pr\u00e9alable Comme la strat\u00e9gie gloutonne retenue pr\u00e9voit de choisir les vid\u00e9os de plus grande dur\u00e9e n'exc\u00e9dant pas la capacit\u00e9 restante, il est judicieux de commencer par trier les vid\u00e9os de `table_videos` par dur\u00e9e d\u00e9croissante. **Question 5** : Utilisez la fonction `sorted` de Python pour obtenir un *nouveau* tableau (appel\u00e9 `table_triee`) contenant les vid\u00e9os de `table_videos` tri\u00e9es par dur\u00e9e d\u00e9croissante. *Indication* : l'instruction `help(sorted)` permet d'afficher l'aide de la fonction `sorted` (vous pouvez aussi revoir le cours sur les tris de table si n\u00e9cessaire). \ud83d\udc0d Script Python # \u00e0 compl\u00e9ter table_triee = ... table_triee # pour afficher le r\u00e9sultat #### Algorithme glouton **Question 6** : en vous inspirant de l'impl\u00e9mentation de l'algorithme glouton du rendu de monnaie (voir cours), \u00e9crivez une fonction `glouton(table_videos, poids_max)` qui prend en param\u00e8tre une table de vid\u00e9os `table_videos` et un poids maximal `poids_max` et renvoie une liste `solution_gloutonne` contenant les vid\u00e9os de la solution gloutonne au probl\u00e8me. La solution gloutonne \u00e0 trouver est donn\u00e9e dans l'assertion qui suit. \ud83d\udc0d Script Python def glouton ( table_videos , poids_max ): # TRI DE LA TABLE # \u00e0 compl\u00e9ter par l'instruction de votre r\u00e9ponse pr\u00e9c\u00e9dente table_triee = ... # ALGORITHME GLOUTON poids_total = 0 solution_gloutonne = [] # \u00e0 compl\u00e9ter # on se positionne sur la premi\u00e8re vid\u00e9o (de la table tri\u00e9e) # tant qu'il reste des vid\u00e9os \u00e0 traiter et que le poids max n'est pas atteint # on prend la premiere video restante # si elle n'est pas trop lourde (capacit\u00e9 restante suffisante) # on l'ajoute \u00e0 solution_gloutonne et on met \u00e0 jour le poids total de la solution gloutonne # on passe \u00e0 la vid\u00e9o suivante return solution_gloutonne \ud83d\udc0d Script Python assert glouton ( table_videos , 5 ) == [{ 'nom' : 'video A' , 'duree' : 114 , 'poids' : 4.57 }, { 'nom' : 'video G' , 'duree' : 5 , 'poids' : 0.32 }, { 'nom' : 'video D' , 'duree' : 4 , 'poids' : 0.085 }] **Question 7** : Utilisez la fonction `duree_totale` pour d\u00e9terminer la dur\u00e9e totale de la solution gloutonne. Quelle est sa dur\u00e9e totale ? \ud83d\udc0d Script Python # \u00e0 compl\u00e9ter ### Impl\u00e9mentation de la *force brute* Le principe est simple : il faut \u00e9tudier tous les cas possibles. Ainsi, pour appliquer cette strat\u00e9gie, il faut : 1. d'abord *\u00e9num\u00e9rer* toutes les combinaisons possibles de vid\u00e9os 2. puis conserver celles dont la capacit\u00e9 maximale n'est pas d\u00e9pass\u00e9e 3. enfin, trouver la meilleure solution parmi les combinaisons restantes >**Remarque** : Dans un souci de simplicit\u00e9, il a \u00e9t\u00e9 fait le choix de ne pas utiliser de fonctions pour impl\u00e9menter la strat\u00e9gie de force brute. Vous pourrez trouver un code plus propre (mais plus complexe) en suivant ce [lien](#). \ud83d\udc0d Script Python table_videos = [{ 'nom' : 'video A' , 'duree' : 114 , 'poids' : 4.57 }, { 'nom' : 'video B' , 'duree' : 32 , 'poids' : 0.63 }, { 'nom' : 'video C' , 'duree' : 20 , 'poids' : 1.65 }, { 'nom' : 'video D' , 'duree' : 4 , 'poids' : 0.085 }, { 'nom' : 'video E' , 'duree' : 18 , 'poids' : 2.15 }, { 'nom' : 'video F' , 'duree' : 80 , 'poids' : 2.71 }, { 'nom' : 'video G' , 'duree' : 5 , 'poids' : 0.32 }] #### Etape 1 : \u00e9num\u00e9ration de toutes les combinaisons Il s'agit de la difficult\u00e9 majeure. Dans une combinaison de vid\u00e9os, chaque vid\u00e9o de d\u00e9part est prise ou non, il s'agit d'une donn\u00e9e binaire. Ainsi, une approche consiste \u00e0 cr\u00e9er des mots binaires repr\u00e9sentant chaque combinaison. Par exemple, le mot '1101001' signifie qu'on prend les vid\u00e9os A, B, D et G tandis que le mot '1111111' signifie que l'on prend toutes les vid\u00e9os. Dans notre exemple, nous avons 7 vid\u00e9os donc il y a $2^{7} = 128$ combinaisons possibles. De mani\u00e8re g\u00e9n\u00e9rale il y a donc $2^n$ combinaisons pour un ensemble de $n$ vid\u00e9os. On va construire un tableau `combinaisons` contenant toutes les combinaisons binaires. Pour cela, l'id\u00e9e est de commencer par construire un tableau `tab_entiers` contenant tous les entiers compris entre $0$ et $2^n-1$. \ud83d\udc0d Script Python n = len ( table_videos ) # nombre de vid\u00e9os tab_entiers = [ i for i in range ( 2 ** n )] # cr\u00e9ation d'un tableau avec tous les entiers entre 0 et 2**n-1 print ( tab_entiers ) Ensuite, on construit un autre tableau `tab_binaire` avec les conversions binaires de chaque entier. >**Astuce** : la fonction `bin` prend un entier en param\u00e8tre et renvoie sa valeur binaire sous forme d'une cha\u00eene de caract\u00e8res. Par exemple, `bin(12)` renvoie la cha\u00eene `'0b1101'`. Il suffira de supprimer les caract\u00e8res `'0b'` en t\u00eate pour obtenir l'\u00e9criture binaire. On veillera \u00e9galement \u00e0 compl\u00e9ter avec des z\u00e9ros devant pour obtenir un mot de la longueur d\u00e9sir\u00e9e. \ud83d\udc0d Script Python tab_binaire = [ bin ( i )[ 2 :] for i in tab_entiers ] # conversion binaire des entiers du tableau pr\u00e9c\u00e9dent, le [2:] permet de supprimer les caract\u00e8res de t\u00eate '0b' renvoy\u00e9s par la fonction bin print ( tab_binaire ) Enfin, pour obtenir le tableau `combinaisons`, on prendra le soin de compl\u00e9ter avec autant de z\u00e9ros que n\u00e9cessaires les valeurs binaires pr\u00e9c\u00e9dentes pour obtenir des mots de longueur 7, repr\u00e9sentant les combinaisons possibles de vid\u00e9os. \ud83d\udc0d Script Python combinaisons = [ '0' * ( n - len ( k )) + k for k in tab_binaire ] # ajout des z\u00e9ros pour obtenir des mots binaires de longueur n On peut v\u00e9rifier que le tableau `combinaisons` contient bien tous les 128 mots binaires de longueur 7. \ud83d\udc0d Script Python combinaisons #### Etape 2 : conservation des combinaisons valides On cherche maintenant \u00e0 conserver uniquement les combinaisons valides, c'est-\u00e0-dire celles ne d\u00e9passant pas la capacit\u00e9 maximale de 5 Go. Par exemple : - `'0000001'` est \u00e0 conserver puisqu'il s'agit uniquement de la vid\u00e9o G de 0.32 Go - `'1010000'` n'est pas \u00e0 conserver car le poids total de cette combinaison (vid\u00e9os A et C) vaut 4.57 + 1.65 = 6.22 Go, ce qui d\u00e9passe la capacit\u00e9 maximale autoris\u00e9e. Pour cela, on peut calculer le poids total de chaque combinaison. Si celui-ci est inf\u00e9rieur au poids maximal autoris\u00e9, alors la combinaison est valide et on la conserve. **Question 8** : Compl\u00e9tez le programme suivant pour qu'en fin d'ex\u00e9cution la liste `combinaisons_valides` contienne tous les couples `(combi, duree_combi)` des combinaisons valides et de leur dur\u00e9e. L'assertion qui suit indique le nombre de combinaisons valides. \ud83d\udc0d Script Python n = len ( table_videos ) poids_max = 5 combinaisons_valides = [] for combi in combinaisons : # on parcourt chaque combinaison du tableau combinaisons poids_combi = 0 duree_combi = 0 for i in range ( n ): # on parcourt la combinaison caract\u00e8re par caract\u00e8re # \u00e0 compl\u00e9ter # si le caract\u00e8re est '1', alors on met \u00e0 jour la dur\u00e9e et le poids de la combinaison avec ceux de la vid\u00e9o # si la combi est valide alors on ajoute le couple (combi, duree_combi)\u00e0 notre liste de combinaisons valides \ud83d\udc0d Script Python assert len ( combinaisons_valides ) == 51 Si vous ne parvenez pas \u00e0 trouver la liste souhait\u00e9e, la voici. Vous pourrez continuer en l'utilisant. \ud83d\udc0d Script Python combinaisons_valides = [( '0000000' , 0 ), ( '0000001' , 5 ), ( '0000010' , 80 ), ( '0000011' , 85 ), ( '0000100' , 18 ), ( '0000101' , 23 ), ( '0000110' , 98 ), ( '0001000' , 4 ), ( '0001001' , 9 ), ( '0001010' , 84 ), ( '0001011' , 89 ), ( '0001100' , 22 ), ( '0001101' , 27 ), ( '0001110' , 102 ), ( '0010000' , 20 ), ( '0010001' , 25 ), ( '0010010' , 100 ), ( '0010011' , 105 ), ( '0010100' , 38 ), ( '0010101' , 43 ), ( '0011000' , 24 ), ( '0011001' , 29 ), ( '0011010' , 104 ), ( '0011011' , 109 ), ( '0011100' , 42 ), ( '0011101' , 47 ), ( '0100000' , 32 ), ( '0100001' , 37 ), ( '0100010' , 112 ), ( '0100011' , 117 ), ( '0100100' , 50 ), ( '0100101' , 55 ), ( '0101000' , 36 ), ( '0101001' , 41 ), ( '0101010' , 116 ), ( '0101011' , 121 ), ( '0101100' , 54 ), ( '0101101' , 59 ), ( '0110000' , 52 ), ( '0110001' , 57 ), ( '0110010' , 132 ), ( '0110100' , 70 ), ( '0110101' , 75 ), ( '0111000' , 56 ), ( '0111001' , 61 ), ( '0111100' , 74 ), ( '0111101' , 79 ), ( '1000000' , 114 ), ( '1000001' , 119 ), ( '1001000' , 118 ), ( '1001001' , 123 )] #### Etape 3 : trouver la meilleure solution C'est tr\u00e8s simple puisqu'il suffit de d\u00e9terminer la combinaison valide de dur\u00e9e maximale. Cela revient donc \u00e0 une recherche de maximum. **Question 9** : Ecrivez un programme permettant de trouver la solution optimale et sa dur\u00e9e totale. \ud83d\udc0d Script Python # \u00e0 compl\u00e9ter Vous devez trouver que la solution optimale est la combinaison `'0110010'` d'une dur\u00e9e de 132 min. **Question 10** : Comparez la solution optimale et la solution gloutonne trouv\u00e9e pr\u00e9c\u00e9demment. R\u00e9ponse : **Question 11** : Ecrivez un programme permettant d'afficher une liste `liste_optimale` contenant les noms des vid\u00e9os correspondant \u00e0 la solution optimale. \ud83d\udc0d Script Python liste_optimale = [] # \u00e0 compl\u00e9ter print ( \"la meilleure solution est de choisir :\" , liste_optimale )","title":"Algo glouton"},{"location":"StructureDonnees/Revision_Arbres/","text":"R\u00e9vision : Structures de donn\u00e9es - Les Arbres Structures de donn\u00e9e COURS et EXERCICES Exercice n\u00b01 : \\(((2 \u2212 10) \u00d7 2 + (3 + 7) \u00d7 6)/(9 + (8 \u00d7 (1 + 4)))\\) Repr\u00e9senter cette expression par un arbre binaire dans lequel les noeuds sont les op\u00e9rations et les feuilles, les nombres. Exercice n\u00b02 : On donne une liste al\u00e9atoire de 13 entiers : [22, 31, 56, 12, 51, 8, 35, 7, 3, 14, 44, 2, 6] Question 1. Construire dans l\u2019ordre de la liste l\u2019arbre binaire de recherche associ\u00e9. Question 2. Quelle est la hauteur de cet arbre ? Question 3. Construire un arbre \u00e9quilibr\u00e9 pour cette m\u00eame liste d\u2019entiers. Question 4. Quelle est la hauteur de l\u2019arbre \u00e9quilibr\u00e9 ? Exercice n\u00b03 : On consid\u00e8re la class suivante et l\u2019arbre suivant : \ud83d\udc0d Script Python class Arbre : def __init__ ( self , valeur ): \"\"\"Initialisation de l'arbre racine+sous-arbre gauche et sous-arbre droit\"\"\" self . v = valeur self . fg = None self . fd = None def ajout_gauche ( self , val ): \"\"\"Ajout valeur dans le sous-arbre gauche sous la forme [val,None,None]\"\"\" self . fg = Arbre ( val ) def ajout_droit ( self , val ): \"\"\" Ajout valeur dans le sous-arbre droit sous la forme [val,None,None]\"\"\" self . fd = Arbre ( val ) def affiche ( self ): \"\"\"permet d'afficher un arbre\"\"\" if self == None : return None else : return [ self . v , Arbre . affiche ( self . fg ), Arbre . affiche ( self . fd )] def get_valeur ( self ): \"\"\" renvoie la valeur du noeud\"\"\" if self == None : return None else : return print ( self . v ) Question 1 : Impl\u00e9menter l\u2019arbre suivant avec la class donn\u00e9e. Question 2 : Donner le r\u00e9sultat du parcours en profondeur infixe. Question 3 : Donner le r\u00e9sultat du parcours en profondeur pr\u00e9fixe. Question 4 : Donner le r\u00e9sultat du parcours en profondeur sufixe. Question 5 : Donner le r\u00e9sultat du parcours en largeur. Exercice n\u00b04 : On consid\u00e8re le labyrinthe ci-dessous : Construire un arbre binaire repr\u00e9sentant ce labyrinthe dans lequel chaque case est repr\u00e9sent\u00e9e par un noeud. On partira du noeud not\u00e9 (4, 0) et chaque noeud sera not\u00e9 \\((i , j)\\) o\u00f9 \\(i\\) et \\(j\\) repr\u00e9sentent respectivement la ligne et la colonne de la case correspondante.","title":"Revision Arbres"},{"location":"StructureDonnees/TD13_Piles/","text":"TD n\u00b013 : Structures de donn\u00e9es - Les Piles Th\u00e8me 1 : Structures de donn\u00e9es COURS et EXERCICES Les piles et les files sont deux structures de donn\u00e9es lin\u00e9aires qui permettent, au m\u00eame titre que les listes, de g\u00e9rer des s\u00e9quences d\u2019\u00e9l\u00e9ments. Ainsi, dans une pile et dans une file chaque \u00e9l\u00e9ment est \u00e9ga- lement rep\u00e9r\u00e9 par sa position, il y a un premier, un dernier, chaque \u00e9l\u00e9ment a un successeur (sauf le premier) et un pr\u00e9d\u00e9cesseur (sauf le dernier). Les op\u00e9rations disponibles pour ces deux structures sont assez proches car dans les deux cas, on veut pouvoir : * cr\u00e9er une pile/file vide * conna\u00eetre sa taille * lui ajouter un \u00e9l\u00e9ment * lui retirer un \u00e9l\u00e9ment * acc\u00e9der \u00e0 un \u00e9l\u00e9ment particulier Cependant, la politique d\u2019ajout/retrait des \u00e9l\u00e9ments dans la s\u00e9quence n\u2019est pas la m\u00eame. Le nom des op\u00e9rations diff\u00e8rent \u00e9galement pour mieux distinguer les deux structures. I. Les Piles Il faut se repr\u00e9senter une pile comme. . . une pile de livres ! Seul le livre dispos\u00e9 sur le dessus est accessible : l\u2019ajout et le retrait d\u2019un livre ne peut donc se faire que sur le sommet de la pile. \u27a1 Interface d'une pile \u2693\ufe0e Interface d'une pile Le jeu d'op\u00e9rations disponibles pour une pile est : construire_pile() : cr\u00e9e une pile vide taille(P) : acc\u00e8s au nombre d'\u00e9l\u00e9ments dans la pile P empiler(P, e) : ajoute l'\u00e9l\u00e9ment e au sommet de la pile P . depiler(P) : retire l'\u00e9l\u00e9ment au sommet de la pile P . Pr\u00e9condition : P n'est pas vide. sommet(P) : pour acc\u00e9der (en lecture) au sommet de la pile P (sans le retirer de la pile). Pr\u00e9condition : P n'est pas vide. En anglais, l'op\u00e9ration empiler est souvent not\u00e9e push , l'op\u00e9ration depiler est souvent not\u00e9e pop et l'op\u00e9ration taille est souvent not\u00e9e top . Remarque : Certaines signatures algorithmiques peuvent l\u00e9g\u00e8rement varier. Par exemple, on peut parfois voir l'op\u00e9ration est_vide (qui teste si une pile est vide) \u00e0 la place de taille (une pile est vide si et seulement si sa taille vaut 0) ou encore l'op\u00e9ration depiler qui renvoie \u00e9galement le sommet (donc l'op\u00e9ration sommet n'est plus n\u00e9cessaire). C'est un choix libre qui ne change pas la nature de la structure de donn\u00e9es abstraite mais la fa\u00e7on d'\u00e9crire des algorithmes. \u27a1 Repr\u00e9sentation d'une pile et exemple \u2693\ufe0e Une pile contenant les \u00e9l\u00e9ments \\(\\text{'a'}\\) , \\(\\text{'b'}\\) et \\(\\text{'c'}\\) ( \\(\\text{'a'}\\) \u00e9tant le sommet et donc \\(\\text{'c'}\\) le fond de la pile) sera repr\u00e9sent\u00e9e : \\[\\text{>'a', 'b', 'c']}\\] Exemple On consid\u00e8re la pile P : \\(\\text{>'a', 'b', 'c']}\\) . Voici comment la manipuler : Op\u00e9ration Contenu de la pile empiler(P, 'e') \\(\\text{>'e', 'a', 'b', 'c']}\\) depiler(P) \\(\\text{>'a', 'b', 'c']}\\) depiler(P) \\(\\text{>'b', 'c']}\\) sommet(P) renvoie \\(\\text{'b'}\\) depiler(P) \\(\\text{>'c']}\\) empiler(P, 'm') \\(\\text{>'m', 'c']}\\) taille(P) renvoie 2 \u27a1 Applications des piles \u2693\ufe0e Les piles sont tr\u00e8s utilis\u00e9es en informatique. Voici quelques usages caract\u00e9ristiques : Les algorithmes r\u00e9cursifs utilisent une pile d'appel pour m\u00e9moriser les contextes d'ex\u00e9cution de chaque appel. (d\u00e9j\u00e0 abord\u00e9) Dans un navigateur web, une pile sert \u00e0 m\u00e9moriser les pages Web visit\u00e9es. L'adresse de chaque nouvelle page visit\u00e9e est empil\u00e9e et l'utilisateur d\u00e9pile l'adresse courante pour acc\u00e9der \u00e0 la page pr\u00e9c\u00e9dente en cliquant le bouton \u00ab Afficher la page pr\u00e9c\u00e9dente \u00bb. La fonction \u00ab Annuler la frappe \u00bb (en anglais Undo, le c\u00e9l\u00e8bre CTRL+F) d'un traitement de texte m\u00e9morise les modifications apport\u00e9es au texte dans une pile. On peut aussi utiliser une pile pour parcourir (en profondeur) un graphe et m\u00e9moriser les sommets visit\u00e9s. (voir Th\u00e8me 5 : Algorithmique) La v\u00e9rification du bon parenth\u00e9sage d'une expression peur \u00e9galement se faire \u00e0 l'aide d'une pile. etc. \u27a1 Impl\u00e9mentations \u2693\ufe0e Une pile est g\u00e9n\u00e9ralement impl\u00e9ment\u00e9e par : un tableau (redimensionnable ou non) ou par une liste cha\u00een\u00e9e. Selon le cas, il faudra veiller \u00e0 ce que l'impl\u00e9mentation soit la plus efficace possible. Si on utilise un tableau, les op\u00e9rations empiler et depiler seront plus efficaces si elles se font \u00e0 la fin du tableau plut\u00f4t qu'au d\u00e9but car cela ne n\u00e9cessite pas de d\u00e9caler les autres \u00e9l\u00e9ments. En revanche, si on utilise une liste cha\u00een\u00e9e, elles seront plus efficaces si elles ont lieu au d\u00e9but (car pour acc\u00e9der au dernier \u00e9l\u00e9ment il faut parcourir tous les \u00e9l\u00e9ments de proche en proche \u00e0 partir du premier qui est le seul accessible). II. Exercices sur les piles Activit\u00e9 1 : Manipulation des piles On consid\u00e8re la s\u00e9quence d'instructions suivantes. Indiquez le r\u00e9sultat \u00e0 chaque \u00e9tape. \ud83d\udccb Texte P = construire_pile() empiler(P, 1) empiler(P, 2) empiler(P, 3) s = sommet(P) depiler(P) depiler(P) empiler(P, s) Ecrivez la s\u00e9quence d'instructions permettant d'obtenir l'\u00e9volution suivante pour une pile P . Etat de la pile P Instructions ( \u00e0 compl\u00e9ter ) \\(\\text{>]}\\) \\(\\text{>3]}\\) \\(\\text{>1, 3]}\\) \\(\\text{>4, 1, 3]}\\) \\(\\text{>1, 3]}\\) \\(\\text{>3]}\\) \\(\\text{>]}\\) Activit\u00e9 2 : Premi\u00e8re impl\u00e9mentation d'une pile (avec le type `list` de Python) Interface On d\u00e9finit le type abstrait Pile par ses op\u00e9rations : cr\u00e9ation de pile vide empiler : ajout au sommet depiler : retrait du sommet sommet : acc\u00e8s (en lecture) au sommet taille : acc\u00e8s au nombre d'\u00e9l\u00e9ments L'objectif est d'impl\u00e9menter ce type abstrait en utilisant le type pr\u00e9d\u00e9fini list de Python (tableau dynamique = redimensionnable). Les \u00e9l\u00e9ments sont ajouter/retirer \u00e0 la fin pour des raisons d'efficacit\u00e9. Vous utiliserez le paradigme objet. Question 1 Enonc\u00e9 Solution Cr\u00e9ez une classe Pile impl\u00e9mentant ce type abstrait. Les objets de cette classe auront un attribut appel\u00e9 contenu qui est le contenu de la pile stock\u00e9 un objet list de Python. Indication : il faudra utiliser les m\u00e9thodes append et pop du type list . \ud83d\udc0d Script Python \ud83d\udc0d Script Python class Pile : def __init__ ( self ): self . contenu = [] def empiler ( self , e ): self . contenu . append ( e ) def depiler ( self ): if self . contenu != []: self . contenu . pop () def sommet ( self ): if self . contenu != []: return self . contenu [ - 1 ] def taille ( self ): return len ( self . contenu ) Question 2 Enonc\u00e9 Solution D\u00e9finissez la m\u00e9thode sp\u00e9ciale __repr__ pour afficher le contenu d'une pile comme une list Python. Attention : la m\u00e9thode __repr__ doit renvoyer une cha\u00eene de caract\u00e8res (conversion avec la fonction str ). \ud83d\udc0d Script Python \ud83d\udc0d Script Python class Pile : def __init__ ( self ): self . contenu = [] def empiler ( self , e ): self . contenu . append ( e ) def depiler ( self ): if self . contenu != []: self . contenu . pop () def sommet ( self ): if self . contenu != []: return self . contenu [ - 1 ] def taille ( self ): return len ( self . contenu ) def __repr__ ( self ): ch = \"\" for e in self . contenu : ch = str ( e ) + \",\" + ch # ne pas oublier de convertir les \u00e9l\u00e9ments en chaine de caract\u00e8res ch = ch [: - 1 ] # pour enlever la derni\u00e8re virgule ch = \">\" + ch + ']' return ch Question 3 Modifiez la m\u00e9thode __repr__ pour afficher les piles avec la notation du cours : \\(\\text{>...]}\\) . Attention \u00e0 l'odre des \u00e9l\u00e9ments, dans cette repr\u00e9sentation le sommet de la pile est \u00e0 gauche . \ud83d\udc0d Script Python Exemple on souhaite que le code \ud83d\udc0d Script Python P = Pile () print ( P ) P . empiler ( 'a' ) print ( P ) P . empiler ( 'c' ) print ( P ) P . empiler ( 'b' ) print ( P ) P . depiler () print ( P ) P . empiler ( 'z' ) print ( P ) produise l'affichage \ud83d\udccb Texte >] >a] >c,a] >b,c,a] >c,a] >z,c,a] Activit\u00e9 3 : Renverser un objet On souhaite renverser une liste en utilisant une pile. Renverser la liste [1, 2, 3] donne une nouvelle liste [3, 2, 1] . Question 1 : Proposez l'algorithme d'une fonction renverser permettant de renverser une liste en utilisant une pile. Question 2 Enonc\u00e9 Solution Ecrivez une fonction renverse(L) qui permet de renverser une liste L . \ud83d\udc0d Script Python def renverser ( P ): P1 = Pile () for k in range ( P . taille ()): v = P . sommet () P . depiler () P1 . empiler ( v ) return P1 \ud83d\udc0d Script Python #Test P = Pile () P . empiler ( 'a' ) P . empiler ( 'c' ) P . empiler ( 'b' ) P . depiler () P . empiler ( 'z' ) print ( P ) P = renverser ( P ) print ( P ) Activit\u00e9 4 : V\u00e9rifier le bon parenth\u00e9sage d'une expression Voici deux expressions mal parenth\u00e9s\u00e9es : \\(2(x-1)(4(x+3)\\) et \\(2(x-1))(4(x+3)\\) En voici une bien parenth\u00e9s\u00e9e : \\(3(x-1)(4(x+3)-2)\\) . On souhaite \u00e9crire une fonction verif_parenthesage(expression) qui renvoie Vrai si l'expression pass\u00e9e en argument est bien parenth\u00e9s\u00e9e et Faux sinon. On suppose que l'expression est une cha\u00eene de caract\u00e8res Sp\u00e9cification : Entr\u00e9e : une cha\u00eene de caract\u00e8res expression Sortie : un bool\u00e9en OK R\u00f4le : OK = Vrai si et seulement si le parenth\u00e9sage dans expression est correct Pr\u00e9condition : les caract\u00e8res \u00e0 tester sont ( et ) . Id\u00e9e de l'algorithme : On consulte les caract\u00e8res un \u00e0 un dans l'ordre de la cha\u00eene Si on voit une parenth\u00e8se ouvrante, il faut attendre pour trouver la fermante correspondante. On peut ajouter cette parenth\u00e8se ouvrante \u00e0 une pile en attendant de trouver la fermante correspondante. Si on voit une fermante, la derni\u00e8re ouvrante qui n'a pas encore \u00e9t\u00e9 associ\u00e9e , celle au sommet de la pile, doit normalement lui correspondre. Comme on a besoin de trouver la derni\u00e8re parenth\u00e8se ouvrante pas encore associ\u00e9e, une pile est appropri\u00e9e pour conserver les ouvrantes non encore associ\u00e9es car la derni\u00e8re se trouve alors au sommet de la pile (donc facilement accessible). Question 1 Proposez un jeu de tests de qualit\u00e9 pour cette fonction avec des assert . \ud83d\udc0d Script Python Question 2 Ecrivez une fonction verif_parenthesage(expression) qui convient. Elle doit passer tous les tests avec succ\u00e8s bien s\u00fbr. \ud83d\udc0d Script Python def verif_parenthesage ( expression ): OK = True P = Pile () # cr\u00e9ation pile vide # \u00e0 compl\u00e9ter # jeu de tests \u00e0 recopier ici Activit\u00e9 5 : Deuxi\u00e8me impl\u00e9mentation d'une pile (avec des listes cha\u00een\u00e9es) Importez la classe ListeChainee du TD 12 listechainee.py qui a \u00e9t\u00e9 cr\u00e9\u00e9 dans l'activit\u00e9 sur les listes cha\u00een\u00e9es puis impl\u00e9mentez une classe Pile par une liste cha\u00een\u00e9e. On rappelle que les op\u00e9rations d'ajout/retrait pour une liste cha\u00een\u00e9e sont efficaces au t\u00eate de liste. \ud83d\udc0d Script Python III. Exercices sur les piles - Sujet BAC Sujet z\u00e9ro - Exercice 1 Cet exercice porte sur la notion de pile et sur la programmation de base en Python. On rappelle qu\u2019une pile est une structure de donn\u00e9es abstraite fond\u00e9e sur le principe \u00ab dernier arriv\u00e9, premier sorti \u00bb : On munit la structure de donn\u00e9es Pile de quatre fonctions primitives d\u00e9finies dans le tableau ci-dessous. : Structure de donn\u00e9es abstraite : Pile Utilise : \u00c9l\u00e9ments, Bool\u00e9en Op\u00e9rations : creer_pile_vide : \u2205 \u2192 Pile creer_pile_vide() renvoie une pile vide est_vide : Pile \u2192 Bool\u00e9en est_vide(pile) renvoie True si pile est vide, False sinon empiler : Pile, \u00c9l\u00e9ment \u2192 Rien empiler(pile, element) ajoute element au sommet de la pile depiler : Pile \u2192 \u00c9l\u00e9ment depiler(pile) renvoie l\u2019\u00e9l\u00e9ment au sommet de la pile en le retirant de la pile Question 1 : Enonc\u00e9 Solution On suppose dans cette question que le contenu de la pile P est le suivant (les \u00e9l\u00e9ments \u00e9tant empil\u00e9s par le haut) : Quel sera le contenu de la pile Q apr\u00e8s ex\u00e9cution de la suite d\u2019instructions suivante ? \ud83d\udccb Texte 1 Q = creer_pile_vide () 2 while not est_vide ( P ): 3 empiler (Q , depiler ( P )) Question 2 : Enonc\u00e9 Solution 1 Solution 2 On appelle hauteur d\u2019une pile le nombre d\u2019\u00e9l\u00e9ments qu\u2019elle contient. La fonction hauteur_pile prend en param\u00e8tre une pile P et renvoie sa hauteur. Apr\u00e8s appel de cette fonction, la pile P doit avoir retrouv\u00e9 son \u00e9tat d\u2019origine. Exemple : si P est la pile de la question 1 : hauteur_pile(P) = 4 . Recopier et compl\u00e9ter sur votre copie le programme Python suivant impl\u00e9mentant la fonction hauteur_pile en rempla\u00e7ant les ??? par les bonnes instructions. \ud83d\udccb Texte 1 def hauteur_pile ( P ): 2 Q = creer_pile_vide () 3 n = 0 4 while not ( est_vide ( P )): 5 ??? 6 x = depiler (P ) 7 empiler (Q ,x ) 8 while not ( est_vide ( Q )): 9 ??? 10 empiler (P , x ) 11 return ??? 2. Cr\u00e9er une fonction max_pile ayant pour param\u00e8tres une pile P et un entier i. Cette fonction renvoie la position j de l\u2019\u00e9l\u00e9ment maximum parmi les i derniers \u00e9l\u00e9ments empil\u00e9s de la pile P. Apr\u00e8s appel de cette fonction, la pile P devra avoir retrouv\u00e9 son \u00e9tat d\u2019origine. La position du sommet de la pile est 1. Exemple : si P est la pile de la question 1 : max_pile(P, 2) = 1 \ud83d\udc0d Script Python def hauteur_pile ( P ): Q = creer_pile_vide () n = 0 while not est_vide ( P ): n += 1 x = depiler ( P ) empiler ( Q , x ) while not est_vide ( Q ): x = depiler ( Q ) empiler ( P , x ) return n Explication \ud83d\udc0d Script Python Q = creer_pile_vide () n = 0 On initialise Q est vide et n = 0 \ud83d\udc0d Script Python while not est_vide ( P ): n += 1 x = depiler ( P ) empiler ( Q , x ) Maintenant il faut remettre la pile P \u00e0 l\u2019\u00e9tat initial, d\u2019o\u00f9 la deuxi\u00e8me partie du programme : \ud83d\udc0d Script Python while not est_vide ( Q ): x = depiler ( Q ) empiler ( P , x ) \ud83d\udc0d Script Python def max_pile ( P , i ): # si la pile comporte moins de i \u00e9l\u00e9ment ou que i=0 on renvoie 0 if i > hauteur_pile ( P ) or i == 0 : return 0 maxi = depiler ( P ) Q = creer_pile_vide () empiler ( Q , maxi ) j = 1 indice = 1 while j < i : j = j + 1 x = depiler ( P ) if x > maxi : maxi = x indice = j empiler ( Q , x ) while not est_vide ( Q ): empiler ( P , depiler ( Q )) return indice Question 3 : Enonc\u00e9 Solution Cr\u00e9er une fonction retourner ayant pour param\u00e8tres une pile P et un entier j. Cette fonction inverse l\u2019ordre des j derniers \u00e9l\u00e9ments empil\u00e9s et ne renvoie rien. On pourra utiliser deux piles auxiliaires. Exemple : si P est la pile de laquestion 1(a), apr\u00e8s l\u2019appel de retourner(P, 3), l\u2019\u00e9tat de la pile P sera : \ud83d\udc0d Script Python def retourner ( P , j ): Q1 = creer_pile_vide () Q2 = creer_pile_vide () i = 0 while not est_vide ( P ) and i < j : i = i + 1 x = depiler ( P ) empiler ( Q1 , x ) while not est_vide ( Q1 ): x = depiler ( Q1 ) empiler ( Q2 , x ) while not est_vide ( Q2 ): x = depiler ( Q2 ) empiler ( P , x ) Question 4 : Enonc\u00e9 Solution L\u2019 objectif de cette question est de trier une pile de cr\u00eapes . On mod\u00e9lise une pile de cr\u00eapes par une pile d\u2019entiers repr\u00e9sentant le diam\u00e8tre de chaque cr\u00eape. On souhaite r\u00e9ordonner les cr\u00eapes de la plus grande (plac\u00e9e en bas de la pile) \u00e0 la plus petite (plac\u00e9e en haut de la pile). On dispose uniquement d\u2019une spatule que l\u2019on peut ins\u00e9rer dans la pile de cr\u00eapes de fa\u00e7on \u00e0 retourner l\u2019ensemble des cr\u00eapes qui lui sont au-dessus. Le principe est le suivant : On recherche la plus grande cr\u00eape. On retourne la pile \u00e0 partir de cette cr\u00eape de fa\u00e7on \u00e0 mettre cette plus grande cr\u00eape tout en haut de la pile. On retourne l\u2019ensemble de la pile de fa\u00e7on \u00e0 ce que cette plus grande cr\u00eape se retrouve tout en bas. La plus grande cr\u00eape \u00e9tant \u00e0 sa place, on recommence le principe avec le reste de la pile Exemple : Cr\u00e9er la fonction tri_crepes ayant pour param\u00e8tre une pile P. Cette fonction trie la pile P selon la m\u00e9thode du tri cr\u00eapes et ne renvoie rien. On utilisera les fonctions cr\u00e9\u00e9es dans les questions pr\u00e9c\u00e9dentes. Exemple : Si la pile P est apr\u00e8s l\u2019appel de tri_crepes(P) , la pile P devient \ud83d\udc0d Script Python def tri_crepes ( P ): N = hauteur_pile ( P ) i = N while i > 1 : j = max_pile ( P , i ) retourner ( P , j ) retourner ( P , i ) i -= 1 Sujet M\u00e9tropole 7 Juin 2021 - Exercice 2 Cet exercice traite des notions de piles et de programmation orient\u00e9e objet. On cr\u00e9e une classe Pile qui mod\u00e9lise la structure d'une pile d'entiers. Le constructeur de la classe initialise une pile vide. La d\u00e9finition de cette classe sans l\u2019impl\u00e9mentation de ses m\u00e9thodes est donn\u00e9e ci-dessous. \ud83d\udc0d Script Python class Pile : def __init__ ( self ): \"\"\"Initialise la pile comme une pile vide.\"\"\" def est_vide ( self ): \"\"\"Renvoie True si la liste est vide, False sinon.\"\"\" def empiler ( self , e ): \"\"\"Ajoute l'\u00e9l\u00e9ment e sur le sommet de la pile, ne renvoie rien.\"\"\" def depiler ( self ): \"\"\"Retire l\u2019\u00e9l\u00e9ment au sommet de la pile et le renvoie.\"\"\" def nb_elements ( self ): \"\"\"Renvoie le nombre d'\u00e9l\u00e9ments de la pile. \"\"\" def afficher ( self ): \"\"\"Affiche de gauche \u00e0 droite les \u00e9l\u00e9ments de la pile, du fond de la pile vers son sommet. Le sommet est alors l\u2019\u00e9l\u00e9ment affich\u00e9 le plus \u00e0 droite. Les \u00e9l\u00e9ments sont s\u00e9par\u00e9s par une virgule. Si la pile est vide la m\u00e9thode affiche \u00ab pile vide \u00bb.\"\"\" Seules les m\u00e9thodes de la classe ci-dessus doivent \u00eatre utilis\u00e9es pour manipuler les objets Pile. 1.a Enonc\u00e9 Solution \u00c9crire une suite d\u2019instructions permettant de cr\u00e9er une instance de la classe Pile affect\u00e9e \u00e0 une variable pile1 contenant les \u00e9l\u00e9ments 7, 5 et 2 ins\u00e9r\u00e9s dans cet ordre. Ainsi, \u00e0 l\u2019issue de ces instructions, l\u2019instruction pile1.afficher() produit l\u2019affichage : 7, 5, 2. \ud83d\udccb Texte pile1 = Pile() pile1.empiler(7) pile1.empiler(5) pile1.empiler(2) 1.b Enonc\u00e9 Solution Donner l\u2019affichage produit apr\u00e8s l\u2019ex\u00e9cution des instructions suivantes. \ud83d\udccb Texte element1 = pile1.depiler() pile1.empiler(5) pile1.empiler(element1) pile1.afficher() 7,5,5,2 2. Enonc\u00e9 Solution On donne la fonction mystere suivante : \ud83d\udc0d Script Python def mystere ( pile , element ): pile2 = Pile () nb_elements = pile . nb_elements () for i in range ( nb_elements ): elem = pile . depiler () pile2 . empiler ( elem ) if elem == element : return pile2 return pile2 a. Dans chacun des quatre cas suivants, quel est l\u2019affichage obtenu dans la console ? Cas n\u00b01 \ud83d\udc0d Script Python >>> pile . afficher () 7 , 5 , 2 , 3 >>> mystere ( pile , 2 ) . afficher () Cas n\u00b02 \ud83d\udc0d Script Python >>> pile . afficher () 7 , 5 , 2 , 3 >>> mystere ( pile , 9 ) . afficher () Cas n\u00b03 \ud83d\udc0d Script Python >>> pile . afficher () 7 , 5 , 2 , 3 >>> mystere ( pile , 3 ) . afficher () Cas n\u00b04 \ud83d\udc0d Script Python >>> pile . est_vide () True >>> mystere ( pile , 3 ) . afficher () b. Expliquer ce que permet d\u2019obtenir la fonction mystere . a) cas n\u00b01 : 3, 2 cas n\u00b02 : 3, 2, 5, 7 cas n\u00b03 : 3 cas n\u00b04 : pile vide b) La fonction mystere renvoie une pile qui contiendra tous les \u00e9l\u00e9ments de la pile pass\u00e9e en param\u00e8tre (pile) \u00e0 condition qu\u2019ils soient situ\u00e9s au-dessus de l\u2019\u00e9l\u00e9ment pass\u00e9 en param\u00e8tre (element). L\u2019\u00e9l\u00e9ment element sera lui aussi pr\u00e9sent dans la pile renvoy\u00e9e par la fonction. 3. Enonc\u00e9 Solution \u00c9crire une fonction etendre(pile1, pile2) qui prend en arguments deux objets Pile appel\u00e9s pile1 et pile2 et qui modifie pile1 en lui ajoutant les \u00e9l\u00e9ments de pile2 rang\u00e9s dans l'ordre inverse. Cette fonction ne renvoie rien. On donne ci-dessous les r\u00e9sultats attendus pour certaines instructions. \ud83d\udc0d Script Python >>> pile1 . afficher () 7 , 5 , 2 , 3 >>> pile2 . afficher () 1 , 3 , 4 >>> etendre ( pile1 , pile2 ) >>> pile1 . afficher () 7 , 5 , 2 , 3 , 4 , 3 , 1 >>> pile2 . est_vide () True \ud83d\udc0d Script Python def etendre ( pile1 , pile2 ): while not pile2 . est_vide (): x = pile2 . depiler () pile1 . empiler ( x ) 4. Enonc\u00e9 Solution \u00c9crire une fonction supprime_toutes_occurences(pile, element) qui prend en arguments un objet Pile appel\u00e9 pile et un \u00e9l\u00e9ment element et supprime tous les \u00e9l\u00e9ments element de pile. On donne ci-dessous les r\u00e9sultats attendus pour certaines instructions. \ud83d\udc0d Script Python >>> pile . afficher () 7 , 5 , 2 , 3 , 5 >>> supprime_toutes_occurences ( pile , 5 ) >>> pile . afficher () 7 , 2 , 3 \ud83d\udc0d Script Python def supprime_toutes_occurences ( pile , element ): p2 = Pile () while not pile . est_vide (): x = pile . depiler () if x != element : p2 . empiler ( x ) while not p2 . est_vide (): x = p2 . depiler () pile . empiler ( x ) Sujet Centres-Etrangers 2021 - Exercice 5 Notion abord\u00e9e : structures de donn\u00e9es : les piles. Dans cet exercice, on consid\u00e8re une pile d'entiers positifs. On suppose que les quatre fonctions suivantes ont \u00e9t\u00e9 programm\u00e9es pr\u00e9alablement en langage Python : \ud83d\udc0d Script Python empiler ( P , e ) : ajoute l '\u00e9l\u00e9ment e sur la pile P ; depiler ( P ) : enl\u00e8ve le sommet de la pile P et retourne la valeur de ce sommet ; est_vide ( P ) : retourne True si la pile est vide et False sinon ; creer_pile () : retourne une pile vide . Dans cet exercice, seule l'utilisation de ces quatre fonctions sur la structure de donn\u00e9es pile est autoris\u00e9e. 1. Enonc\u00e9 Solution Recopier le sch\u00e9ma ci-dessous et le compl\u00e9ter sur votre copie en ex\u00e9cutant les appels de fonctions donn\u00e9s. On \u00e9crira ce que renvoie la fonction utilis\u00e9e dans chaque cas, et on indiquera None si la fonction ne retourne aucune valeur. 2. Enonc\u00e9 Solution On propose la fonction ci-dessous, qui prend en argument une pile P et renvoie un couple de piles : \ud83d\udc0d Script Python def transforme ( P ) : Q = creer_pile () while not est_vide ( P ) : v = depile ( P ) empile ( Q , v ) return ( P , Q ) Recopier et compl\u00e9ter sur votre copie le document ci-dessous 3. Enonc\u00e9 Solution Ecrire une fonction en langage Python maximum(P) recevant une pile P comme argument et qui renvoie la valeur maximale de cette pile. On ne s\u2019interdit pas qu\u2019apr\u00e8s ex\u00e9cution de la fonction, la pile soit vide. On souhaite conna\u00eetre le nombre d\u2019\u00e9l\u00e9ments d\u2019une pile \u00e0 l\u2019aide de la fonction taille(P) \ud83d\udc0d Script Python def maximum ( P ): m = depiler ( P ) while not est_vide ( P ): v = depiler ( P ) if v > m : m = v return m 4. Enonc\u00e9 Solution a Solution b a. Proposer une strat\u00e9gie \u00e9crite en langage naturel et/ou expliqu\u00e9e \u00e0 l\u2019aide de sch\u00e9mas, qui permette de mettre en place une telle fonction. b. Donner le code Python de cette fonction taille(P) (on pourra utiliser les cinq fonctions d\u00e9j\u00e0 programm\u00e9es). Il suffit de mettre place une boucle qui s'arr\u00eatera quand la pile P sera vide. \u00c0 chaque tour de boucle, on d\u00e9pile P, on empile les valeurs pr\u00e9c\u00e9demment d\u00e9pil\u00e9es dans une pile auxiliaire Q et on incr\u00e9mente un compteur de 1. Une fois la boucle termin\u00e9e, on cr\u00e9e une nouvelle boucle o\u00f9 on d\u00e9pile Q et on empile P avec les valeurs d\u00e9pil\u00e9es (l\u2019id\u00e9e est de retrouver l\u2019\u00e9tat originel de pile. Il suffit ensuite de renvoyer la valeur du compteur. \ud83d\udc0d Script Python def taille ( P ): cmp = 0 Q = creer_pile () while not est_vide ( P ): v = depiler ( P ) empiler ( Q , v ) cmp = cmp + 1 while not est_vide ( Q ): v = depiler ( Q ) empiler ( P , v ) return cmp","title":"TD13 Piles"},{"location":"StructureDonnees/TD13_Piles_Corrige/","text":"TD n\u00b013 : Structures de donn\u00e9es - Les Piles Th\u00e8me 1 : Structures de donn\u00e9es COURS et EXERCICES Les piles et les files sont deux structures de donn\u00e9es lin\u00e9aires qui permettent, au m\u00eame titre que les listes, de g\u00e9rer des s\u00e9quences d\u2019\u00e9l\u00e9ments. Ainsi, dans une pile et dans une file chaque \u00e9l\u00e9ment est \u00e9ga- lement rep\u00e9r\u00e9 par sa position, il y a un premier, un dernier, chaque \u00e9l\u00e9ment a un successeur (sauf le premier) et un pr\u00e9d\u00e9cesseur (sauf le dernier). Les op\u00e9rations disponibles pour ces deux structures sont assez proches car dans les deux cas, on veut pouvoir : cr\u00e9er une pile/file vide conna\u00eetre sa taille lui ajouter un \u00e9l\u00e9ment lui retirer un \u00e9l\u00e9ment acc\u00e9der \u00e0 un \u00e9l\u00e9ment particulier Cependant, la politique d\u2019ajout/retrait des \u00e9l\u00e9ments dans la s\u00e9quence n\u2019est pas la m\u00eame. Le nom des op\u00e9rations diff\u00e8rent \u00e9galement pour mieux distinguer les deux structures. I. Les Piles Il faut se repr\u00e9senter une pile comme. . . une pile de livres ! Seul le livre dispos\u00e9 sur le dessus est accessible : l\u2019ajout et le retrait d\u2019un livre ne peut donc se faire que sur le sommet de la pile. \u27a1 Interface d'une pile \u2693\ufe0e Interface d'une pile Le jeu d'op\u00e9rations disponibles pour une pile est : construire_pile() : cr\u00e9e une pile vide taille(P) : acc\u00e8s au nombre d'\u00e9l\u00e9ments dans la pile P empiler(P, e) : ajoute l'\u00e9l\u00e9ment e au sommet de la pile P . depiler(P) : retire l'\u00e9l\u00e9ment au sommet de la pile P . Pr\u00e9condition : P n'est pas vide. sommet(P) : pour acc\u00e9der (en lecture) au sommet de la pile P (sans le retirer de la pile). Pr\u00e9condition : P n'est pas vide. En anglais, l'op\u00e9ration empiler est souvent not\u00e9e push , l'op\u00e9ration depiler est souvent not\u00e9e pop et l'op\u00e9ration taille est souvent not\u00e9e top . Remarque : Certaines signatures algorithmiques peuvent l\u00e9g\u00e8rement varier. Par exemple, on peut parfois voir l'op\u00e9ration est_vide (qui teste si une pile est vide) \u00e0 la place de taille (une pile est vide si et seulement si sa taille vaut 0) ou encore l'op\u00e9ration depiler qui renvoie \u00e9galement le sommet (donc l'op\u00e9ration sommet n'est plus n\u00e9cessaire). C'est un choix libre qui ne change pas la nature de la structure de donn\u00e9es abstraite mais la fa\u00e7on d'\u00e9crire des algorithmes. \u27a1 Repr\u00e9sentation d'une pile et exemple \u2693\ufe0e Une pile contenant les \u00e9l\u00e9ments \\(\\text{'a'}\\) , \\(\\text{'b'}\\) et \\(\\text{'c'}\\) ( \\(\\text{'a'}\\) \u00e9tant le sommet et donc \\(\\text{'c'}\\) le fond de la pile) sera repr\u00e9sent\u00e9e : \\[\\text{>'a', 'b', 'c']}\\] Exemple On consid\u00e8re la pile P : \\(\\text{>'a', 'b', 'c']}\\) . Voici comment la manipuler : Op\u00e9ration Contenu de la pile empiler(P, 'e') \\(\\text{>'e', 'a', 'b', 'c']}\\) depiler(P) \\(\\text{>'a', 'b', 'c']}\\) depiler(P) \\(\\text{>'b', 'c']}\\) sommet(P) renvoie \\(\\text{'b'}\\) depiler(P) \\(\\text{>'c']}\\) empiler(P, 'm') \\(\\text{>'m', 'c']}\\) taille(P) renvoie 2 \u27a1 Applications des piles \u2693\ufe0e Les piles sont tr\u00e8s utilis\u00e9es en informatique. Voici quelques usages caract\u00e9ristiques : Les algorithmes r\u00e9cursifs utilisent une pile d'appel pour m\u00e9moriser les contextes d'ex\u00e9cution de chaque appel. (d\u00e9j\u00e0 abord\u00e9) Dans un navigateur web, une pile sert \u00e0 m\u00e9moriser les pages Web visit\u00e9es. L'adresse de chaque nouvelle page visit\u00e9e est empil\u00e9e et l'utilisateur d\u00e9pile l'adresse courante pour acc\u00e9der \u00e0 la page pr\u00e9c\u00e9dente en cliquant le bouton \u00ab Afficher la page pr\u00e9c\u00e9dente \u00bb. La fonction \u00ab Annuler la frappe \u00bb (en anglais Undo, le c\u00e9l\u00e8bre CTRL+F) d'un traitement de texte m\u00e9morise les modifications apport\u00e9es au texte dans une pile. On peut aussi utiliser une pile pour parcourir (en profondeur) un graphe et m\u00e9moriser les sommets visit\u00e9s. (voir Th\u00e8me 5 : Algorithmique) La v\u00e9rification du bon parenth\u00e9sage d'une expression peur \u00e9galement se faire \u00e0 l'aide d'une pile. etc. \u27a1 Impl\u00e9mentations \u2693\ufe0e Une pile est g\u00e9n\u00e9ralement impl\u00e9ment\u00e9e par : un tableau (redimensionnable ou non) ou par une liste cha\u00een\u00e9e. Selon le cas, il faudra veiller \u00e0 ce que l'impl\u00e9mentation soit la plus efficace possible. Si on utilise un tableau, les op\u00e9rations empiler et depiler seront plus efficaces si elles se font \u00e0 la fin du tableau plut\u00f4t qu'au d\u00e9but car cela ne n\u00e9cessite pas de d\u00e9caler les autres \u00e9l\u00e9ments. En revanche, si on utilise une liste cha\u00een\u00e9e, elles seront plus efficaces si elles ont lieu au d\u00e9but (car pour acc\u00e9der au dernier \u00e9l\u00e9ment il faut parcourir tous les \u00e9l\u00e9ments de proche en proche \u00e0 partir du premier qui est le seul accessible). II. Exercices sur les piles Activit\u00e9 1 : Manipulation des piles On consid\u00e8re la s\u00e9quence d'instructions suivantes. Indiquez le r\u00e9sultat \u00e0 chaque \u00e9tape. \ud83d\udccb Texte P = construire_pile() empiler(P, 1) empiler(P, 2) empiler(P, 3) s = sommet(P) depiler(P) depiler(P) empiler(P, s) Ecrivez la s\u00e9quence d'instructions permettant d'obtenir l'\u00e9volution suivante pour une pile P . Etat de la pile P Instructions ( \u00e0 compl\u00e9ter ) \\(\\text{>]}\\) \\(\\text{>3]}\\) \\(\\text{>1, 3]}\\) \\(\\text{>4, 1, 3]}\\) \\(\\text{>1, 3]}\\) \\(\\text{>3]}\\) \\(\\text{>]}\\) Activit\u00e9 2 : Premi\u00e8re impl\u00e9mentation d'une pile (avec le type `list` de Python) Interface On d\u00e9finit le type abstrait Pile par ses op\u00e9rations : cr\u00e9ation de pile vide empiler : ajout au sommet depiler : retrait du sommet sommet : acc\u00e8s (en lecture) au sommet taille : acc\u00e8s au nombre d'\u00e9l\u00e9ments L'objectif est d'impl\u00e9menter ce type abstrait en utilisant le type pr\u00e9d\u00e9fini list de Python (tableau dynamique = redimensionnable). Les \u00e9l\u00e9ments sont ajouter/retirer \u00e0 la fin pour des raisons d'efficacit\u00e9. Vous utiliserez le paradigme objet. Question 1 Enonc\u00e9 Solution Cr\u00e9ez une classe Pile impl\u00e9mentant ce type abstrait. Les objets de cette classe auront un attribut appel\u00e9 contenu qui est le contenu de la pile stock\u00e9 un objet list de Python. Indication : il faudra utiliser les m\u00e9thodes append et pop du type list . \ud83d\udc0d Script Python \ud83d\udc0d Script Python class Pile : def __init__ ( self ): self . contenu = [] def empiler ( self , e ): self . contenu . append ( e ) def depiler ( self ): if self . contenu != []: self . contenu . pop () def sommet ( self ): if self . contenu != []: return self . contenu [ - 1 ] def taille ( self ): return len ( self . contenu ) Question 2 Enonc\u00e9 Solution D\u00e9finissez la m\u00e9thode sp\u00e9ciale __repr__ pour afficher le contenu d'une pile comme une list Python. Attention : la m\u00e9thode __repr__ doit renvoyer une cha\u00eene de caract\u00e8res (conversion avec la fonction str ). \ud83d\udc0d Script Python \ud83d\udc0d Script Python class Pile : def __init__ ( self ): self . contenu = [] def empiler ( self , e ): self . contenu . append ( e ) def depiler ( self ): if self . contenu != []: self . contenu . pop () def sommet ( self ): if self . contenu != []: return self . contenu [ - 1 ] def taille ( self ): return len ( self . contenu ) def __repr__ ( self ): ch = \"\" for e in self . contenu : ch = str ( e ) + \",\" + ch # ne pas oublier de convertir les \u00e9l\u00e9ments en chaine de caract\u00e8res ch = ch [: - 1 ] # pour enlever la derni\u00e8re virgule ch = \">\" + ch + ']' return ch Question 3 Modifiez la m\u00e9thode __repr__ pour afficher les piles avec la notation du cours : \\(\\text{>...]}\\) . Attention \u00e0 l'odre des \u00e9l\u00e9ments, dans cette repr\u00e9sentation le sommet de la pile est \u00e0 gauche . \ud83d\udc0d Script Python Exemple on souhaite que le code \ud83d\udc0d Script Python P = Pile () print ( P ) P . empiler ( 'a' ) print ( P ) P . empiler ( 'c' ) print ( P ) P . empiler ( 'b' ) print ( P ) P . depiler () print ( P ) P . empiler ( 'z' ) print ( P ) produise l'affichage \ud83d\udccb Texte >] >a] >c,a] >b,c,a] >c,a] >z,c,a] Activit\u00e9 3 : Renverser un objet On souhaite renverser une liste en utilisant une pile. Renverser la liste [1, 2, 3] donne une nouvelle liste [3, 2, 1] . Question 1 : Proposez l'algorithme d'une fonction renverser permettant de renverser une liste en utilisant une pile. Question 2 Enonc\u00e9 Solution Ecrivez une fonction renverse(L) qui permet de renverser une liste L . def renverser(P): P1=Pile() for k in range(P.taille()): v=P.sommet() P.depiler() P1.empiler(v) \ud83d\udccb Texte return P1 \ud83d\udc0d Script Python #Test P = Pile () P . empiler ( 'a' ) P . empiler ( 'c' ) P . empiler ( 'b' ) P . depiler () P . empiler ( 'z' ) print ( P ) P = renverser ( P ) print ( P ) Activit\u00e9 4 : V\u00e9rifier le bon parenth\u00e9sage d'une expression Voici deux expressions mal parenth\u00e9s\u00e9es : \\(2(x-1)(4(x+3)\\) et \\(2(x-1))(4(x+3)\\) En voici une bien parenth\u00e9s\u00e9e : \\(3(x-1)(4(x+3)-2)\\) . On souhaite \u00e9crire une fonction verif_parenthesage(expression) qui renvoie Vrai si l'expression pass\u00e9e en argument est bien parenth\u00e9s\u00e9e et Faux sinon. On suppose que l'expression est une cha\u00eene de caract\u00e8res Sp\u00e9cification : Entr\u00e9e : une cha\u00eene de caract\u00e8res expression Sortie : un bool\u00e9en OK R\u00f4le : OK = Vrai si et seulement si le parenth\u00e9sage dans expression est correct Pr\u00e9condition : les caract\u00e8res \u00e0 tester sont ( et ) . Id\u00e9e de l'algorithme : On consulte les caract\u00e8res un \u00e0 un dans l'ordre de la cha\u00eene Si on voit une parenth\u00e8se ouvrante, il faut attendre pour trouver la fermante correspondante. On peut ajouter cette parenth\u00e8se ouvrante \u00e0 une pile en attendant de trouver la fermante correspondante. Si on voit une fermante, la derni\u00e8re ouvrante qui n'a pas encore \u00e9t\u00e9 associ\u00e9e , celle au sommet de la pile, doit normalement lui correspondre. Comme on a besoin de trouver la derni\u00e8re parenth\u00e8se ouvrante pas encore associ\u00e9e, une pile est appropri\u00e9e pour conserver les ouvrantes non encore associ\u00e9es car la derni\u00e8re se trouve alors au sommet de la pile (donc facilement accessible). Question 1 Proposez un jeu de tests de qualit\u00e9 pour cette fonction avec des assert . \ud83d\udc0d Script Python Question 2 Ecrivez une fonction verif_parenthesage(expression) qui convient. Elle doit passer tous les tests avec succ\u00e8s bien s\u00fbr. \ud83d\udc0d Script Python def verif_parenthesage ( expression ): OK = True P = Pile () # cr\u00e9ation pile vide # \u00e0 compl\u00e9ter # jeu de tests \u00e0 recopier ici Activit\u00e9 5 : Deuxi\u00e8me impl\u00e9mentation d'une pile (avec des listes cha\u00een\u00e9es) Importez la classe ListeChainee du TD 12 listechainee.py qui a \u00e9t\u00e9 cr\u00e9\u00e9 dans l'activit\u00e9 sur les listes cha\u00een\u00e9es puis impl\u00e9mentez une classe Pile par une liste cha\u00een\u00e9e. On rappelle que les op\u00e9rations d'ajout/retrait pour une liste cha\u00een\u00e9e sont efficaces au t\u00eate de liste. \ud83d\udc0d Script Python III. Exercices sur les piles - Sujet BAC Sujet z\u00e9ro - Exercice 1 Cet exercice porte sur la notion de pile et sur la programmation de base en Python. On rappelle qu\u2019une pile est une structure de donn\u00e9es abstraite fond\u00e9e sur le principe \u00ab dernier arriv\u00e9, premier sorti \u00bb : On munit la structure de donn\u00e9es Pile de quatre fonctions primitives d\u00e9finies dans le tableau ci-dessous. : Structure de donn\u00e9es abstraite : Pile Utilise : \u00c9l\u00e9ments, Bool\u00e9en Op\u00e9rations : creer_pile_vide : \u2205 \u2192 Pile creer_pile_vide() renvoie une pile vide est_vide : Pile \u2192 Bool\u00e9en est_vide(pile) renvoie True si pile est vide, False sinon empiler : Pile, \u00c9l\u00e9ment \u2192 Rien empiler(pile, element) ajoute element au sommet de la pile depiler : Pile \u2192 \u00c9l\u00e9ment depiler(pile) renvoie l\u2019\u00e9l\u00e9ment au sommet de la pile en le retirant de la pile Question 1 : Enonc\u00e9 Solution On suppose dans cette question que le contenu de la pile P est le suivant (les \u00e9l\u00e9ments \u00e9tant empil\u00e9s par le haut) : Quel sera le contenu de la pile Q apr\u00e8s ex\u00e9cution de la suite d\u2019instructions suivante ? \ud83d\udccb Texte 1 Q = creer_pile_vide () 2 while not est_vide ( P ): 3 empiler (Q , depiler ( P )) Question 2 : Enonc\u00e9 Solution 1 Solution 2 On appelle hauteur d\u2019une pile le nombre d\u2019\u00e9l\u00e9ments qu\u2019elle contient. La fonction hauteur_pile prend en param\u00e8tre une pile P et renvoie sa hauteur. Apr\u00e8s appel de cette fonction, la pile P doit avoir retrouv\u00e9 son \u00e9tat d\u2019origine. Exemple : si P est la pile de la question 1 : hauteur_pile(P) = 4 . Recopier et compl\u00e9ter sur votre copie le programme Python suivant impl\u00e9mentant la fonction hauteur_pile en rempla\u00e7ant les ??? par les bonnes instructions. \ud83d\udccb Texte 1 def hauteur_pile ( P ): 2 Q = creer_pile_vide () 3 n = 0 4 while not ( est_vide ( P )): 5 ??? 6 x = depiler (P ) 7 empiler (Q ,x ) 8 while not ( est_vide ( Q )): 9 ??? 10 empiler (P , x ) 11 return ??? 2. Cr\u00e9er une fonction max_pile ayant pour param\u00e8tres une pile P et un entier i. Cette fonction renvoie la position j de l\u2019\u00e9l\u00e9ment maximum parmi les i derniers \u00e9l\u00e9ments empil\u00e9s de la pile P. Apr\u00e8s appel de cette fonction, la pile P devra avoir retrouv\u00e9 son \u00e9tat d\u2019origine. La position du sommet de la pile est 1. Exemple : si P est la pile de la question 1 : max_pile(P, 2) = 1 \ud83d\udc0d Script Python def hauteur_pile ( P ): Q = creer_pile_vide () n = 0 while not est_vide ( P ): n += 1 x = depiler ( P ) empiler ( Q , x ) while not est_vide ( Q ): x = depiler ( Q ) empiler ( P , x ) return n Explication \ud83d\udc0d Script Python Q = creer_pile_vide () n = 0 On initialise Q est vide et n = 0 \ud83d\udc0d Script Python while not est_vide ( P ): n += 1 x = depiler ( P ) empiler ( Q , x ) Maintenant il faut remettre la pile P \u00e0 l\u2019\u00e9tat initial, d\u2019o\u00f9 la deuxi\u00e8me partie du programme : \ud83d\udc0d Script Python while not est_vide ( Q ): x = depiler ( Q ) empiler ( P , x ) \ud83d\udc0d Script Python def max_pile ( P , i ): # si la pile comporte moins de i \u00e9l\u00e9ment ou que i=0 on renvoie 0 if i > hauteur_pile ( P ) or i == 0 : return 0 maxi = depiler ( P ) Q = creer_pile_vide () empiler ( Q , maxi ) j = 1 indice = 1 while j < i : j = j + 1 x = depiler ( P ) if x > maxi : maxi = x indice = j empiler ( Q , x ) while not est_vide ( Q ): empiler ( P , depiler ( Q )) return indice Question 3 : Enonc\u00e9 Solution Cr\u00e9er une fonction retourner ayant pour param\u00e8tres une pile P et un entier j. Cette fonction inverse l\u2019ordre des j derniers \u00e9l\u00e9ments empil\u00e9s et ne renvoie rien. On pourra utiliser deux piles auxiliaires. Exemple : si P est la pile de laquestion 1(a), apr\u00e8s l\u2019appel de retourner(P, 3), l\u2019\u00e9tat de la pile P sera : \ud83d\udc0d Script Python def retourner ( P , j ): Q1 = creer_pile_vide () Q2 = creer_pile_vide () i = 0 while not est_vide ( P ) and i < j : i = i + 1 x = depiler ( P ) empiler ( Q1 , x ) while not est_vide ( Q1 ): x = depiler ( Q1 ) empiler ( Q2 , x ) while not est_vide ( Q2 ): x = depiler ( Q2 ) empiler ( P , x ) Question 4 : Enonc\u00e9 Solution L\u2019 objectif de cette question est de trier une pile de cr\u00eapes . On mod\u00e9lise une pile de cr\u00eapes par une pile d\u2019entiers repr\u00e9sentant le diam\u00e8tre de chaque cr\u00eape. On souhaite r\u00e9ordonner les cr\u00eapes de la plus grande (plac\u00e9e en bas de la pile) \u00e0 la plus petite (plac\u00e9e en haut de la pile). On dispose uniquement d\u2019une spatule que l\u2019on peut ins\u00e9rer dans la pile de cr\u00eapes de fa\u00e7on \u00e0 retourner l\u2019ensemble des cr\u00eapes qui lui sont au-dessus. Le principe est le suivant : On recherche la plus grande cr\u00eape. On retourne la pile \u00e0 partir de cette cr\u00eape de fa\u00e7on \u00e0 mettre cette plus grande cr\u00eape tout en haut de la pile. On retourne l\u2019ensemble de la pile de fa\u00e7on \u00e0 ce que cette plus grande cr\u00eape se retrouve tout en bas. La plus grande cr\u00eape \u00e9tant \u00e0 sa place, on recommence le principe avec le reste de la pile Exemple : Cr\u00e9er la fonction tri_crepes ayant pour param\u00e8tre une pile P. Cette fonction trie la pile P selon la m\u00e9thode du tri cr\u00eapes et ne renvoie rien. On utilisera les fonctions cr\u00e9\u00e9es dans les questions pr\u00e9c\u00e9dentes. Exemple : Si la pile P est apr\u00e8s l\u2019appel de tri_crepes(P) , la pile P devient \ud83d\udc0d Script Python def tri_crepes ( P ): N = hauteur_pile ( P ) i = N while i > 1 : j = max_pile ( P , i ) retourner ( P , j ) retourner ( P , i ) i -= 1 Sujet M\u00e9tropole 7 Juin 2021 - Exercice 2 Cet exercice traite des notions de piles et de programmation orient\u00e9e objet. On cr\u00e9e une classe Pile qui mod\u00e9lise la structure d'une pile d'entiers. Le constructeur de la classe initialise une pile vide. La d\u00e9finition de cette classe sans l\u2019impl\u00e9mentation de ses m\u00e9thodes est donn\u00e9e ci-dessous. \ud83d\udc0d Script Python class Pile : def __init__ ( self ): \"\"\"Initialise la pile comme une pile vide.\"\"\" def est_vide ( self ): \"\"\"Renvoie True si la liste est vide, False sinon.\"\"\" def empiler ( self , e ): \"\"\"Ajoute l'\u00e9l\u00e9ment e sur le sommet de la pile, ne renvoie rien.\"\"\" def depiler ( self ): \"\"\"Retire l\u2019\u00e9l\u00e9ment au sommet de la pile et le renvoie.\"\"\" def nb_elements ( self ): \"\"\"Renvoie le nombre d'\u00e9l\u00e9ments de la pile. \"\"\" def afficher ( self ): \"\"\"Affiche de gauche \u00e0 droite les \u00e9l\u00e9ments de la pile, du fond de la pile vers son sommet. Le sommet est alors l\u2019\u00e9l\u00e9ment affich\u00e9 le plus \u00e0 droite. Les \u00e9l\u00e9ments sont s\u00e9par\u00e9s par une virgule. Si la pile est vide la m\u00e9thode affiche \u00ab pile vide \u00bb.\"\"\" Seules les m\u00e9thodes de la classe ci-dessus doivent \u00eatre utilis\u00e9es pour manipuler les objets Pile. 1.a Enonc\u00e9 \u00c9crire une suite d\u2019instructions permettant de cr\u00e9er une instance de la classe Pile affect\u00e9e \u00e0 une variable pile1 contenant les \u00e9l\u00e9ments 7, 5 et 2 ins\u00e9r\u00e9s dans cet ordre. Ainsi, \u00e0 l\u2019issue de ces instructions, l\u2019instruction pile1.afficher() produit l\u2019affichage : 7, 5, 2. 1.b Enonc\u00e9 Donner l\u2019affichage produit apr\u00e8s l\u2019ex\u00e9cution des instructions suivantes. \ud83d\udccb Texte element1 = pile1.depiler() pile1.empiler(5) pile1.empiler(element1) pile1.afficher() 2. Enonc\u00e9 On donne la fonction mystere suivante : \ud83d\udc0d Script Python def mystere ( pile , element ): pile2 = Pile () nb_elements = pile . nb_elements () for i in range ( nb_elements ): elem = pile . depiler () pile2 . empiler ( elem ) if elem == element : return pile2 return pile2 a. Dans chacun des quatre cas suivants, quel est l\u2019affichage obtenu dans la console ? Cas n\u00b01 \ud83d\udc0d Script Python >>> pile . afficher () 7 , 5 , 2 , 3 >>> mystere ( pile , 2 ) . afficher () Cas n\u00b02 \ud83d\udc0d Script Python >>> pile . afficher () 7 , 5 , 2 , 3 >>> mystere ( pile , 9 ) . afficher () Cas n\u00b03 \ud83d\udc0d Script Python >>> pile . afficher () 7 , 5 , 2 , 3 >>> mystere ( pile , 3 ) . afficher () Cas n\u00b04 \ud83d\udc0d Script Python >>> pile . est_vide () True >>> mystere ( pile , 3 ) . afficher () b. Expliquer ce que permet d\u2019obtenir la fonction mystere . 3. Enonc\u00e9 \u00c9crire une fonction etendre(pile1, pile2) qui prend en arguments deux objets Pile appel\u00e9s pile1 et pile2 et qui modifie pile1 en lui ajoutant les \u00e9l\u00e9ments de pile2 rang\u00e9s dans l'ordre inverse. Cette fonction ne renvoie rien. On donne ci-dessous les r\u00e9sultats attendus pour certaines instructions. \ud83d\udc0d Script Python >>> pile1 . afficher () 7 , 5 , 2 , 3 >>> pile2 . afficher () 1 , 3 , 4 >>> etendre ( pile1 , pile2 ) >>> pile1 . afficher () 7 , 5 , 2 , 3 , 4 , 3 , 1 >>> pile2 . est_vide () True 4. Enonc\u00e9 \u00c9crire une fonction supprime_toutes_occurences(pile, element) qui prend en arguments un objet Pile appel\u00e9 pile et un \u00e9l\u00e9ment element et supprime tous les \u00e9l\u00e9ments element de pile. On donne ci-dessous les r\u00e9sultats attendus pour certaines instructions. \ud83d\udc0d Script Python >>> pile . afficher () 7 , 5 , 2 , 3 , 5 >>> supprime_toutes_occurences ( pile , 5 ) >>> pile . afficher () 7 , 2 , 3 Sujet Centres-Etrangers 2021 - Exercice 5 Notion abord\u00e9e : structures de donn\u00e9es : les piles. Dans cet exercice, on consid\u00e8re une pile d'entiers positifs. On suppose que les quatre fonctions suivantes ont \u00e9t\u00e9 programm\u00e9es pr\u00e9alablement en langage Python : \ud83d\udc0d Script Python empiler ( P , e ) : ajoute l '\u00e9l\u00e9ment e sur la pile P ; depiler ( P ) : enl\u00e8ve le sommet de la pile P et retourne la valeur de ce sommet ; est_vide ( P ) : retourne True si la pile est vide et False sinon ; creer_pile () : retourne une pile vide . Dans cet exercice, seule l'utilisation de ces quatre fonctions sur la structure de donn\u00e9es pile est autoris\u00e9e. 1. Enonc\u00e9 Recopier le sch\u00e9ma ci-dessous et le compl\u00e9ter sur votre copie en ex\u00e9cutant les appels de fonctions donn\u00e9s. On \u00e9crira ce que renvoie la fonction utilis\u00e9e dans chaque cas, et on indiquera None si la fonction ne retourne aucune valeur. 2. Enonc\u00e9 On propose la fonction ci-dessous, qui prend en argument une pile P et renvoie un couple de piles : \ud83d\udc0d Script Python def transforme ( P ) : Q = creer_pile () while not est_vide ( P ) : v = depile ( P ) empile ( Q , v ) return ( P , Q ) Recopier et compl\u00e9ter sur votre copie le document ci-dessous 3. Enonc\u00e9 Ecrire une fonction en langage Python maximum(P) recevant une pile P comme argument et qui renvoie la valeur maximale de cette pile. On ne s\u2019interdit pas qu\u2019apr\u00e8s ex\u00e9cution de la fonction, la pile soit vide. On souhaite conna\u00eetre le nombre d\u2019\u00e9l\u00e9ments d\u2019une pile \u00e0 l\u2019aide de la fonction taille(P) 4. Enonc\u00e9 a. Proposer une strat\u00e9gie \u00e9crite en langage naturel et/ou expliqu\u00e9e \u00e0 l\u2019aide de sch\u00e9mas, qui permette de mettre en place une telle fonction. b. Donner le code Python de cette fonction taille(P) (on pourra utiliser les cinq fonctions d\u00e9j\u00e0 programm\u00e9es).","title":"TD13 Piles Corrige"},{"location":"StructureDonnees/TD14_Files/","text":"TD n\u00b014 : Structures de donn\u00e9es - Les Files Th\u00e8me 1 : Structures de donn\u00e9es COURS et EXERCICES Les piles et les files sont deux structures de donn\u00e9es lin\u00e9aires qui permettent, au m\u00eame titre que les listes, de g\u00e9rer des s\u00e9quences d\u2019\u00e9l\u00e9ments. Ainsi, dans une pile et dans une file chaque \u00e9l\u00e9ment est \u00e9ga- lement rep\u00e9r\u00e9 par sa position, il y a un premier, un dernier, chaque \u00e9l\u00e9ment a un successeur (sauf le premier) et un pr\u00e9d\u00e9cesseur (sauf le dernier). Les op\u00e9rations disponibles pour ces deux structures sont assez proches car dans les deux cas, on veut pouvoir : * cr\u00e9er une file vide * conna\u00eetre sa taille * lui ajouter un \u00e9l\u00e9ment * lui retirer un \u00e9l\u00e9ment * acc\u00e9der \u00e0 un \u00e9l\u00e9ment particulier Cependant, la politique d\u2019ajout/retrait des \u00e9l\u00e9ments dans la s\u00e9quence n\u2019est pas la m\u00eame. Le nom des op\u00e9rations diff\u00e8rent \u00e9galement pour mieux distinguer les deux structures. I. Les files Il faut se repr\u00e9senter une file comme... une file d'attente ! On ne peut entrer dans la file qu'en derni\u00e8re position et on ne peut la quitter que si on est le premier. L'ajout d'un \u00e9l\u00e9ment dans une file ne peut se faire qu'\u00e0 la fin (en derni\u00e8re position) et le retrait d'un \u00e9l\u00e9ment ne peut se faire qu'au d\u00e9but (en premi\u00e8re position). On dit que les files sont en mode FIFO ( First In, First Out qui signifie \u00ab premier entr\u00e9, premier sorti \u00bb). \u27a1 Interface d'une file Le jeu d'op\u00e9rations disponibles pour une file est : construire_file() : cr\u00e9e une file vide taille(F) : acc\u00e8s au nombre d'\u00e9l\u00e9ments dans la file F enfiler(F, e) : ajoute l'\u00e9l\u00e9ment e en dernier dans la file F . defiler(F) : retire le premier \u00e9l\u00e9ment de la file F . Pr\u00e9condition : F n'est pas vide. premier(F) : pour acc\u00e9der (en lecture) au premier \u00e9l\u00e9ment de la file F (sans le retirer de la file). Pr\u00e9condition : F n'est pas vide. En anglais, l'op\u00e9ration enfiler est souvent not\u00e9e push , l'op\u00e9ration depiler est souvent not\u00e9e pop et l'op\u00e9ration taille est souvent not\u00e9e top . Remarque : Comme pour les piles, on pourrait remplacer l'op\u00e9ration taille par l'op\u00e9ration est_vide et choisir que defiler renvoie \u00e9galement le premier \u00e9l\u00e9ment pour s'\u00e9conomiser l'op\u00e9ration premier . \u27a1 Repr\u00e9sentation d'une file et exemple \u2693\ufe0e Une file contenant les \u00e9l\u00e9ments \\(\\text{'a'}\\) , \\(\\text{'b'}\\) et \\(\\text{'c'}\\) ( \\(\\text{'a'}\\) \u00e9tant le premier et \\(\\text{'c'}\\) le dernier) sera repr\u00e9sent\u00e9e : \\[\\text{<'a', 'b', 'c'<}\\] Exemple : Voici comment manipuler une file F : Op\u00e9ration Contenu de la file F F = construire_file() \\(\\text{<<}\\) taille(F) renvoie 0 enfiler(F, 'a') \\(\\text{<'a'<}\\) enfiler(F, 'b') \\(\\text{<'a', 'b'<}\\) enfiler(F, 'c') \\(\\text{<'a', 'b', 'c'<}\\) premier(F) renvoie 'a' defiler(F) \\(\\text{<'b', 'c'<}\\) enfiler(F, premier(F)) \\(\\text{<'b', 'c', 'b'<}\\) \u27a1 Applications des files \u2693\ufe0e Les files sont tr\u00e8s utilis\u00e9es en informatique. Leur usage caract\u00e9ristique concerne les files d'attentes : Un syst\u00e8me d'exploitation g\u00e8re l'ordonnancement des processus par des files (voir Th\u00e8me 3 : Architectures mat\u00e9rielles, syst\u00e8mes d'exploitation et r\u00e9seaux) Une imprimante g\u00e8re les t\u00e2ches d'impression avec des files : chaque nouvelle t\u00e2che est ins\u00e9r\u00e9e dans une file d'attente, et celles-ci sont trait\u00e9es dans l'ordre d'arriv\u00e9e. On peut aussi utiliser une pile pour parcourir (en profondeur) un graphe et m\u00e9moriser les sommets visit\u00e9s. (voir Th\u00e8me 5 : Algorithmique) etc. II. Exercices sur les files Activit\u00e9 1 : Manipulation des files Question 1. On consid\u00e8re la s\u00e9quence d\u2019instructions suivantes. Indiquez le r\u00e9sultat \u00e0 chaque \u00e9tape. \ud83d\udccb Texte - F = construire_file() - enfiler(F, 1) - enfiler(F, 2) - enfiler(F, 3) - s = premier(F) - defiler(F) - defiler(F) - enfiler(F, s) Question 2. \u00c9crivez la s\u00e9quence d\u2019instructions permettant d\u2019obtenir l\u2019\u00e9volution suivante pour une file F. Etat de la pile P Instructions ( \u00e0 compl\u00e9ter ) \\(\\text{<<}\\) \\(\\text{<3<}\\) \\(\\text{<3 , 1<}\\) \\(\\text{<3 , 1 , 4<}\\) \\(\\text{<1 , 4<}\\) \\(\\text{<4<}\\) \\(\\text{<<}\\) \u27a1 Impl\u00e9mentations \u2693\ufe0e Il existe diff\u00e9rentes fa\u00e7ons d'impl\u00e9menter une file, on peut par exemple utiliser : un tableau (redimensionnable ou non) une liste cha\u00een\u00e9e deux piles Avec ces impl\u00e9mentations, il faudra en g\u00e9n\u00e9ral faire un compromis sur l'efficacit\u00e9 des op\u00e9rations car celles-ci n\u00e9cessitent de travailler sur les deux extr\u00e9mit\u00e9s de la file (pour enfiler/d\u00e9filer). Si on utilise un tableau, les op\u00e9rations en d\u00e9but sont co\u00fbteuses et celles \u00e0 la fin ne le sont pas. On peut alors d\u00e9cider d'enfiler en fin de tableau (peu co\u00fbteux) mais il faudra d\u00e9filer en d\u00e9but de tableau (co\u00fbteux). Si on fait le choix inverse, c'est l'op\u00e9ration defiler qui sera peu co\u00fbteuse et l'op\u00e9ration enfiler qui sera co\u00fbteuse. Si on utilise une liste cha\u00een\u00e9e, c'est l'inverse (efficace en t\u00eate et co\u00fbteux en queue) mais le probl\u00e8me reste le m\u00eame : une des deux op\u00e9rations sera moins efficace. Il existe en r\u00e9alit\u00e9 une impl\u00e9mentation plus efficace mais nous n'en parlerons pas ici. Activit\u00e9 2 : Premi\u00e8re impl\u00e9mentation d'une file (avec le type `list` de Python) On d\u00e9finit le type abstrait File par les op\u00e9rations : cr\u00e9ation d\u2019une file vide enfiler : ajout en queue de file defiler : retrait du premier \u00e9lement de la file premier : acc\u00e8s (en lecture) au premier \u00e9l\u00e9ment de la file taille : acc\u00e8s au nombre d\u2019\u00e9l\u00e9ments L\u2019objectif est d\u2019impl\u00e9menter ce type abstrait en utilisant le type pr\u00e9d\u00e9fini list de Python (tableau dynamique = redimensionnable). On choisira d\u2019enfiler en fin de list (efficace) et de d\u00e9filer en d\u00e9but de list (co\u00fbteux). On aurait tr\u00e8s bien pu faire l\u2019inverse, mais l\u2019une des deux op\u00e9rations (enfiler ou d\u00e9filer) ne peut pas \u00eatre en temps constant avec le type list. Pour une \u00e9valuation de la complexit\u00e9 des op\u00e9rations \u00e9l\u00e9mentaires de Python voir le site : Python.org - Time complexity. Question 1 : Consultez les m\u00e9thodes disponibles sur le type list de Python pour trouver comment retirer un \u00e9l\u00e9ment en t\u00eate de liste (vous devriez savoir comment ajouter en fin de liste !). Quelle est la m\u00e9thode \u00e0 utiliser ? Question 2 : Enonc\u00e9 Solution Ecrivez une classe File impl\u00e9mentant les op\u00e9rations du type abstrait file avec les list de Python. Vous utiliserez la m\u00e9thode __len__ pour renvoyer la longueur d\u2019une file. Exemple : on veut que le code \ud83d\udccb Texte F = File() print(F) F.enfiler(1) print(F) F.enfiler(2) print(F) F.enfiler(3) print(F) s = F.premier() print(s) F.defiler() print(F) F.defiler() print(F) F.enfiler(s) print(F) produise l\u2019affichage \ud83d\udccb Texte <<> <1< <1,2< <1,2,3< 1 <2, 3< <3< <3,1< \ud83d\udc0d Script Python \ud83d\udc0d Script Python class File : def __init__ ( self ): self . contenu = [] def enfiler ( self , element ): self . contenu . append ( element ) def defiler ( self ): assert self . taille () != 0 , \"on ne peut pas d\u00e9filer une file vide\" self . contenu . pop ( 0 ) # ou return self.contenu.pop(0) si l'op\u00e9ration d\u00e9filer doit aussi renvoyer le sommet def premier ( self ): assert self . taille () != 0 , \"une file vide n'a pas de premier \u00e9l\u00e9ment\" return self . contenu [ 0 ] def taille ( self ): return len ( self . contenu ) __len__ = taille # pour pouvoir \u00e9galement utiliser len pour obtenir la longueur d'une file # pour repr\u00e9senter une file def __repr__ ( self ): ch = \"\" for e in self . contenu : ch = ch + str ( e ) + \",\" ch = ch [: - 1 ] # pour enlever la derni\u00e8re virgule ch = \"<\" + ch + \"<\" return ch Question 3 : D\u00e9finissez la m\u00e9thode sp\u00e9ciale __repr__ pour afficher le contenu d\u2019une file comme unelist de Python. Attention : la m\u00e9thode __repr__ doit renvoyer une cha\u00eene de caract\u00e8res (conversion avec la fonction str) Exemple : on veut que le code \ud83d\udccb Texte F = File() print(F) F.enfiler(1) print(F) F.enfiler(2) print(F) F.enfiler(3) print(F) s = F.premier() print(s) F.defiler() print(F) F.defiler() print(F) F.enfiler(s) print(F) produise l\u2019affichage \ud83d\udccb Texte << <1< <1,2< <1,2,3< 1 <2, 3< <3< <3,1< \ud83d\udc0d Script Python Activit\u00e9 3 : Deuxi\u00e8me impl\u00e9mentation d\u2019une file (avec deux piles) On veut r\u00e9aliser une impl\u00e9mentation objet d\u2019une file en utilisant deux piles. Vous utiliserez l\u2019impl\u00e9mentation suivante d\u2019une pile pour travailler \ud83d\udc0d Script Python class Pile : def __init__ ( self ): self . contenu = [] def empiler ( self , e ): self . contenu . append ( e ) def depiler ( self ): assert self . taille != 0 , \"on ne peut pas d\u00e9piler une pile vide\" self . contenu . pop () def sommet ( self ): assert self . taille != 0 , \"une pile vide n\u2019a pas de sommet\" return self . contenu [ - 1 ] def taille ( self ): return len ( self . contenu ) # pour repr\u00e9senter la Pile def __repr__ ( self ): ch = '' for e in self . contenu : ch = str ( e ) + \",\" + ch # ne pas oublier de convertir les \u00e9l\u00e9ments en\u2423chaine de caract\u00e8res ch = ch [: - 1 ] # pour enlever la derni\u00e8re virgule ch = '>' + ch + ']' return ch Pour simplifier, l\u2019op\u00e9ration defiler renverra \u00e9galement le premier \u00e9l\u00e9ment (en plus de le retirer de la file). L\u2019op\u00e9ration premier n\u2019est alors plus n\u00e9cessaire. Vous devez donc impl\u00e9menter une classe File permettant les op\u00e9rations suivantes : cr\u00e9ation d\u2019une file vide enfiler : ajout en queue de file defiler : renvoie le premier \u00e9lement de la file et retire cet \u00e9l\u00e9ment de la file len : acc\u00e8s au nombre d\u2019\u00e9l\u00e9ments Aide : Op\u00e9ration enfiler (simple) : C\u2019est toujours dans l\u2019une des deux piles (par exemple pA) que l\u2019on empile un nouvel \u00e9l\u00e9ment \u00e0 enfiler. Op\u00e9ration defiler (compliqu\u00e9e) : Si l\u2019autre pile (pB) n\u2019est pas vide, son sommet est le premier \u00e9l\u00e9ment de la file (celui \u00e0 d\u00e9filer) Sinon (si pB est vide), le premier \u00e9l\u00e9ment de la file (celui \u00e0 d\u00e9filer) est au fond de pA. On peut alors \u201cretourner\u201d pA sur pB pour le premier \u00e9l\u00e9ment de la file arrive au sommet de pB. Op\u00e9ration len (simple) : il suffit d\u2019utiliser la m\u00e9thode taille d\u00e9finie dans la classe Pile. Question : Enonc\u00e9 Solution Compl\u00e9tez les m\u00e9thodes enfiler, len et defiler de la classe File suivante qui impl\u00e9mente une file avec deux piles. \ud83d\udc0d Script Python class File : \"\"\"File avec deux piles\"\"\" def __init__ ( self ): self . pA = Pile () # pA et pB sont les deux attributs de nos objets de la classe File self . pB = Pile () def enfiler ( self , e ): # \u00e0 compl\u00e9ter pass def __len__ ( self ): # \u00e0 compl\u00e9ter pass def defiler ( self ): if self . pA . taille () == 0 and self . pB . taille () == 0 : raise ValueError ( \"on ne peut pas d\u00e9filer une file vide\" ) # \u00e0 compl\u00e9ter # La m\u00e9thode __repr__ est d\u00e9finie pour que vous puissiez voir l\u2019\u00e9tat d\u2019une file def __repr__ ( self ): import copy #print(\"pile A : \", repr(self.pA)) # pour voir le contenu des deux piles #print(\"pile B : \", repr(self.pB)) lstA = copy . copy ( self . pA . contenu ) # copie des list Python repr\u00e9sentant nos deux piles lstB = copy . copy ( self . pB . contenu ) # pour ne pas les modifier lstB . reverse () # on a besoin de renverser lstB pour avoir nos \u00e9l\u00e9ments dans l\u2019ordre d\u2019entr\u00e9e lst = lstB + lstA # et de concat\u00e9ner lstB et lstA dans cet ordre # on construit ensuite la chaine \"<...<\" qui repr\u00e9sente nos files ch = \"\" for e in lst : ch = ch + str ( e ) + \",\" ch = ch [: - 1 ] # pour enlever la derni\u00e8re virgule ch = \"<\" + ch + \"<\" return ch \ud83d\udc0d Script Python \ud83d\udc0d Script Python class Pile : def __init__ ( self ): self . contenu = [] def empiler ( self , e ): self . contenu . append ( e ) def depiler ( self ): assert self . taille != 0 , \"on ne peut pas d\u00e9piler une pile vide\" self . contenu . pop () def sommet ( self ): assert self . taille != 0 , \"une pile vide n\u2019a pas de sommet\" return self . contenu [ - 1 ] def taille ( self ): return len ( self . contenu ) # pour repr\u00e9senter la Pile def __repr__ ( self ): ch = \"\" for e in self . contenu : ch = str ( e ) + \",\" + ch # ne pas oublier de convertir les \u00e9l\u00e9ments en chaine de caract\u00e8res ch = ch [: - 1 ] # pour enlever la derni\u00e8re virgule ch = \">\" + ch + ']' return ch class File : \"\"\"File avec deux piles\"\"\" def __init__ ( self ): self . pA = Pile () # pA et pB sont les deux attributs de nos objets de la classe File self . pB = Pile () def enfiler ( self , e ): return self . pA . empiler ( e ) def __len__ ( self ): return self . pA . taille () + self . pB . taille () def defiler ( self ): if self . pA . taille () == 0 and self . pB . taille () == 0 : raise ValueError ( \"on ne peut pas d\u00e9filer une file vide\" ) # La m\u00e9thode __repr__ est d\u00e9finie pour que vous puissiez voir l\u2019\u00e9tat d\u2019une file else : if self . pB . taille () == 0 : for x in range ( self . pA . taille () - 1 ): self . pB . empiler ( self . pA . sommet ()) self . pA . depiler () self . pA . depiler () print ( 'pA' , self . pA ) print ( 'pB1' , self . pB ) else : self . pB . depiler () def __repr__ ( self ): import copy #print(\"pile A : \", repr(self.pA)) # pour voir le contenu des deux piles #print(\"pile B : \", repr(self.pB)) lstA = copy . copy ( self . pA . contenu ) # copie des list Python repr\u00e9sentant nos deux piles lstB = copy . copy ( self . pB . contenu ) # pour ne pas les modifier lstB . reverse () # on a besoin de renverser lstB pour avoir nos \u00e9l\u00e9ments dans l\u2019ordre d\u2019entr\u00e9e lst = lstB + lstA # et de concat\u00e9ner lstB et lstA dans cet ordre # on construit ensuite la chaine \"<...<\" qui repr\u00e9sente nos files ch = \"\" for e in lst : ch = ch + str ( e ) + \",\" ch = ch [: - 1 ] # pour enlever la derni\u00e8re virgule ch = \"<\" + ch + \"<\" return ch III. Sujet BAC sur les files M\u00e9tropole Juin 2021 - Sujet 2 Cet exercice porte sur les structures de donn\u00e9es lin\u00e9aires Une m\u00e9thode simple pour g\u00e9rer l'ordonnancement des processus est d'ex\u00e9cuter les processus en une seule fois et dans leur ordre d'arriv\u00e9e. Question 1 Enonc\u00e9 Solution Parmi les propositions suivantes, quelle est la structure de donn\u00e9es la plus appropri\u00e9e pour mettre en \u0153uvre le mode FIFO (First In First Out) ? a. liste b. dictionnaire c. pile d. file r\u00e9ponse d une file Question 2 Enonc\u00e9 Solution On choisit de stocker les donn\u00e9es des processus en attente \u00e0 l'aide d'une liste Python lst. On dispose d\u00e9j\u00e0 d'une fonction retirer(lst) qui renvoie l'\u00e9l\u00e9ment lst[0] puis le supprime de la liste lst . \u00c9crire en Python le code d'une fonction ajouter(lst, proc) qui ajoute \u00e0 la fin de la liste lst le nouveau processus en attente proc . \ud83d\udc0d Script Python def ajouter ( lst , proc ): lst . append ( proc ) On choisit maintenant d'impl\u00e9menter une file file \u00e0 l'aide d'un couple ( p1,p2) o\u00f9 p1 et p2 sont des piles. Ainsi file[0] et file[1] sont respectivement les piles p1 et p2 . Pour enfiler un nouvel \u00e9l\u00e9ment elt dans file , on l'empile dans p1 . Pour d\u00e9filer file , deux cas se pr\u00e9sentent. La pile p2 n'est pas vide : on d\u00e9pile p2 . La pile p2 est vide : on d\u00e9pile les \u00e9l\u00e9ments de p1 en les empilant dans p2 jusqu'\u00e0 ce que p1 soit vide, puis on d\u00e9pile p2 . Question 3 Enonc\u00e9e Solution On consid\u00e8re la situation repr\u00e9sent\u00e9e ci-dessous. On ex\u00e9cute la s\u00e9quence d'instructions suivante : \ud83d\udccb Texte enfiler(file,ps6) defiler(file) defiler(file) defiler(file) enfiler(file,ps7) Repr\u00e9senter le contenu final des deux piles \u00e0 la suite de ces instructions. Question 4 Enonc\u00e9e Solution 4.a Solution 4.b Solution 4.c On dispose des fonctions : empiler(p,elt) qui empile l'\u00e9l\u00e9ment elt dans la pile p , depiler(p) qui renvoie le sommet de la pile p si p n'est pas vide et le supprime, pile_vide(p) qui renvoie True si la pile p est vide, False si la pile p n'est pas vide. a. \u00c9crire en Python une fonction est_ vide(f) qui prend en argument un couple de piles f et qui renvoie True si la file repr\u00e9sent\u00e9e par f est vide, False sinon. b. \u00c9crire en Python une fonction enfiler(f,elt) qui prend en arguments un couple de piles f et un \u00e9l\u00e9ment elt et qui ajoute elt en queue de la file repr\u00e9sent\u00e9e par f . c. \u00c9crire en Python une fonction defiler(f) qui prend en argument un couple de piles f et qui renvoie l'\u00e9lement en t\u00eate de la file repr\u00e9sent\u00e9e par f en le retirant. \ud83d\udc0d Script Python def est_vide ( f ): return pile_vide ( f [ 0 ]) and pile_vide ( f [ 1 ]) \ud83d\udc0d Script Python def enfiler ( f , elt ): empiler ( f [ 0 ], elt ) \ud83d\udc0d Script Python def defiler ( f ): p1 = f [ 0 ] p2 = f [ 1 ] if pile_vide ( p2 ): while not pile_vide ( p1 ): v = depiler ( p1 ) empiler ( p2 , v ) return depiler ( p2 ) Am\u00e9rique du Nord 2021 - Sujet 2 Cet exercice porte sur la notion de pile, de file et sur la programmation de base en Python. Les interfaces des structures de donn\u00e9es abstraites Pile et File sont propos\u00e9es ci-dessous. On utilisera uniquement les fonctions ci-dessous : Structure de donn\u00e9es abstraite : Pile Utilise : \u00c9l\u00e9ments, Bool\u00e9en Op\u00e9rations : creer_pile_vide : \u2205 \u2192 Pile creer_pile_vide() renvoie une pile vide est_vide : Pile \u2192 Bool\u00e9en est_vide(pile) renvoie True si pile est vide, False sinon empiler : Pile, \u00c9l\u00e9ment \u2192 Rien empiler(pile, element) ajoute element au sommet de la pile depiler : Pile \u2192 \u00c9l\u00e9ment depiler(pile) renvoie l\u2019\u00e9l\u00e9ment au sommet de la pile en le retirant de la pile Structure de donn\u00e9es abstraite : File Utilise : \u00c9l\u00e9ments, Bool\u00e9en Op\u00e9rations : creer_file_vide : \u2205 \u2192 File creer_file_vide() renvoie une file vide est_vide : File \u2192 Bool\u00e9en est_vide(file) renvoie True si file est vide, False sinon empiler : File, \u00c9l\u00e9ment \u2192 Rien empiler(file, element) ajoute element dans la file depiler : File \u2192 \u00c9l\u00e9ment depiler(file) renvoie l\u2019\u00e9l\u00e9ment au sommet de la file en le retirant de la file Question 1 Enonc\u00e9 Solution 1.a Solution 1.b (a) On consid\u00e8re la file F suivante : Quel sera le contenu de la pile P et de la file F apr\u00e8s l\u2019ex\u00e9cution du programme Python suivant ? \ud83d\udc0d Script Python 1 P = creer_pile_vide () 2 while not ( est_vide ( F )): 3 empiler ( P , defiler ( F )) (b) Cr\u00e9er une fonction taille_file qui prend en param\u00e8tre une file F et qui renvoie le nombre d\u2019\u00e9l\u00e9ments qu\u2019elle contient. Apr\u00e8s appel de cette fonction la file F doit avoir retrouv\u00e9 son \u00e9tat d\u2019origine. \ud83d\udc0d Script Python 1 def taille_file ( F ): 2 \"\"\" File -> Int \"\"\" \ud83d\udc0d Script Python def taille_file ( F ): t = 0 ft = creer_file_vide () while not est_vide ( F ): t = t + 1 enfiler ( ft , defiler ( F )) while not est_vide ( ft ): enfiler ( F , defiler ( ft )) return t Question 2 Enonc\u00e9 Solution \u00c9crire une fonction former_pile qui prend en param\u00e8tre une file F et qui renvoie une pile P contenant les m\u00eames \u00e9l\u00e9ments que la file. Le premier \u00e9l\u00e9ment sorti de la file devra se trouver au sommet de la pile ; le deuxi\u00e8me \u00e9l\u00e9ment sorti de la file devra se trouver juste en-dessous du sommet, etc. Exemple : former_pile(F) va renvoyer la pile P ci-dessous : \ud83d\udc0d Script Python def former_pile ( F ): p = creer_pile_vide () pt = creer_pile_vide () while not est_vide ( F ): empiler ( pt , defiler ( F )) while not est_vide ( pt ): empiler ( p , depiler ( pt )) return p Question 3 Enonc\u00e9 Solution \u00c9crire une fonction nb_elements qui prend en param\u00e8tres une file F et un \u00e9l\u00e9ment elt et qui renvoie le nombre de fois o\u00f9 elt est pr\u00e9sent dans la file F . Apr\u00e8s appel de cette fonction la file F doit avoir retrouv\u00e9 son \u00e9tat d\u2019origine. \ud83d\udc0d Script Python def nb_elements ( F , ele ): nb = 0 ft = creer_file_vide () while not est_vide ( F ): x = defiler ( F ) if x == ele : nb = nb + 1 enfiler ( ft , x ) while not est_vide ( ft ): enfiler ( F , defiler ( ft )) return nb Question 4 Enonc\u00e9 Solution \u00c9crire une fonction verifier_contenu qui prend en param\u00e8tres une file F et trois entiers : nb_rouge , nb_vert et nb_jaune . Cette fonction renvoie le bool\u00e9en True si \"rouge\" appara\u00eet au plus nb_rouge fois dans la file F , \"vert\" appara\u00eet au plus nb_vert fois dans la file F et \"jaune\" appara\u00eet au plus nb_jaune fois dans la file F . Elle renvoie False sinon. On pourra utiliser les fonctions pr\u00e9c\u00e9dentes. \ud83d\udc0d Script Python def verifier_contenu ( F , nb_rouge , nb_vert , nb_jaune ): return nb_elements ( F , \"rouge\" ) <= nb_rouge and nb_elements ( F , \"vert\" ) <= nb_vert and nb_elements ( F , \"jaune\" ) <= nb_jaune","title":"Les Files"},{"location":"StructureDonnees/TP07_Dictionnaires_Corrige/","text":"Th\u00e8me 1 : Structure de Donn\u00e9es 07 Les dictionnaires Introduction \u2693\ufe0e Prenons l'exemple d'un r\u00e9pertoire t\u00e9l\u00e9honique. Nous pouvons le m\u00e9moriser simplement comme un tableau (ou liste) de tableaux [nom,num\u00e9ro] \ud83d\udc0d Script Python liste_tel = [[ \"Paul\" , 5234 ], [ \"Emile\" , 5345 ], [ \"Victor\" , 5186 ], [ \"Rose\" , 5678 ], [ \"H\u00e9l\u00e8ne\" , 5432 ]] Si nous voulons appeler Rose , nous avons deux possibilit\u00e9s avec un tel tableau : * soit il faut savoir que les informations la concernant sont dans le quatri\u00e8me \u00e9l\u00e9ment de la liste (ce qui ne semble pas tr\u00e8s pratique et r\u00e9aliste) \ud83d\udc0d Script Python print ( liste_tel [ 3 ][ 1 ]) # il faut savoir que l'index de Rose est 3 soit nous cherchons dans le tableau en partant du premier \u00e9l\u00e9ment de la liste jusqu'\u00e0 ce que nous trouvions Rose (ce qui revient \u00e0 feuilleter son r\u00e9pertoire) : cela n\u00e9cessite d'utiliser une boucle pour parcourir le tableau. \ud83d\udc0d Script Python for element in liste_tel : if element [ 0 ] == 'Rose' : print ( element [ 1 ]) Vous conviendrez que ce n'est pas pratique pour acc\u00e9der \u00e0 son num\u00e9ro de t\u00e9l\u00e9phone. De m\u00eame, la modification ou l'ajout d'un information n\u00e9cessiterait de devoir feuilleter tout le r\u00e9pertoire. Il semblerait plus pratique d'associer un nom \u00e0 un num\u00e9ro, autrement dit d'associer \u00e0 une information \u00e0 une cl\u00e9 . C'est ce que les dictionnaires permettent ! Les dictionnaires en Python \u2693\ufe0e Un dictionnaire, de type dict en Python, est un ensemble non ordonn\u00e9 de paires (cl\u00e9, valeur) avec un acc\u00e8s tr\u00e8s rapide \u00e0 la valeur \u00e0 partir de la cl\u00e9. C'est un type de conteneur comme les list et les tuple mais ce n'est pas une s\u00e9quence. Au sens o\u00f9 les valeurs des tableaux ne sont pas index\u00e9s par des entiers. On peut ajouter des couples (cl\u00e9, valeur) \u00e0 un dictionnaire, si la cl\u00e9 figure d\u00e9j\u00e0 dans le dictionnaire alors le couple est remplac\u00e9 par le nouveau. Une cl\u00e9 peut \u00eatre de type alphab\u00e9tique, num\u00e9rique, ou m\u00eame de type construit sous certaines conditions. Les valeurs pourront \u00eatre de tout type sans exclusion. En Python, le dictionnaire est un objet mutable , autrement dit, on peut le modifier. A partir d\u2019une cl\u00e9, on peut alors acc\u00e9der directement \u00e0 la valeur qui lui est associ\u00e9e. Exemples : \ud83d\udc0d Script Python dico = { \"yes\" : \"oui\" , \"no\" : \"non\" , \"and\" : \"et\" , \"nsi\" : \"dansletop2desp\u00e9\" , \"maths\" : \"dansletop2dessp\u00e9\" } dico \ud83d\udc0d Script Python jours = { 1 : \"lundi\" , 2 : \"mardi\" , 3 : \"mercredi\" , 4 : \"jeudi\" , 5 : \"vendredi\" , 6 : \"samedi\" , 7 : \"dimanche\" } jours \ud83d\udc0d Script Python Balzac = { 'pnom' : 'Honor\u00e9 de Balzac' , 'nais' : 1799 , 'mort' : 1850 , 'romans' :[ 'Les Chouans' , 'La Peau de chagrin' , 'Les Contes drolatiques' , 'Eug\u00e9nie Grandet' , 'Le P\u00e8re Goriot' , 'Le Colonel Chabert' , 'Le Lys dans la vall\u00e9e' , 'Illusions perdues' , 'Ursule Mirou\u00ebt' , 'La Cousine Bette' , 'Le Cousin Pons' ]} Balzac Cr\u00e9ation d'un dictionnaire \u2693\ufe0e Plusieurs m\u00e9thodes permettent de cr\u00e9er soit un dictionnaire vide, soit de le noter en extension, soit par compr\u00e9hension. \ud83d\udc0d Script Python d1 = {} # Cr\u00e9ation d'un dictionnaire vide d2 = dict () # Cr\u00e9ation d'un dictionnaire vide (autre m\u00e9thode) d3 = { 'poires' : 5 , 'bananes' : 7 , 'abricots' : 12 } # cr\u00e9ation d'un dictionnaire par extension d4 = { k : k ** 2 for k in range ( 1 , 10 )} # cr\u00e9ation d'un dictionnaire par compr\u00e9hension print ( type ( d1 )) Question 1 : Donner l'expression du dictionnaire d4 R\u00e9ponse : \ud83d\udc0d Script Python print ( \"d1 =>\" , d1 ) print ( \"d2 =>\" , d2 ) print ( \"d3 =>\" , d3 ) print ( \"d4 =>\" , d4 ) Il est m\u00eame possible de cr\u00e9er un dictionnaire \u00e0 partir d'une liste de couples. \ud83d\udc0d Script Python liste = [( 'cle1' , 'valeur1' ),( 'cle2' , 'valeur2' )] d5 = dict ( liste ) liste_tel = [[ \"Paul\" , 5234 ], [ \"Emile\" , 5345 ], [ \"Victor\" , 5186 ], [ \"Rose\" , 5678 ], [ \"H\u00e9l\u00e8ne\" , 5432 ]] d6 = dict ( liste_tel ) print ( \"d5 =>\" , d5 ) print ( \"d6 =>\" , d6 ) Important : Vous aurez not\u00e9 que les dictionnaires Python se repr\u00e9sentent entre accolades {} . Les diff\u00e9rentes paires sont s\u00e9par\u00e9es par des virgules et sont de la forme cl\u00e9: valeur . A vous 1 \u2693\ufe0e Cr\u00e9ez un dictionnaire appel\u00e9 notes qui contient les paires (mati\u00e8res, moyenne) de vos trois sp\u00e9cialit\u00e9s. Affichez ensuite ce dictionnaire. \ud83d\udc0d Script Python # \u00e0 vous de jouer ! notes = { 'NSI' : 18 , 'Maths' : 15 , 'PC' : 14 } notes \ud83d\udccb Texte {'NSI': 18, 'Maths': 15, 'PC': 14} Acc\u00e8s, modification, ajout, suppression \u2693\ufe0e L' acc\u00e8s \u00e0 une valeur d'un dictionnaire se fait par sa cl\u00e9. \ud83d\udc0d Script Python d3 = { 'poires' : 5 , 'bananes' : 7 , 'abricots' : 12 } d3 [ 'abricots' ] Le dictionnaire \u00e9tant un objet mutable on peut modifier la valeur associ\u00e9e \u00e0 une cl\u00e9 ou ajouter une nouvelle association et afficher le dictionnaire modifi\u00e9. \ud83d\udc0d Script Python d = { 'Paul' : 5234 , 'Emile' : 5345 , 'Victor' : 5186 , 'Rose' : 5678 , 'H\u00e9l\u00e8ne' : 5432 } d [ 'Rose' ] = 4921 # cl\u00e9 existante donc modification de la valeur d [ 'Louane' ] = 4118 # nouvelle cl\u00e9 donc ajout d'une nouvelle association print ( d ) Pour supprimer une association d'un dictionnaire on peut utilise le mot cl\u00e9 del . \ud83d\udc0d Script Python print ( d ) del d [ 'Paul' ] print ( d ) Taille d'un dictionnaire \u2693\ufe0e La fonction len renvoie la taille d'un dictionnaire. \ud83d\udc0d Script Python d3 = { 'poires' : 5 , 'bananes' : 7 , 'abricots' : 12 } len ( d3 ) A vous 2 \u2693\ufe0e On reprend le dictionnaire notes de A vous 1. \ud83d\udc0d Script Python notes = { 'NSI' : 18 , 'Maths' : 15 , 'PC' : 14 } Affichez la moyenne de NSI. \ud83d\udc0d Script Python notes = { 'NSI' : 18 , 'Maths' : 15 , 'PC' : 14 } notes [ 'NSI' ] \ud83d\udccb Texte 18 Modifiez votre moyenne de NSI qui a gagn\u00e9 2 points. Affichez le dictionnaire. \ud83d\udc0d Script Python notes [ 'NSI' ] += 2 notes \ud83d\udccb Texte {'NSI': 20, 'Maths': 15, 'PC': 14} Ajoutez la mati\u00e8re Anglais avec sa moyenne. Affichez le dictionnaire. \ud83d\udc0d Script Python notes [ 'Anglais' ] = 17 notes \ud83d\udccb Texte {'NSI': 20, 'Maths': 15, 'PC': 14, 'Anglais': 17} Affichez la taille du dictionnaire. \ud83d\udc0d Script Python taille = len ( notes ) taille \ud83d\udccb Texte 4 Supprimez une des trois sp\u00e9cialit\u00e9s et affichez le dictionnaire. \ud83d\udc0d Script Python del notes [ 'PC' ] notes \ud83d\udccb Texte {'NSI': 20, 'Maths': 15, 'Anglais': 17} Les it\u00e9rateurs pour les dictionnaires \u2693\ufe0e Il est possible de parcourir un dictionnaire de trois mani\u00e8res : parcourir l'ensemble des cl\u00e9s avec la m\u00e9thode keys() ; parcourir l'ensemble des valeurs avec la m\u00e9thode values() ; parcourir l'ensemble des paires cl\u00e9s-valeurs avec la m\u00e9thode items() . On peut it\u00e9rer sur un dictionnaire gr\u00e2ce \u00e0 l'une de ces m\u00e9thodes. \ud83d\udc0d Script Python d = { 'Paul' : 5234 , 'Emile' : 5345 , 'Victor' : 5186 , 'Rose' : 5678 , 'H\u00e9l\u00e8ne' : 5432 } for prenom in d . keys (): print ( prenom ) \ud83d\udc0d Script Python for num in d . values (): print ( num ) \ud83d\udc0d Script Python for prenom , num in d . items (): print ( prenom , '->' , num ) On peut aussi interroger l'appartenance d'une valeur ou d'une cl\u00e9 gr\u00e2ce au mot cl\u00e9 in . \ud83d\udc0d Script Python 'John' in d . keys () \ud83d\udc0d Script Python 'Paul' not in d . keys () \ud83d\udc0d Script Python 5186 in d . values () A vous 3 \u2693\ufe0e On consid\u00e8re le dictionnaire fruits suivant. \ud83d\udc0d Script Python fruits = { 'poires' : 5 , 'pommes' : 11 , 'bananes' : 7 , 'abricots' : 12 } Affichez tous les fruits du dictionnaire. \ud83d\udc0d Script Python for f in fruits . keys (): print ( f ) \ud83d\udccb Texte poires pommes bananes abricots Affichez toutes les quantit\u00e9s du dictionnaire. \ud83d\udc0d Script Python for valeur in fruits . values (): print ( valeur ) \ud83d\udccb Texte 5 11 7 12 Ecrivez un programme permettant d'obtenir l'affichage suivant. \ud83d\udccb Texte Il reste 5 poires Il reste 11 pommes Il reste 7 bananes Il reste 12 abricots \ud83d\udc0d Script Python for cle , valeur in fruits . items (): print ( f 'il reste { valeur } { cle } ' ) \ud83d\udccb Texte il reste 5 poires il reste 11 pommes il reste 7 bananes il reste 12 abricots Les dictionnaires : EXERCICES \u2693\ufe0e Exercice 1 : \u2693\ufe0e On consid\u00e8re le dictionnaire suivant qui contient diff\u00e9rents fruits ainsi que leurs quantit\u00e9s. \ud83d\udc0d Script Python fruits = { \"pommes\" : 8 , \"melons\" : 3 , \"poires\" : 6 } Quelle instruction permet d'acc\u00e9der au nombre de melons ? \ud83d\udc0d Script Python fruits [ 'melons' ] \ud83d\udccb Texte 3 On a achet\u00e9 16 cl\u00e9mentines et utilis\u00e9 4 pommes pour faire une tarte. Quelles instructions permettent de mettre \u00e0 jour le dictionnaire ? \ud83d\udc0d Script Python fruits [ 'pommes' ] += 4 fruits [ 'clementines' ] = 16 fruits \ud83d\udccb Texte {'pommes': 12, 'melons': 3, 'poires': 6, 'clementines': 16} Exercice 2 : \u2693\ufe0e R\u00e9pondez aux questions suivantes sans ex\u00e9cuter les scripts propos\u00e9s . Vous les ex\u00e9cuterez pour v\u00e9rifier vos r\u00e9ponses. 1. Qu'affiche le programme suivant ? \ud83d\udc0d Script Python fruits = { 'pommes' : 4 , 'melons' : 3 , 'poires' : 6 , 'cl\u00e9mentines' : 16 } for c in fruits . keys (): print ( c ) Qu'affiche le programme suivant ? \ud83d\udc0d Script Python fruits = { 'pommes' : 4 , 'melons' : 3 , 'poires' : 6 , 'cl\u00e9mentines' : 16 } for cle , valeur in fruits . items (): print ( cle , \"->\" , valeur ) R\u00e9ponse : Qu'affiche le programme suivant ? \ud83d\udc0d Script Python fruits = { 'pommes' : 4 , 'melons' : 3 , 'poires' : 6 , 'cl\u00e9mentines' : 16 } for v in fruits . values (): print ( v ) R\u00e9ponse : Exercice 3 : \u2693\ufe0e On consid\u00e8re qu'il faut ajouter un fruit sur la liste des courses s'il en reste 4 ou moins. 1. Ecrivez un programme qui affiche la liste des courses en consid\u00e9rant le dictionnaire suivant. \ud83d\udc0d Script Python fruits = { 'pommes' : 4 , 'melons' : 3 , 'poires' : 6 , 'cl\u00e9mentines' : 16 } # \u00e0 compl\u00e9ter : for nom , num in fruits . items (): if num <= 4 : print ( f 'il faut racheter des { nom } , il en reste { num } ' ) \ud83d\udccb Texte il faut racheter des pommes, il en reste 4 il faut racheter des melons, il en reste 3 Ecrivez une fonction liste_courses(fruits) qui prend en param\u00e8tre un dictionnaire fruits et qui renvoie un tableau avec les fruits de la liste de courses. \ud83d\udc0d Script Python def liste_courses ( fruits ): liste = [] for nom , num in fruits . items (): if num <= 4 : liste . append ({ nom : num }) #on rajoute le fruit et la valeur restante sous forme de dictionnaire return liste liste_courses ( fruits ) \ud83d\udccb Texte [{'pommes': 4}, {'melons': 3}] Exercice 4 : \u2693\ufe0e On dispose d\u2019un dictionnaire associant \u00e0 des noms de commerciaux d\u2019une soci\u00e9t\u00e9 le nombre de ventes qu\u2019ils ont r\u00e9alis\u00e9es. Par exemple : ventes={\"Dupont\":14, \"Hervy\":19, \"Geoffroy\":15, \"Layec\":21} 1. \u00c9crivez une fonction qui prend en entr\u00e9e un tel dictionnaire et renvoie le nombre total de ventes dans la soci\u00e9t\u00e9. 2. \u00c9crivez une fonction qui prend en entr\u00e9e un tel dictionnaire et renvoie le nom du vendeur ayant r\u00e9alis\u00e9 le plus de ventes. Si plusieurs vendeurs sont ex-aequo sur ce crit\u00e8re, la fonction devra retourner le nom de l\u2019un d\u2019entre eux. \ud83d\udc0d Script Python def total_ventes ( ventes ): somme = 0 for valeur in ventes . values (): somme += valeur return somme ventes = { \"Dupont\" : 14 , \"Hervy\" : 19 , \"Geoffroy\" : 15 , \"Layec\" : 21 } reponse = total_ventes ( ventes ) print ( f \"Le total des ventes est { reponse } \" ) \ud83d\udccb Texte Le total des ventes est 69 Exercice 5 : \u2693\ufe0e Voici deux dictionnaires : \ud83d\udc0d Script Python athletes = { \"Mike\" : ( 1.75 , 68 ), \"John\" : ( 1.89 , 93 ), \"Kate\" : ( 1.67 , 62 )} sportifs = { \"Mike\" : { \"taille\" : 1.75 , \"poids\" : 68 }, \"John\" : { \"taille\" : 1.89 , \"poids\" : 93 }, \"Kate\" : { \"taille\" : 1.67 , \"poids\" : 62 }} De quel type sont les cl\u00e9s des deux dictionnaires athletes et sportifs ? De quels types sont les valeurs de ces deux dictionnaires ? R\u00e9ponse : Quelle instruction permet d'acc\u00e9der \u00e0 la taille de Kate dans le dictionnaire athletes ? \ud83d\udc0d Script Python taille = athletes [ 'Kate' ][ 0 ] #on acc\u00e9de d\u2019abord aux informations concernat Kate puis on prend la premiere valeur print ( f 'Kate mesure { taille } ' ) \ud83d\udccb Texte Kate mesure 1.67 Quelle instruction permet d'acc\u00e9der \u00e0 la taille de Kate dans le dictionnaire sportifs ? \ud83d\udc0d Script Python sportifs [ \"Kate\" ][ \"taille\" ] \ud83d\udccb Texte 1.67 Exercice 6 : \u2693\ufe0e Le Scrabble est un jeu de soci\u00e9t\u00e9 o\u00f9 l'on doit former des mots avec tirage al\u00e9atoire de lettres, chaque lettre valant un certain nombre de points. Le dictionnaire scrabble contient cette association entre une lettre et son nombre de points. \ud83d\udc0d Script Python scrabble = { 'A' : 1 , 'B' : 3 , 'C' : 3 , 'D' : 2 , 'E' : 1 , 'F' : 4 , 'G' : 2 , 'H' : 4 , 'I' : 1 , 'J' : 8 , 'K' : 10 , 'L' : 1 , 'M' : 2 , 'N' : 1 , 'O' : 1 , 'P' : 3 , 'Q' : 8 , 'R' : 1 , 'S' : 1 , 'T' : 1 , 'U' : 1 , 'V' : 4 , 'W' : 10 , 'X' : 10 , 'Y' : 10 , 'Z' : 10 } Ecrivez une fonction points(mot) qui renvoie le nombre de points au scrabble de mot , qui est une cha\u00eene de caract\u00e8res majuscules. Par exemple, le mot \"ARBRE\" doit rapporter 7 points, le mot \"XYLOPHONE\" doit rapporter 32 points . \ud83d\udc0d Script Python def points ( mot ): mot = mot . upper () #mise du mot en majuscule scrabble = { 'A' : 1 , 'B' : 3 , 'C' : 3 , 'D' : 2 , 'E' : 1 , 'F' : 4 , 'G' : 2 , 'H' : 4 , 'I' : 1 , 'J' : 8 , 'K' : 10 , 'L' : 1 , 'M' : 2 , 'N' : 1 , 'O' : 1 , 'P' : 3 , 'Q' : 8 , 'R' : 1 , 'S' : 1 , 'T' : 1 , 'U' : 1 , 'V' : 4 , 'W' : 10 , 'X' : 10 , 'Y' : 10 , 'Z' : 10 } score = 0 for lettre in mot : #on parcours chaque lettre du mot score += scrabble [ lettre ] #on ajoute la valeur de la lettre au score return score assert points ( \"XYLOPHONE\" ) == 32 assert points ( \"Arbre\" ) == 7 Exercice 7 : \u2693\ufe0e On consid\u00e8re la variable personnages suivante qui r\u00e9unit quelques informations sur des personnalit\u00e9s (les \u00e2ges sont fictifs, vous l'aurez compris). \ud83d\udc0d Script Python personnages = [{ 'nom' : 'Einstein' , 'pr\u00e9nom' : 'Albert' , '\u00e2ge' : '35' , 'genre' : 'm' }, { 'nom' : 'Hamilton' , 'pr\u00e9nom' : 'Margaret' , '\u00e2ge' : '23' , 'genre' : 'f' }, { 'nom' : 'Nelson' , 'pr\u00e9nom' : 'Ted' , '\u00e2ge' : '64' , 'genre' : 'm' }, { 'nom' : 'Curie' , 'pr\u00e9nom' : 'Marie' , '\u00e2ge' : '41' , 'genre' : 'f' }] Quel est le type de la variable personnages ? Quel est le type des \u00e9l\u00e9ments de personnages ? R\u00e9ponse : Quelle instruction permet d'acc\u00e9der au dictionnaire de Ted Nelson ? \ud83d\udc0d Script Python position = 0 for p in personnages : if p [ 'pr\u00e9nom' ] == 'Ted' and p [ 'nom' ] == 'Nelson' : print ( personnages [ position ]) else : position += 1 \ud83d\udccb Texte {'nom': 'Nelson', 'pr\u00e9nom': 'Ted', '\u00e2ge': '64', 'genre': 'm'} Quelle instruction permet d'acc\u00e9der \u00e0 l'\u00e2ge de Ted Nelson ? \ud83d\udc0d Script Python position = 0 for p in personnages : if p [ 'pr\u00e9nom' ] == 'Ted' and p [ 'nom' ] == 'Nelson' : print ( personnages [ position ][ '\u00e2ge' ]) else : position += 1 \ud83d\udccb Texte 64 Dans le programme suivant, quel est le type de la variable p \u00e0 chaque tour de boucle ? Quel est le r\u00f4le de ce programme ? \ud83d\udccb Texte for p in personnages: if int(p['\u00e2ge']) <= 40: print(p['nom'], p['pr\u00e9nom']) R\u00e9ponse : Proposez un programme qui affiche uniquement les noms et pr\u00e9noms des femmes du tableau personnages . \ud83d\udc0d Script Python for p in personnages : if p [ 'genre' ] == 'f' : print ( p [ 'nom' ], p [ 'pr\u00e9nom' ]) \ud83d\udccb Texte Hamilton Margaret Curie Marie Ecrivez une fonction age_moyen(personnages) qui renvoie l'\u00e2ge moyen des personnalit\u00e9s du tableau personnages entr\u00e9 en param\u00e8tre. On doit trouver 40,75 ans . \ud83d\udc0d Script Python def age_moyen ( personnages ): total_age = 0 for p in personnages : total_age += int ( p [ '\u00e2ge' ]) moy = total_age / len ( personnages ) return moy age_moyen ( personnages ) \ud83d\udccb Texte 40.75 Exercice 8 : \u2693\ufe0e On consid\u00e8re le dictionnaire suivant : \ud83d\udc0d Script Python res = { 'nsi' : 18 , 'maths' : 17 , 'svt' : 14 , 'fran\u00e7ais' : 14 , 'lv1' : 8 , 'physique' : 12 , 'HG' : 11 } Ajouter la moyenne de 12 en lv2. \ud83d\udc0d Script Python res [ 'lv2' ] = 12 res \ud83d\udccb Texte {'nsi': 18, 'maths': 17, 'svt': 14, 'fran\u00e7ais': 14, 'lv1': 8, 'physique': 12, 'HG': 11, 'lv2': 12} Calculer la moyenne des notes. \ud83d\udc0d Script Python somme_notes = 0 for note in res . values (): somme_notes += note moy = somme_notes / len ( res ) print ( f 'La moyenne est { moy } ' ) \ud83d\udccb Texte La moyenne est 13.25 R\u00e9aliser un affichage des notes qui ressemble \u00e0 cela : \ud83d\udccb Texte la moyenne en nsi est 18 la moyenne en maths est 17 etc la moyenne g\u00e9n\u00e9rale est ... \ud83d\udc0d Script Python somme_notes = 0 for matiere , note in res . items (): print ( f 'la moyenne en { matiere } est { note } ' ) somme_notes += note print ( f 'la moyenne g\u00e9n\u00e9rale est { somme_notes / len ( res ) } ' ) \ud83d\udccb Texte la moyenne en nsi est 18 la moyenne en maths est 17 la moyenne en svt est 14 la moyenne en fran\u00e7ais est 14 la moyenne en lv1 est 8 la moyenne en physique est 12 la moyenne en HG est 11 la moyenne en lv2 est 12 la moyenne g\u00e9n\u00e9rale est 13.25 Exercice 9 : \u2693\ufe0e Ecrire une fonction const_dico(cle,valeur) qui renvoie le dictionnaire d\u00e9finie par les cl\u00e9s et les valeurs entr\u00e9es en argument. \ud83d\udc0d Script Python def const_dico ( cle : list , valeur : list ): dico = {} for i in range ( len ( cle )): dico [ pseudo [ i ]] = valeur [ i ] return dico On donne des listes de certains joueurs de League Of Legend ainsi que leur classement et leur nombre de points : \ud83d\udc0d Script Python pseudo = [ 'Major Alexander' , 'KBM Wiz' , 'FNC MagiFelix' , 'Avalanche' , 'love camile' , 'Nobody' ] classement = [( 12 , 1406 ),( 1 , 1613 ),( 4 , 1507 ),( 9 , 1429 ),( 16 , 1341 ),( 11 , 1416 )] Appliquer votre fonction const_dico(cle,valeur) sur les joueurs de LOL. \ud83d\udc0d Script Python dico = const_dico ( pseudo , classement ) dico \ud83d\udccb Texte {'Major Alexander': (12, 1406), 'KBM Wiz': (1, 1613), 'FNC MagiFelix': (4, 1507), 'Avalanche': (9, 1429), 'love camile': (16, 1341), 'Nobody': (11, 1416)} Exercice 10 : \u2693\ufe0e On donne le dictionnaire suivant : \ud83d\udc0d Script Python turing = { 'nom' : 'Turing' , 'prenom' :( 'Alan' , 'Mathison' ), 'nation' : 'anglaise' , 'naissance' : 1912 , 'mort' : 1954 } Afficher les pr\u00e9noms de Turing. Afficher sa nationalit\u00e9 D\u00e9terminer l'\u00e2ge qu'avait Alan Turing \u00e0 sa mort. \ud83d\udc0d Script Python print ( turing [ 'prenom' ]) print ( turing [ 'nation' ]) print ( turing [ 'mort' ]) \ud83d\udccb Texte ('Alan', 'Mathison') anglaise 1954 Exercice 11 : \u2693\ufe0e Voici une citation c\u00e9l\u00e8bre de Gandhi : La vie est un myst\u00e8re qu'il faut vivre, et non un probl\u00e8me \u00e0 r\u00e9soudre. Cr\u00e9er un dictionnaire qui associe \u00e0 chaque lettre (cl\u00e9) son occurrence (valeur) * Par exemple la lettre 'a' apparait deux fois. Par exemple dico= {'a':2, .........} \ud83d\udc0d Script Python #cr\u00e9ation de l\u2019alphabet alphabet = [ chr ( num ) for num in range ( 97 , 97 + 26 )] alphabet += [ '\u00e9' , '\u00e8' , '\u00e0' ] print ( alphabet ) phrase = \"La vie est un myst\u00e8re qu\u2019il faut vivre, et non un probl\u00e8me \u00e0 r\u00e9soudre.\" dico = {} phrase = phrase . lower () for lettre in phrase : if lettre in alphabet : if lettre not in dico : dico [ lettre ] = 1 else : dico [ lettre ] += 1 dico \ud83d\udccb Texte ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '\u00e9', '\u00e8', '\u00e0'] {'l': 3, 'a': 2, 'v': 3, 'i': 3, 'e': 7, 's': 3, 't': 4, 'u': 5, 'n': 4, 'm': 2, 'y': 1, '\u00e8': 2, 'r': 5, 'q': 1, 'f': 1, 'o': 3, 'p': 1, 'b': 1, '\u00e0': 1, '\u00e9': 1, 'd': 1} Exercice 12 : QCM de NSI \u2693\ufe0e Les r\u00e9ponses correctes d'un QCM de NSI sont stock\u00e9es dans un dictionnaire nomm\u00e9 reponses_valides. Les cl\u00e9s sont des cha\u00eenes de caract\u00e8res de la forme \"Q1\". Les valeurs possibles sont des cha\u00eenes de caract\u00e8res correspondant aux quatre r\u00e9ponses \"a\",\"b\",\"c\",\"d\". Exemple : reponses_valides = {\"Q1\":\"c\",\"Q2\":\"a\",\"Q3\":\"d\",\"Q4\":\"c\",\"Q5\":\"b\"} Les r\u00e9ponses donn\u00e9es par Alice sont stock\u00e9es dans le dictionnaire reponses_Alice dont voici un exemple possible : reponses_Alice = {\"Q1\":\"b\",\"Q2\":\"a\",\"Q3\":\"d\",\"Q5\":\"a\"} Lorsqu'Alice n'a pas r\u00e9pondu \u00e0 une question, il n'y a pas de clef correspondant au nom de l'exercice. La notation d'un QCM de NSI est la suivante : 3 points par r\u00e9ponse correcte, -1 point par r\u00e9ponse incorrecte et 0 si l'on n'a pas r\u00e9pondu Compl\u00e9ter la fonction correction_QCM_Alice(reponses_Alice,reponses_valides) qui, \u00e0 partir des dictionnaires reponses_Alice et reponses_valides pass\u00e9es en param\u00e8tres renvoie le nombre de points obtenus au QCM par Alice. \ud83d\udc0d Script Python def correction_QCM_Alice ( reponses_Alice , reponses_valides ): note = 0 for question in reponses_valides . keys (): if question in reponses_Alice : if reponses_Alice [ question ] == reponses_valides [ question ]: note += 3 elif reponses_Alice [ question ] != reponses_valides [ question ]: note -= 1 return note reponses_valides = { \"Q1\" : \"c\" , \"Q2\" : \"a\" , \"Q3\" : \"d\" , \"Q4\" : \"c\" , \"Q5\" : \"b\" } reponses_Alice = { \"Q1\" : \"b\" , \"Q2\" : \"a\" , \"Q3\" : \"d\" , \"Q5\" : \"a\" } note_Alice = correction_QCM_Alice ( reponses_Alice , reponses_valides ) print ( f \"Alice obtient la note de { note_Alice } \" ) \ud83d\udccb Texte Alice obtient la note de 4 Exercice 13 : L'application \"Contacts\" de vos smartphones \u2693\ufe0e L'objectif de cette activit\u00e9 est de programmer deux des fonctionnalit\u00e9s importantes des smartphones actuels : Ajouter un contact au r\u00e9pertoire ; Rechercher un contact dans le r\u00e9pertoire. On suppose pour simplifier que le repertoire t\u00e9l\u00e9phonique est m\u00e9moris\u00e9 dans le smartphone sous la forme d'un dictionnaire et que chaque \u00e9l\u00e9ment du dictionnaire est une paire (prenom, numero) o\u00f9 prenom est la cl\u00e9 et numero la valeur associ\u00e9e. Etape 1 : Ajouter un contact \u2693\ufe0e On consid\u00e8re que le r\u00e9pertoire t\u00e9l\u00e9phonique est m\u00e9moris\u00e9 dans le dictionnaire repertoire . Quelques contacts sont d\u00e9j\u00e0 enregistr\u00e9s dans ce r\u00e9pertoire. \ud83d\udc0d Script Python repertoire = { 'David' : 1010 , 'M\u00e9lanie' : 1111 , 'Alain' : 121212 } Question 1 : Ecrivez une fonction ajout_contact(repertoire) qui demande \u00e0 l'utilisateur de saisir les donn\u00e9es (pr\u00e9nom et num\u00e9ro de t\u00e9l\u00e9phone) d'un contact et qui ajoute ce contact \u00e0 repertoire . \ud83d\udc0d Script Python Question 2 : On veut maintenant cr\u00e9er une fonction remplissage qui permet d'ajouter des contacts au r\u00e9pertoire autant de fois que l'on souhaite. Plus pr\u00e9cis\u00e9ment, une fois qu'un contact a \u00e9t\u00e9 saisi on demande \u00e0 l'utilisateur s'il souhaite ajouter un autre contact. Compl\u00e9tez la fonction remplissage en cons\u00e9quence. Vous utiliserez la fonction ajout_contact \u00e9crite \u00e0 la question pr\u00e9c\u00e9dente. \ud83d\udc0d Script Python def remplissage ( repertoire ): encore = True # \u00e0 compl\u00e9ter Etape 2 : Rechercher un contact \u2693\ufe0e On souhaite maintenant \u00e9crire une fonction numero_de(prenom, repertoire) qui renvoie le num\u00e9ro de prenom si prenom est bien dans repertoire et qui renvoie un message sinon. Question 3 : Si prenom est pr\u00e9sent dans repertoire , quelle instruction permet d'afficher le num\u00e9ro associ\u00e9 \u00e0 prenom ? \ud83d\udc0d Script Python Question 4 : Compl\u00e9tez la fonction numero_de(prenom, repertoire) qui renvoie le num\u00e9ro de t\u00e9l\u00e9phone associ\u00e9 dans l'affirmative et un message d'erreur sinon. \ud83d\udc0d Script Python def numero_de ( prenom , repertoire ): '''prenom est une chaine de caract\u00e8res et repertoire est un dictionnaire''' # \u00e0 compl\u00e9ter Exercice 14 : Quel est le mot de 6 lettres le plus pr\u00e9sent dans Le tour du monde en 80 jours de Jules Verne ? \u2693\ufe0e Le fichier texte de l'oeuvre de Jules Verne, intitul\u00e9 ltdme80j.txt , a \u00e9t\u00e9 plac\u00e9 dans le dossier data du r\u00e9pertoire de ce notebook. Par souci de simplification, le texte ne contient aucun signe de ponctuation. De mani\u00e8re g\u00e9n\u00e9rale, le site du Projet Gutenberg permet de r\u00e9cup\u00e9rer librement le texte de plusieurs milliers d'oeuvres du domaine public : https://www.gutenberg.org . Etape 1 : Lecture du contenu du fichier \u2693\ufe0e On peut ouvrir et m\u00e9moriser dans une variable texte le contenu du fichier texte. Pour cela, il suffit d'ouvrir le fichier puis en lire le contenu sous la forme d'une unique cha\u00eene de caract\u00e8res avec la m\u00e9thode read() . On ferme ensuit le flux de lecture du fichier. \ud83d\udc0d Script Python # Ouverture du fichier ('r' pour read = lecture, 'utf-8' pour l'encodage des caract\u00e8res) fichier = open ( \"ltdme80j.txt\" , mode = \"r\" , encoding = \"utf-8\" ) # M\u00e9morisation du texte de l'oeuvre dans une cha\u00eene de caract\u00e8res appel\u00e9e texte texte = fichier . read () # Fermeture du flux de lecture fichier . close () print ( texte ) Etape 2 : Conversion en un tableau de mots \u2693\ufe0e On peut ensuite convertir la cha\u00eene texte en un tableau contenant les diff\u00e9rents mots de l'oeuvre. Pour cela, on peut utiliser la m\u00e9thode split() des cha\u00eenes de caract\u00e8res. \ud83d\udc0d Script Python tab = texte . split () print ( tab ) Etape 3 : Compter le nombre d'occurrences de chaque mot \u2693\ufe0e Un cas d\u2019utilisation typique des dictionnaires consiste \u00e0 compter les occurrences des \u00e9l\u00e9ments d\u2019un tableau. Consid\u00e9rons par exemple le tableau suivant : \ud83d\udccb Texte ['b', 'c', 'e', 'b', 'c', 'j', 'd', 'b', 'j', 'a', 'b'] Dans cette liste le caract\u00e8re 'b' est par exemple r\u00e9p\u00e9t\u00e9 quatre fois, et le 'j' deux fois, etc. L'objectif est de d\u00e9finir une fonction occurrences(t) qui renvoie un dictionnaire avec le nombre d'occurences de chaque \u00e9l\u00e9ment du tableau t entr\u00e9e en param\u00e8tre. Par exemple, la fonction occurences appliqu\u00e9e au tableau pr\u00e9c\u00e9dent \ud83d\udccb Texte occurrences(['b', 'c', 'e', 'b', 'c', 'j', 'd', 'b', 'j', 'a', 'b']) doit renvoyer le dictionnaire : \ud83d\udccb Texte {'b': 4, 'a': 1, 'c': 2, 'e': 1, 'j': 2, 'd': 1} Question 1 : Ecrivez la fonction occurrences(t) et testez-la sur un tableau de caract\u00e8res. \ud83d\udc0d Script Python def occurence ( tab ): dico = {} for elt in tab : if elt not in dico : dico [ elt ] = 1 else : dico [ elt ] += 1 return dico Question 2 : Appliquez la fonction occurences \u00e0 ce tableau pour r\u00e9cup\u00e9rer un dictionnaire d du nombre d'occurences de chaque mot. \ud83d\udc0d Script Python occurence ( tab ) Etape 4 : Trouver le mot de 6 lettres le plus pr\u00e9sent \u2693\ufe0e Question 3 : Ecrivez une fonction mot_6_lettres_plus_frequent(d) qui renvoie le mot de 6 lettres les plus fr\u00e9quent dans l'oeuvre de Jules Verne ainsi que son nombre d'occurence. (r\u00e9ponse : 'heures' avec 243 occurrences) \ud83d\udc0d Script Python def mot_6_lettres_plus_frequent ( d ): rep = {} for elt in d : if len ( elt ) == 6 : if elt not in rep : rep [ elt ] = 1 else : rep [ elt ] += 1 maxi = 0 nom = '' for elt1 in rep : if rep [ elt1 ] > maxi : maxi = rep [ elt1 ] nom = elt1 return ( nom , maxi ) mot_6_lettres_plus_frequent ( tab ) \ud83d\udccb Texte ('heures', 243) R\u00e9ponse : cela revient \u00e0 effectuer une recherche de maximum sur les occurences des mots de 6 lettres. On parcourt donc toutes les cl\u00e9s du dictionnaire d (les cl\u00e9s sont les mots) et parmi les mots de 6 lettres on regarde si son nombre d'occurence est le nouveau maximum. Dans l'affirmative, ce mot devient le mot le plus fr\u00e9quent (provisoire) et sa valeur dans le dictionnaire le nombre d'occurrences maximum (provisoire). \ud83d\udc0d Script Python Question BONUS : Ecrire une fonction mot_plus_frequent(d, k) qui renvoie le mot de k lettres le plus pr\u00e9sent dans le dictionnaire d . Affichez ensuite le mot le plus fr\u00e9quent d'une lettre, de deux lettres, etc. \ud83d\udc0d Script Python def mot_plus_frequent ( d , k ): rep = {} for elt in d : if len ( elt ) == k : if elt not in rep : rep [ elt ] = 1 else : rep [ elt ] += 1 maxi = 0 nom = '' for elt1 in rep : if rep [ elt1 ] > maxi : maxi = rep [ elt1 ] nom = elt1 return ( nom , maxi ) mot_plus_frequent ( tab , 2 ) \ud83d\udccb Texte ('de', 2826) Exercice 15 : gestion de commandes \u2693\ufe0e Compl\u00e9ter les fonction pour r\u00e9pondre aux docstring \ud83d\udc0d Script Python global commandes commandes = { '0' : { 'numero' : 'EMA70495' , 'nom' : 'Ada Lovelace' , 'adresse' : '64 rue Jocelyne Troccaz' , 'ville' : 'Tours' , 'etat' : 'En cours' }, '1' : { 'numero' : 'VWD74550' , 'nom' : 'Dorothy Vaughan' , 'adresse' : '33 rue Al-Kindi' , 'ville' : 'Bordeaux' , 'etat' : 'En cours' }, '2' : { 'numero' : 'SWK65993' , 'nom' : 'Gilles Kahn' , 'adresse' : '53 rue Ingrid Daubechies' , 'ville' : 'Lille' , 'etat' : 'En cours' }, '3' : { 'numero' : 'NKR34542' , 'nom' : 'Ada Lovelace' , 'adresse' : '98 rue Jules C\u00e9sar' , 'ville' : 'Bordeaux' , 'etat' : 'Livr\u00e9e' }, '4' : { 'numero' : 'GEG58414' , 'nom' : 'Jacques-Louis Lions' , 'adresse' : '84 rue Al-Kindi' , 'ville' : 'Rennes' , 'etat' : 'Retour' }, '5' : { 'numero' : 'FZA36963' , 'nom' : 'Al-Khwarizmi' , 'adresse' : '73 rue Adi Shamir' , 'ville' : 'Marseille' , 'etat' : 'En cours' }, '6' : { 'numero' : 'QWE58690' , 'nom' : 'Alonzo Church' , 'adresse' : '47 rue Jules C\u00e9sar' , 'ville' : 'Paris' , 'etat' : 'Retour' }, '7' : { 'numero' : 'NLY90647' , 'nom' : 'Hypatie d\u2019Alexandrie' , 'adresse' : '51 rue Whitfield Diffie' , 'ville' : 'Bordeaux' , 'etat' : 'En cours' }, '8' : { 'numero' : 'VVL26047' , 'nom' : 'Alonzo Church' , 'adresse' : '6: rue Adi Shamir' , 'ville' : 'Montpellier' , 'etat' : 'En cours' }, '9' : { 'numero' : 'CXO07384' , 'nom' : 'Jacques-Louis Lions' , 'adresse' : '30 rue Whitfield Diffie' , 'ville' : 'Paris' , 'etat' : 'Livr\u00e9e' } } \ud83d\udc0d Script Python def afficher_commande_numero ( numero_commande ): '''affiche la commande correspondant au numero : numero : str : return : print ''' numero = '' for cle1 , valeur1 in commandes . items (): for cle2 , valeur2 in valeur1 . items (): if valeur2 == numero_commande : numero = cle1 if numero == '' : print ( f ' { numero_commande } : numero commande non enregistr\u00e9' ) else : reponse = commandes [ numero ] for cle , valeur in reponse . items (): print ( f ' { cle } : { valeur } ' ) afficher_commande_numero ( 'NLY90647' ) \ud83d\udc0d Script Python numero : NLY90647 nom : Hypatie d \u2019 Alexandrie adresse : 51 rue Whitfield Diffie ville : Bordeaux etat : En cours >>> afficher_commande_numero ( 'NLY90647' ) commande : NLY90647 Nom : Hypatie d \u2019 Alexandrie Adresse : 51 rue Whitfield Diffie Ville : Bordeaux Etat : En cours >>> afficher_commande_numero ( 'NLY90687' ) NLY90687 : numero commande non enregistr\u00e9 \ud83d\udc0d Script Python def recherche_par_nom ( nom ): '''recherche les commandes correspondantes au nom : nom : str : return : un tuple contenant les commandes >>> print(recherche_par_nom(\"Ada Lovelace\")) ({\u2019numero\u2019: \u2019EMA70495\u2019, \u2019nom\u2019: \u2019Ada Lovelace\u2019, \u2019adresse\u2019: \u201964 rue Jocelyne, Troccaz\u2019, \u2019ville\u2019: \u2019Tours\u2019, \u2019etat\u2019: \u2019En cours\u2019},{\u2019numero\u2019: \u2019NKR34542\u2019, \u2019nom\u2019: \u2019Ada Lovelace\u2019, \u2019adresse\u2019: \u201998 rue Jules C\u00e9sar\u2019, \u2019ville\u2019: \u2019Bordeaux\u2019, \u2019etat\u2019: \u2019Livr\u00e9e\u2019}) >>>print(recherche_par_nom(\"Alan Turing\")) () ''' global commandes numero = [] reponse = [] for cle1 , valeur1 in commandes . items (): for cle2 , valeur2 in valeur1 . items (): if valeur2 == nom : numero . append ( cle1 ) if numero == []: print ( f ' { numero_commande } : pas de commande \u00e0 ce nom' ) else : for k in numero : reponse . append ( commandes [ k ]) return tuple ( reponse ) def ajouter_commande ( numero , nom , adresse , ville , etat ): '''ajoute une commande : numero,nom,adresse,ville,etat : str : return : le dict commande modifi\u00e9 global commandes ''' liste = [ numero , nom , adresse , ville , etat ] k = 0 numero = str ( len ( commandes )) for cle in commandes [ '0' ] . keys (): commandes [ numero ] = { cle : liste [ k ]} k += 1 return commandes ajouter_commande ( \"AZE1029\" , \"Alan Turin\" , \"314 rue d\u2019Enigma\" , \"Londres\" , \"En cours\" ) print ( commandes ) \ud83d\udc0d Script Python { '0' : { 'numero' : 'EMA70495' , 'nom' : 'Ada Lovelace' , 'adresse' : '64 rue Jocelyne Troccaz' , 'ville' : 'Tours' , 'etat' : 'En cours' }, '1' : { 'numero' : 'VWD74550' , 'nom' : 'Dorothy Vaughan' , 'adresse' : '33 rue Al-Kindi' , 'ville' : 'Bordeaux' , 'etat' : 'En cours' }, '2' : { 'numero' : 'SWK65993' , 'nom' : 'Gilles Kahn' , 'adresse' : '53 rue Ingrid Daubechies' , 'ville' : 'Lille' , 'etat' : 'En cours' }, '3' : { 'numero' : 'NKR34542' , 'nom' : 'Ada Lovelace' , 'adresse' : '98 rue Jules C\u00e9sar' , 'ville' : 'Bordeaux' , 'etat' : 'Livr\u00e9e' }, '4' : { 'numero' : 'GEG58414' , 'nom' : 'Jacques-Louis Lions' , 'adresse' : '84 rue Al-Kindi' , 'ville' : 'Rennes' , 'etat' : 'Retour' }, '5' : { 'numero' : 'FZA36963' , 'nom' : 'Al-Khwarizmi' , 'adresse' : '73 rue Adi Shamir' , 'ville' : 'Marseille' , 'etat' : 'En cours' }, '6' : { 'numero' : 'QWE58690' , 'nom' : 'Alonzo Church' , 'adresse' : '47 rue Jules C\u00e9sar' , 'ville' : 'Paris' , 'etat' : 'Retour' }, '7' : { 'numero' : 'NLY90647' , 'nom' : 'Hypatie d\u2019Alexandrie' , 'adresse' : '51 rue Whitfield Diffie' , 'ville' : 'Bordeaux' , 'etat' : 'En cours' }, '8' : { 'numero' : 'VVL26047' , 'nom' : 'Alonzo Church' , 'adresse' : '6: rue Adi Shamir' , 'ville' : 'Montpellier' , 'etat' : 'En cours' }, '9' : { 'numero' : 'CXO07384' , 'nom' : 'Jacques-Louis Lions' , 'adresse' : '30 rue Whitfield Diffie' , 'ville' : 'Paris' , 'etat' : 'Livr\u00e9e' }, '10' : { 'etat' : 'En cours' }} >>> commandes = { '0' : { 'numero' : 'EMA70495' , 'nom' : 'Ada Lovelace' , 'adresse' : '64 rue Jocelyne Troccaz' , 'ville' : 'Tours' , 'etat' : 'En cours' }, '1' : { 'numero' : 'VWD74550' , 'nom' : 'Dorothy Vaughan' , 'adresse' : '33 rue Al-Kindi' , 'ville' : 'Bordeaux' , 'etat' : 'En cours' }, '2' : { 'numero' : 'SWK65993' , 'nom' : 'Gilles Kahn' , 'adresse' : '53 rue Ingrid Daubechies' , 'ville' : 'Lille' , 'etat' : 'En cours' }, '3' : { 'numero' : 'NKR34542' , 'nom' : 'Ada Lovelace' , 'adresse' : '98 rue Jules C\u00e9sar' , 'ville' : 'Bordeaux' , 'etat' : 'Livr\u00e9e' }, '4' : { 'numero' : 'GEG58414' , 'nom' : 'Jacques-Louis Lions' , 'adresse' : '84 rue Al-Kindi' , 'ville' : 'Rennes' , 'etat' : 'Retour' }, '5' : { 'numero' : 'FZA36963' , 'nom' : 'Al-Khwarizmi' , 'adresse' : '73 rue Adi Shamir' , 'ville' : 'Marseille' , 'etat' : 'En cours' }, '6' : { 'numero' : 'QWE58690' , 'nom' : 'Alonzo Church' , 'adresse' : '47 rue Jules C\u00e9sar' , 'ville' : 'Paris' , 'etat' : 'Retour' }, '7' : { 'numero' : 'NLY90647' , 'nom' : 'Hypatie d\u2019Alexandrie' , 'adresse' : '51 rue Whitfield Diffie' , 'ville' : 'Bordeaux' , 'etat' : 'En cours' }, '8' : { 'numero' : 'VVL26047' , 'nom' : 'Alonzo Church' , 'adresse' : '6: rue Adi Shamir' , 'ville' : 'Montpellier' , 'etat' : 'En cours' }, '9' : { 'numero' : 'CXO07384' , 'nom' : 'Jacques-Louis Lions' , 'adresse' : '30 rue Whitfield Diffie' , 'ville' : 'Paris' , 'etat' : 'Livr\u00e9e' } } >>> ajouter_commande ( \"AZE1029\" , \"Alan Turin\" , \"314 rue d'Enigma\" , \"Londres\" , \"En cours\" ) >>> print ( commandes ) { '0' : { 'numero' : 'EMA70495' , 'nom' : 'Ada Lovelace' , 'adresse' : '64 rue Jocelyne Troccaz' , 'ville' : 'Tours' , 'etat' : 'En cours' }, '1' : { 'numero' : 'VWD74550' , 'nom' : 'Dorothy Vaughan' , 'adresse' : '33 rue Al-Kindi' , 'ville' : 'Bordeaux' , 'etat' : 'En cours' }, '2' : { 'numero' : 'SWK65993' , 'nom' : 'Gilles Kahn' , 'adresse' : '53 rue Ingrid Daubechies' , 'ville' : 'Lille' , 'etat' : 'En cours' }, '3' : { 'numero' : 'NKR34542' , 'nom' : 'Ada Lovelace' , 'adresse' : '98 rue Jules C\u00e9sar' , 'ville' : 'Bordeaux' , 'etat' : 'Livr\u00e9e' }, '4' : { 'numero' : 'GEG58414' , 'nom' : 'Jacques-Louis Lions' , 'adresse' : '84 rue Al-Kindi' , 'ville' : 'Rennes' , 'etat' : 'Retour' }, '5' : { 'numero' : 'FZA36963' , 'nom' : 'Al-Khwarizmi' , 'adresse' : '73 rue Adi Shamir' , 'ville' : 'Marseille' , 'etat' : 'En cours' }, '6' : { 'numero' : 'QWE58690' , 'nom' : 'Alonzo Church' , 'adresse' : '47 rue Jules C\u00e9sar' , 'ville' : 'Paris' , 'etat' : 'Retour' }, '7' : { 'numero' : 'NLY90647' , 'nom' : 'Hypatie d\u2019Alexandrie' , 'adresse' : '51 rue Whitfield Diffie' , 'ville' : 'Bordeaux' , 'etat' : 'En cours' }, '8' : { 'numero' : 'VVL26047' , 'nom' : 'Alonzo Church' , 'adresse' : '6: rue Adi Shamir' , 'ville' : 'Montpellier' , 'etat' : 'En cours' }, '9' : { 'numero' : 'CXO07384' , 'nom' : 'Jacques-Louis Lions' , 'adresse' : '30 rue Whitfield Diffie' , 'ville' : 'Paris' , 'etat' : 'Livr\u00e9e' } '11' : { 'numero' : 'AZE1029' , 'nom' : 'Alan Turin' , 'adresse' : \"314 rue d'Enigma\" , 'ville' : 'Londres' , 'etat' : 'En cours' } } \ud83d\udc0d Script Python def supprimer_commande ( numero ): ''' supprime la commande correspondant au n\u00b0 : numero : str : return : le dict commandes ''' num = '' for cle1 , valeur1 in commandes . items (): for cle2 , valeur2 in valeur1 . items (): if valeur2 == numero : num = cle1 if numero == '' : print ( f ' { numero } : numero commande non enregistr\u00e9' ) else : del commandes [ num ] return commandes supprimer_commande ( 'EMA70495' ) print ( commandes ) \ud83d\udc0d Script Python { '1' : { 'numero' : 'VWD74550' , 'nom' : 'Dorothy Vaughan' , 'adresse' : '33 rue Al-Kindi' , 'ville' : 'Bordeaux' , 'etat' : 'En cours' }, '2' : { 'numero' : 'SWK65993' , 'nom' : 'Gilles Kahn' , 'adresse' : '53 rue Ingrid Daubechies' , 'ville' : 'Lille' , 'etat' : 'En cours' }, '3' : { 'numero' : 'NKR34542' , 'nom' : 'Ada Lovelace' , 'adresse' : '98 rue Jules C\u00e9sar' , 'ville' : 'Bordeaux' , 'etat' : 'Livr\u00e9e' }, '4' : { 'numero' : 'GEG58414' , 'nom' : 'Jacques-Louis Lions' , 'adresse' : '84 rue Al-Kindi' , 'ville' : 'Rennes' , 'etat' : 'Retour' }, '5' : { 'numero' : 'FZA36963' , 'nom' : 'Al-Khwarizmi' , 'adresse' : '73 rue Adi Shamir' , 'ville' : 'Marseille' , 'etat' : 'En cours' }, '6' : { 'numero' : 'QWE58690' , 'nom' : 'Alonzo Church' , 'adresse' : '47 rue Jules C\u00e9sar' , 'ville' : 'Paris' , 'etat' : 'Retour' }, '7' : { 'numero' : 'NLY90647' , 'nom' : 'Hypatie d\u2019Alexandrie' , 'adresse' : '51 rue Whitfield Diffie' , 'ville' : 'Bordeaux' , 'etat' : 'En cours' }, '8' : { 'numero' : 'VVL26047' , 'nom' : 'Alonzo Church' , 'adresse' : '6: rue Adi Shamir' , 'ville' : 'Montpellier' , 'etat' : 'En cours' }, '9' : { 'numero' : 'CXO07384' , 'nom' : 'Jacques-Louis Lions' , 'adresse' : '30 rue Whitfield Diffie' , 'ville' : 'Paris' , 'etat' : 'Livr\u00e9e' }, '10' : { 'etat' : 'En cours' }} >>> supprimer_commande ( 'EMA70495' ) >>> print ( commandes ) { '1' : { 'numero' : 'VWD74550' , 'nom' : 'Dorothy Vaughan' , 'adresse' : '33 rue Al-Kindi' , 'ville' : 'Bordeaux' , 'etat' : 'En cours' }, '2' : { 'numero' : 'SWK65993' , 'nom' : 'Gilles Kahn' , 'adresse' : '53 rue Ingrid Daubechies' , 'ville' : 'Lille' , 'etat' : 'En cours' }, '3' : { 'numero' : 'NKR34542' , 'nom' : 'Ada Lovelace' , 'adresse' : '98 rue Jules C\u00e9sar' , 'ville' : 'Bordeaux' , 'etat' : 'Livr\u00e9e' }, '4' : { 'numero' : 'GEG58414' , 'nom' : 'Jacques-Louis Lions' , 'adresse' : '84 rue Al-Kindi' , 'ville' : 'Rennes' , 'etat' : 'Retour' }, '5' : { 'numero' : 'FZA36963' , 'nom' : 'Al-Khwarizmi' , 'adresse' : '73 rue Adi Shamir' , 'ville' : 'Marseille' , 'etat' : 'En cours' }, '6' : { 'numero' : 'QWE58690' , 'nom' : 'Alonzo Church' , 'adresse' : '47 rue Jules C\u00e9sar' , 'ville' : 'Paris' , 'etat' : 'Retour' }, '7' : { 'numero' : 'NLY90647' , 'nom' : 'Hypatie d\u2019Alexandrie' , 'adresse' : '51 rue Whitfield Diffie' , 'ville' : 'Bordeaux' , 'etat' : 'En cours' }, '8' : { 'numero' : 'VVL26047' , 'nom' : 'Alonzo Church' , 'adresse' : '6: rue Adi Shamir' , 'ville' : 'Montpellier' , 'etat' : 'En cours' }, '9' : { 'numero' : 'CXO07384' , 'nom' : 'Jacques-Louis Lions' , 'adresse' : '30 rue Whitfield Diffie' , 'ville' : 'Paris' , 'etat' : 'Livr\u00e9e' }} >>> supprimer_commande ( 'EMA70895' ) numero de commande non existant","title":"TD - Les dictionnaires"},{"location":"crypto/crypto/","text":"Cryptographie \u2693\ufe0e 1. Chiffrement sym\u00e9trique \u2693\ufe0e 1.1 Activit\u00e9 du masque jetable \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aide On consid\u00e8re la variable suivante : \ud83d\udc0d Script Python masque = \"CETTEPHRASEESTVRAIMENTTRESTRESLONGUEMAISCESTFAITEXPRES\" Cr\u00e9er une fonction chiffre(message, masque) qui chiffre message en le XORant avec masque . Cette fonction doit pouvoir aussi servir \u00e0 d\u00e9chiffrer le message chiffr\u00e9. Le XOR (voir ici ) est une op\u00e9ration sym\u00e9trique : \ud83d\udc0d Script Python >>> 34 ^ 23 53 >>> 53 ^ 23 34 La fonction ord permet de renvoyer le code ASCII d'un caract\u00e8re. La fonction chr fait l'op\u00e9ration inverse. \ud83d\udc0d Script Python >>> ord ( 'A' ) 65 >>> chr ( 65 ) 'A' 1.2 Principe du chiffrement sym\u00e9trique \u2693\ufe0e Dans un chiffrement sym\u00e9trique, c'est la m\u00eame cl\u00e9 qui va servir au chiffrement et au d\u00e9chiffrement. Qu'appelle-t-on une cl\u00e9 ? \u2693\ufe0e La cl\u00e9 est un renseignement permettant de chiffrer ou d\u00e9chiffrer un message. Cela peut \u00eatre : un nombre (dans un simple d\u00e9calage des lettres de l'alphabet, comme le chiffre de C\u00e9sar ) une phrase (dans la m\u00e9thode du masque jetable ) une image (imaginez un chiffrement o\u00f9 on effectue un XOR par les pixels d'une image, comme dans cette \u00e9nigme ) Un chiffrement est dit sym\u00e9trique lorsque la connaissance de la cl\u00e9 ayant servi au chiffrement permet de d\u00e9chiffrer le message. Par exemple, Alice chiffre son message en d\u00e9calant les lettres de 3 rangs vers la droite dans l'alphabet, Bob saura qu'il doit les d\u00e9caler de 3 rangs vers la gauche pour retrouver le message initial. Quel est l'avantage d'un chiffrement sym\u00e9trique ? \u2693\ufe0e Les chiffrements sym\u00e9triques sont souvent rapides, consommant peu de ressources et donc adapt\u00e9s au chiffrement de flux important d'informations. Comme nous le verrons, la s\u00e9curisation des donn\u00e9es transitant par le protocole https est bas\u00e9e sur un chiffrement sym\u00e9trique. Quel est l'inconv\u00e9nient d'un chiffrement sym\u00e9trique ? \u2693\ufe0e La cl\u00e9 ! Si Alice et Bob ont besoin d'utiliser un chiffrement pour se parler, comment peuvent-ils \u00e9changer leurs cl\u00e9s puisque leur canal de transmission n'est pas s\u00fbr ? Le chiffrement sym\u00e9trique impose qu'Alice et Bob aient pu se rencontrer physiquement au pr\u00e9alable pour convenir d'une cl\u00e9 secr\u00e8te, ou bien qu'ils aient r\u00e9ussi \u00e0 \u00e9tablir une connexion s\u00e9curis\u00e9e pour s'\u00e9changer cette cl\u00e9. Un chiffrement sym\u00e9trique est-il un chiffrement de mauvaise qualit\u00e9 ? \u2693\ufe0e Pas du tout ! S'il est associ\u00e9 naturellement \u00e0 des chiffrements simples et faibles (comme le d\u00e9calage de C\u00e9sar), un chiffrement sym\u00e9trique peut \u00eatre tr\u00e8s robuste... voire inviolable. C'est le cas du masque jetable. Si le masque avec lequel on effectue le XOR sur le message est aussi long que le message, alors il est impossible de retrouver le message initial. Pourquoi ? Imaginons qu'Alice veuille transmettre le message clair \"LUNDI\". Elle le chiffre avec un masque jetable (que connait aussi Bob), et Bob re\u00e7oit donc \"KHZOK\". Si Marc a intercept\u00e9 le message \"KHZOK\", m\u00eame s'il sait que la m\u00e9thode de chiffrement utilis\u00e9e est celle du masque jetable (principe de Kerckhoffs), il n'a pas d'autre choix que de tester tous les masques de 5 lettres possibles. Ce qui lui donne \\(26^5\\) possibilit\u00e9s (plus de 11 millions) pour le masque, et par cons\u00e9quent (propri\u00e9t\u00e9 de bijectivit\u00e9 du XOR) \\(26^5\\) possibilit\u00e9s pour le message \u00abd\u00e9chiffr\u00e9\u00bb... Cela signifie que Marc verra appara\u00eetre, dans sa tentative de d\u00e9chiffrage, les mots \"MARDI\", \"JEUDI\", \"JOUDI\", \"STYLO\", \"FSDJK\", \"LUNDI, \"LUNDA\"... Il n'a aucune possibilit\u00e9 de savoir o\u00f9 est le bon message original parmi toutes les propositions (on parle de s\u00e9curit\u00e9 s\u00e9mantique ). Principe de Kerckhoffs : la s\u00e9curit\u00e9 d'un syst\u00e8me de chiffrement ne doit reposer que sur la s\u00e9curit\u00e9 de la cl\u00e9, et non pas sur la connaissance de l'algorithme de chiffrement. Cet algorithme peut m\u00eame \u00eatre public (ce qui est pratiquement toujours le cas). Quels sont les chiffrements sym\u00e9triques modernes ? \u2693\ufe0e L'algorithme de chiffrement sym\u00e9trique le plus utilis\u00e9 actuellement est le chiffrement AES , pour Advanced Encryption Standard. chiffrement par bloc de 128 bits, r\u00e9partis dans une matrice de 16 octets (matrice carr\u00e9e de taille 4). ces 128 bits sont transform\u00e9s par des rotations, multiplications, transpositions, [...] de la matrice initiale, en faisant intervenir dans ces transformations une cl\u00e9 de 128, 192 ou 256 bits. pour l'AES-256 (avec une cl\u00e9 de 256 bits), l'attaque par force brute n\u00e9cessiterait 2^256 op\u00e9rations, soit un nombre \u00e0 78 chiffres... il n'existe pas d'attaque connue efficace \u00e0 ce jour. Les seules attaques sont des attaques sur des faiblesses d'impl\u00e9mentation, ou par canal auxiliaire . 2. Chiffrement asym\u00e9trique \u2693\ufe0e Invent\u00e9 par Whitfield Diffie et Martin Hellman en 1976, le chiffrement asym\u00e9trique vient r\u00e9soudre l'inconv\u00e9nient essentiel du chiffrement sym\u00e9trique : le n\u00e9cessaire partage d'un secret (la cl\u00e9) avant l'\u00e9tablissement de la communication s\u00e9curis\u00e9e. 2.1 Principe du chiffrement asym\u00e9trique \u2693\ufe0e Le principe de base est l'existence d'une cl\u00e9 publique , appel\u00e9e \u00e0 \u00eatre distribu\u00e9e largement, et d'une cl\u00e9 priv\u00e9e , qui ne quitte jamais son propri\u00e9taire. 2.2 Le r\u00f4le interchangeable des cl\u00e9s publiques et priv\u00e9es \u2693\ufe0e L'illustration pr\u00e9c\u00e9dente associe : une image de cadenas \u00e0 la cl\u00e9 publique (car on s'en sert pour chiffrer les messages) une image de cl\u00e9 \u00e0 la cl\u00e9 priv\u00e9e (car on s'en sert pour d\u00e9chiffrer les messages) Concr\u00e8tement, (nous le verrons dans l'application par le chiffrement RSA), la cl\u00e9 priv\u00e9e et la cl\u00e9 publique sont deux nombres aux r\u00f4les identiques. Appelons-les A et B : il est impossible de trouver A en fonction de B. R\u00e9ciproquement, si on conna\u00eet A, il est impossible d'en d\u00e9duire B. si on chiffre un message avec A, on peut le d\u00e9chiffrer avec B. R\u00e9ciproquement, si on chiffre avec B, on peut d\u00e9chiffrer le message gr\u00e2ce \u00e0 A. on peut donc chiffrer avec une cl\u00e9 publique et d\u00e9chiffrer avec la cl\u00e9 priv\u00e9e associ\u00e9e (ce qui est fait dans l'exemple pr\u00e9c\u00e9dent). Mais on peut aussi chiffrer avec la cl\u00e9 priv\u00e9e, et d\u00e9chiffrer avec la cl\u00e9 publique associ\u00e9e. A et B ont donc des r\u00f4les interchangeables (chacun peut \u00eatre un cadenas, chacun peut \u00eatre une cl\u00e9), et ce n'est qu'en connaissant A et B qu'on peut d\u00e9chiffrer le message. Nous allons donc maintenant adopter une nouvelle convention infographique : Consid\u00e9rons ce message : Si ce message est chiffr\u00e9 avec la cl\u00e9 publique d'Alice, le message sera : Si on d\u00e9chiffre ce message avec la cl\u00e9 priv\u00e9e d'Alice, il deviendra et donc puisque l'application de la cl\u00e9 priv\u00e9e sur la cl\u00e9 publique, ou bien de la cl\u00e9 publique sur la cl\u00e9 priv\u00e9e, permet de retrouver le message en clair. De mani\u00e8re graphique, la connaissance des deux moiti\u00e9s du disque qui s'assemblent permet de les faire disparaitre, peu importe qu'on ait commenc\u00e9 par chiffrer avec la cl\u00e9 publique ou avec la cl\u00e9 priv\u00e9e. 2.3 Communication authentifi\u00e9e. \u2693\ufe0e Dans la situation du 2.1, Alice (qui a distribu\u00e9 largement sa cl\u00e9 publique) ne peut pas s'assurer que le message vient bien de Bob. Il peut avoir \u00e9t\u00e9 cr\u00e9\u00e9 par Marc, qui signe \u00abBob\u00bb et usurpe ainsi son identit\u00e9. Le protocole que nous allons d\u00e9crire ci-dessous permet : d'emp\u00eacher qu'un message intercept\u00e9 soit d\u00e9chiffr\u00e9 (ce qui \u00e9tait d\u00e9j\u00e0 le cas dans le 2.1) mais aussi de s'assurer que chaque personne est bien celle qu'elle pr\u00e9tend \u00eatre : on r\u00e9sout le probl\u00e8me d'authentification . En r\u00e9sum\u00e9 : Alice est s\u00fbre que seul Bob pourra d\u00e9chiffrer le message qu'elle envoie. Bob est s\u00fbr que le message qu'il re\u00e7oit vient bien d'Alice. 2.3 Un exemple de chiffrement asym\u00e9trique : le chiffrement RSA \u2693\ufe0e 2.3.1 Histoire \u2693\ufe0e Lorsqu'en 1976 Diffie et Hellman (chercheurs \u00e0 Stanford) pr\u00e9sentent le concept de chiffrement asym\u00e9trique (souvent appel\u00e9 cryptographie \u00e0 cl\u00e9s publiques ), ils en proposent uniquement un mod\u00e8le th\u00e9orique, n'ayant pas trouv\u00e9 une r\u00e9elle impl\u00e9mentation de leur protocole. Trois chercheurs du MIT (Boston), Ron Rivest, Adi Shamir et Len Adleman se penchent alors sur ce protocole, convaincus qu'il est en effet impossible d'en trouver une impl\u00e9mentation pratique. En 1977, au cours de leurs recherches, ils d\u00e9montrent en fait l'inverse de ce qu'ils cherchaient : ils cr\u00e9ent le premier protocole concret de chiffrement asym\u00e9trique : le chiffrement RSA . Au m\u00eame moment \u00e0 Londres, Clifford Cocks, (chercheur au tr\u00e8s secret GCHQ ) apprend que Rivest Shamir et Adleman viennent de d\u00e9couvrir ce que lui-m\u00eame a d\u00e9couvert 3 ans auparavant mais qui est rest\u00e9 class\u00e9 Secret D\u00e9fense. Il est le v\u00e9ritable inventeur du RSA... mais le reste du monde ne l'apprendra qu'en 1997 au moment de la d\u00e9classification de cette information. 2.3.1 Description \u2693\ufe0e Le chiffrement RSA est bas\u00e9 sur l'arithm\u00e9tique modulaire . Faire des calculs modulo un entier \\(n\\) , c'est ne garder que le reste de la division euclidienne par \\(n\\) . Le fait que 15 soit \u00e9gal \u00e0 1 modulo 7 (car \\(15=2 \\times 7+1\\) ) s'\u00e9crira \\(15 \\equiv 1 [7]\\) . De m\u00eame, \\(10 \\equiv 3 [7]\\) , \\(25 \\equiv 4 [7]\\) , \\(32 \\equiv 2 [10]\\) , etc. \u00c9tape 1 \u2693\ufe0e Alice choisit 2 grands nombres premiers \\(p\\) et \\(q\\) . Dans la r\u00e9alit\u00e9 ces nombres seront vraiment tr\u00e8s grands (plus de 100 chiffres). Dans notre exemple, nous prendrons \\(p = 3\\) et \\(q = 11\\) . \u00c9tape 2 \u2693\ufe0e Alice multiplie ces deux nombres \\(p\\) et \\(q\\) et obtient ainsi un nombre \\(n\\) . Il est tr\u00e8s facile pour Alice de calculer \\(n\\) en connaissant \\(p\\) et \\(q\\) , mais il extr\u00eamement difficile pour Marc de faire le travail inverse : trouver \\(p\\) et \\(q\\) en connaissant \\(n\\) prend un temps exponentiel avec la taille de \\(n\\) . C'est sur cette difficult\u00e9 (appel\u00e9e difficult\u00e9 de factorisation ) que repose la robustesse du syst\u00e8me RSA. \u00c9tape 3 \u2693\ufe0e Alice choisit un nombre \\(e\\) qui doit \u00eatre premier avec \\((p-1)(q-1)\\) . On note \\(\\phi(n)\\) le nombre \\((p-1)(q-1)\\) . Dans notre exemple, \\((p-1)(q-1) = 20\\) , Alice choisit donc \\(e = 3\\) . (mais elle aurait pu aussi choisir 7, 9, 13...). Le couple \\((e, n)\\) sera la cl\u00e9 publique d'Alice. Elle la diffuse \u00e0 qui veut lui \u00e9crire. Dans notre exemple, la cl\u00e9 publique d'Alice est \\((3, 33)\\) . \u00c9tape 4 \u2693\ufe0e Alice calcule maintenant sa cl\u00e9 priv\u00e9e : elle doit trouver un nombre d qui v\u00e9rifie l'\u00e9galit\u00e9 \\(e d \\equiv 1 [\\phi(n)]\\) . Dans notre exemple, comme \\(7 \\times 3 \\equiv 1 [20]\\) , ce nombre \\(d\\) est \u00e9gal \u00e0 7. En pratique, il existe un algorithme simple (algorithme d' Euclide \u00e9tendu ) pour trouver cette valeur \\(d\\) , appel\u00e9e inverse de e . Le couple \\((d, n)\\) sera la cl\u00e9 priv\u00e9e d'Alice. Elle ne la diffuse \u00e0 personne. Dans notre exemple, la cl\u00e9 priv\u00e9e d'Alice est \\((7, 33)\\) . \u00c9tape 5 \u2693\ufe0e Supposons que Bob veuille \u00e9crire \u00e0 Alice pour lui envoyer le nombre 4. Il poss\u00e8de la cl\u00e9 publique d'Alice, qui est \\((3, 33)\\) . Il calcule donc \\(4^3\\) modulo 33, qui vaut 31. C'est cette valeur 31 qu'il transmet \u00e0 Alice. \\[4^3 \\equiv 31 [33]\\] Si Marc intercepte cette valeur 31, m\u00eame en connaissant la cl\u00e9 publique d'Alice (3,33), il ne peut pas r\u00e9soudre l'\u00e9quation \\(x^3 \\equiv 31 [33]\\) de mani\u00e8re efficace. \u00c9tape 6 \u2693\ufe0e Alice re\u00e7oit la valeur 31. Il lui suffit alors d'\u00e9lever 31 \u00e0 la puissance 7 (sa cl\u00e9 priv\u00e9e), et de calculer le reste modulo 33 : \\(31^7 = 27512614111\\) \\(27512614111 \\equiv 4 [33]\\) Elle r\u00e9cup\u00e8re la valeur 4, qui est bien le message original de Bob. Comment \u00e7a marche ? Gr\u00e2ce au Petit Th\u00e9or\u00e8me de Fermat , on d\u00e9montre (voir ici ) assez facilement que \\(M^{ed} \\equiv M [n]\\) . Il faut remarquer que \\(M^{ed} = M^{de}\\) . On voit que les r\u00f4les de la cl\u00e9 publique et de la cl\u00e9 priv\u00e9e sont sym\u00e9triques : un message chiffr\u00e9 avec la cl\u00e9 publique se d\u00e9chiffrera en le chiffrant avec la cl\u00e9 priv\u00e9e, tout comme un message chiffr\u00e9 avec la cl\u00e9 priv\u00e9e se d\u00e9chiffrera en le chiffrant avec la cl\u00e9 publique. Animation interactive voir https://animations.interstices.info/interstices-rsa/rsa.html RSA, un syst\u00e8me inviolable ? \u2693\ufe0e Le chiffrement RSA a des d\u00e9fauts (notamment une grande consommation des ressources, due \u00e0 la manipulation de tr\u00e8s grands nombres). Mais le choix d'une cl\u00e9 publique de grande taille (actuellement 1024 ou 2048 bits) le rend pour l'instant inviolable. Actuellement, il n'existe pas d'algorithme efficace pour factoriser un nombre ayant plusieurs centaines de chiffres. Deux \u00e9v\u00e8nements pourraient faire s'\u00e9crouler la s\u00e9curit\u00e9 du RSA : la d\u00e9couverte d'un algorithme efficace de factorisation, capable de tourner sur les ordinateurs actuels. Cette annonce est r\u00e9guli\u00e8rement faite, et tout aussi r\u00e9guli\u00e8rement contredite par la communaut\u00e9 scientifique. (voir, le 05/03/2021, https://www.schneier.com/blog/archives/2021/03/no-rsa-is-not-broken.html ) l'av\u00e8nement d' ordinateurs quantiques , dont la vitesse d'ex\u00e9cution permettrait une factorisation rapide. Il est \u00e0 noter que l'algorithme de factorisation destin\u00e9 \u00e0 tourner sur un ordinateur quantique existe d\u00e9j\u00e0 : l'algorithme de Schor . 3. HTTPS : exemple d'utilisation conjointe d'un chiffrement asym\u00e9trique et d'un chiffrement sym\u00e9trique. \u2693\ufe0e 3.1 Principe g\u00e9n\u00e9ral \u2693\ufe0e Aujourd'hui, plus de 90 % du trafic sur internet est chiffr\u00e9 : les donn\u00e9es ne transitent plus en clair (protocole http ) mais de mani\u00e8re chiffr\u00e9e (protocole https ), ce qui emp\u00eache la lecture de paquets \u00e9ventuellements intercept\u00e9s. Le protocole https est la r\u00e9union de deux protocoles : le protocole TLS (Transport Layer Security, qui a succ\u00e9d\u00e9 au SSL) : ce protocole, bas\u00e9 sur du chiffrement asym\u00e9trique , va conduire \u00e0 la g\u00e9n\u00e9ration d'une cl\u00e9 identique chez le client et chez le serveur. le (bon vieux) protocole http , mais qui convoiera maintenant des donn\u00e9es chiffr\u00e9es avec la cl\u00e9 g\u00e9n\u00e9r\u00e9e \u00e0 l'\u00e9tape pr\u00e9c\u00e9dente. Les donn\u00e9es peuvent toujours \u00eatre intercept\u00e9es, mais sont illisibles. Le chiffrement sym\u00e9trique utilis\u00e9 est actuellement le chiffrement AES. Pourquoi ne pas utiliser que le chiffrement asym\u00e9trique, RSA par exemple ? Car il est tr\u00e8s gourmand en ressources ! Le chiffrement/d\u00e9chiffrement doit \u00eatre rapide pour ne pas ralentir les communications ou l'exploitation des donn\u00e9es. Le chiffrement asym\u00e9trique est donc r\u00e9serv\u00e9 \u00e0 l'\u00e9change de cl\u00e9s (au d\u00e9but de la communication). Le chiffrement sym\u00e9trique, bien plus rapide, prend ensuite le relais pour l'ensemble de la communication. 3.2 (HP) Fonctionnement du TLS : explication du handshake \u2693\ufe0e Observons en d\u00e9tail le fonctionnement du protocole TLS , dont le r\u00f4le est de g\u00e9n\u00e9rer de mani\u00e8re s\u00e9curis\u00e9e une cl\u00e9 dont disposeront \u00e0 la fois le client et le serveur, leur permettant ainsi d'appliquer un chiffrement sym\u00e9trique \u00e0 leurs \u00e9changes. \u00e9tape 1 : le \u00abclient Hello\u00bb. Le client envoie sa version de TLS utilis\u00e9e. \u00e9tape 2 : le \u00abserver Hello\u00bb. Le serveur r\u00e9pond en renvoyant son certificat prouvant son identit\u00e9, ainsi que sa cl\u00e9 publique. \u00e9tape 3 : le client interroge l'autorit\u00e9 de certification pour valider le fait que le certificat est bien valide et que le serveur est bien celui qu'il pr\u00e9tend \u00eatre. Cette v\u00e9rification est faite gr\u00e2ce \u00e0 un m\u00e9canisme de chiffrement asym\u00e9trique. La pr\u00e9sentation du certificat \u00e0 l'autorit\u00e9 de certification peut se repr\u00e9senter comme le scan d'une pi\u00e8ce d'identit\u00e9 dans un a\u00e9roport. L'autorit\u00e9 de certification est alors l'\u00c9tat (dont la base de donn\u00e9es est interrog\u00e9e par un logiciel) qui valide que la pi\u00e8ce d'identit\u00e9 est bien un document officiel. \u00e9tape 4 : une fois v\u00e9rifi\u00e9e l'authenticit\u00e9 du serveur et que son certificat est valide, le client calcule ce qui sera la future cl\u00e9 de chiffrement sym\u00e9trique (appel\u00e9e \u00abcl\u00e9 AES\u00bb dans l'infographie). Cette cl\u00e9 est chiffr\u00e9e avec la cl\u00e9 publique du server (transmise \u00e0 l'\u00e9tape 1), ce qui assure la s\u00e9curit\u00e9 de son transfert. Le serveur d\u00e9chiffre cette cl\u00e9 gr\u00e2ce \u00e0 sa cl\u00e9 priv\u00e9e, et dispose ainsi lui aussi de la cl\u00e9. Le transmission par protocole http de donn\u00e9es chiffr\u00e9es au pr\u00e9alable avec la cl\u00e9 AES peut commencer. Remarque : en r\u00e9alit\u00e9, ce n'est pas la cl\u00e9 AES qui est transmise \u00e0 l'\u00e9tape 4, mais un nombre choisi par le client, qui permettra, avec deux autres nombres choisis par le client (\u00e9tape 1) et le serveur (\u00e9tape 2) de reconstituer la cl\u00e9 AES, qui sera donc identique c\u00f4t\u00e9 client et c\u00f4t\u00e9 serveur. Bibliographie \u2693\ufe0e Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G. CONNAN, V. PETROV, G. ROZSAVOLGYI, L. SIGNAC, \u00e9ditions HATIER. https://www.cloudflare.com/fr-fr/learning/ssl/what-happens-in-a-tls-handshake/","title":"Cryptographie"},{"location":"crypto/crypto/#cryptographie","text":"","title":"Cryptographie"},{"location":"divers/Consigne_EP/","text":"Epreuve Pratique - Consigne \u2693\ufe0e D\u00e9roulement de l\u2019\u00e9preuve pratique \u2693\ufe0e Chaque session d\u2019\u00e9preuve pratique dure une heure. Une fois l\u2019\u00e9preuve lanc\u00e9e, l\u2019examinateur laisse les candidats en autonomie pendant 5 \u00e0 10 minutes , puis l\u2019examinateur passe ensuite \u00e0 tour de r\u00f4le aupr\u00e8s de chaque candidat afin d\u2019 installer un dialogue avec ce candidat. Durant l\u2019\u00e9preuve, l\u2019examinateur doit s\u2019adresser aux candidats en faisant preuve de discr\u00e9tion, afin de ne pas g\u00eaner les autres candidats ou afin de ne pas leur procurer une aide non demand\u00e9e. Chaque heure d\u2019\u00e9preuve est suivie d\u2019un quart d\u2019heure de Pr\u00e9paration/Accueil. Durant ce quart d\u2019heure : l\u2019examinateur remplit les fiches d\u2019\u00e9valuation individuelles des candidats ; le r\u00e9f\u00e9rent informatique installe sur les postes les nouveaux sujets ; l\u2019examinateur accueille les candidats de la session suivante, v\u00e9rifie leur identit\u00e9 et leur fait signer la feuille d\u2019\u00e9margement. Evaluation du candidat \u2693\ufe0e Grille d\u2019\u00e9valuation \u2693\ufe0e Lors de l\u2019\u00e9valuation, il est attendu une \u00e9valuation pr\u00e9cise des comp\u00e9tences qui peut prendre appui sur l\u2019exemple de grille d\u2019\u00e9valuation de la note de service du 16-3-2021 jointe en annexe 1. Cette grille est un exemple de grille de comp\u00e9tence pour aider les examinateurs ; elle n'a aucun caract\u00e8re prescriptif . Chaque exercice est not\u00e9 sur 4 points et doit faire l'objet d'une notation. Les notes des deux exercices sont exprim\u00e9es \u00e0 0,5 point pr\u00e9s. Pour chaque exercice, le professeur examinateur peut attribuer au candidat des notes du types 3 \u2013 3,5 \u2013 4 mais pas 3,75. La note sur 8 points attribu\u00e9e au candidat est la somme de ces deux notes. Cette somme est laiss\u00e9e telle quelle sans \u00eatre arrondie. Par exemple, un candidat qui a obtenue 3 points sur 4 au premier exercice et 3,5 points sur 4 au deuxi\u00e8me exercice se voit attribu\u00e9 la note de 6,5 points sur 8. L'aspect oral fait pleinement partie de l'\u00e9preuve pratique. Il est donc conseill\u00e9 de poser une ou plusieurs questions sur le code pour chaque exercice. Concernant la notation des exercices, il est recommand\u00e9 d'appliquer le bar\u00e8me suivant : - 3 points pour la programmation - 1 point pour l'expression orale . Pour la programmation, il faut donner a minima 2,5 points si le code est coh\u00e9rent m\u00eame si le programme ne \u00ab tourne \u00bb pas.","title":"Epreuve Pratique - Consigne"},{"location":"divers/Consigne_EP/#epreuve-pratique-consigne","text":"","title":"Epreuve Pratique - Consigne"},{"location":"divers/EP_2022/","text":"Th\u00e8me : Epreuve Pratique 22 TD : Sujet E.P 2022 Sujet 01 \u2693\ufe0e Exercice 01.1 Enonc\u00e9 \u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : \ud83d\udc0d Script Python >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 Correction \ud83d\udc0d Script Python def nb_occurrences ( caractere , mot ): nb_occ = 0 for lettre in mot : if lettre == caractere : nb_occ += 1 return nb_occ ou \ud83d\udc0d Script Python def nb_occurrences ( caractere , mot ): nb_occ = 0 for i in range ( len ( mot )): if mot [ i ] == caractere : nb_occ += 1 return nb_occ","title":"Epreuve Pratique 2022"},{"location":"divers/EP_2022/#sujet-01","text":"Exercice 01.1 Enonc\u00e9 \u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : \ud83d\udc0d Script Python >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 Correction \ud83d\udc0d Script Python def nb_occurrences ( caractere , mot ): nb_occ = 0 for lettre in mot : if lettre == caractere : nb_occ += 1 return nb_occ ou \ud83d\udc0d Script Python def nb_occurrences ( caractere , mot ): nb_occ = 0 for i in range ( len ( mot )): if mot [ i ] == caractere : nb_occ += 1 return nb_occ","title":"Sujet 01"},{"location":"divers/EpreuvePratique/","text":"\u00c9preuve pratique \ud83d\udcbb \u2693\ufe0e Vous trouverez ci-dessous un s\u00e9rie de sujets de l'\u00e9preuve pratique, disponibles publiquement sur la Banque Nationale des Sujets (novembre 2021). Une nouvelle version (qui sera a priori en grande partie semblable \u00e0 celle-ci) sera publi\u00e9e en janvier 2022 sur le site Eduscol . Exercice 04.1 \ud83d\uddf9 \u2693\ufe0e Exercice 04.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. \ud83d\udc0d Script Python def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne ([ 1 ]) == 1 assert moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] == 4 assert moyenne ([ 1 , 2 ]) == 1.5 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' somme = 0 for elt in tab : somme += elt return somme / len ( tab ) Exercice 04.2 \ud83d\uddf9 \u2693\ufe0e Exercice 04.2 \u00c9nonc\u00e9 Correction Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide. L'algorithme est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient False en renvoyant False,1 , False,2 et False,3 . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ... : return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ... : return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if tab = []: return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ( x > tab [ - 1 ]): return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False Exercice 05.1 \ud83d\uddf9 \u2693\ufe0e Exercice 05.1 \u00c9nonc\u00e9 Correction On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau [1, 0, 1, 0, 0, 1, 1] repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est 2**6 + 2**4 + 2**1 + 2**0 = 83 . \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : \ud83d\udc0d Script Python def convertir ( T ): \"\"\" T est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau T \"\"\" Exemple : \ud83d\udc0d Script Python >>> convertir ([ 1 , 0 , 1 , 0 , 0 , 1 , 1 ]) 83 >>> convertir ([ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ]) 130 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def convertir ( T ): puissance = 0 total = 0 for i in range ( len ( T ) - 1 , - 1 , - 1 ): total += T [ i ] * ( 2 ** puissance ) puissance += 1 return total Exercice 05.2 \ud83d\uddf9 \u2693\ufe0e Exercice 05.2 \u00c9nonc\u00e9 Correction La fonction tri_insertion suivante prend en argument une liste L et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if ... : return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > ... : i = ... # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , ... ): L [ k ] = L [ ... ] L [ i ] = ... return L Exemples : \ud83d\udc0d Script Python >>> tri_insertion ([ 2 , 5 , - 1 , 7 , 0 , 28 ]) [ - 1 , 0 , 2 , 5 , 7 , 28 ] >>> tri_insertion ([ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ]) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if L == []: return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > e : i = i - 1 # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , - 1 ): L [ k ] = L [ k - 1 ] L [ i ] = e return L Exercice 06.1 \ud83d\uddf9 \u2693\ufe0e Exercice 06.1 \u00c9nonc\u00e9 Correction On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e rendu dont le param\u00e8tre est un entier positif non nul somme_a_rendre et qui retourne une liste de trois entiers n1 , n2 et n3 qui correspondent aux nombres de billets de 5 euros ( n1 ) de pi\u00e8ces de 2 euros ( n2 ) et de pi\u00e8ces de 1 euro ( n3 ) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 somme_a_rendre . On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : \ud83d\udc0d Script Python >>> rendu ( 13 ) [ 2 , 1 , 1 ] >>> rendu ( 64 ) [ 12 , 2 , 0 ] >>> rendu ( 89 ) [ 17 , 2 , 0 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def rendu ( somme_a_rendre ): pieces = [ 5 , 2 , 1 ] retour = [ 0 , 0 , 0 ] reste_a_rendre = somme_a_rendre for i in range ( 3 ): retour [ i ] = reste_a_rendre // pieces [ i ] reste_a_rendre = reste_a_rendre % pieces [ i ] return retour Exercice 06.2 \ud83d\uddf9 \u2693\ufe0e \u00e0 noter une erreur dans la version officielle, sur la m\u00e9thode enfile() Exercice 06.2 \u00c9nonc\u00e9 Correction On veut \u00e9crire une classe pour g\u00e9rer une file \u00e0 l\u2019aide d\u2019une liste cha\u00een\u00e9e. On dispose d\u2019une classe Maillon permettant la cr\u00e9ation d\u2019un maillon de la cha\u00eene, celui-ci \u00e9tant constitu\u00e9 d\u2019une valeur et d\u2019une r\u00e9f\u00e9rence au maillon suivant de la cha\u00eene : \ud83d\udc0d Script Python 1 2 3 4 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None Compl\u00e9ter la classe File suivante o\u00f9 l\u2019attribut dernier_file contient le maillon correspondant \u00e0 l\u2019\u00e9l\u00e9ment arriv\u00e9 en dernier dans la file : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( ... ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = ... def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != ... : print ( maillon . valeur ) maillon = ... def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = ... while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = ... maillon . suivant = None return resultat return None On pourra tester le fonctionnement de la classe en utilisant les commandes suivantes dans la console Python : \ud83d\udc0d Script Python >>> F = File () >>> F . est_vide () True >>> F . enfile ( 2 ) >>> F . affiche () 2 >>> F . est_vide () False >>> F . enfile ( 5 ) >>> F . enfile ( 7 ) >>> F . affiche () 7 5 2 >>> F . defile () 2 >>> F . defile () 5 >>> F . affiche () 7 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( element ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = nouveau_maillon def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != None : print ( maillon . valeur ) maillon = maillon . suivant def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = self . dernier_file while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = maillon . suivant . valeur maillon . suivant = None return resultat return None Exercice 07.1 \ud83d\uddf9 \u2693\ufe0e Exercice 07.1 \u00c9nonc\u00e9 Correction On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par U1 = 1 , U2 = 1 et, pour tout entier naturel n , par Un+2 = Un+1 + Un . Elle s\u2019appelle la suite de Fibonacci. \u00c9crire la fonction fibonacci qui prend un entier n > 0 et qui renvoie l\u2019\u00e9l\u00e9ment d\u2019indice n de cette suite. On utilisera une programmation dynamique (pas de r\u00e9cursivit\u00e9). Exemple : \ud83d\udc0d Script Python >>> fibonacci ( 1 ) 1 >>> fibonacci ( 2 ) 1 >>> fibonacci ( 25 ) 75025 >>> fibonacci ( 45 ) 1134903170 On utilise un dictionnaire pour stocker au fur et \u00e0 mesure les valeurs. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fibonnaci ( n ): d = {} d [ 1 ] = 1 d [ 2 ] = 1 for k in range ( 3 , n + 1 ): d [ k ] = d [ k - 1 ] + d [ k - 2 ] return d [ n ] Exercice 07.2 \ud83d\uddf9 \u2693\ufe0e Exercice 07.2 \u00c9nonc\u00e9 Correction Les variables liste_eleves et liste_notes ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction meilleures_notes renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction meilleures_notes ci-dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range ( ... ): if liste_notes [ compteur ] == ... : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ ... ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = ... liste_maxi = [ ... ] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Une fois compl\u00e9t\u00e9, le code ci-dessus donne \ud83d\udc0d Script Python >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ]) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = 0 liste_maxi = [] for compteur in range ( len ( liste_eleves )): if liste_notes [ compteur ] == note_maxi : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ compteur ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = 1 liste_maxi = [ liste_eleves [ compteur ]] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Exercice 08.1 \ud83d\uddf9 \u2693\ufe0e Exercice 08.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : \ud83d\udc0d Script Python >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( caractere , mot ): somme = 0 for lettre in mot : if lettre == caractere : somme += 1 return somme Exercice 08.2 \ud83d\uddf9 \u2693\ufe0e Exercice 08.2 \u00c9nonc\u00e9 Correction On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets - le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste pieces=[100, 50, 20, 10, 5, 2, 1] - (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre), on cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return ... p = pieces [ i ] if p <= ... : solution . append ( ... ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , ... ) On devra obtenir : \ud83d\udc0d Script Python >>> rendu_glouton ( 68 ,[], 0 ) [ 50 , 10 , 5 , 2 , 1 ] >>> rendu_glouton ( 291 ,[], 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return solution p = pieces [ i ] if p <= arendre : solution . append ( p ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , i + 1 ) Exercice 15.1 \ud83d\uddf9 \u2693\ufe0e Exercice 15.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction rechercheMinMax qui prend en param\u00e8tre un tableau de nombres non tri\u00e9s tab , et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s \u2018min\u2019 et \u2018max\u2019. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> tableau = [ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : - 2 , 'max' : 9 } >>> tableau = [] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : None , 'max' : None } \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def rechercheMinMax ( tab ): if tab == []: return { 'min' : None , 'max' : None } else : d = {} d [ 'min' ] = tab [ 0 ] d [ 'max' ] = tab [ 0 ] for val in tab : if val < d [ 'min' ]: d [ 'min' ] = val if val > d [ 'max' ]: d [ 'max' ] = val return d Exercice 15.2 \ud83d\uddf9 \u2693\ufe0e Exercice 15.2 \u00c9nonc\u00e9 Correction On dispose d\u2019un programme permettant de cr\u00e9er un objet de type PaquetDeCarte , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par #A compl\u00e9ter , puis ajouter des assertions dans l\u2019initialiseur de Carte , ainsi que dans la m\u00e9thode getCarteAt() . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): #A compl\u00e9ter \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): #A compl\u00e9ter Exemple : \ud83d\udc0d Script Python >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) 8 de carreau Attention, le code propos\u00e9 ne respecte pas les standards de notation : il ne faut pas de majuscules sur les noms des attributs la docstring se place \u00e0 l'int\u00e9rieur de la fonction et non au dessus. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): assert c in range ( 1 , 5 ) assert v in range ( 1 , 14 ) self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): for nb_coul in range ( 1 , 5 ): for val in range ( 1 , 14 ): self . contenu . append ( Carte ( nb_coul , val )) \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): assert pos < 52 , 'erreur position' return self . contenu [ pos ] Exercice 19.1 \ud83d\uddf9 \u2693\ufe0e Exercice 19.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1 Exercice 19.2 \ud83d\uddf9 \u2693\ufe0e Exercice 19.2 \u00c9nonc\u00e9 Correction Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res ALPHABET s\u2019il s\u2019y trouve et -1 sinon. La fonction cesar prend en param\u00e8tre une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for ... in message : if lettre in ALPHABET : indice = ( ... ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : \ud83d\udc0d Script Python >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for lettre in message : if lettre in ALPHABET : indice = ( position_alphabet ( lettre ) + decalage ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = resultat + lettre return resultat Exercice 20.1 \ud83d\uddf9 \u2693\ufe0e Exercice 20.1 \u00c9nonc\u00e9 Correction On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : \ud83d\udc0d Script Python t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] \u00c9crire la fonction mini qui prend en param\u00e8tres le tableau releve des relev\u00e9s et le tableau date des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. Exemple : \ud83d\udc0d Script Python >>> mini ( t_moy , annees ) ( 12.5 , 2016 ) {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] def mini ( releve , date ): temp_mini = releve [ 0 ] date_mini = date [ 0 ] for i in range ( len ( releve )): if releve [ i ] < temp_mini : temp_mini = releve [ i ] date_mini = date [ i ] return temp_mini , date_mini \" ) }} Exercice 20.2 \ud83d\uddf9 \u2693\ufe0e Exercice 20.2 \u00c9nonc\u00e9 Correction Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : bob , radar , et non sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction est_nbre_palindrome s\u2019appuiera sur la fonction est_palindrome qui elle-m\u00eame s\u2019appuiera sur la fonction inverse_chaine . La fonction inverse_chaine inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res chaine et renvoie la cha\u00eene invers\u00e9e. La fonction est_palindrome teste si une chaine de caract\u00e8res chaine est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction est_nbre_palindrome teste si un nombre nbre est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. \ud83d\udc0d Script Python def inverse_chaine ( chaine ): result = ... for caractere in chaine : result = ... return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return ... def est_nbre_palindrome ( nbre ): chaine = ... return est_palindrome ( chaine ) Exemples : \ud83d\udc0d Script Python >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def inverse_chaine ( chaine ): result = '' for caractere in chaine : result = caractere + result return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return chaine == inverse def est_nbre_palindrome ( nbre ): chaine = str ( nbre ) return est_palindrome ( chaine ) \" ) }} Exercice 29.1 \ud83d\uddf9 \u2693\ufe0e Exercice 29.1 \u00c9nonc\u00e9 Correction Soit un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 1 : s'il est pair, on le divise par 2 ; s\u2019il est impair, on le multiplie par 3 et on ajoute 1. Puis on recommence ces \u00e9tapes avec le nombre entier obtenu, jusqu\u2019\u00e0 ce que l\u2019on obtienne la valeur 1. On d\u00e9finit ainsi la suite \\((U_n)\\) par : \\(U_0=k\\) , o\u00f9 \\(k\\) est un entier choisi initialement; \\(U_{n+1} = \\dfrac{U_n}{2}\\) si \\(U_n\\) est pair; \\(U_{n+1} = 3 \\times U_n + 1\\) si \\(U_n\\) est impair. On admet que, quel que soit l'entier k choisi au d\u00e9part, la suite finit toujours sur la valeur 1. \u00c9crire une fonction calcul prenant en param\u00e8tres un entier n strictement positif et qui renvoie la liste des valeurs de la suite, en partant de n et jusqu'\u00e0 atteindre 1. Exemple : \ud83d\udc0d Script Python >>> calcul ( 7 ) [ 7 , 22 , 11 , 34 , 17 , 52 , 26 , 13 , 40 , 20 , 10 , 5 , 16 , 8 , 4 , 2 , 1 ] {{ correction(True, \" \" ) }} Exercice 29.2 \ud83d\uddf9 \u2693\ufe0e Exercice 29.2 \u00c9nonc\u00e9 Correction On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son code alphab\u00e9tique concat\u00e9n\u00e9 , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, son code additionn\u00e9 , qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : Pour le mot \"PAUL\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1612112' , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot \"PAUL\" n\u2019est pas parfait. Pour le mot \"ALAIN\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1121914' , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Compl\u00e9ter la fonction est_parfait ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res mot (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de mot , ainsi qu\u2019un bool\u00e9en qui indique si mot est parfait ou pas. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = ??? for c in mot : code_c = code_c + ??? code_a = ??? code_c = int ( code_c ) if ??? : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] Exemples : \ud83d\udc0d Script Python >>> est_parfait ( \"PAUL\" ) [ 50 , 1612112 , False ] >>> est_parfait ( \"ALAIN\" ) [ 37 , 1121914 , True ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = 0 for c in mot : code_c = code_c + str ( dico [ c ]) code_a = code_a + dico [ c ] code_c = int ( code_c ) if code_c % code_a == 0 : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ]","title":"\u00c9preuve pratique \ud83d\udcbb"},{"location":"divers/EpreuvePratique/#epreuve-pratique","text":"Vous trouverez ci-dessous un s\u00e9rie de sujets de l'\u00e9preuve pratique, disponibles publiquement sur la Banque Nationale des Sujets (novembre 2021). Une nouvelle version (qui sera a priori en grande partie semblable \u00e0 celle-ci) sera publi\u00e9e en janvier 2022 sur le site Eduscol .","title":"\u00c9preuve pratique \ud83d\udcbb"},{"location":"divers/Exercice_Bac_2_Correction/","text":"Th\u00e8me : BAC 22 TD : Exercices Divers BAC - Programmation Sujet 4 : la programmation en g\u00e9n\u00e9ral et la r\u00e9cursivit\u00e9 en particulier. On consid\u00e8re un tableau de nombres de \\(n\\) lignes et \\(p\\) colonnes. Les lignes sont num\u00e9rot\u00e9es de 0 \u00e0 \\(n-1\\) et les colonnes sont num\u00e9rot\u00e9es de 0 \u00e0 \\(p-1\\) . La case en haut \u00e0 gauche est rep\u00e9r\u00e9e par (0, 0) et la case en bas \u00e0 droite par \\((n - 1, p - 1)\\) . On appelle chemin une succession de cases allant de la case (0, 0) \u00e0 la case \\((n - 1, p - 1)\\) , en n\u2019autorisant que des d\u00e9placements case par case : soit vers la droite, soit vers le bas. On appelle somme d\u2019un chemin la somme des entiers situ\u00e9s sur ce chemin. Par exemple, pour le tableau T suivant : Un chemin est (0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (2, 3) (en gras sur le tableau) ; La somme du chemin pr\u00e9c\u00e9dent est 14. (0, 0), (0, 2), (2, 2), (2, 3) n\u2019est pas un chemin. L\u2019objectif de cet exercice est de d\u00e9terminer la somme maximale pour tous les chemins possibles allant de la case (0, 0) \u00e0 la case \\((n - 1, p - 1)\\) . Question 1 Enonc\u00e9 Solution 1.1 Solution 1.2 On consid\u00e8re tous les chemins allant de la case (0, 0) \u00e0 la case (2, 3) du tableau T donn\u00e9 en exemple. Un tel chemin comprend n\u00e9cessairement 3 d\u00e9placements vers la droite. Combien de d\u00e9placements vers le bas comprend-il ? La longueur d\u2019un chemin est \u00e9gal au nombre de cases de ce chemin. Justifier que tous les chemins allant de (0, 0) \u00e0 (2, 3) ont une longueur \u00e9gale \u00e0 6. Le chemin comprend 2 d\u00e9placements vers le bas Sachant que les d\u00e9placements en diagonale ne sont pas autoris\u00e9s, il faudra obligatoirement se d\u00e9placer 3 fois vers la droite (parcours 4 cases) et 2 fois vers le bas (parcours 2 cases suppl\u00e9mentaires) quel que soit l\u2019ordre de ces d\u00e9placements. On aura donc bien un chemin de longueur \u00e9gale \u00e0 6 quel que soit le chemin emprunt\u00e9. Question 2 Enonc\u00e9 Solution En listant tous les chemins possibles allant de (0, 0) \u00e0 (2, 3) du tableau T, d\u00e9terminer un chemin qui permet d\u2019obtenir la somme maximale et la valeur de cette somme. avec le parcours 0,0 -> 1,0 -> 2,0 -> 2,1 -> 2,2 -> 2,3 on obtient la somme 4 + 2 + 3 + 1 + 5 + 1 = 16 qui est la somme maximale. Question 3 Enonc\u00e9 Solution 3.1 Solution 3.2 On veut cr\u00e9er le tableau T\u2019 o\u00f9 chaque \u00e9l\u00e9ment T\u2019[i][j] est la somme maximale pour tous les chemins possibles allant de (0, 0) \u00e0 \\((i, j)\\) . Compl\u00e9ter et recopier sur votre copie le tableau T\u2019 donn\u00e9 ci-dessous associ\u00e9 au tableau Justifier que si \\(j\\) est diff\u00e9rent de 0, alors : T\u2019[0][j] = T[0][j] + T\u2019[0][j-1] La somme obtenue \u00e0 la colonne \\(j\\) est \u00e9gale \u00e0 la somme obtenue \u00e0 la colonne \\(j-1\\) (\u00e0 gauche de \\(j\\) ) plus la valeur de la case \\(0,j\\) (puisque l\u2019on peut uniquement aller \u00e0 droite) d\u2019o\u00f9 T'[0][j] = T[0][j] + T'[0][j-1] Question 4 Enonc\u00e9 Solution Justifier que si \\(i\\) et \\(j\\) sont diff\u00e9rents de 0, alors : T\u2019[i][j] = T[i][j] + max(T\u2019[i-1][j], T\u2019[i][j-1]) . Quand on se trouve \u00e0 la case \\((i,j)\\) , on vient : soit de la case \\((i-1,j)\\) (case situ\u00e9e au-dessus de \\((i,j)\\) ), soit de la case \\((i, j-1)\\) (case situ\u00e9e \u00e0 gauche de \\((i,j)\\) ). Donc on doit ajouter \u00e0 la valeur de la case T[i][j] soit la somme obtenue \u00e0 la case \\((i-1,j)\\) , soit la somme obtenue \u00e0 la case \\((i, j-1)\\) (on prendra la somme maximum). d\u2019o\u00f9 : T'[i][j] = T[i][j] + max(T'[i-1][j], T'[i][j-1]) Question 5 Enonc\u00e9 Solution 5.1 Solution 5.2 Solution 5.3 On veut cr\u00e9er la fonction r\u00e9cursive somme_max ayant pour param\u00e8tres un tableau T, un entier \\(i\\) et un entier \\(j\\) . Cette fonction renvoie la somme maximale pour tous les chemins possibles allant de la case (0, 0) \u00e0 la case \\((i, j)\\) . Quel est le cas de base, \u00e0 savoir le cas qui est trait\u00e9 directement sans faire appel \u00e0 la fonction somme_max ? Que renvoie-t-on dans ce cas ? \u00c0 l\u2019aide de la question pr\u00e9c\u00e9dente, \u00e9crire en Python la fonction r\u00e9cursive somme_max . Quel appel de fonction doit-on faire pour r\u00e9soudre le probl\u00e8me initial ? Le cas de base est le cas o\u00f9 i = 0 et j = 0, on renvoie alors la valeur T[0][0] \ud83d\udc0d Script Python def somme_max ( T , i , j ): if i == 0 and j == 0 : return T [ 0 ][ 0 ] else : if i == 0 : return T [ 0 ][ j ] + somme_max ( T , 0 , j - 1 ) elif j == 0 : return T [ i ][ 0 ] + somme_max ( T , i - 1 , 0 ) else : return T [ i ][ j ] + max ( somme_max ( T , i - 1 , j ), somme_max ( T , i , j - 1 )) Pour r\u00e9soudre le probl\u00e8me initial, on doit effectuer l\u2019appel suivant : somme_max(T, 2, 3) Sujet 5 : la programmation en g\u00e9n\u00e9ral et la r\u00e9cursivit\u00e9 en particulier. Cet exercice porte sur la programmation en g\u00e9n\u00e9ral et la r\u00e9cursivit\u00e9 en particulier. On s\u2019int\u00e9resse dans cet exercice \u00e0 un algorithme de m\u00e9lange des \u00e9l\u00e9ments d\u2019une liste. Question 1. Enonc\u00e9 Solution Pour la suite, il sera utile de disposer d'une fonction echange qui permet d'\u00e9changer dans une liste lst les \u00e9l\u00e9ments d'indice i1 et i2 . Expliquer pourquoi le code Python ci-dessous ne r\u00e9alise pas cet \u00e9change et en proposer une modification. \ud83d\udc0d Script Python def echange ( lst , i1 , i2 ): lst [ i2 ] = lst [ i1 ] lst [ i1 ] = lst [ i2 ] Prenons un exemple o\u00f9 au d\u00e9part on a : lst[i1] = 3 et lst[2] = 8 Apr\u00e8s la ligne lst[i2] = lst[i1] , nous avons lst[i2] = 3 Apr\u00e8s la ligne lst[i1] = lst[i2] , nous avons lst[i1] = 3 Le r\u00e9sultat attendu \u00e9tait lst[i1] = 8 et lst[2] = 3 , le r\u00e9sultat obtenu est lst[i1] = 3 et lst[2] = 3 , le code Python propos\u00e9 ne r\u00e9alise pas l\u2019\u00e9change attendu. Il faut utiliser une variable temporaire pour que cela fonctionne : \ud83d\udc0d Script Python temp = lst [ i2 ] lst [ i2 ] = lst [ i1 ] lst [ i1 ] = temp Question 2. Enonc\u00e9 Solution La documentation du module random de Python fournit les informations cidessous concernant la fonction randint(a,b) : \ud83d\udc0d Script Python Renvoie un entier al\u00e9atoire N tel que a <= N <= b . Alias pour randrange ( a , b + 1 ) . Parmi les valeurs ci-dessous, quelles sont celles qui peuvent \u00eatre renvoy\u00e9es par l'appel randint(0, 10) ? \u25a1 0 \u25a1 1 \u25a1 3.5 \u25a1 9 \u25a1 10 \u25a1 11 Les valeurs qui pourront \u00eatre renvoy\u00e9es par randint(0, 10) sont : 0, 1, 9 et 10 Question 3. Enonc\u00e9 Solution 3.a Solution 3.b Solution 3.c Solution 3.d Le m\u00e9lange de Fischer Yates est un algorithme permettant de permuter al\u00e9atoirement les \u00e9l\u00e9ments d'une liste. On donne ci-dessous une mise en \u0153uvre r\u00e9cursive de cet algorithme en Python. \ud83d\udc0d Script Python from random import randint def melange ( lst , ind ): print ( lst ) if ind > 0 : j = randint ( 0 , ind ) echange ( lst , ind , j ) melange ( lst , ind - 1 ) a. Expliquer pourquoi la fonction melange se termine toujours. b. Lors de l\u2019appel de la fonction melange , la valeur du param\u00e8tre ind doit \u00eatre \u00e9gal au plus grand indice possible de la liste lst . Pour une liste de longueur \u074a, quel est le nombre d'appels r\u00e9cursifs de la fonction melange effectu\u00e9s, sans compter l\u2019appel initial ? c. On consid\u00e8re le script ci-dessous : \ud83d\udc0d Script Python lst = [ v for v in range ( 5 )] melange ( lst , 4 ) On suppose que les valeurs successivement renvoy\u00e9es par la fonction randint sont 2, 1, 2 et 0. Les deux premiers affichages produits par l'instruction print(lst) de la fonction melange sont : \ud83d\udccb Texte [0, 1, 2, 3, 4] [0, 1, 4, 3, 2] Donner les affichages suivants produits par la fonction melange. d. Proposer une version it\u00e9rative du m\u00e9lange de Fischer Yates. Nous avons un appel r\u00e9cursif avec melange(lst, ind-1). \u00c0 chaque appel r\u00e9cursif on soustrait 1 au param\u00e8tre ind. Au bout d\u2019un certain nombre d\u2019appels r\u00e9cursifs, le param\u00e8tre sera \u00e9gal \u00e0 0, les instructions \u201ccontenues\u201d dans le \u201cif\u201d (if ind>0) ne seront plus ex\u00e9cut\u00e9es et le programme s'arr\u00eatera. Pour l\u2019appel initial de la fonction nous avons ind = n-1. Pour le premier appel r\u00e9cursif nous avons ind = n-2. Pour le dernier appel r\u00e9cursif nous avons ind = 0, nous avons donc eu n-1 appels r\u00e9cursifs. \ud83d\udc0d Script Python def melange ( lst ): ind = len ( lst ) - 1 while ind > 0 : j = randint ( 0 , ind ) echange ( lst , ind , j ) ind = ind - 1 Sujet 6 : la programmation objet. Cryptage selon le \u00ab Code de C\u00e9sar \u00bb Dans cet exercice, on \u00e9tudie une m\u00e9thode de chiffrement de cha\u00eenes de caract\u00e8res alphab\u00e9tiques. Pour des raisons historiques, cette m\u00e9thode de chiffrement est appel\u00e9e \"code de C\u00e9sar\". On consid\u00e8re que les messages ne contiennent que les lettres capitales de l\u2019alphabet \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" et la m\u00e9thode de chiffrement utilise un nombre entier fix\u00e9 appel\u00e9 la cl\u00e9 de chiffrement. Question 1. Enonc\u00e9 Solution Soit la classe CodeCesar d\u00e9finie ci-dessous : \ud83d\udc0d Script Python class CodeCesar : def __init__ ( self , cle ): self . cle = cle self . alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" def decale ( self , lettre ): num1 = self . alphabet . find ( lettre ) num2 = num1 + self . cle if num2 >= 26 : num2 = num2 - 26 if num2 < 0 : num2 = num2 + 26 nouvelle_lettre = self . alphabet [ num2 ] return nouvelle_lettre On rappelle que la m\u00e9thode str.find(lettre) renvoie l'indice (index) de la lettre dans la cha\u00eene de caract\u00e8res str Repr\u00e9senter le r\u00e9sultat d\u2019ex\u00e9cution du code Python suivant : \ud83d\udc0d Script Python code1 = CodeCesar ( 3 ) print ( code1 . decale ( 'A' )) print ( code1 . decale ( 'X' )) R\u00e9sultat d\u2019ex\u00e9cution : D A Question 2. Enonc\u00e9 Solution La m\u00e9thode de chiffrement du \u00ab code C\u00e9sar \u00bb consiste \u00e0 d\u00e9caler les lettres du message dans l\u2019alphabet d'un nombre de rangs fix\u00e9 par la cl\u00e9. Par exemple, avec la cl\u00e9 3, toutes les lettres sont d\u00e9cal\u00e9es de 3 rangs vers la droite : le A devient le D, le B devient le E, etc. Ajouter une m\u00e9thode cryptage(self, texte) dans la classe CodeCesar d\u00e9finie \u00e0 la question pr\u00e9c\u00e9dente, qui re\u00e7oit en param\u00e8tre une cha\u00eene de caract\u00e8res (le message \u00e0 crypter) et qui retourne une cha\u00eene de caract\u00e8res (le message crypt\u00e9). Cette m\u00e9thode cryptage(self, texte) doit crypter la cha\u00eene texte avec la cl\u00e9 de l'objet de la classe CodeCesar qui a \u00e9t\u00e9 instanci\u00e9. Exemple : \ud83d\udc0d Script Python >>> code1 = CodeCesar ( 3 ) >>> code1 . cryptage ( \"NSI\" ) 'QVL' \ud83d\udc0d Script Python def cryptage ( self , texte ): c = \"\" for lettre in texte : c = c + self . decale ( lettre ) return c Question 3. Enonc\u00e9 Solution Ecrire un programme qui : demande de saisir la cl\u00e9 de chiffrement cr\u00e9e un objet de classe CodeCesar demande de saisir le texte \u00e0 chiffrer affiche le texte chiffr\u00e9 en appelant la m\u00e9thode cryptage \ud83d\udc0d Script Python cle = input ( \"saisir la cl\u00e9 de chiffrement : \" ) cle = int ( cle ) c = CodeCesar ( cle ) txt = input ( \"saisir le texte \u00e0 chiffrer : \" ) print ( \"le message chiffr\u00e9 est : \" + c . cryptage ( txt )) Question 4. Enonc\u00e9 Solution On ajoute la m\u00e9thode transforme(texte) \u00e0 la classe CodeCesar : \ud83d\udc0d Script Python def transforme ( self , texte ): self . cle = - self . cle message = self . cryptage ( texte ) self . cle = - self . cle return message On ex\u00e9cute la ligne suivante : print(CodeCesar(10).transforme(\"PSX\")) Que va-t-il s\u2019afficher ? Expliquer votre r\u00e9ponse. La ligne print(CodeCesar(10).transforme(\"PSX\")) va permettre d\u2019afficher FIN Sujet 7 : programmation Python, tuples et listes. L\u2019objectif de cet exercice est de mettre en place une mod\u00e9lisation d\u2019un jeu de labyrinthe en langage Python. On d\u00e9cide de repr\u00e9senter un labyrinthe par un tableau carr\u00e9 de taille n, dans lequel les cases seront des 0 si l\u2019on peut s\u2019y d\u00e9placer et des 1 s\u2019il s\u2019agit d\u2019un mur. Voici un exemple de repr\u00e9sentation d\u2019un labyrinthe : L\u2019entr\u00e9e du labyrinthe se situe \u00e0 la premi\u00e8re case du tableau (celle en haut \u00e0 gauche) et la sortie du labyrinthe se trouve \u00e0 la derni\u00e8re case (celle en bas \u00e0 droite). Question 1. Enonc\u00e9 Solution Proposer, en langage Python, une fonction mur, prenant en param\u00e8tre un tableau repr\u00e9sentant un labyrinthe et deux entiers \\(i\\) et \\(j\\) compris entre 0 et n1 et qui renvoie un bool\u00e9en indiquant la pr\u00e9sence ou non d\u2019un mur. Par exemple : \ud83d\udc0d Script Python >> mur ( laby , 2 , 3 ) True >> mur ( laby , 1 , 8 ) False \ud83d\udc0d Script Python def mur ( l , i , j ): return l [ i ][ j ] == 1 Un parcours dans le labyrinthe va \u00eatre repr\u00e9sent\u00e9 par une liste de cases. Il s\u2019agit de couples (i,j) o\u00f9 i et j correspondent respectivement aux num\u00e9ros de ligne et de colonne des cases successivement visit\u00e9es au long du parcours. Ainsi, la liste suivante [(1,4),(1,5),(1,6),(2,6),(3,6),(3,5),(3,4)] correspond au parcours rep\u00e9r\u00e9 par des \u00e9toiles ci-dessous : La liste [(0,0),(1,0),(1,1),(5,1),(6,1)] ne peut correspondre au parcours d\u2019un labyrinthe car toutes les cases parcourues successivement ne sont pas adjacentes. Question 2. Enonc\u00e9 Solution 2.a On consid\u00e8re la fonction voisine ci-dessous, \u00e9crite en langage Python, qui prend en param\u00e8tres deux cases donn\u00e9es sous forme de couple. \ud83d\udc0d Script Python def voisine ( case1 , case2 ) : l1 , c1 = case1 l2 , c2 = case2 # on vous rappelle que **2 signifie puissance 2 d = ( l1 - l2 ) ** 2 + ( c1 - c2 ) ** 2 return ( d == 1 ) 2.a. Apr\u00e8s avoir remarqu\u00e9 que les quantit\u00e9s l1-l2 et c1-c2 sont des entiers, expliquer pourquoi la fonction voisine indique si deux cases donn\u00e9es sous forme de tuples (l,c) sont adjacentes. 2.b. En d\u00e9duire une fonction adjacentes qui re\u00e7oit une liste de cases et renvoie un bool\u00e9en indiquant si la liste des cases forme une cha\u00eene de cases adjacentes. La variable d repr\u00e9sente le carr\u00e9 de la distance entre entre les cases case1 et case2. Deux cases adjacentes ont une distance \u00e9gale \u00e0 1. Donc d==1 (et donc la fonction voisine) renvoie True si case1 et case2 sont adjacentes et False dans le cas contraire. Un parcours sera qualifi\u00e9 de compatible avec le labyrinthe lorsqu\u2019il s\u2019agit d\u2019une succession de cases adjacentes accessibles (non mur\u00e9es). On donne la fonction teste(cases, laby) qui indique si le chemin cases est un chemin possible compatible avec le labyrinthe laby : \ud83d\udc0d Script Python def teste ( cases , laby ) : if not adjacentes ( cases ) : return False possible = True i = 0 while i < len ( cases ) and possible : if mur ( laby , cases [ i ][ 0 ], cases [ i ][ 1 ]) : possible = False i = i + 1 return possible Question 3. Justifier que la boucle de la fonction pr\u00e9c\u00e9dente se termine. Question 4. En d\u00e9duire une fonction echappe(cases, laby) qui indique par un bool\u00e9en si le chemin cases permet d\u2019aller de l\u2019entr\u00e9e \u00e0 la sortie du labyrinthe laby . Adaptation en TP : Lien vers TP Capytale Sujet 8 : structure de donn\u00e9es (tableaux, dictionnaires) et langages et programmation (sp\u00e9cification). Objectif de l\u2019exercice : Les Aventuriers du Rail\u00a9 est un jeu de soci\u00e9t\u00e9 dans lequel les joueurs doivent construire des lignes de chemin de fer entre diff\u00e9rentes villes d'un pays. La carte des liaisons possibles dans la r\u00e9gion Occitanie est donn\u00e9e en annexe 1 de l\u2019exercice. Dans l\u2019annexe 2 de l\u2019exercice, les liaisons poss\u00e9d\u00e9es par le joueur 1 sont en noir, et celles du joueur 2 en blanc. Les liaisons en gris sont encore en jeu. Codages des structures de donn\u00e9es utilis\u00e9es : Liste des liaisons d'un joueur : Toutes les liaisons directes (sans ville interm\u00e9diaire) construites par un joueur seront enregistr\u00e9es dans une variable de type \"tableau de tableaux\". Le joueur 1 poss\u00e8de les lignes directes \"Toulouse-Muret\", \"Toulouse-Montauban\", \"Gaillac-St Sulpice\" et \"Muret-Pamiers\" (liaisons indiqu\u00e9es en noir dans l\u2019annexe 2 de l\u2019exercice). Ces liaisons sont m\u00e9moris\u00e9es dans la variable ci-dessous. \ud83d\udc0d Script Python liaisonsJoueur1 = [ [ \"Toulouse\" , \"Muret\" ], [ \"Toulouse\" , \"Montauban\" ], [ \"Gaillac\" , \"St Sulpice\" ], [ \"Muret\" , \"Pamiers\" ] ] Remarque : Seules les liaisons directes existent, par exemple [\"Toulouse\",\"Muret\"] ou [\"Muret\",\"Toulouse\"] . Par contre, le tableau [\"Toulouse\",\"Mazamet\"] n'existe pas, puisque la ligne Toulouse-Mazamet passe par Castres. Dictionnaire associ\u00e9 \u00e0 un joueur : On code la liste des villes et des trajets poss\u00e9d\u00e9e par un joueur en utilisant un dictionnaire de tableaux. Chaque clef de ce dictionnaire est une ville de d\u00e9part, et chaque valeur est un tableau contenant les villes d'arriv\u00e9e possibles en fonction des liaisons poss\u00e9d\u00e9es par le joueur. Le dictionnaire de tableaux du joueur 1 est donn\u00e9 ci-dessous : \ud83d\udc0d Script Python DictJoueur1 = { \"Toulouse\" :[ \"Muret\" , \"Montauban\" ], \"Montauban\" :[ \"Toulouse\" ], \"Gaillac\" :[ \"St Sulpice\" ], \"St Sulpice\" :[ \"Gaillac\" ], \"Muret\" :[ \"Toulouse\" , \"Pamiers\" ], \"Pamiers\" :[ \"Muret\" ]} Question 1. Expliquer pourquoi la liste des liaisons suivante n'est pas valide : \ud83d\udc0d Script Python tableauliaisons = [[ \"Toulouse\" , \"Auch\" ], [ \"Luchon\" , \"Muret\" ], [ \"Quillan\" , \"Limoux\" ] ] Question 2. Cette question concerne le joueur n\u00b02 (Rappel : les liaisons poss\u00e9d\u00e9es par le joueur n\u00b02 sont repr\u00e9sent\u00e9es par un rectangle blanc dans l\u2019annexe 2 de l\u2019exercice 2). a) Donner le tableau liaisonsJoueur2, des liaisons poss\u00e9d\u00e9es par le joueur n\u00b02. b) Recopier et compl\u00e9ter le dictionnaire suivant, associ\u00e9 au joueur n\u00b02 : \ud83d\udc0d Script Python DictJoueur2 = { \"Toulouse\" :[ \"Castres\" , \"Castelnaudary\" ], \u2026 } Question 3. \u00c0 partir du tableau de tableaux contenant les liaisons d'un joueur, on souhaite construire le dictionnaire correspondant au joueur. Une premi\u00e8re proposition a abouti \u00e0 la fonction construireDict ci-dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def construireDict ( listeLiaisons ): \"\"\" listeLiaisons est un tableau de tableaux repr\u00e9sentant la liste des liaisons d'un joueur comme d\u00e9crit dans le probl\u00e8me \"\"\" Dict = {} for liaison in listeLiaisons : villeA = liaison [ 0 ] villeB = liaison [ 1 ] if not villeA in Dict . keys () : Dict [ villeA ] = [ villeB ] else : destinationsA = Dict [ villeA ] if not villeB in destinationsA : destinationsA . append ( villeB ) return Dict a) \u00c9crire sur votre copie un assert dans la fonction construireDict qui permet de v\u00e9rifier que la listeLiaisons n\u2019est pas vide. b) Sur votre copie, donner le r\u00e9sultat de cette fonction ayant comme argument la variable liaisonsJoueur1 donn\u00e9e dans l\u2019\u00e9nonc\u00e9 et expliquer en quoi cette fonction ne r\u00e9pond que partiellement \u00e0 la demande. c) La fonction construireDict , d\u00e9finie ci-dessus, est donc partiellement inexacte. Compl\u00e9ter la fonction construireDict pour qu\u2019elle g\u00e9n\u00e8re bien l\u2019ensemble du dictionnaire de tableaux correspondant \u00e0 la liste de liaisons donn\u00e9es en argument. \u00c0 l\u2019aide des num\u00e9ros de lignes, on pr\u00e9cisera o\u00f9 est ins\u00e9r\u00e9 ce code.","title":"TD n\u00b021 - Exercices BAC 2"},{"location":"divers/Exercice_Bac__2/","text":"Th\u00e8me : BAC 22 TD : Exercices Divers BAC - Programmation Sujet 4 : la programmation en g\u00e9n\u00e9ral et la r\u00e9cursivit\u00e9 en particulier. \u2693\ufe0e On consid\u00e8re un tableau de nombres de \\(n\\) lignes et \\(p\\) colonnes. Les lignes sont num\u00e9rot\u00e9es de 0 \u00e0 \\(n-1\\) et les colonnes sont num\u00e9rot\u00e9es de 0 \u00e0 \\(p-1\\) . La case en haut \u00e0 gauche est rep\u00e9r\u00e9e par (0, 0) et la case en bas \u00e0 droite par \\((n - 1, p - 1)\\) . On appelle chemin une succession de cases allant de la case (0, 0) \u00e0 la case \\((n - 1, p - 1)\\) , en n\u2019autorisant que des d\u00e9placements case par case : soit vers la droite, soit vers le bas. On appelle somme d\u2019un chemin la somme des entiers situ\u00e9s sur ce chemin. Par exemple, pour le tableau T suivant : Un chemin est (0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (2, 3) (en gras sur le tableau) ; La somme du chemin pr\u00e9c\u00e9dent est 14. (0, 0), (0, 2), (2, 2), (2, 3) n\u2019est pas un chemin. L\u2019objectif de cet exercice est de d\u00e9terminer la somme maximale pour tous les chemins possibles allant de la case (0, 0) \u00e0 la case \\((n - 1, p - 1)\\) . Question 1 On consid\u00e8re tous les chemins allant de la case (0, 0) \u00e0 la case (2, 3) du tableau T donn\u00e9 en exemple. Un tel chemin comprend n\u00e9cessairement 3 d\u00e9placements vers la droite. Combien de d\u00e9placements vers le bas comprend-il ? La longueur d\u2019un chemin est \u00e9gal au nombre de cases de ce chemin. Justifier que tous les chemins allant de (0, 0) \u00e0 (2, 3) ont une longueur \u00e9gale \u00e0 6. Question 2 En listant tous les chemins possibles allant de (0, 0) \u00e0 (2, 3) du tableau T, d\u00e9terminer un chemin qui permet d\u2019obtenir la somme maximale et la valeur de cette somme. Question 3 On veut cr\u00e9er le tableau T\u2019 o\u00f9 chaque \u00e9l\u00e9ment T\u2019[i][j] est la somme maximale pour tous les chemins possibles allant de (0, 0) \u00e0 \\((i, j)\\) . Compl\u00e9ter et recopier sur votre copie le tableau T\u2019 donn\u00e9 ci-dessous associ\u00e9 au tableau Justifier que si \\(j\\) est diff\u00e9rent de 0, alors : T\u2019[0][j] = T[0][j] + T\u2019[0][j-1] Question 4 Justifier que si \\(i\\) et \\(j\\) sont diff\u00e9rents de 0, alors : T\u2019[i][j] = T[i][j] + max(T\u2019[i-1][j], T\u2019[i][j-1]) . Question 5 On veut cr\u00e9er la fonction r\u00e9cursive somme_max ayant pour param\u00e8tres un tableau T, un entier \\(i\\) et un entier \\(j\\) . Cette fonction renvoie la somme maximale pour tous les chemins possibles allant de la case (0, 0) \u00e0 la case \\((i, j)\\) . Quel est le cas de base, \u00e0 savoir le cas qui est trait\u00e9 directement sans faire appel \u00e0 la fonction somme_max ? Que renvoie-t-on dans ce cas ? \u00c0 l\u2019aide de la question pr\u00e9c\u00e9dente, \u00e9crire en Python la fonction r\u00e9cursive somme_max . Quel appel de fonction doit-on faire pour r\u00e9soudre le probl\u00e8me initial ? Sujet 5 : la programmation en g\u00e9n\u00e9ral et la r\u00e9cursivit\u00e9 en particulier. \u2693\ufe0e Cet exercice porte sur la programmation en g\u00e9n\u00e9ral et la r\u00e9cursivit\u00e9 en particulier. On s\u2019int\u00e9resse dans cet exercice \u00e0 un algorithme de m\u00e9lange des \u00e9l\u00e9ments d\u2019une liste. Question 1. Pour la suite, il sera utile de disposer d'une fonction echange qui permet d'\u00e9changer dans une liste lst les \u00e9l\u00e9ments d'indice i1 et i2 . Expliquer pourquoi le code Python ci-dessous ne r\u00e9alise pas cet \u00e9change et en proposer une modification. \ud83d\udc0d Script Python def echange ( lst , i1 , i2 ): lst [ i2 ] = lst [ i1 ] lst [ i1 ] = lst [ i2 ] Question 2. La documentation du module random de Python fournit les informations cidessous concernant la fonction randint(a,b) : \ud83d\udc0d Script Python Renvoie un entier al\u00e9atoire N tel que a <= N <= b . Alias pour randrange ( a , b + 1 ) . Parmi les valeurs ci-dessous, quelles sont celles qui peuvent \u00eatre renvoy\u00e9es par l'appel randint(0, 10) ? \u25a1 0 \u25a1 1 \u25a1 3.5 \u25a1 9 \u25a1 10 \u25a1 11 Question 3. Le m\u00e9lange de Fischer Yates est un algorithme permettant de permuter al\u00e9atoirement les \u00e9l\u00e9ments d'une liste. On donne ci-dessous une mise en \u0153uvre r\u00e9cursive de cet algorithme en Python. \ud83d\udc0d Script Python from random import randint def melange ( lst , ind ): print ( lst ) if ind > 0 : j = randint ( 0 , ind ) echange ( lst , ind , j ) melange ( lst , ind - 1 ) a. Expliquer pourquoi la fonction melange se termine toujours. b. Lors de l\u2019appel de la fonction melange , la valeur du param\u00e8tre ind doit \u00eatre \u00e9gal au plus grand indice possible de la liste lst . Pour une liste de longueur \u074a, quel est le nombre d'appels r\u00e9cursifs de la fonction melange effectu\u00e9s, sans compter l\u2019appel initial ? c. On consid\u00e8re le script ci-dessous : \ud83d\udc0d Script Python lst = [ v for v in range ( 5 )] melange ( lst , 4 ) On suppose que les valeurs successivement renvoy\u00e9es par la fonction randint sont 2, 1, 2 et 0. Les deux premiers affichages produits par l'instruction print(lst) de la fonction melange sont : \ud83d\udccb Texte [0, 1, 2, 3, 4] [0, 1, 4, 3, 2] Donner les affichages suivants produits par la fonction melange. d. Proposer une version it\u00e9rative du m\u00e9lange de Fischer Yates. Sujet 6 : la programmation objet. \u2693\ufe0e Cryptage selon le \u00ab Code de C\u00e9sar \u00bb Dans cet exercice, on \u00e9tudie une m\u00e9thode de chiffrement de cha\u00eenes de caract\u00e8res alphab\u00e9tiques. Pour des raisons historiques, cette m\u00e9thode de chiffrement est appel\u00e9e \"code de C\u00e9sar\". On consid\u00e8re que les messages ne contiennent que les lettres capitales de l\u2019alphabet \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" et la m\u00e9thode de chiffrement utilise un nombre entier fix\u00e9 appel\u00e9 la cl\u00e9 de chiffrement. Question 1. Soit la classe CodeCesar d\u00e9finie ci-dessous : \ud83d\udc0d Script Python class CodeCesar : def __init__ ( self , cle ): self . cle = cle self . alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" def decale ( self , lettre ): num1 = self . alphabet . find ( lettre ) num2 = num1 + self . cle if num2 >= 26 : num2 = num2 - 26 if num2 < 0 : num2 = num2 + 26 nouvelle_lettre = self . alphabet [ num2 ] return nouvelle_lettre On rappelle que la m\u00e9thode str.find(lettre) renvoie l'indice (index) de la lettre dans la cha\u00eene de caract\u00e8res str Repr\u00e9senter le r\u00e9sultat d\u2019ex\u00e9cution du code Python suivant : \ud83d\udc0d Script Python code1 = CodeCesar ( 3 ) print ( code1 . decale ( 'A' )) print ( code1 . decale ( 'X' )) Question 2. La m\u00e9thode de chiffrement du \u00ab code C\u00e9sar \u00bb consiste \u00e0 d\u00e9caler les lettres du message dans l\u2019alphabet d'un nombre de rangs fix\u00e9 par la cl\u00e9. Par exemple, avec la cl\u00e9 3, toutes les lettres sont d\u00e9cal\u00e9es de 3 rangs vers la droite : le A devient le D, le B devient le E, etc. Ajouter une m\u00e9thode cryptage(self, texte) dans la classe CodeCesar d\u00e9finie \u00e0 la question pr\u00e9c\u00e9dente, qui re\u00e7oit en param\u00e8tre une cha\u00eene de caract\u00e8res (le message \u00e0 crypter) et qui retourne une cha\u00eene de caract\u00e8res (le message crypt\u00e9). Cette m\u00e9thode cryptage(self, texte) doit crypter la cha\u00eene texte avec la cl\u00e9 de l'objet de la classe CodeCesar qui a \u00e9t\u00e9 instanci\u00e9. Exemple : \ud83d\udc0d Script Python >>> code1 = CodeCesar ( 3 ) >>> code1 . cryptage ( \"NSI\" ) 'QVL' Question 3. Ecrire un programme qui : demande de saisir la cl\u00e9 de chiffrement cr\u00e9e un objet de classe CodeCesar demande de saisir le texte \u00e0 chiffrer affiche le texte chiffr\u00e9 en appelant la m\u00e9thode cryptage Question 4. On ajoute la m\u00e9thode transforme(texte) \u00e0 la classe CodeCesar : \ud83d\udc0d Script Python def transforme ( self , texte ): self . cle = - self . cle message = self . cryptage ( texte ) self . cle = - self . cle return message On ex\u00e9cute la ligne suivante : print(CodeCesar(10).transforme(\"PSX\")) Que va-t-il s\u2019afficher ? Expliquer votre r\u00e9ponse. Sujet 7 : programmation Python, tuples et listes. \u2693\ufe0e L\u2019objectif de cet exercice est de mettre en place une mod\u00e9lisation d\u2019un jeu de labyrinthe en langage Python. On d\u00e9cide de repr\u00e9senter un labyrinthe par un tableau carr\u00e9 de taille n, dans lequel les cases seront des 0 si l\u2019on peut s\u2019y d\u00e9placer et des 1 s\u2019il s\u2019agit d\u2019un mur. Voici un exemple de repr\u00e9sentation d\u2019un labyrinthe : L\u2019entr\u00e9e du labyrinthe se situe \u00e0 la premi\u00e8re case du tableau (celle en haut \u00e0 gauche) et la sortie du labyrinthe se trouve \u00e0 la derni\u00e8re case (celle en bas \u00e0 droite). Question 1. Proposer, en langage Python, une fonction mur, prenant en param\u00e8tre un tableau repr\u00e9sentant un labyrinthe et deux entiers \\(i\\) et \\(j\\) compris entre 0 et n1 et qui renvoie un bool\u00e9en indiquant la pr\u00e9sence ou non d\u2019un mur. Par exemple : \ud83d\udc0d Script Python >> mur ( laby , 2 , 3 ) True >> mur ( laby , 1 , 8 ) False Un parcours dans le labyrinthe va \u00eatre repr\u00e9sent\u00e9 par une liste de cases. Il s\u2019agit de couples (i,j) o\u00f9 i et j correspondent respectivement aux num\u00e9ros de ligne et de colonne des cases successivement visit\u00e9es au long du parcours. Ainsi, la liste suivante [(1,4),(1,5),(1,6),(2,6),(3,6),(3,5),(3,4)] correspond au parcours rep\u00e9r\u00e9 par des \u00e9toiles ci-dessous : La liste [(0,0),(1,0),(1,1),(5,1),(6,1)] ne peut correspondre au parcours d\u2019un labyrinthe car toutes les cases parcourues successivement ne sont pas adjacentes. Question 2. On consid\u00e8re la fonction voisine ci-dessous, \u00e9crite en langage Python, qui prend en param\u00e8tres deux cases donn\u00e9es sous forme de couple. \ud83d\udc0d Script Python def voisine ( case1 , case2 ) : l1 , c1 = case1 l2 , c2 = case2 # on vous rappelle que **2 signifie puissance 2 d = ( l1 - l2 ) ** 2 + ( c1 - c2 ) ** 2 return ( d == 1 ) 2.a. Apr\u00e8s avoir remarqu\u00e9 que les quantit\u00e9s l1-l2 et c1-c2 sont des entiers, expliquer pourquoi la fonction voisine indique si deux cases donn\u00e9es sous forme de tuples (l,c) sont adjacentes. 2.b. En d\u00e9duire une fonction adjacentes qui re\u00e7oit une liste de cases et renvoie un bool\u00e9en indiquant si la liste des cases forme une cha\u00eene de cases adjacentes. Un parcours sera qualifi\u00e9 de compatible avec le labyrinthe lorsqu\u2019il s\u2019agit d\u2019une succession de cases adjacentes accessibles (non mur\u00e9es). On donne la fonction teste(cases, laby) qui indique si le chemin cases est un chemin possible compatible avec le labyrinthe laby : \ud83d\udc0d Script Python def teste ( cases , laby ) : if not adjacentes ( cases ) : return False possible = True i = 0 while i < len ( cases ) and possible : if mur ( laby , cases [ i ][ 0 ], cases [ i ][ 1 ]) : possible = False i = i + 1 return possible Question 3. Justifier que la boucle de la fonction pr\u00e9c\u00e9dente se termine. Question 4. En d\u00e9duire une fonction echappe(cases, laby) qui indique par un bool\u00e9en si le chemin cases permet d\u2019aller de l\u2019entr\u00e9e \u00e0 la sortie du labyrinthe laby . Adaptation en TP : Lien vers TP Capytale Sujet 8 : structure de donn\u00e9es (tableaux, dictionnaires) et langages \u2693\ufe0e et programmation (sp\u00e9cification). Objectif de l\u2019exercice : Les Aventuriers du Rail\u00a9 est un jeu de soci\u00e9t\u00e9 dans lequel les joueurs doivent construire des lignes de chemin de fer entre diff\u00e9rentes villes d'un pays. La carte des liaisons possibles dans la r\u00e9gion Occitanie est donn\u00e9e en annexe 1 de l\u2019exercice. Dans l\u2019annexe 2 de l\u2019exercice, les liaisons poss\u00e9d\u00e9es par le joueur 1 sont en noir, et celles du joueur 2 en blanc. Les liaisons en gris sont encore en jeu. Codages des structures de donn\u00e9es utilis\u00e9es : Liste des liaisons d'un joueur : Toutes les liaisons directes (sans ville interm\u00e9diaire) construites par un joueur seront enregistr\u00e9es dans une variable de type \"tableau de tableaux\". Le joueur 1 poss\u00e8de les lignes directes \"Toulouse-Muret\", \"Toulouse-Montauban\", \"Gaillac-St Sulpice\" et \"Muret-Pamiers\" (liaisons indiqu\u00e9es en noir dans l\u2019annexe 2 de l\u2019exercice). Ces liaisons sont m\u00e9moris\u00e9es dans la variable ci-dessous. \ud83d\udc0d Script Python liaisonsJoueur1 = [ [ \"Toulouse\" , \"Muret\" ], [ \"Toulouse\" , \"Montauban\" ], [ \"Gaillac\" , \"St Sulpice\" ], [ \"Muret\" , \"Pamiers\" ] ] Remarque : Seules les liaisons directes existent, par exemple [\"Toulouse\",\"Muret\"] ou [\"Muret\",\"Toulouse\"] . Par contre, le tableau [\"Toulouse\",\"Mazamet\"] n'existe pas, puisque la ligne Toulouse-Mazamet passe par Castres. Dictionnaire associ\u00e9 \u00e0 un joueur : On code la liste des villes et des trajets poss\u00e9d\u00e9e par un joueur en utilisant un dictionnaire de tableaux. Chaque clef de ce dictionnaire est une ville de d\u00e9part, et chaque valeur est un tableau contenant les villes d'arriv\u00e9e possibles en fonction des liaisons poss\u00e9d\u00e9es par le joueur. Le dictionnaire de tableaux du joueur 1 est donn\u00e9 ci-dessous : \ud83d\udc0d Script Python DictJoueur1 = { \"Toulouse\" :[ \"Muret\" , \"Montauban\" ], \"Montauban\" :[ \"Toulouse\" ], \"Gaillac\" :[ \"St Sulpice\" ], \"St Sulpice\" :[ \"Gaillac\" ], \"Muret\" :[ \"Toulouse\" , \"Pamiers\" ], \"Pamiers\" :[ \"Muret\" ]} Question 1. Expliquer pourquoi la liste des liaisons suivante n'est pas valide : \ud83d\udc0d Script Python tableauliaisons = [[ \"Toulouse\" , \"Auch\" ], [ \"Luchon\" , \"Muret\" ], [ \"Quillan\" , \"Limoux\" ] ] Question 2. Cette question concerne le joueur n\u00b02 (Rappel : les liaisons poss\u00e9d\u00e9es par le joueur n\u00b02 sont repr\u00e9sent\u00e9es par un rectangle blanc dans l\u2019annexe 2 de l\u2019exercice 2). a) Donner le tableau liaisonsJoueur2, des liaisons poss\u00e9d\u00e9es par le joueur n\u00b02. b) Recopier et compl\u00e9ter le dictionnaire suivant, associ\u00e9 au joueur n\u00b02 : \ud83d\udc0d Script Python DictJoueur2 = { \"Toulouse\" :[ \"Castres\" , \"Castelnaudary\" ], \u2026 } Question 3. \u00c0 partir du tableau de tableaux contenant les liaisons d'un joueur, on souhaite construire le dictionnaire correspondant au joueur. Une premi\u00e8re proposition a abouti \u00e0 la fonction construireDict ci-dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def construireDict ( listeLiaisons ): \"\"\" listeLiaisons est un tableau de tableaux repr\u00e9sentant la liste des liaisons d'un joueur comme d\u00e9crit dans le probl\u00e8me \"\"\" Dict = {} for liaison in listeLiaisons : villeA = liaison [ 0 ] villeB = liaison [ 1 ] if not villeA in Dict . keys () : Dict [ villeA ] = [ villeB ] else : destinationsA = Dict [ villeA ] if not villeB in destinationsA : destinationsA . append ( villeB ) return Dict a) \u00c9crire sur votre copie un assert dans la fonction construireDict qui permet de v\u00e9rifier que la listeLiaisons n\u2019est pas vide. b) Sur votre copie, donner le r\u00e9sultat de cette fonction ayant comme argument la variable liaisonsJoueur1 donn\u00e9e dans l\u2019\u00e9nonc\u00e9 et expliquer en quoi cette fonction ne r\u00e9pond que partiellement \u00e0 la demande. c) La fonction construireDict , d\u00e9finie ci-dessus, est donc partiellement inexacte. Compl\u00e9ter la fonction construireDict pour qu\u2019elle g\u00e9n\u00e8re bien l\u2019ensemble du dictionnaire de tableaux correspondant \u00e0 la liste de liaisons donn\u00e9es en argument. \u00c0 l\u2019aide des num\u00e9ros de lignes, on pr\u00e9cisera o\u00f9 est ins\u00e9r\u00e9 ce code.","title":"TD n\u00b022 - Exercices BAC n\u00b02"},{"location":"divers/Exercices_Bac/","text":"Th\u00e8me : BAC 21 TD : Exercices Divers BAC - Programmation Sujet 1 : Tableaux et Programmation \u2693\ufe0e On rappelle que len est une fonction qui prend un tableau en param\u00e8tre et renvoie sa longueur. C\u2019est-\u00e0-dire le nombre d\u2019\u00e9l\u00e9ments pr\u00e9sents dans le tableau. Exemple : len([12, 54, 34, 57]) vaut 4. Le but de cet exercice est de programmer diff\u00e9rentes r\u00e9ductions pour un site de vente de v\u00eatements en ligne. On rappelle que si le prix d\u2019un article avant r\u00e9duction est de x euros, son prix vaut 0, 5x si on lui applique une r\u00e9duction de 50%, son prix vaut 0, 6x si on lui applique une r\u00e9duction de 40%, son prix vaut 0, 7x si on lui applique une r\u00e9duction de 30%, son prix vaut 0, 8x si on lui applique une r\u00e9duction de 20%, son prix vaut 0, 9x si on lui applique une r\u00e9duction de 10%. Dans le syst\u00e8me informatique du site de vente, l\u2019ensemble des articles qu\u2019un client veut acheter, appel\u00e9 panier, est mod\u00e9lis\u00e9 par un tableau de flottants. Par exemple, si un client veut acheter un pantalon \u00e0 30,50 euros, un tee-shirt \u00e0 15 euros, une paire de chaussettes \u00e0 6 euros, une jupe \u00e0 20 euros, une paire de collants \u00e0 5 euros, une robe \u00e0 35 euros et un short \u00e0 10,50 euros, le syst\u00e8me informatique aura le tableau suivant : \ud83d\udc0d Script Python tab = [ 30.5 , 15.0 , 6.0 , 20.0 , 5.0 , 35.0 , 10.5 ] Question 1. (a) \u00c9crire une fonction Python total_hors_reduction ayant pour argument le tableau des prix des articles du panier d\u2019un client et renvoyant le total des prix de ces articles. Question 1. (b) Le site de vente propose la promotion suivante comme offre de bienvenue : 20% de r\u00e9duction sur le premier article de la liste, 30% de r\u00e9duction sur le deuxi\u00e8me article de la liste (s\u2019il y a au moins deux articles) et aucune r\u00e9duction sur le reste des articles (s\u2019il y en a). Recopier sur la copie et compl\u00e9ter la fonction Python offre_bienvenue prenant en param\u00e8tre le tableau tab des prix des articles du panier d\u2019un client et renvoyant le total \u00e0 payer lorsqu\u2019on leur applique l\u2019offre de bienvenue. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def offre_bienvenue ( tab ): \"\"\" tableau -> float \"\"\" somme = 0 longueur = len ( tab ) if longueur > 0 : somme = tab [ 0 ] *... if longueur > 1 : somme = somme + ... if longueur > 2 : for i in range ( 2 , longueur ): somme =... return ... Pour toute la suite de l\u2019exercice, on pourra utiliser la fonction total_hors_reduction m\u00eame si la question 1 n\u2019a pas \u00e9t\u00e9 trait\u00e9e. Question 2. Lors de la p\u00e9riode des soldes, le site de vente propose les r\u00e9ductions suivantes : si le panier contient 5 articles ou plus, une r\u00e9duction globale de 50%, si le panier contient 4 articles, une r\u00e9duction globale de 40%, si le panier contient 3 articles, une r\u00e9duction globale de 30%, si le panier contient 2 articles, une r\u00e9duction globale de 20%, si le panier contient 1 article, une r\u00e9duction globale de 10%. Proposer une fonction Python prix_solde ayant pour argument le tableau tab des prix des articles du panier d\u2019un client et renvoyant le total des prix de ces articles lorsqu\u2019on leur applique la r\u00e9duction des soldes. Question 3. (a) \u00c9crire une fonction minimum qui prend en param\u00e8tre un tableau tab de nombres et renvoie la valeur minimum pr\u00e9sente dans le tableau. Question 3. (b) Pour ses bons clients, le site de vente propose une offre promotionnelle, \u00e0 partir de 2 articles achet\u00e9s, l\u2019article le moins cher des articles command\u00e9s est offert. \u00c9crire une fonction Python offre_bon_client ayant pour param\u00e8tre le tableau des prix des articles du panier d\u2019un client et renvoyant le total \u00e0 payer lorsqu\u2019on leur applique l\u2019offre bon client. Question 4. Afin de diminuer le stock de ses articles dans ses entrep\u00f4ts, l\u2019entreprise imagine faire l\u2019offre suivante \u00e0 ses clients : en suivant l\u2019ordre des articles dans le panier du client, elle consid\u00e8re les 3 premiers articles et offre le moins cher, puis les 3 suivants et offre le moins cher et ainsi de suite jusqu\u2019\u00e0 ce qu\u2019il reste au plus 2 articles qui n\u2019ont alors droit \u00e0 aucune r\u00e9duction. Exemple : Si le panier du client contient un pantalon \u00e0 30,50 euros, un tee-shirt \u00e0 15 euros, une paire de chaussettes \u00e0 6 euros, une jupe \u00e0 20 euros, une paire de collants \u00e0 5 euros, une robe \u00e0 35 euros et un short \u00e0 10,50 euros, ce panier est repr\u00e9sent\u00e9 par le tableau suivant : \ud83d\udc0d Script Python tab = [ 30.5 , 15.0 , 6.0 , 20.0 , 5.0 , 35.0 , 10.5 ] Pour le premier groupe (le pantalon \u00e0 30,50 euros, le tee-shirt \u00e0 15 euros, la paire de chaussettes \u00e0 6 euros), l\u2019article le moins cher, la paire de chaussettes \u00e0 6 euros, est offert. Pour le second groupe (la jupe \u00e0 20 euros, la paire de collants \u00e0 5 euros, la robe \u00e0 35 euros), la paire de collants \u00e0 5 euros est offerte. Donc le total apr\u00e8s promotion de d\u00e9stockage est 111 euros. On constate que le prix apr\u00e8s promotion de d\u00e9stockage d\u00e9pend de l\u2019ordre dans lequel se pr\u00e9sentent les articles dans le panier. Question 4.(a) Proposer un panier contenant les m\u00eames articles que ceux de l\u2019exemple mais ayant un prix apr\u00e8s promotion de d\u00e9stockage diff\u00e9rent de 111 euros. Question 4. (b) Proposer un panier contenant les m\u00eames articles mais ayant le prix apr\u00e8s promotion de d\u00e9stockage le plus bas possible. Question 4. (c) Une fois ses articles choisis, quel algorithme le client peut-il utiliser pour modifier son panier afin de s\u2019assurer qu\u2019il obtiendra le prix apr\u00e8s promotion de d\u00e9stockage le plus bas possible ? On ne demande pas d\u2019\u00e9crire cet algorithme. Sujet 2 : Programmation en G\u00e9n\u00e9ral \u2693\ufe0e Cet exercice porte sur la programmation en g\u00e9n\u00e9ral. \u00c9tant donn\u00e9 un tableau non vide de nombres entiers relatifs, on appelle sous-s\u00e9quence une suite non vide d'\u00e9l\u00e9ments voisins de ce tableau. On cherche dans cet exercice \u00e0 d\u00e9terminer la plus grande somme possible obtenue en additionnant les \u00e9l\u00e9ments d'une sous-s\u00e9quence. Par exemple, pour le tableau ci-dessous, la somme maximale vaut 18. Elle est obtenue en additionnant les \u00e9l\u00e9ments de la sous-s\u00e9quence encadr\u00e9e en gras ci-dessous (6 ; 8 ; -6 ; 10). Question 1. a. Quelle est la solution du probl\u00e8me si les \u00e9l\u00e9ments du tableau sont tous positifs ? Question 1. b. Quelle est la solution du probl\u00e8me si tous les \u00e9l\u00e9ments sont n\u00e9gatifs ? Dans cette question, on examine toutes les sous-s\u00e9quences possibles. Question 2. a. \u00c9crire le code Python d'une fonction somme_sous_sequence(lst, i, j) qui prend en argument une liste et deux entiers i, j et renvoie la somme de la sous-s\u00e9quence d\u00e9limit\u00e9e par les indices i et j (inclus). Question 2. b. La fonction pgsp ci-dessous permet de d\u00e9terminer la plus grande des sommes obtenues en additionnant les \u00e9l\u00e9ments de toutes les sous-s\u00e9quences possibles du tableau lst. \ud83d\udc0d Script Python def pgsp ( lst ): n = len ( lst ) somme_max = lst [ 0 ] for i in range ( n ): for j in range ( i , n ): s = somme_sous_sequence ( lst , i , j ) if s > somme_max : somme_max = s return somme_max Parmi les quatre choix suivants, quel est le nombre de comparaisons effectu\u00e9es par cette fonction si le tableau lst pass\u00e9 en param\u00e8tre contient 10 \u00e9l\u00e9ments ? 10 55 100 1055 Question 2. c. Recopier et modifier la fonction pgsp pour qu'elle renvoie un tuple contenant la somme maximale et les indices qui d\u00e9limitent la sous-s\u00e9quence correspondant \u00e0 cette somme maximale. Question 3. On consid\u00e8re dans cette question une approche plus \u00e9labor\u00e9e. Son principe consiste, pour toutes les valeurs possibles de l\u2019indice \u0745, \u00e0 d\u00e9terminer la somme maximale \u0735(\u0745) des sous-s\u00e9quences qui se terminent \u00e0 l'indice \u0745. En d\u00e9signant par lst[\u0745] l\u2019\u00e9l\u00e9ment de lst d\u2019indice \u0745, on peut v\u00e9rifier que S(0) = lst[0] et pour \u0745 \\(i \\geq 1\\) : \\(S\u0735(i) = lst[\u0745i]\\) si \u0735 \\((\u0745i- 1) \u2264 0\\) ; \\(i = lst[\u0745i] + \u0735S(\u0745i-1)\\) si \u0735 \\(S(\u0745i-1) > 0\\) . Question 3. a. Recopier et compl\u00e9ter le tableau ci-dessous avec les valeurs de \u0735 \\(S(\u0745i)\\) pour la liste consid\u00e9r\u00e9e en exemple. Question 3. b. La solution au probl\u00e8me \u00e9tant la plus grande valeur des \u0735 \\(S(\u0745i)\\) , on demande de compl\u00e9ter la fonction pgsp2 ci-dessous, de sorte que la variable sommes_max contienne la liste des valeurs \u0735 \\(S(\u0745i)\\) . \ud83d\udc0d Script Python def pgsp2 ( lst ): sommes_max = [ lst [ 0 ]] for i in range ( 1 , len ( lst )): # \u00e0 compl\u00e9ter return max ( sommes_max ) Question 3. c. En quoi la solution obtenue par cette approche est-elle plus avantageuse que celle de la question 2.b. ? Sujet 3 : Tableau - Parcours - Programmation en G\u00e9n\u00e9ral \u2693\ufe0e Cet exercice porte sur l\u2019algorithmique et la programmation en Python. Il aborde les notions de tableaux de tableaux et d\u2019algorithmes de parcours de tableaux. Partie A : Repr\u00e9sentation d\u2019un labyrinthe On mod\u00e9lise un labyrinthe par un tableau \u00e0 deux dimensions \u00e0 \u074a \\(n\\) lignes et \u0749 \\(m\\) colonnes avec \u074a \\(n\\) et \u0749 \\(m\\) des entiers strictement positifs. Les lignes sont num\u00e9rot\u00e9es de 0 \u00e0 \u074a \\(n-1\\) et les colonnes de 0 \u00e0 \\(m-1\\) . La case en haut \u00e0 gauche est rep\u00e9r\u00e9e par \\((0,0)\\) et la case en bas \u00e0 droite par \\((n-1,m-1)\\) . Dans ce tableau : 0 repr\u00e9sente une case vide, hors case de d\u00e9part et arriv\u00e9e, 1 repr\u00e9sente un mur, 2 repr\u00e9sente le d\u00e9part du labyrinthe, 3 repr\u00e9sente l'arriv\u00e9e du labyrinthe. Ainsi, en Python, le labyrinthe ci-dessous est repr\u00e9sent\u00e9e par le tableau de tableaux lab1 . Question A.1. Le labyrinthe ci-dessous est cens\u00e9 \u00eatre repr\u00e9sent\u00e9 par le tableau de tableaux lab2. Cependant, dans ce tableau, un mur se trouve \u00e0 la place du d\u00e9part du labyrinthe. Donner une instruction permettant de placer le d\u00e9part au bon endroit dans lab2. Question A.2. \u00c9crire une fonction est_valide(i, j, n, m) qui renvoie True si le couple \\((i,j)\\) correspond \u00e0 des coordonn\u00e9es valides pour un labyrinthe de taille \\((n,m)\\) , et False sinon. On donne ci-dessous des exemples d'appels. \ud83d\udc0d Script Python >>> est_valide ( 5 , 2 , 10 , 10 ) True >>> est_valide ( - 3 , 4 , 10 , 10 ) False Question A.3. On suppose que le d\u00e9part d'un labyrinthe est toujours indiqu\u00e9, mais on ne fait aucune supposition sur son emplacement. Compl\u00e9ter la fonction depart(lab)ci-dessous de sorte qu'elle renvoie, sous la forme d'un tuple, les coordonn\u00e9es du d\u00e9part d'un labyrinthe (repr\u00e9sent\u00e9 par le param\u00e8tre lab). Par exemple, l'appel depart(lab1) doit renvoyer le tuple (5, 0). \ud83d\udc0d Script Python def depart ( lab ) : n = len ( lab ) m = len ( lab [ 0 ]) ... Question A.4. \u00c9crire une fonction nb_cases_vides(lab) qui renvoie le nombre de cases vides d'un labyrinthe (comprenant donc l'arriv\u00e9e et le d\u00e9part). Par exemple, l'appel nb_cases_vides(lab2) doit renvoyer la valeur 19. Partie B : Recherche d\u2019une solution dans un labyrinthe On suppose dans cette partie que les labyrinthes poss\u00e8dent un unique chemin allant du d\u00e9part \u00e0 l\u2019arriv\u00e9e sans repasser par la m\u00eame case. Dans la suite, c\u2019est ce chemin que l\u2019on appellera solution du labyrinthe. Pour d\u00e9terminer la solution d'un labyrinthe, on parcourt les cases vides de proche en proche. Lors d\u2019un tel parcours, afin d\u2019\u00e9viter de tourner en rond, on choisit de marquer les cases visit\u00e9es. Pour cela, on remplace la valeur d'une case visit\u00e9e dans le tableau repr\u00e9sentant le labyrinthe par la valeur 4. Question B.1. On dit que deux cases d'un labyrinthe sont voisines si elles ont un c\u00f4t\u00e9 commun. On consid\u00e8re une fonction voisines(i, j, lab) qui prend en arguments deux entiers \u0745 \\(i\\) et \u0746 \\(j\\) repr\u00e9sentant les coordonn\u00e9es d\u2019une case et un tableau lab qui repr\u00e9sente un labyrinthe. Cette fonction renvoie la liste des coordonn\u00e9es des cases voisines de la case de coordonn\u00e9es \\((i,j)\\) qui sont valides, non visit\u00e9es et qui ne sont pas des murs. L'ordre des \u00e9l\u00e9ments de cette liste n'importe pas. Ainsi, l'appel voisines(1, 1, [[1, 1, 1], [4, 0, 0], [1, 0, 1]]) renvoie la liste [(2, 1), (1, 2)] . Que renvoie l'appel voisines(1, 2, [[1, 1, 4], [0, 0, 0], [1, 1, 0]]) ? Question 2. On souhaite stocker la solution dans une liste chemin. Cette liste contiendra les coordonn\u00e9es des cases de la solution, dans l'ordre. Pour cela, on proc\u00e8de de la fa\u00e7on suivante. Initialement : d\u00e9terminer les coordonn\u00e9es du d\u00e9part : c'est la premi\u00e8re case \u00e0 visiter ; ajouter les coordonn\u00e9es de la case d\u00e9part \u00e0 la liste chemin. Tant que l'arriv\u00e9e n'a pas \u00e9t\u00e9 atteinte : on marque la case visit\u00e9e avec la valeur 4 ; si la case visit\u00e9e poss\u00e8de une case voisine libre, la premi\u00e8re case de la liste renvoy\u00e9e par la fonction voisines devient la prochaine case \u00e0 visiter et on ajoute \u00e0 la liste chemin ; sinon, il s'agit d'une impasse. On supprime alors la derni\u00e8re case dans la liste chemin. La prochaine case \u00e0 visiter est celle qui est d\u00e9sormais en derni\u00e8re position de la liste chemin. Question B.2. a. Le tableau de tableaux lab3 ci-dessous repr\u00e9sente un labyrinthe. \ud83d\udc0d Script Python lab3 = [[ 1 , 1 , 1 , 1 , 1 , 1 ], [ 2 , 0 , 0 , 0 , 0 , 3 ], [ 1 , 0 , 1 , 0 , 1 , 1 ], [ 1 , 1 , 1 , 0 , 0 , 1 ]] La suite d'instructions ci-dessous simule le d\u00e9but des modifications subies par la liste chemin lorsque l'on applique la m\u00e9thode pr\u00e9sent\u00e9e. \ud83d\udc0d Script Python # entr\u00e9e: (1, 0), sortie (1, 5) chemin = [( 1 , 0 )] chemin . append (( 1 , 1 )) chemin . append (( 2 , 1 )) chemin . pop () chemin . append (( 1 , 2 )) chemin . append (( 1 , 3 )) chemin . append (( 2 , 3 )) Compl\u00e9ter cette suite d'instructions jusqu'\u00e0 ce que la liste chemin repr\u00e9sente la solution. Rappel : la m\u00e9thode pop supprime le dernier \u00e9l\u00e9ment d'une liste et renvoie cet \u00e9l\u00e9ment. Question B.2. b. Recopier et compl\u00e9ter la fonction solution(lab) donn\u00e9e ci-dessous de sorte qu'elle renvoie le chemin solution du labyrinthe repr\u00e9sent\u00e9 par le param\u00e8tre lab. On pourra pour cela utiliser la fonction voisines. \ud83d\udc0d Script Python def solution ( lab ): chemin = [ depart ( lab )] case = chemin [ 0 ] i = case [ 0 ] j = case [ 1 ] --- Par exemple, l 'appel solution(lab2) doit renvoyer [(1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (2, 5), (3, 5), (4, 5), (5, 5), (6, 5)] .","title":"TD n\u00b021 - Exercices BAC"},{"location":"divers/Exercices_Bac_Correction/","text":"Th\u00e8me : BAC 21 TD : Exercices Divers BAC - Programmation Sujet 1 : Tableaux et Programmation On rappelle que len est une fonction qui prend un tableau en param\u00e8tre et renvoie sa longueur. C\u2019est-\u00e0-dire le nombre d\u2019\u00e9l\u00e9ments pr\u00e9sents dans le tableau. Exemple : len([12, 54, 34, 57]) vaut 4. Le but de cet exercice est de programmer diff\u00e9rentes r\u00e9ductions pour un site de vente de v\u00eatements en ligne. On rappelle que si le prix d\u2019un article avant r\u00e9duction est de x euros, son prix vaut 0, 5x si on lui applique une r\u00e9duction de 50%, son prix vaut 0, 6x si on lui applique une r\u00e9duction de 40%, son prix vaut 0, 7x si on lui applique une r\u00e9duction de 30%, son prix vaut 0, 8x si on lui applique une r\u00e9duction de 20%, son prix vaut 0, 9x si on lui applique une r\u00e9duction de 10%. Dans le syst\u00e8me informatique du site de vente, l\u2019ensemble des articles qu\u2019un client veut acheter, appel\u00e9 panier, est mod\u00e9lis\u00e9 par un tableau de flottants. Par exemple, si un client veut acheter un pantalon \u00e0 30,50 euros, un tee-shirt \u00e0 15 euros, une paire de chaussettes \u00e0 6 euros, une jupe \u00e0 20 euros, une paire de collants \u00e0 5 euros, une robe \u00e0 35 euros et un short \u00e0 10,50 euros, le syst\u00e8me informatique aura le tableau suivant : \ud83d\udc0d Script Python tab = [ 30.5 , 15.0 , 6.0 , 20.0 , 5.0 , 35.0 , 10.5 ] Question 1. (a) Enonc\u00e9 Solution \u00c9crire une fonction Python total_hors_reduction ayant pour argument le tableau des prix des articles du panier d\u2019un client et renvoyant le total des prix de ces articles. \ud83d\udc0d Script Python def total_hors_reduction ( tab ): total = 0 for pa in tab : total = total + pa return total Question 1. (b) Enonc\u00e9 Solution Le site de vente propose la promotion suivante comme offre de bienvenue : 20% de r\u00e9duction sur le premier article de la liste, 30% de r\u00e9duction sur le deuxi\u00e8me article de la liste (s\u2019il y a au moins deux articles) et aucune r\u00e9duction sur le reste des articles (s\u2019il y en a). Recopier sur la copie et compl\u00e9ter la fonction Python offre_bienvenue prenant en param\u00e8tre le tableau tab des prix des articles du panier d\u2019un client et renvoyant le total \u00e0 payer lorsqu\u2019on leur applique l\u2019offre de bienvenue. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def offre_bienvenue ( tab ): \"\"\" tableau -> float \"\"\" somme = 0 longueur = len ( tab ) if longueur > 0 : somme = tab [ 0 ] *... if longueur > 1 : somme = somme + ... if longueur > 2 : for i in range ( 2 , longueur ): somme =... return ... \ud83d\udc0d Script Python def offre_bienvenue ( tab ): somme = 0 longueur = len ( tab ) if longueur > 0 : somme = tab [ 0 ] * 0.8 if longueur > 1 : somme = somme + tab [ 1 ] * 0.7 if longueur > 2 : for i in range ( 2 , longueur ): somme = somme + tab [ i ] return somme Pour toute la suite de l\u2019exercice, on pourra utiliser la fonction total_hors_reduction m\u00eame si la question 1 n\u2019a pas \u00e9t\u00e9 trait\u00e9e. Question 2. Enonc\u00e9 Solution Lors de la p\u00e9riode des soldes, le site de vente propose les r\u00e9ductions suivantes : si le panier contient 5 articles ou plus, une r\u00e9duction globale de 50%, si le panier contient 4 articles, une r\u00e9duction globale de 40%, si le panier contient 3 articles, une r\u00e9duction globale de 30%, si le panier contient 2 articles, une r\u00e9duction globale de 20%, si le panier contient 1 article, une r\u00e9duction globale de 10%. Proposer une fonction Python prix_solde ayant pour argument le tableau tab des prix des articles du panier d\u2019un client et renvoyant le total des prix de ces articles lorsqu\u2019on leur applique la r\u00e9duction des soldes. \ud83d\udc0d Script Python def prix_solde ( tab ): longueur = len ( tab ) reduc = 1 if longueur == 1 : reduc = 0.9 if longueur == 2 : reduc = 0.8 if longueur == 3 : reduc = 0.7 if longueur == 4 : reduc = 0.6 if longueur >= 5 : reduc = 0.5 return reduc * total_hors_reduction ( tab ) ``` autre possibilit\u00e9 plus \u201c courte \u201d : ``` python def prix_soldeb ( tab ): return total_hors_reduction ( tab ) * ( 1 - 0.1 * min ( 5 , len ( tab ))) Question 3. (a) Enonc\u00e9 Solution \u00c9crire une fonction minimum qui prend en param\u00e8tre un tableau tab de nombres et renvoie la valeur minimum pr\u00e9sente dans le tableau. Dans cette question nous partons du principe que tab n\u2019est pas vide. \ud83d\udc0d Script Python def minimum ( tab ): mini = tab [ 0 ] for pa in tab : if pa < mini : mini = pa return mini Question 3. (b) Enonc\u00e9 Solution Pour ses bons clients, le site de vente propose une offre promotionnelle, \u00e0 partir de 2 articles achet\u00e9s, l\u2019article le moins cher des articles command\u00e9s est offert. \u00c9crire une fonction Python offre_bon_client ayant pour param\u00e8tre le tableau des prix des articles du panier d\u2019un client et renvoyant le total \u00e0 payer lorsqu\u2019on leur applique l\u2019offre bon client. \ud83d\udc0d Script Python def offre_bon_client ( tab ): longueur = len ( tab ) total = total_hors_reduction ( tab ) if longueur >= 2 : total = total - minimum ( tab ) return total Question 4. Afin de diminuer le stock de ses articles dans ses entrep\u00f4ts, l\u2019entreprise imagine faire l\u2019offre suivante \u00e0 ses clients : en suivant l\u2019ordre des articles dans le panier du client, elle consid\u00e8re les 3 premiers articles et offre le moins cher, puis les 3 suivants et offre le moins cher et ainsi de suite jusqu\u2019\u00e0 ce qu\u2019il reste au plus 2 articles qui n\u2019ont alors droit \u00e0 aucune r\u00e9duction. Exemple : Si le panier du client contient un pantalon \u00e0 30,50 euros, un tee-shirt \u00e0 15 euros, une paire de chaussettes \u00e0 6 euros, une jupe \u00e0 20 euros, une paire de collants \u00e0 5 euros, une robe \u00e0 35 euros et un short \u00e0 10,50 euros, ce panier est repr\u00e9sent\u00e9 par le tableau suivant : \ud83d\udc0d Script Python tab = [ 30.5 , 15.0 , 6.0 , 20.0 , 5.0 , 35.0 , 10.5 ] Pour le premier groupe (le pantalon \u00e0 30,50 euros, le tee-shirt \u00e0 15 euros, la paire de chaussettes \u00e0 6 euros), l\u2019article le moins cher, la paire de chaussettes \u00e0 6 euros, est offert. Pour le second groupe (la jupe \u00e0 20 euros, la paire de collants \u00e0 5 euros, la robe \u00e0 35 euros), la paire de collants \u00e0 5 euros est offerte. Donc le total apr\u00e8s promotion de d\u00e9stockage est 111 euros. On constate que le prix apr\u00e8s promotion de d\u00e9stockage d\u00e9pend de l\u2019ordre dans lequel se pr\u00e9sentent les articles dans le panier. Question 4.(a) Enonc\u00e9 Solution Proposer un panier contenant les m\u00eames articles que ceux de l\u2019exemple mais ayant un prix apr\u00e8s promotion de d\u00e9stockage diff\u00e9rent de 111 euros. plusieurs solutions possibles [30.5, 20.0, 35.0, 15.0, 6.0, 5.0, 10.5] => total apr\u00e8s promotion = 122 - 20 - 5 = 97 Question 4. (b) Enonc\u00e9 Solution Proposer un panier contenant les m\u00eames articles mais ayant le prix apr\u00e8s promotion de d\u00e9stockage le plus bas possible. [35, 30.5, 20.0, 15.0, 10.5, 6.0, 5.0] => total apr\u00e8s promotion = 122 - 20 - 6 = 96 Question 4. (c) === \"Enonc\u00e9\u00e9 Une fois ses articles choisis, quel algorithme le client peut-il utiliser pour modifier son panier afin de s\u2019assurer qu\u2019il obtiendra le prix apr\u00e8s promotion de d\u00e9stockage le plus bas possible ? On ne demande pas d\u2019\u00e9crire cet algorithme. Solution Pour avoir le prix apr\u00e8s promotion de d\u00e9stockage le plus bas possible, il faut trier le tableau dans l\u2019ordre d\u00e9croissant. On peut donc utiliser un algorithme de tri (tri par s\u00e9lection, tri par insertion ou tri fusion) Sujet 2 : Programmation en G\u00e9n\u00e9ral Cet exercice porte sur la programmation en g\u00e9n\u00e9ral. \u00c9tant donn\u00e9 un tableau non vide de nombres entiers relatifs, on appelle sous-s\u00e9quence une suite non vide d'\u00e9l\u00e9ments voisins de ce tableau. On cherche dans cet exercice \u00e0 d\u00e9terminer la plus grande somme possible obtenue en additionnant les \u00e9l\u00e9ments d'une sous-s\u00e9quence. Par exemple, pour le tableau ci-dessous, la somme maximale vaut 18. Elle est obtenue en additionnant les \u00e9l\u00e9ments de la sous-s\u00e9quence encadr\u00e9e en gras ci-dessous (6 ; 8 ; -6 ; 10). Question 1. a. Enonc\u00e9 Solution Quelle est la solution du probl\u00e8me si les \u00e9l\u00e9ments du tableau sont tous positifs ? Si les \u00e9l\u00e9ments du tableau sont tous positifs, il suffit d\u2019additionner tous les \u00e9l\u00e9ments du tableau pour obtenir la somme maximale (la sous-s\u00e9quence correspond \u00e0 l\u2019ensemble du tableau). Question 1. b. Enonc\u00e9 Solution Quelle est la solution du probl\u00e8me si tous les \u00e9l\u00e9ments sont n\u00e9gatifs ? Si les \u00e9l\u00e9ments du tableau sont tous n\u00e9gatifs, il suffit de prendre l\u2019\u00e9l\u00e9ment le plus grand du tableau (la sous-s\u00e9quence est r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment) Dans cette question, on examine toutes les sous-s\u00e9quences possibles. Question 2. a. Enonc\u00e9 Solution \u00c9crire le code Python d'une fonction somme_sous_sequence(lst, i, j) qui prend en argument une liste et deux entiers i, j et renvoie la somme de la sous-s\u00e9quence d\u00e9limit\u00e9e par les indices i et j (inclus). \ud83d\udc0d Script Python def somme_sous_sequence ( lst , i , j ): somme = 0 for ind in range ( i , j + 1 ): somme = somme + lst [ ind ] return somme Question 2. b. Enonc\u00e9 Solution La fonction pgsp ci-dessous permet de d\u00e9terminer la plus grande des sommes obtenues en additionnant les \u00e9l\u00e9ments de toutes les sous-s\u00e9quences possibles du tableau lst. \ud83d\udc0d Script Python def pgsp ( lst ): n = len ( lst ) somme_max = lst [ 0 ] for i in range ( n ): for j in range ( i , n ): s = somme_sous_sequence ( lst , i , j ) if s > somme_max : somme_max = s return somme_max Parmi les quatre choix suivants, quel est le nombre de comparaisons effectu\u00e9es par cette fonction si le tableau lst pass\u00e9 en param\u00e8tre contient 10 \u00e9l\u00e9ments ? 10 55 100 1055 Pour un tableau de 10 \u00e9l\u00e9ments, nous avons 55 comparaisons \\((10+9+8+7+6+5+4+3+2+1=55)\\) . Question 2. c. Enonc\u00e9 Solution Recopier et modifier la fonction pgsp pour qu'elle renvoie un tuple contenant la somme maximale et les indices qui d\u00e9limitent la sous-s\u00e9quence correspondant \u00e0 cette somme maximale. python def pgsp(lst): n = len(lst) somme_max = lst[0] i_max = 0 j_max = 0 for i in range(n): for j in range(i,n): s = somme_sous_sequence(lst,i,j) if s > somme_max: somme_max = s i_max = i j_max = j return (somme_max, i_max, j_max) Question 3. On consid\u00e8re dans cette question une approche plus \u00e9labor\u00e9e. Son principe consiste, pour toutes les valeurs possibles de l\u2019indice \u0745, \u00e0 d\u00e9terminer la somme maximale \u0735(\u0745) des sous-s\u00e9quences qui se terminent \u00e0 l'indice \u0745. En d\u00e9signant par lst[\u0745] l\u2019\u00e9l\u00e9ment de lst d\u2019indice \u0745, on peut v\u00e9rifier que S(0) = lst[0] et pour \u0745 \\(i \\geq 1\\) : \\(S\u0735(i) = lst[\u0745i]\\) si \u0735 \\((\u0745i- 1) \u2264 0\\) ; \\(i = lst[\u0745i] + \u0735S(\u0745i-1)\\) si \u0735 \\(S(\u0745i-1) > 0\\) . Question 3. a. Enonc\u00e9 Solution Recopier et compl\u00e9ter le tableau ci-dessous avec les valeurs de \u0735 \\(S(\u0745i)\\) pour la liste consid\u00e9r\u00e9e en exemple. Question 3. b. Enonc\u00e9 Solution La solution au probl\u00e8me \u00e9tant la plus grande valeur des \u0735 \\(S(\u0745i)\\) , on demande de compl\u00e9ter la fonction pgsp2 ci-dessous, de sorte que la variable sommes_max contienne la liste des valeurs \u0735 \\(S(\u0745i)\\) . \ud83d\udc0d Script Python def pgsp2 ( lst ): sommes_max = [ lst [ 0 ]] for i in range ( 1 , len ( lst )): # \u00e0 compl\u00e9ter return max ( sommes_max ) \ud83d\udc0d Script Python def pgsp2 ( lst ): somme_max = [ lst [ 0 ]] for i in range ( 1 , len ( lst )): if somme_max [ i - 1 ] <= 0 : somme_max . append ( lst [ i ]) else : somme_max . append ( lst [ i ] + somme_max [ i - 1 ]) return max ( somme_max ) Question 3. c. Enonc\u00e9 Solution En quoi la solution obtenue par cette approche est-elle plus avantageuse que celle de la question 2.b. ? Cette solution est plus avantageuse, car la complexit\u00e9 en temps de l\u2019algorithme est en \\(O(n)\\) alors que dans le cas pr\u00e9c\u00e9dent il \u00e9tait en \\(O(n^2)\\) . Sujet 3 : Tableau - Parcours - Programmation en G\u00e9n\u00e9ral Cet exercice porte sur l\u2019algorithmique et la programmation en Python. Il aborde les notions de tableaux de tableaux et d\u2019algorithmes de parcours de tableaux. Partie A : Repr\u00e9sentation d\u2019un labyrinthe On mod\u00e9lise un labyrinthe par un tableau \u00e0 deux dimensions \u00e0 \u074a \\(n\\) lignes et \u0749 \\(m\\) colonnes avec \u074a \\(n\\) et \u0749 \\(m\\) des entiers strictement positifs. Les lignes sont num\u00e9rot\u00e9es de 0 \u00e0 \u074a \\(n-1\\) et les colonnes de 0 \u00e0 \\(m-1\\) . La case en haut \u00e0 gauche est rep\u00e9r\u00e9e par \\((0,0)\\) et la case en bas \u00e0 droite par \\((n-1,m-1)\\) . Dans ce tableau : 0 repr\u00e9sente une case vide, hors case de d\u00e9part et arriv\u00e9e, 1 repr\u00e9sente un mur, 2 repr\u00e9sente le d\u00e9part du labyrinthe, 3 repr\u00e9sente l'arriv\u00e9e du labyrinthe. Ainsi, en Python, le labyrinthe ci-dessous est repr\u00e9sent\u00e9e par le tableau de tableaux lab1 . Question A.1. Enonc\u00e9 Le labyrinthe ci-dessous est cens\u00e9 \u00eatre repr\u00e9sent\u00e9 par le tableau de tableaux lab2. Cependant, dans ce tableau, un mur se trouve \u00e0 la place du d\u00e9part du labyrinthe. Donner une instruction permettant de placer le d\u00e9part au bon endroit dans lab2. ``` Solution \ud83d\udc0d Script Python lab2 [ 1 ][ 0 ] = 2 Question A.2. Enonc\u00e9 Solution \u00c9crire une fonction est_valide(i, j, n, m) qui renvoie True si le couple \\((i,j)\\) correspond \u00e0 des coordonn\u00e9es valides pour un labyrinthe de taille \\((n,m)\\) , et False sinon. On donne ci-dessous des exemples d'appels. \ud83d\udc0d Script Python >>> est_valide ( 5 , 2 , 10 , 10 ) True >>> est_valide ( - 3 , 4 , 10 , 10 ) False \ud83d\udc0d Script Python def est_valide ( i , j , n , m ): return i >= 0 and j >= 0 and i < n and j < m Question A.3. === \"Enonc\u00e9 On suppose que le d\u00e9part d'un labyrinthe est toujours indiqu\u00e9, mais on ne fait aucune supposition sur son emplacement. Compl\u00e9ter la fonction depart(lab)ci-dessous de sorte qu'elle renvoie, sous la forme d'un tuple, les coordonn\u00e9es du d\u00e9part d'un labyrinthe (repr\u00e9sent\u00e9 par le param\u00e8tre lab). Par exemple, l'appel depart(lab1) doit renvoyer le tuple (5, 0). \ud83d\udccb Texte ```python def depart(lab) : n = len(lab) m = len(lab[0]) ... ``` Solution \ud83d\udc0d Script Python def depart ( lab ): n = len ( lab ) m = len ( lab [ 0 ]) for i in range ( n ): for j in range ( m ): if lab [ i ][ j ] == 2 : return ( i , j ) Question A.4. Enonc\u00e9 Solution \u00c9crire une fonction nb_cases_vides(lab) qui renvoie le nombre de cases vides d'un labyrinthe (comprenant donc l'arriv\u00e9e et le d\u00e9part). Par exemple, l'appel nb_cases_vides(lab2) doit renvoyer la valeur 19. \ud83d\udc0d Script Python def nb_cases_vides ( lab ): n = len ( lab ) m = len ( lab [ 0 ]) compt = 0 for i in range ( n ): for j in range ( m ): if lab [ i ][ j ] == 2 or lab [ i ][ j ] == 3 or lab [ i ][ j ] == 0 : compt = compt + 1 return compt Partie B : Recherche d\u2019une solution dans un labyrinthe On suppose dans cette partie que les labyrinthes poss\u00e8dent un unique chemin allant du d\u00e9part \u00e0 l\u2019arriv\u00e9e sans repasser par la m\u00eame case. Dans la suite, c\u2019est ce chemin que l\u2019on appellera solution du labyrinthe. Pour d\u00e9terminer la solution d'un labyrinthe, on parcourt les cases vides de proche en proche. Lors d\u2019un tel parcours, afin d\u2019\u00e9viter de tourner en rond, on choisit de marquer les cases visit\u00e9es. Pour cela, on remplace la valeur d'une case visit\u00e9e dans le tableau repr\u00e9sentant le labyrinthe par la valeur 4. Question B.1. Enonc\u00e9 Solution On dit que deux cases d'un labyrinthe sont voisines si elles ont un c\u00f4t\u00e9 commun. On consid\u00e8re une fonction voisines(i, j, lab) qui prend en arguments deux entiers \u0745 \\(i\\) et \u0746 \\(j\\) repr\u00e9sentant les coordonn\u00e9es d\u2019une case et un tableau lab qui repr\u00e9sente un labyrinthe. Cette fonction renvoie la liste des coordonn\u00e9es des cases voisines de la case de coordonn\u00e9es \\((i,j)\\) qui sont valides, non visit\u00e9es et qui ne sont pas des murs. L'ordre des \u00e9l\u00e9ments de cette liste n'importe pas. Ainsi, l'appel voisines(1, 1, [[1, 1, 1], [4, 0, 0], [1, 0, 1]]) renvoie la liste [(2, 1), (1, 2)] . Que renvoie l'appel voisines(1, 2, [[1, 1, 4], [0, 0, 0], [1, 1, 0]]) ? L\u2019appel de la fonction renvoie : [(2, 2), (1, 1)] Question 2. On souhaite stocker la solution dans une liste chemin. Cette liste contiendra les coordonn\u00e9es des cases de la solution, dans l'ordre. Pour cela, on proc\u00e8de de la fa\u00e7on suivante. Initialement : d\u00e9terminer les coordonn\u00e9es du d\u00e9part : c'est la premi\u00e8re case \u00e0 visiter ; ajouter les coordonn\u00e9es de la case d\u00e9part \u00e0 la liste chemin. Tant que l'arriv\u00e9e n'a pas \u00e9t\u00e9 atteinte : on marque la case visit\u00e9e avec la valeur 4 ; si la case visit\u00e9e poss\u00e8de une case voisine libre, la premi\u00e8re case de la liste renvoy\u00e9e par la fonction voisines devient la prochaine case \u00e0 visiter et on ajoute \u00e0 la liste chemin ; sinon, il s'agit d'une impasse. On supprime alors la derni\u00e8re case dans la liste chemin. La prochaine case \u00e0 visiter est celle qui est d\u00e9sormais en derni\u00e8re position de la liste chemin. Question B.2. a. === \"Enonc\u00e9 Le tableau de tableaux lab3 ci-dessous repr\u00e9sente un labyrinthe. \ud83d\udccb Texte ```python lab3 = [[1, 1, 1, 1, 1, 1], [2, 0, 0, 0, 0, 3], [1, 0, 1, 0, 1, 1], [1, 1, 1, 0, 0, 1]] ``` La suite d'instructions ci-dessous simule le d\u00e9but des modifications subies par la liste chemin lorsque l'on applique la m\u00e9thode pr\u00e9sent\u00e9e. ```python # entr\u00e9e: (1, 0), sortie (1, 5) chemin = [(1, 0)] chemin.append((1, 1)) chemin.append((2, 1)) chemin.pop() chemin.append((1, 2)) chemin.append((1, 3)) chemin.append((2, 3)) ``` Compl\u00e9ter cette suite d'instructions jusqu'\u00e0 ce que la liste chemin repr\u00e9sente la solution. Rappel : la m\u00e9thode pop supprime le dernier \u00e9l\u00e9ment d'une liste et renvoie cet \u00e9l\u00e9ment. Solution \ud83d\udc0d Script Python # entr\u00e9e: (1, 0), sortie (1, 5) chemin = [( 1 , 0 )] chemin . append (( 1 , 1 )) chemin . append (( 2 , 1 )) chemin . pop () chemin . append (( 1 , 2 )) chemin . append (( 1 , 3 )) chemin . append (( 2 , 3 )) chemin . append (( 3 , 3 )) chemin . append (( 3 , 4 )) chemin . pop () chemin . pop () chemin . pop () chemin . append (( 1 , 4 )) chemin . append (( 1 , 5 )) Question B.2. b. Enonc\u00e9 Solution Recopier et compl\u00e9ter la fonction solution(lab) donn\u00e9e ci-dessous de sorte qu'elle renvoie le chemin solution du labyrinthe repr\u00e9sent\u00e9 par le param\u00e8tre lab. On pourra pour cela utiliser la fonction voisines. \ud83d\udc0d Script Python def solution ( lab ): chemin = [ depart ( lab )] case = chemin [ 0 ] i = case [ 0 ] j = case [ 1 ] --- Par exemple, l 'appel solution(lab2) doit renvoyer [(1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (2, 5), (3, 5), (4, 5), (5, 5), (6, 5)] . * \ud83d\udc0d Script Python def solution ( lab ): chemin = [ depart ( lab )] case = chemin [ 0 ] i = case [ 0 ] j = case [ 1 ] while lab [ i ][ j ] != 3 : lab [ i ][ j ] = 4 v = voisines ( i , j , lab ) if len ( v ) != 0 : prochaine = v . pop () chemin . append ( prochaine ) i = prochaine [ 0 ] j = prochaine [ 1 ] else : chemin . pop () n = len ( chemin ) i = chemin [ n - 1 ][ 0 ] j = chemin [ n - 1 ][ 1 ] return chemin","title":"TD n\u00b021 - Exercices BAC"},{"location":"divers/bns22/","text":"BNS 2022 : passage en revue des sujets \u2693\ufe0e Sujet 1 \u2693\ufe0e Exercice 1.1 \u2693\ufe0e L'\u00e9nonc\u00e9 \u2693\ufe0e \u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : \ud83d\udc0d Script Python >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 Commentaires \u2693\ufe0e Pas grand chose mis \u00e0 part cette distinction caract\u00e8re/cha\u00eene de caract\u00e8res qui n'existe pas en Python. La personne qui a r\u00e9dig\u00e9 est s\u00fbrement une habitu\u00e9e d'Ocaml en pr\u00e9pa :) Il y a aussi cette espace apr\u00e8s la virgule des appels de recherche plus ou moins existante... Enfin le choix du nom recherche est discutable car cela ferait plus penser \u00e0 un test renvoyant un bool\u00e9en (je recherche i dans mississippi ). On aurait pu choisr compte_lettres , nb_occurrences , compte_occurrences , etc. Exercice 1.2 \u2693\ufe0e L'\u00e9nonc\u00e9 \u2693\ufe0e On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets - le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste pieces=[100, 50, 20, 10, 5, 2, 1] - (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre), on cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 Pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return ... p = pieces [ i ] if p <= ... : solution . append ( ... ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , ... ) On devra obtenir : \ud83d\udc0d Script Python >>> rendu_glouton_r ( 68 ,[], 0 ) [ 50 , 10 , 5 , 2 , 1 ] >>> rendu_glouton_r ( 291 ,[], 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] 2 / 3 Commentaires \u2693\ufe0e Une erreur grossi\u00e8re sur 4 de la version 2021 de cet exercice a disparu mais il en reste 3... On fermerait presque les yeux sur l'erreur d'indentation de la premi\u00e8re ligne du bloc de la fonction, de l'oubli du _r en suffixe du nom de la fonction dans le code de celle-ci, du P majuscule de pieces ...Mais le pire est \u00e0 venir : la param\u00e8tre par d\u00e9faut mutable. La personne qui a r\u00e9dig\u00e9 semble s'en \u00eatre rendu compte puisqu'elle remet l'argument par d\u00e9faut dans l'appel de la fonction mais alors on se demande vraiment pourquoi il y a eu un param\u00e8tre par d\u00e9faut. Le raisonnement a s\u00fbrement \u00e9t\u00e9 : \" oh \u00e7a marche p\u00f4 ! Je vais remettre le param\u00e8tre par d\u00e9faut dans l'appel pour voir...ah tiens \u00e7a marche\". Pourquoi un param\u00e8tre par d\u00e9faut mutable, c'est le mal ? \u2693\ufe0e Si on utilise le code propos\u00e9 dans le sujet 1 (en r\u00e9tablissant l'indentation, en corrigeant les coquilles) : \ud83d\udc0d Script Python pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton_r ( arendre , solution = [], i = 0 ): if arendre == 0 : return solution p = pieces [ i ] if p <= arendre : solution . append ( p ) return rendu_glouton_r ( arendre - p , solution , i ) else : return rendu_glouton_r ( arendre , solution , i + 1 ) On obtient : \ud83d\udc0d Script Python In [ 2 ]: rendu_glouton_r ( 68 ) Out [ 4 ]: [ 50 , 10 , 5 , 2 , 1 ] In [ 5 ]: rendu_glouton_r ( 68 ) Out [ 5 ]: [ 50 , 10 , 5 , 2 , 1 , 50 , 10 , 5 , 2 , 1 ] In [ 6 ]: rendu_glouton_r ( 68 ) Out [ 6 ]: [ 50 , 10 , 5 , 2 , 1 , 50 , 10 , 5 , 2 , 1 , 50 , 10 , 5 , 2 , 1 ] L'id\u00e9e de la personne qui a propos\u00e9 ce code est s\u00fbrement de retrouver l'id\u00e9e de r\u00e9cursion terminale ch\u00e8re aux utilisateurs de Ocaml en pr\u00e9pa. Mais ici, on travaille en Python...Le code de la fonction est cr\u00e9\u00e9 une bonne fois pour toute \u00e0 la cr\u00e9ation de la fonction i.e. le param\u00e8tre par d\u00e9faut est li\u00e9 une bonne fois pour toute \u00e0 solution . Quand on appelle la fonction, on l'appelle toujours avec le m\u00eame param\u00e8tre par d\u00e9faut. Le probl\u00e8me est que solution est ici mutable et va donc \u00e9voluer \u00e0 chaque ex\u00e9cution de la fonction. Une erreur classique mais d\u00e9licate \u00e0 comprendre pour les \u00e9l\u00e8ves et qu'on attend s\u00fbrement pas \u00e0 trouver dans un sujet. Comment faire ? \u2693\ufe0e On pouvait dire\u2026 Oh ! Dieu !\u2026 bien des choses en somme\u2026 La 1\u00e8re id\u00e9e est de prendre un param\u00e8tre par d\u00e9faut non mutable comme un tuple mais on ne pourra pas le faire \u00e9voluer car il est par essence non mutable. On peut prendre None : il n'y a pas de solution au d\u00e9part. Le probl\u00e8me est que ce n'est pas ce qu'on a envie d'avoir. Mais on peut bidouiller ainsi : \ud83d\udc0d Script Python pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton_r ( arendre , solution = None , i = 0 ): if solution is None : solution = [] if arendre == 0 : return solution p = pieces [ i ] if p <= arendre : solution . append ( p ) return rendu_glouton_r ( arendre - p , solution , i ) else : return rendu_glouton_r ( arendre , solution , i + 1 ) Ou on peut simuler de la r\u00e9cursion terminale (inutile en python) avec une fonction auxiliaire. Ou on ne cherche pas \u00e0 rendre la r\u00e9cursion terminale car c'est totalement inutile en Python : \ud83d\udc0d Script Python def rendu_glouton_r ( arendre , i = 0 ): if arendre == 0 : return [] p = pieces [ i ] if p <= arendre : return rendu_glouton_r ( arendre - p , i ) + [ p ] else : return rendu_glouton_r ( arendre , i + 1 ) Petit bonus : la visualisation avec Pythontutor Sujet 2 \u2693\ufe0e Exercice 2.1 \u2693\ufe0e \u00c9nonc\u00e9 \u2693\ufe0e Soit le couple ( note , coefficient ): note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples ( note , coefficient ). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer le r\u00e9sultat du calcul suivant : \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) Commentaires \u2693\ufe0e Pas grand chose \u00e0 dire, \u00e0 part que c'est plus facile \u00e0 \u00e9crire qu'un tri ou un algo glouton comme on en demande dans d'autres sujets. Attend-on une gestion de la liste vide, des coefficients n\u00e9gatifs ? Exercice 2.2 \u2693\ufe0e \u00c9nonc\u00e9 \u2693\ufe0e On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : Compl\u00e9ter la fonction pascal ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne 1 \u00e0 la ligne n o\u00f9 n est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 2 (le tableau sera contenu dans la variable C ). La variable Ck doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro k , la k -i\u00e8me ligne du tableau. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , ... ): Ck = [ ... ] for i in range ( 1 , k ): Ck . append ( C [ ... ][ i - 1 ] + C [ ... ][ ... ] ) Ck . append ( ... ) C . append ( Ck ) return C Pour n = 4 , voici ce qu'on devra obtenir : Bash Session >>> pascal(4) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] Pour n = 5 , voici ce qu'on devra obtenir : Bash Session >>> pascal(5) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1]] Commentaires \u2693\ufe0e Un sujet un peu math\u00e9matique (apr\u00e8s la moyenne en 1) d'un professeur fran\u00e7ais n\u00e9 avant 2000 qui pense encore aux coefficients binomiaux \u00e9crits sous la forme \\(C_n^k\\) :) Les \u00e9l\u00e8ves ayant vu la formule de Pascal en maths seront avantag\u00e9s mais...ah...on me parle dans mon \u00e9couteur...cela a disparu du programme de sp\u00e9cialit\u00e9 terminale depuis la r\u00e9forme...mais cela a subsist\u00e9 en maths compl\u00e9mentaires...j'ai d\u00fb mal comprendre. Encore du laisser-aller dans les espaces entre les op\u00e9rateurs binaires. Une liste pr\u00e9sent\u00e9e en \"triangle rectangle\" aurait peut-\u00eatre \u00e9t\u00e9 plus facile \u00e0 visualiser et la gestion des bornes des range est \u00e0 mener avec attention. Le choix des indices est peut-\u00eatre perturbant car on a plus l'habitude de i et j mais je pinaille. Je suppose qu'on attend \u00e7a: \ud83d\udc0d Script Python def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , n + 1 ): Ck = [ 1 ] for i in range ( 1 , k ): Ck . append ( C [ k - 1 ][ i - 1 ] + C [ k - 1 ][ i ]) Ck . append ( 1 ) C . append ( Ck ) return C Je suppose aussi que les coups des 1 en bordure vont se r\u00e9gler par essais successifs. On est presque content qu'il n'y ait pas de grosse absurdit\u00e9 ici... Sujet 3 \u2693\ufe0e Exercice 3.1 \u2693\ufe0e \u00c9nonc\u00e9 \u2693\ufe0e Le codage par diff\u00e9rence (delta encoding en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es assez petites n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction delta qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : \ud83d\udc0d Script Python >>> delta ([ 1000 , 800 , 802 , 1000 , 1003 ]) [ 1000 , - 200 , 2 , 198 , 3 ] >>> delta ([ 42 ]) 42 Commentaires \u2693\ufe0e Allez, la coquille, la coquille, la coquille ! Oui, bien s\u00fbr, vous l'avez vue : delta([42]) doit renvoyer [42] et non pas 42 , \u00e0 moins que la personne qui a test\u00e9 le sujet n'ait utilis\u00e9 Deep Thought et recherchait la r\u00e9ponse \u00e0 la question ultime sur la vie, l'univers et tout le reste. Puisqu'on ne peut pas modifier les sujets, encore un \u00e0 jeter \u00e0 la poubelle en plus du 1 et du 2 pour ne pas favoriser les maths comps. On esp\u00e8re qu'on va bient\u00f4t en trouver un de publiable. Sinon, il y a quand m\u00eame des pi\u00e8ges... On peut penser \u00e0 un changement en place : \ud83d\udc0d Script Python def delta1 ( xs ): for i in range ( 1 , len ( xs )): xs [ i ] = xs [ i ] - xs [ i - 1 ] return xs mais \u00e7a pose probl\u00e8me: Bash Session In [142]: delta1([1000, 800, 802, 1000, 1003]) Out[142]: [1000, -200, 1002, -2, 1005] Donc en bon habitu\u00e9 de la programmation fonctionnelle qui ne fait pas de mal \u00e0 ses arguments, on pr\u00e9f\u00e8rera \u00e7a : \ud83d\udc0d Script Python def delta2 ( xs ): ys = [ xs [ 0 ]] # mais il y a le probl\u00e8me de la liste vide for i in range ( 1 , len ( xs )): ys . append ( xs [ i ] - xs [ i - 1 ]) return ys mais on aura un probl\u00e8me avec la liste vide. On peut arranger comme \u00e7a : \ud83d\udc0d Script Python def delta3 ( xs ): ys = xs [:] # il faut conna\u00eetre les probl\u00e8mes de copie de liste for i in range ( 1 , len ( xs )): ys [ i ] = xs [ i ] - xs [ i - 1 ] return ys mais il faut savoir faire une copie de liste car sinon avec \u00e7a : \ud83d\udc0d Script Python def delta4 ( xs ): ys = xs for i in range ( 1 , len ( xs )): ys [ i ] = xs [ i ] - xs [ i - 1 ] return ys on a ce probl\u00e8me : Bash Session In [146]: delta4([1000, 800, 802, 1000, 1003]) Out[146]: [1000, -200, 1002, -2, 1005] On peut aussi penser \u00e0 \u00e7a: \ud83d\udc0d Script Python def delta5 ( xs ): return [ xs [ 0 ]] + [ xs [ i ] - xs [ i - 1 ] for i in range ( 1 , len ( xs ))] Bref, il y a quand m\u00eame des pi\u00e8ges. Exercice 3.2 \u2693\ufe0e \u00c9nonc\u00e9 \u2693\ufe0e Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212,\u00d7,\u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : \\[3 \\times (8 + 7) \u2212 (2 + 1)\\] La classe Noeud ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire. Compl\u00e9ter la fonction r\u00e9cursive expression_infixe qui prend en param\u00e8tre un objet de la classe Noeud et qui renvoie l\u2019expression arithm\u00e9tique repr\u00e9sent\u00e9e par l\u2019arbre binaire pass\u00e9 en param\u00e8tre, sous forme d\u2019une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses. R\u00e9sultat attendu avec l\u2019arbre ci-dessus : \ud83d\udc0d Script Python >>> e = Noeud ( Noeud ( Noeud ( None , 3 , None ), '*' , Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None ))), '-' , Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None ))) >>> expression_infixe ( e ) '((3*(8+7))-(2+1))' \ud83d\udc0d Script Python class Noeud : def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def __str__ ( self ): return str ( self . valeur ) def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None def expression_infixe ( e ): s = ... if e . gauche is not None : s = s + expression_infixe ( ... ) s = s + ... if ... is not None : s = s + ... if ... : return s return '(' + s + ')' Commentaire \u2693\ufe0e Ouh la, c'est pas \u00e9vident \u00e9vident ici. J'ai r\u00e9pondu un peu au hasard pour \u00e9quilibrer les \u00e9critures et \u00e7a a march\u00e9. Je suppose qu'on attend \u00e7a : \ud83d\udc0d Script Python def expression_infixe ( e ): s = '' if e . gauche is not None : s = s + expression_infixe ( e . gauche ) s = s + str ( e . valeur ) if e . droit is not None : s = s + expression_infixe ( e . droit ) if e . est_une_feuille (): return s return '(' + s + ')' Cette construction de plusieurs if successifs sans else me met tr\u00e8s mal \u00e0 l'aise. Je ne pense pas non plus que les candidats comprennent grand chose \u00e0 cette fonction et vont faire des essais jusqu'\u00e0 ce que \u00e7a marche ou vont utiliser les aides de la personne qui les examine. Un exercice \u00e0 \u00e9viter de prendre dans sa liste. Sujet 4 \u2693\ufe0e Exercice 4.1 \u2693\ufe0e \u00c9nonc\u00e9 \u2693\ufe0e \u00c9crire une fonction recherche qui prend en param\u00e8tre un tableau de nombres entiers tab , et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : \ud83d\udc0d Script Python >>> recherche ([ 1 , 4 , 3 , 5 ]) [] >>> recherche ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> recherche ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> recherche ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] Commentaires \u2693\ufe0e Tiens, encore une recherche...Sauf que c'est une toute autre recherche que dans le sujet 1. On peut donc l'appeler recherche_consecutifs peut-\u00eatre. Ensuite la liste en param\u00e8tre est d\u00e9sign\u00e9e comme \u00e9tant un tableau et la liste renvoy\u00e9e est d\u00e9sign\u00e9e comme \u00e9tant une liste. Comme M. Preskovic, je suis dans toutes mes confuses avec un tel \u00e9nonc\u00e9. Je suppose qu'on attend quelque chose comme \u00e7a: \ud83d\udc0d Script Python def recherche ( tab ): couples = [] for i in range ( len ( tab ) - 1 ): if tab [ i + 1 ] - tab [ i ] == 1 : couples . append (( tab [ i ], tab [ i + 1 ])) return couples Exercice 4.2 \u2693\ufe0e \u00c9nonc\u00e9 \u2693\ufe0e Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image M , deux entiers i et j et une valeur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien s\u2019il vaut 0 . Par exemple, propager(M,2,1,3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction propager donn\u00e9 ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == ... : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == ... ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( ... ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , ... , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( ... ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , ... , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( ... ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , ... , val ) Exemple : Bash Session >>> M = [[0,0,1,0],[0,1,0,1],[1,1,1,0],[0,1,1,0]] >>> propager(M,2,1,3) >>> M [[0, 0, 1, 0], [0, 3, 0, 1], [3, 3, 3, 0], [0, 3, 3, 0]] Commentaires \u2693\ufe0e Je vais \u00eatre d\u00e9sagr\u00e9able mais cet exercice n'a strictement aucun int\u00e9r\u00eat en l'\u00e9tat si ce n'est \u00eatre capable de comprendre un \u00e9nonc\u00e9 pas clair. Ensuite, on peut compl\u00e9ter les trous sans du tout chercher \u00e0 comprendre l'algo. Je le sais puisque c'est comme \u00e7a que j'ai fait. \u00c0 \u00e9viter donc. Ah, voici le jeu des devinettes \u00e0 la Pif Gadget : \ud83d\udc0d Script Python def propager ( M , i , j , val ): if M [ i ][ j ] == 0 : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == 1 ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( i + 1 ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , i + 1 , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( j - 1 ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , j - 1 , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( j + 1 ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , j + 1 , val ) Sujet 5 \u2693\ufe0e Exercice 5.1 \u2693\ufe0e \u00c9nonc\u00e9 \u2693\ufe0e \u00c9crire une fonction rechercheMinMax qui prend en param\u00e8tre un tableau de nombres non tri\u00e9s tab , et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s \u2018min\u2019 et \u2018max\u2019. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> tableau = [ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : - 2 , 'max' : 9 } >>> tableau = [] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : None , 'max' : None } Commentaires \u2693\ufe0e Tiens, une fonction recherche...Celle-ci a un suffixe. Mais avec une \u00e9criture de Haskellien. On doit \u00eatre patient. Un jour les personnes qui r\u00e9digent les sujets liront la PEP 8. On aurait aim\u00e9 un recherche_min_max . On ne parlera pas du choix de nom un peu perturbant pour qui a fait un peu d'algo. On trouve encore ici le nom de tableau. Au moins, on ne parle pas de liste juste apr\u00e8s. Bon, sinon c'est du quatre en un: recherche d'un max et d'un min et manipulation d'un dictionnaire et faire attention \u00e0 l'initialisation avec les None . \ud83d\udc0d Script Python def recherche_min_max ( tab ): if len ( tab ) == 0 : return { 'min' : None , 'max' : None } dic = { 'min' : tab [ 0 ], 'max' : tab [ 0 ]} for nombre in tab [ 1 :]: if nombre < dic [ 'min' ]: dic [ 'min' ] = nombre if nombre > dic [ 'max' ]: dic [ 'max' ] = nombre return dic Exercice 5.2 \u2693\ufe0e \u00c9nonc\u00e9 \u2693\ufe0e On dispose d\u2019un programme permettant de cr\u00e9er un objet de type PaquetDeCarte , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par #A compl\u00e9ter , puis ajouter des assertions dans l\u2019initialiseur de Carte , ainsi que dans la m\u00e9thode getCarteAt() . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): #A compl\u00e9ter \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): #A compl\u00e9ter Commentaires \u2693\ufe0e Bon, vous allez encore dire que je ne suis jamais content. les docstrings sont mises n'importe o\u00f9. Pas pro. des majuscules pour les noms d'attributs. les noms \u00e0 la Haskell au lieu de les \u00e9crire \u00e0 la Python on aurait pu utiliser un dictionnaire pour ces associations valeur: nom puisque c'est au programme et plus joli. Les assertions, c'est limite. Et de toute fa\u00e7on, c'est pr\u00e9vu pour le d\u00e9bugage seulement. \u00c7a c'est des d\u00e9tails. Ensuite, je n'ai pas compris la question (mon c\u00f4t\u00e9 un peu maniaco-depressif). \u00c7a veut dire quoi remplir le paquet de carte ? Avec quoi ? Ensuite, selon la mani\u00e8re dont on remplit le jeu, la carte num\u00e9ro 20 ne sera pas celle du test propos\u00e9 (moi j'ai eu le roi de tr\u00e8fle). Encore un sujet \u00e0 \u00e9viter. Une proposition: \ud83d\udc0d Script Python class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): if c not in range ( 1 , 5 ) or v not in range ( 1 , 14 ): raise ValueError ( \"Hauteur ou couleur invalide(s)\" ) self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): # self.contenu = [Carte(couleur, valeur) for couleur in range(1, 5) for valeur in range(1, 14)] # ou self . contenu = [ Carte ( couleur , valeur ) for valeur in range ( 1 , 14 ) for couleur in range ( 1 , 5 )] \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): if pos not in range ( 52 ): raise ValueError ( \"Y a que 52 cartes, tricheur\" ) return self . contenu [ pos ]","title":"BNS 2022 : passage en revue des sujets"},{"location":"divers/bns22/#bns-2022-passage-en-revue-des-sujets","text":"","title":"BNS 2022 : passage en revue des sujets"},{"location":"divers/conseil/","text":"Conseils de travail \u2693\ufe0e Conditions mat\u00e9rielles \u2693\ufe0e Lorsqu'on ne travaillera pas sur les notebook de capytale, il est conseill\u00e9 de travailler avec 3 espaces : l'\u00e9cran de l'ordinateur partitionn\u00e9 avec les 2 premiers espaces: ce site et un IDE (Thonny par exemple); C'est en codant qu'on apprend \u00e0 coder Tous les exemples de code dans le cours doivent \u00eatre retap\u00e9s (r\u00e9sistez \u00e0 l'envie du copier-coller) dans Thonny, soit en fen\u00eatre de script, soit en console. Cela permet de : m\u00e9moriser la syntaxe ; v\u00e9rifier si le code propos\u00e9 ne contient pas d'erreur ; et le plus important : faire ses propres tests et modifications pour v\u00e9rifier sa bonne compr\u00e9hension. et un troisi\u00e8me espace essentiel : un petit cahier \u00e0 spirale et un stylo ! Script ou console ??? \u2693\ufe0e Thonny, comme la grande majorit\u00e9 des IDE Python, est compos\u00e9 de deux zones distinctes : la zone de script la console La zone de script est asynchrone . Il ne se passera rien tant que vous n'aurez pas ex\u00e9cut\u00e9 le script (par F5 par exemple). C'est donc l'endroit o\u00f9 on va r\u00e9diger son programme. La console est synchrone : elle r\u00e9pond d\u00e8s que vous appuyez sur la touche Entr\u00e9e. Elle sert donc aux petits tests rapides, ou bien tests post-ex\u00e9cution d'un code. Utilisation classique du couple script / console On \u00e9crit son code dans la zone de script On l'ex\u00e9cute. On interroge la console pour conna\u00eetre l'\u00e9tat des variables, pour utiliser les fonctions construites dans le script. Pour les extraits de code pr\u00e9sents sur ce site : tout le code qui est pr\u00e9c\u00e9d\u00e9 d'une num\u00e9rotation de ligne est \u00e0 \u00e9crire en zone de script. Exemple : \ud83d\udc0d Script Python 1 2 3 def accueil ( n ): for k in range ( n ): print ( \"bonjour\" ) tout le code qui est pr\u00e9c\u00e9d\u00e9 >>> est \u00e0 taper en console. Exemple : \ud83d\udc0d Script Python >>> accueil ( 5 ) Dossiers, fichiers et versionning \u2693\ufe0e Cette ann\u00e9e en NSI nous allons manipuler un certain nombre de fichiers qui sont dans capytale sur l'ENT. Il est possible de les t\u00e9l\u00e9charger sur cl\u00e9 usb, dans ce cas il est important de les nommer et les classer de fa\u00e7on rigoureuse pour les retrouver rapidement et les partager. Conseils Utilisez des dossiers pour classer vos fichiers. Il n'y en a jamais assez. Prenez l'habitude de faire plusieurs sauvegardes de vos documents (sur le r\u00e9seau du lyc\u00e9e, sur l'ENT, sur cl\u00e9 USB). \u00c9vitez dans les noms de fichiers et de dossiers les espaces (utilisez plut\u00f4t _ ) ainsi que les caract\u00e8res accentu\u00e9s et les caract\u00e8res sp\u00e9ciaux. Un nom de fichier doit \u00eatre parlant (un peu comme une variable en fait). On \u00e9vitera de nommer ses codes Python python1.py , python2.py , python3.py , etc. Mais plut\u00f4t NSI_T4_tri_selection.py par exemple pour un exercice de programmation sur le tri par selection au th\u00e8me 4. Lorsqu'on travaille sur un projet ou un programme cons\u00e9quent, il peut \u00eatre utile de conserver des archives du travail \u00e0 plusieurs \u00e9tapes de l'\u00e9laboration, plut\u00f4t que de ne conserver que la derni\u00e8re version. \u00c0 cet effet on pourra num\u00e9roter : NSI_projet_morpion_v1.py , puis NSI_projet_morpion_v2.py , NSI_projet_morpion_v3.py , etc. Usage du clavier \u2693\ufe0e Utiliser le clavier est souvent bien plus pratique et surtout plus rapide qu'utiliser la souris. Encore faut-il apprendre \u00e0 l'apprivoiser... La s\u00e9lection au clavier Outre les touches DEBUT et FIN qui permettent d'atteindre rapidement le d\u00e9but ou la fin d'une ligne, les fl\u00e8ches directionelles servent \u00e9videmment \u00e0 se d\u00e9placer dans du texte. Mais combin\u00e9es: \u00e0 la touche CTRL : elles permettent de se d\u00e9placer de mot en mot; \u00e0 la touche MAJ : elles permettent de s\u00e9lectionner un caract\u00e8re; aux touches MAJ et CTRL : elles permettent de s\u00e9lectionner une mot. De m\u00eame, en se pla\u00e7ant en d\u00e9but d'une ligne et en combinant la touche MAJ et FIN , on s\u00e9lectionne la ligne enti\u00e8re. Les raccourcis clavier Il existe de tr\u00e8s nombreux raccourcis clavier qui permettent d'ex\u00e9cuter des t\u00e2ches courantes sans passer par les menus du logiciel. Certains sont (quasi-)universels, c'est-\u00e0-dire que ce sont les m\u00eames sur tous les logiciels, d'autres sont sp\u00e9cifiques \u00e0 chaque logiciel. Il est important d'en conna\u00eetre quelques-uns pour \u00eatre plus efficace. Les universels IDE Navigateur Web La triplette magique CTRL+X , CTRL+C , CTRL+V pour couper, copier, coller; CTRL+O pour ouvrir un fichier CTRL+N pour cr\u00e9er un nouveau document; CTRL+S pour sauvegarder le document en cours; CTRL+MAJ+S pour sauvegarder en pr\u00e9cisant le nom du fichier; CTRL+Z pour annuler la derni\u00e8re action, CTRL+Y ou CTRL+MAJ+Z pour la r\u00e9tablir; CTRL+W pour fermer un onglet; CTRL+Q ou ALT+F4 pour fermer le logiciel; CTRL+A pour s\u00e9lectionner tout (All). \u00c0 chercher de suite lorsqu'on utilise un nouvel IDE, les raccourcis pour les actions suivantes (entre parenth\u00e8ses ceux de Thonny): ex\u00e9cuter le code ( F5 ) commenter/d\u00e9commenter une ligne ( CTRL+M ) CTRL+T pour ouvrir un nouvel onglet; CTRL+H pour ouvrir l'historique; combiner CTRL + clic pour forcer l'ouverture d'un lien dans un nouvel onglet; combiner MAJ + clic pour forcer l'ouverture d'un lien dans une nouvelle fen\u00eatre; sources site de C\u00e9dric Gouygou","title":"Conseils de travail"},{"location":"divers/conseil/#conseils-de-travail","text":"","title":"Conseils de travail"},{"location":"divers/ep/","text":"\u00c9preuve pratique \ud83d\udcbb \u2693\ufe0e Rappel des conditions de passation sur cette page Pdf de l'int\u00e9gralit\u00e9 des exercices Exercice 01.1 \u25a1 \u2693\ufe0e Exercice 01.1 \u00c9nonc\u00e9 Correction Programmer la fonction recherche , prenant en param\u00e8tre un tableau non vide tab (type list ) d'entiers et un entier n , et qui renvoie l'indice de la derni\u00e8re occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples \ud83d\udc0d Script Python >>> recherche ([ 5 , 3 ], 1 ) 2 >>> recherche ([ 2 , 4 ], 2 ) 0 >>> recherche ([ 2 , 3 , 5 , 2 , 4 ], 2 ) 3 {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( tab , n ): indice_solution = len ( tab ) for i in range ( len ( tab )): if tab [ i ] == n : indice_solution = i return indice_solution \" ) }} Exercice 01.2 \u25a1 \u2693\ufe0e Exercice 01.2 \u00c9nonc\u00e9 Correction On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es \\((x;y)\\) et \\((x';y')\\) est donn\u00e9e par la formule : \\[d=\\sqrt{(x-x')^2+(y-y')^2}\\] On importe pour cela la fonction racine carr\u00e9e ( sqrt ) du module math de Python. On dispose d'une fonction distance et d'une fonction plus_courte_distance : \ud83d\udc0d Script Python from math import sqrt # import de la fonction racine carr\u00e9e def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( ... ) ** 2 + ( ... ) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = ... for i in range ( 1 , ... ): if distance ( tab [ i ], depart ) ... : point = ... min_dist = ... return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" Recopier sous Python (sans les commentaires) ces deux fonctions puis compl\u00e9ter leur code et ajouter une ou des d\u00e9clarations ( assert ) \u00e0 la fonction distance permettant de v\u00e9rifier la ou les pr\u00e9conditions. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from math import sqrt def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( point1 [ 0 ] - point2 [ 0 ]) ** 2 + (( point1 [ 1 ] - point2 [ 1 ])) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = distance ( point , depart ) for i in range ( 1 , len ( tab )): if distance ( tab [ i ], depart ) < min_dist : point = tab [ i ] min_dist = distance ( tab [ i ], depart ) return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" Exercice 02.1 \u25a1 \u2693\ufe0e Exercice 02.1 \u00c9nonc\u00e9 Correction Programmer la fonction moyenne prenant en param\u00e8tre un tableau d'entiers tab (type list ) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide et affiche 'erreur' si le tableau est vide. Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 5 , 3 , 8 ]) 5.333333333333333 >>> moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) 5.5 >>> moyenne ([]) 'erreur' {{ correction(True, \" L'\u00e9nonc\u00e9 n'est pas tr\u00e8s clair quand il dit \u00abd'afficher 'erreur'\u00bb (ce qui suppose un print et non un return ). Nous choississons donc dans ce cas de renvoyer None . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): if tab == []: print ( 'erreur' ) return None else : somme = 0 for elt in tab : somme += elt return somme / len ( tab ) \" ) }} Exercice 02.2 \u25a1 \u2693\ufe0e Exercice 02.2 \u00c9nonc\u00e9 Correction On consid\u00e8re un tableau d'entiers tab (type list dont les \u00e9l\u00e9ments sont des 0 ou des 1 ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri,le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des 0 , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des 1 . Zone de 0 Zone non tri\u00e9e Zone de 1 Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction tri suivante : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = ... j = ... while i != j : if tab [ i ] == 0 : i = ... else : valeur = tab [ j ] tab [ j ] = ... ... j = ... ... Exemple : \ud83d\udc0d Script Python >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = 0 j = len ( tab ) - 1 while i != j : if tab [ i ] == 0 : i = i + 1 else : valeur = tab [ j ] tab [ j ] = tab [ i ] tab [ i ] = valeur j = j - 1 return tab Exercice 03.1 \u25a1 \u2693\ufe0e Exercice 03.1 \u00c9nonc\u00e9 Correction Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. \u00c9nonc\u00e9 peu clair, on ne sait pas si n1 et n2 sont entiers naturels ou relatifs. Nous d\u00e9cidons qu'ils sont relatifs et donc qu'ils peuvent \u00eatre n\u00e9gatifs, auquel cas on utilise le fait que \\(5 \\\\times (-6)= - (5 \\\\times 6)\\) . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat Exercice 03.2 \u25a1 \u2693\ufe0e Exercice 03.2 \u00c9nonc\u00e9 Correction Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False Exercice 04.1 \u25a1 \u2693\ufe0e Exercice 04.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. \ud83d\udc0d Script Python def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne ([ 1 ]) == 1 assert moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] == 4 assert moyenne ([ 1 , 2 ]) == 1.5 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' somme = 0 for elt in tab : somme += elt return somme / len ( tab ) Exercice 04.2 \u25a1 \u2693\ufe0e Exercice 04.2 \u00c9nonc\u00e9 Correction Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide. L'algorithme est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient False en renvoyant False,1 , False,2 et False,3 . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ... : return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ... : return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if tab = []: return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ( x > tab [ - 1 ]): return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False Exercice 05.1 \u25a1 \u2693\ufe0e Exercice 05.1 \u00c9nonc\u00e9 Correction On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau [1, 0, 1, 0, 0, 1, 1] repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est 2**6 + 2**4 + 2**1 + 2**0 = 83 . \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : \ud83d\udc0d Script Python def convertir ( T ): \"\"\" T est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau T \"\"\" Exemple : \ud83d\udc0d Script Python >>> convertir ([ 1 , 0 , 1 , 0 , 0 , 1 , 1 ]) 83 >>> convertir ([ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ]) 130 {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def convertir ( T ): puissance = 0 total = 0 for i in range ( len ( T ) - 1 , - 1 , - 1 ): total += T [ i ] * ( 2 ** puissance ) puissance += 1 return total \" ) }} Exercice 05.2 \u25a1 \u2693\ufe0e Exercice 05.2 \u00c9nonc\u00e9 Correction La fonction tri_insertion suivante prend en argument une liste L et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if ... : return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > ... : i = ... # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , ... ): L [ k ] = L [ ... ] L [ i ] = ... return L Exemples : \ud83d\udc0d Script Python >>> tri_insertion ([ 2 , 5 , - 1 , 7 , 0 , 28 ]) [ - 1 , 0 , 2 , 5 , 7 , 28 ] >>> tri_insertion ([ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ]) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if L == []: return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > e : i = i - 1 # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , - 1 ): L [ k ] = L [ k - 1 ] L [ i ] = e return L \" ) }} Exercice 06.1 \u25a1 \u2693\ufe0e Exercice 06.1 \u00c9nonc\u00e9 Correction On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e rendu dont le param\u00e8tre est un entier positif non nul somme_a_rendre et qui retourne une liste de trois entiers n1 , n2 et n3 qui correspondent aux nombres de billets de 5 euros ( n1 ) de pi\u00e8ces de 2 euros ( n2 ) et de pi\u00e8ces de 1 euro ( n3 ) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 somme_a_rendre . On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : \ud83d\udc0d Script Python >>> rendu ( 13 ) [ 2 , 1 , 1 ] >>> rendu ( 64 ) [ 12 , 2 , 0 ] >>> rendu ( 89 ) [ 17 , 2 , 0 ] {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def rendu ( somme_a_rendre ): pieces = [ 5 , 2 , 1 ] retour = [ 0 , 0 , 0 ] reste_a_rendre = somme_a_rendre for i in range ( 3 ): retour [ i ] = reste_a_rendre // pieces [ i ] reste_a_rendre = reste_a_rendre % pieces [ i ] return retour \" ) }} Exercice 06.2 \u25a1 \u2693\ufe0e \u00e0 noter une erreur dans la version officielle, sur la m\u00e9thode enfile() Exercice 06.2 \u00c9nonc\u00e9 Correction On veut \u00e9crire une classe pour g\u00e9rer une file \u00e0 l\u2019aide d\u2019une liste cha\u00een\u00e9e. On dispose d\u2019une classe Maillon permettant la cr\u00e9ation d\u2019un maillon de la cha\u00eene, celui-ci \u00e9tant constitu\u00e9 d\u2019une valeur et d\u2019une r\u00e9f\u00e9rence au maillon suivant de la cha\u00eene : \ud83d\udc0d Script Python 1 2 3 4 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None Compl\u00e9ter la classe File suivante o\u00f9 l\u2019attribut dernier_file contient le maillon correspondant \u00e0 l\u2019\u00e9l\u00e9ment arriv\u00e9 en dernier dans la file : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( ... ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = ... def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != ... : print ( maillon . valeur ) maillon = ... def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = ... while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = ... maillon . suivant = None return resultat return None On pourra tester le fonctionnement de la classe en utilisant les commandes suivantes dans la console Python : \ud83d\udc0d Script Python >>> F = File () >>> F . est_vide () True >>> F . enfile ( 2 ) >>> F . affiche () 2 >>> F . est_vide () False >>> F . enfile ( 5 ) >>> F . enfile ( 7 ) >>> F . affiche () 7 5 2 >>> F . defile () 2 >>> F . defile () 5 >>> F . affiche () 7 {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( element ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = nouveau_maillon def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != None : print ( maillon . valeur ) maillon = maillon . suivant def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = self . dernier_file while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = maillon . suivant . valeur maillon . suivant = None return resultat return None \" ) }} Exercice 07.1 \u25a1 \u2693\ufe0e Exercice 07.1 \u00c9nonc\u00e9 Correction On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par U1 = 1 , U2 = 1 et, pour tout entier naturel n , par Un+2 = Un+1 + Un . Elle s\u2019appelle la suite de Fibonnaci. \u00c9crire la fonction fibonacci qui prend un entier n > 0 et qui renvoie l\u2019\u00e9l\u00e9ment d\u2019indice n de cette suite. On utilisera une programmation dynamique (pas de r\u00e9cursivit\u00e9). Exemple : \ud83d\udc0d Script Python >>> fibonacci ( 1 ) 1 >>> fibonacci ( 2 ) 1 >>> fibonacci ( 25 ) 75025 >>> fibonacci ( 45 ) 1134903170 {{ correction(True, \" On utilise un dictionnaire pour stocker au fur et \u00e0 mesure les valeurs. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fibonnaci ( n ): d = {} d [ 1 ] = 1 d [ 2 ] = 1 for k in range ( 3 , n + 1 ): d [ k ] = d [ k - 1 ] + d [ k - 2 ] return d [ n ] \" ) }} Exercice 07.2 \u25a1 \u2693\ufe0e Exercice 07.2 \u00c9nonc\u00e9 Correction Les variables liste_eleves et liste_notes ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction meilleures_notes renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction meilleures_notes ci-dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range ( ... ): if liste_notes [ compteur ] == ... : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ ... ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = ... liste_maxi = [ ... ] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Une fois compl\u00e9t\u00e9, le code ci-dessus donne \ud83d\udc0d Script Python >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ]) {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = 0 liste_maxi = [] for compteur in range ( len ( liste_eleves )): if liste_notes [ compteur ] == note_maxi : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ compteur ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = 1 liste_maxi = [ liste_eleves [ compteur ]] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) \" ) }} Exercice 08.1 \u25a1 \u2693\ufe0e Exercice 08.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : \ud83d\udc0d Script Python >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( caractere , mot ): somme = 0 for lettre in mot : if lettre == caractere : somme += 1 return somme \" ) }} Exercice 08.2 \u25a1 \u2693\ufe0e Exercice 08.2 \u00c9nonc\u00e9 Correction On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets - le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste pieces=[100, 50, 20, 10, 5, 2, 1] - (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre), on cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return ... p = pieces [ i ] if p <= ... : solution . append ( ... ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , ... ) On devra obtenir : \ud83d\udc0d Script Python >>> rendu_glouton ( 68 ,[], 0 ) [ 50 , 10 , 5 , 2 , 1 ] >>> rendu_glouton ( 291 ,[], 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return solution p = pieces [ i ] if p <= arendre : solution . append ( p ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , i + 1 ) \" ) }} Exercice 09.1 \u25a1 \u2693\ufe0e Exercice 09.1 \u00c9nonc\u00e9 Correction Soit le couple ( note , coefficient ): note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples ( note , coefficient ). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer le r\u00e9sultat du calcul suivant : \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): somme_notes = 0 somme_coeffs = 0 for devoir in tab : note = devoir [ 0 ] coeff = devoir [ 1 ] somme_notes += note * coeff somme_coeffs += coeff return somme_notes / somme_coeffs \" ) }} Exercice 09.2 \u25a1 \u2693\ufe0e Exercice 09.2 \u00c9nonc\u00e9 Correction On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : Compl\u00e9ter la fonction pascal ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne 1 \u00e0 la ligne n o\u00f9 n est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 2 (le tableau sera contenu dans la variable C ). La variable Ck doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro k , la k -i\u00e8me ligne du tableau. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , ... ): Ck = [ ... ] for i in range ( 1 , k ): Ck . append ( C [ ... ][ i - 1 ] + C [ ... ][ ... ] ) Ck . append ( ... ) C . append ( Ck ) return C Pour n = 4 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , n + 1 ): Ck = [ 1 ] for i in range ( 1 , k ): Ck . append ( C [ k - 1 ][ i - 1 ] + C [ k - 1 ][ i ] ) Ck . append ( 1 ) C . append ( Ck ) return C \" ) }} Exercice 10.1 \u25a1 \u2693\ufe0e Exercice 10.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : \ud83d\udc0d Script Python >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) {{ correction(True, \" \" ) }} Exercice 10.2 \ud83d\uddf9 \u2693\ufe0e Exercice 10.2 \u00c9nonc\u00e9 Correction Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type list ). On rappelle que l\u2019expression T1 = list(T) fait une copie de T ind\u00e9pendante de T , que l\u2019expression x = T.pop() enl\u00e8ve le sommet de la pile T et le place dans la variable x et, enfin, que l\u2019expression T.append(v) place la valeur v au sommet de la pile T . Compl\u00e9ter le code Python de la fonction positif ci-dessous qui prend une pile T de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable T . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = ... ( T ) T3 = ... while T2 != []: x = ... if ... >= 0 : T3 . append ( ... ) T2 = [] while T3 != ... : x = T3 . pop () ... print ( 'T = ' , T ) return T2 Exemple : \ud83d\udc0d Script Python >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) T = [ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ] [ 0 , 5 , 4 , 10 , 9 ] {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = list ( T ) T3 = [] while T2 != []: x = T2 . pop () if x >= 0 : T3 . append ( x ) T2 = [] # <- NB : cette ligne est inutile while T3 != []: x = T3 . pop () T2 . append ( x ) print ( 'T = ' , T ) return T2 \" ) }} Exercice 11.1 \u25a1 \u2693\ufe0e Exercice 11.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction conv_bin qui prend en param\u00e8tre un entier positif n et renvoie un couple ( b,bit) o\u00f9 : b est une liste d'entiers correspondant \u00e0 la repr\u00e9sentation binaire de n ; bit correspond aux nombre de bits qui constituent b . Exemple : \ud83d\udc0d Script Python >>> conv_bin ( 9 ) ([ 1 , 0 , 0 , 1 ], 4 ) Aide : l'op\u00e9rateur // donne le quotient de la division euclidienne : 5//2 donne 2 ; l'op\u00e9rateur % donne le reste de la division euclidienne : 5%2 donne 1 ; append est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit T=[5,2,4] , alors T.append(10) ajoute 10 \u00e0 la liste T . Ainsi, T devient [5,2,4,10] . reverse est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit T=[5,2,4,10] . Apr\u00e8s T.reverse() , la liste devient [10,4,2,5] . On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier n en partant de la gauche en appliquant successivement les instructions : b = n%2 n = n//2 r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire. {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def conv_bin ( n ): b = [] bits = 0 while n != 0 : b . append ( n % 2 ) bits += 1 n = n // 2 b . reverse () return ( b , bits ) \" ) }} Exercice 11.2 \u25a1 \u2693\ufe0e Exercice 11.2 \u00c9nonc\u00e9 Correction La fonction tri_bulles prend en param\u00e8tre une liste T d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def tri_bulles ( T ): n = len ( T ) for i in range ( ... , ... , - 1 ): for j in range ( i ): if T [ j ] > T [ ... ]: ... = T [ j ] T [ j ] = T [ ... ] T [ j + 1 ] = temp return T \u00c9crire une autre version de l\u2019algorithme avec \ud83d\udc0d Script Python for i in range ( n - 1 ): en lieu et place de la troisi\u00e8me ligne du code pr\u00e9c\u00e9dent. {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def tri_bulles ( T ): n = len ( T ) for i in range ( n - 1 , 0 , - 1 ): for j in range ( i ): if T [ j ] > T [ j + 1 ]: temp = T [ j ] T [ j ] = T [ j + 1 ] T [ j + 1 ] = temp return T #version 2 def tri_bulles ( T ): n = len ( T ) for i in range ( n - 1 ): for j in range ( n - 1 , i , - 1 ): if T [ j ] < T [ j - 1 ]: temp = T [ j ] T [ j ] = T [ j - 1 ] T [ j - 1 ] = temp return T \" ) }} Exercice 12.1 \u25a1 \u2693\ufe0e Ce sujet est le m\u00eame que le 10.1... \u00af\\_(\u30c4)_/\u00af Exercice 12.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : \ud83d\udc0d Script Python >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) {{ correction(True, \" \" ) }} Exercice 12.2 \u25a1 \u2693\ufe0e Exercice 12.2 \u00c9nonc\u00e9 Correction La fonction recherche prend en param\u00e8tres deux chaines de caract\u00e8res gene et seq_adn et renvoie True si on retrouve gene dans seq_adn et False sinon. Compl\u00e9ter le code Python ci-dessous pour qu\u2019il impl\u00e9mente la fonction recherche . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = ... trouve = False while i < ... and trouve == ... : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: ... if j == g : trouve = True ... return trouve Exemples : \ud83d\udc0d Script Python >>> recherche ( \"AATC\" , \"GTACAAATCTTGCC\" ) True >>> recherche ( \"AGTC\" , \"GTACAAATCTTGCC\" ) False {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = 0 trouve = False while i < n - g and trouve == False : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: j += 1 if j == g : trouve = True i += 1 return trouve \" ) }} Exercice 13.1 \u25a1 \u2693\ufe0e Exercice 13.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction tri_selection qui prend en param\u00e8tre une liste tab de nombres entiers et qui renvoie le tableau tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : on recherche le plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; on recherche le second plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; on continue de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : \ud83d\udc0d Script Python >>> tri_selection ([ 1 , 52 , 6 , - 9 , 12 ]) [ - 9 , 1 , 6 , 12 , 52 ] {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def tri_selection ( tab ): for i in range ( len ( tab ) - 1 ): indice_min = i for j in range ( i + 1 , len ( tab )): if tab [ j ] < tab [ indice_min ]: indice_min = j tab [ i ], tab [ indice_min ] = tab [ indice_min ], tab [ i ] return tab \" ) }} Exercice 13.2 \u25a1 \u2693\ufe0e Exercice 13.2 \u00c9nonc\u00e9 Correction Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction randint est utilis\u00e9e. Si a et b sont des entiers, randint(a,b) renvoie un nombre entier compris entre a et b . Compl\u00e9ter le code ci-dessous et le tester : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , ... ) nb_test = int ( input ( \"Proposez un nombre entre 1 et 99 : \" )) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test : nb_test = int ( input ( \"Trop petit ! Testez encore : \" )) else : nb_test = int ( input ( \"Trop grand ! Testez encore : \" )) if nb_mystere == nb_test : print ( \"Bravo ! Le nombre \u00e9tait \" , ... ) print ( \"Nombre d'essais: \" , ... ) else : print ( \"Perdu ! Le nombre \u00e9tait \" , ... ) {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , 100 ) nb_test = int ( input ( 'Proposez un nombre entre 1 et 99 : ' )) compteur = 0 while nb_mystere != nb_test and compteur < 10 : compteur = compteur + 1 if nb_mystere > nb_test : nb_test = int ( input ( 'Trop petit ! Testez encore : ' )) else : nb_test = int ( input ( 'Trop grand ! Testez encore : ' )) if nb_mystere == nb_test : print ( 'Bravo ! Le nombre \u00e9tait ' , nb_mystere ) print ( 'Nombre d essais: ' , compteur ) else : print ( 'Perdu ! Le nombre \u00e9tait ' , nb_mystere ) \" ) }} Exercice 14.1 \u25a1 \u2693\ufe0e Exercice 14.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre et tab un tableau de nombres, et qui renvoie le tableau des indices de elt dans tab si elt est dans tab et le tableau vide [] sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ( 3 , [ 3 , 2 , 1 , 3 , 2 , 1 ]) [ 0 , 3 ] >>> recherche ( 4 , [ 1 , 2 , 3 ]) [] {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( elt , tab ): tab_indices = [] for i in range ( len ( tab )): if tab [ i ] == elt : tab_indices . append ( i ) return tab_indices \" ) }} Exercice 14.2 \u25a1 \u2693\ufe0e Exercice 14.2 \u00c9nonc\u00e9 Correction Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : les clefs sont les noms des \u00e9l\u00e8ves ; les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients. Avec : \ud83d\udc0d Script Python resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ces \u00e9l\u00e8ves et lui renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom ): if nom in ... : notes = resultats [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} def moyenne ( nom ): if nom in resultats : notes = resultats [ nom ] total_points = 0 total_coefficients = 0 for valeurs in notes . values (): note , coefficient = valeurs total_points = total_points + note * coefficient total_coefficients = total_coefficients + coefficient return round ( total_points / total_coefficients , 1 ) else : return - 1 \" ) }} Exercice 15.1 \u25a1 \u2693\ufe0e Exercice 15.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction rechercheMinMax qui prend en param\u00e8tre un tableau de nombres non tri\u00e9s tab , et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s \u2018min\u2019 et \u2018max\u2019. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> tableau = [ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : - 2 , 'max' : 9 } >>> tableau = [] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : None , 'max' : None } {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def rechercheMinMax ( tab ): d = {} d [ 'min' ] = None d [ 'max' ] = None for val in tab : if val < d [ 'min' ]: d [ 'min' ] = val if val > d [ 'max' ]: d [ 'max' ] = val return d \" ) }} Exercice 15.2 \u2693\ufe0e Exercice 15.2 \u00c9nonc\u00e9 Correction {{ correction(True, \" \" ) }} Exercice 16.1 \u25a1 \u2693\ufe0e Exercice 16.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 1.0 ]) 1.0 >>> moyenne ([ 1.0 , 2.0 , 4.0 ]) 2.3333333333333335 {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) \" ) }} Exercice 16.2 \u2693\ufe0e Exercice 16.2 \u00c9nonc\u00e9 Correction {{ correction(True, \" \" ) }} Exercice 17.1 \u25a1 \u2693\ufe0e Exercice 17.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction indice_du_min qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 tab , et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> indice_du_min ([ 5 ]) 0 >>> indice_du_min ([ 2 , 4 , 1 ]) 2 >>> indice_du_min ([ 5 , 3 , 2 , 2 , 4 ]) 2 {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 def indice_du_min ( tab ): indice_min = 0 for i in range ( len ( tab )): if tab [ i ] < tab [ indice_min ]: indice_min = i return indice_min \" ) }} Exercice 17.2 \u2693\ufe0e Exercice 17.2 \u00c9nonc\u00e9 Correction {{ correction(True, \" \" ) }} Exercice 18.1 \u25a1 \u2693\ufe0e Exercice 18.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1 \" ) }} Exercice 18.2 \u2693\ufe0e Exercice 18.2 \u00c9nonc\u00e9 Correction {{ correction(True, \" \" ) }} Exercice 19.1 \u25a1 \u2693\ufe0e Exercice 19.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 {{ correction(True, \" \" ) }} Exercice 19.2 \u2693\ufe0e Exercice 19.2 \u00c9nonc\u00e9 Correction {{ correction(True, \" \" ) }} Exercice 20.1 \u25a1 \u2693\ufe0e Exercice 20.1 \u00c9nonc\u00e9 Correction On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : \ud83d\udc0d Script Python t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] \u00c9crire la fonction mini qui prend en param\u00e8tres le tableau releve des relev\u00e9s et le tableau date des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. Exemple : \ud83d\udc0d Script Python >>> mini ( t_moy , annees ) 12.5 , 2016 {{ correction(True, \" \" ) }} Exercice 20.2 \u2693\ufe0e Exercice 20.2 \u00c9nonc\u00e9 Correction {{ correction(True, \" \" ) }} Exercice 21.1 \u25a1 \u2693\ufe0e Exercice 21.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction python appel\u00e9e nb_repetitions qui prend en param\u00e8tres un \u00e9l\u00e9ment elt et une liste tab et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : \ud83d\udc0d Script Python >>> nb_repetitions ( 5 ,[ 2 , 5 , 3 , 5 , 6 , 9 , 5 ]) 3 >>> nb_repetitions ( 'A' ,[ 'B' , 'A' , 'B' , 'A' , 'R' ]) 2 >>> nb_repetitions ( 12 ,[ 1 , '! ' , 7 , 21 , 36 , 44 ]) 0 {{ correction(True, \" \" ) }} Exercice 21.2 \u2693\ufe0e Exercice 21.2 \u00c9nonc\u00e9 Correction {{ correction(True, \" \" ) }} Exercice 22.1 \u25a1 \u2693\ufe0e Exercice 22.1 \u00c9nonc\u00e9 Correction \u00c9crire en langage Python une fonction recherche prenant comme param\u00e8tres une variable a de type num\u00e9rique ( float ou int ) et un tableau t (type list ) et qui renvoie le nombre d'occurrences de a dans t . Exemples : \ud83d\udc0d Script Python >>> recherche ( 5 ,[]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 4 , 8 ]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 1 , 5 , 3 , 7 , 4 ]) 1 >>> recherche ( 5 ,[ - 2 , 5 , 3 , 5 , 4 , 5 ]) 3 {{ correction(True, \" \" ) }} Exercice 22.2 \u2693\ufe0e Exercice 22.2 \u00c9nonc\u00e9 Correction {{ correction(True, \" \" ) }} Exercice 23.1 \u25a1 \u2693\ufe0e Exercice 23.1 \u00c9nonc\u00e9 Correction L\u2019occurrence d\u2019un caract\u00e8re dans un phrase est le nombre de fois o\u00f9 ce caract\u00e8re est pr\u00e9sent. Exemples : l\u2019occurrence du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; l\u2019occurrence du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : {'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1} \u00c9crire une fonction occurence_lettres prenant comme param\u00e8tre une variable phrase de type str . Cette fonction doit renvoyer un dictionnaire de type constitu\u00e9 des occurrences des caract\u00e8res pr\u00e9sents dans la phrase. {{ correction(True, \" \" ) }} Exercice 23.2 \u2693\ufe0e Exercice 23.2 \u00c9nonc\u00e9 Correction {{ correction(True, \" \" ) }} Exercice 24.1 \u25a1 \u2693\ufe0e identique au 18.1 Exercice 24.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 {{ correction(True, \" \" ) }} Exercice 24.2 \u2693\ufe0e Exercice 24.2 \u00c9nonc\u00e9 Correction {{ correction(True, \" \" ) }} Exercice 25.1 \u25a1 \u2693\ufe0e Exercice 25.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tre un tableau de nombres entiers tab , et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : \ud83d\udc0d Script Python >>> recherche ([ 1 , 4 , 3 , 5 ]) [] >>> recherche ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> recherche ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> recherche ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] {{ correction(True, \" \" ) }} Exercice 25.2 \u2693\ufe0e Exercice 25.2 \u00c9nonc\u00e9 Correction {{ correction(True, \" \" ) }} Exercice 26.1 \u25a1 \u2693\ufe0e Exercice 26.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction occurrence_max prenant en param\u00e8tres une cha\u00eene de caract\u00e8res chaine et qui renvoie le caract\u00e8re le plus fr\u00e9quent de la cha\u00eene. La chaine ne contient que des lettres en minuscules sans accent. On pourra s\u2019aider du tableau alphabet=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o,','p','q','r','s','t','u','v','w','x','y','z'] et du tableau occurrence de 26 \u00e9l\u00e9ments o\u00f9 l\u2019on mettra dans occurrence[i] le nombre d\u2019apparitions de alphabet[i] dans la chaine. Puis on calculera l\u2019indice k d\u2019un maximum du tableau occurrence et on affichera alphabet[k] . Exemple : \ud83d\udc0d Script Python >>> ch = 'je suis en terminale et je passe le bac et je souhaite poursuivre des etudes pour devenir expert en informatique\u2019 >>> occurrence_max ( ch ) \u2018 e \u2019 {{ correction(True, \" \" ) }} Exercice 26.2 \u2693\ufe0e Exercice 26.2 \u00c9nonc\u00e9 Correction {{ correction(True, \" \" ) }} Exercice 27.1 \u25a1 \u2693\ufe0e Exercice 27.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction moyenne prenant en param\u00e8tres une liste d\u2019entiers et qui renvoie la moyenne des valeurs de cette liste. Exemple : \ud83d\udc0d Script Python >>> moyenne ([ 10 , 20 , 30 , 40 , 60 , 110 ]) 45.0 {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) \" ) }} Exercice 27.2 \u2693\ufe0e Exercice 27.2 \u00c9nonc\u00e9 Correction {{ correction(True, \" \" ) }} Exercice 28.1 \u25a1 \u2693\ufe0e Exercice 28.1 \u00c9nonc\u00e9 Correction Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre est stock\u00e9 dans \ud83d\udc0d Script Python a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], \\ 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], \\ 'H' :[ '' , '' ]} \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tres un arbre binaire arbre sous la forme d\u2019un dictionnaire et un caract\u00e8re lettre qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153ud. On pourra distinguer les 4 cas o\u00f9 les deux \u00ab fils \u00bb du n\u0153ud sont '' , le fils gauche seulement est '' , le fils droit seulement est '' , aucun des deux fils n\u2019est '' . Exemple : \ud83d\udc0d Script Python >>> taille ( a , \u2019 F \u2019 ) 9 {{ correction(True, \" \" ) }} Exercice 28.2 \u2693\ufe0e Exercice 28.2 \u00c9nonc\u00e9 Correction {{ correction(True, \" \" ) }} Exercice 29.1 \u25a1 \u2693\ufe0e Exercice 29.1 \u00c9nonc\u00e9 Correction Soit un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 1 : s'il est pair, on le divise par 2 ; s\u2019il est impair, on le multiplie par 3 et on ajoute 1. Puis on recommence ces \u00e9tapes avec le nombre entier obtenu, jusqu\u2019\u00e0 ce que l\u2019on obtienne la valeur 1. On d\u00e9finit ainsi la suite \\((U_n)\\) par : \\(U_0=k\\) , o\u00f9 \\(k\\) est un entier choisi initialement; \\(U_{n+1} = \\dfrac{U_n}{2}\\) si \\(U_n\\) est pair; \\(U_{n+1} = 3 \\times U_n + 1\\) si \\(U_n\\) est impair. On admet que, quel que soit l'entier k choisi au d\u00e9part, la suite finit toujours sur la valeur 1. \u00c9crire une fonction calcul prenant en param\u00e8tres un entier n strictement positif et qui renvoie la liste des valeurs de la suite, en partant de n et jusqu'\u00e0 atteindre 1. Exemple : \ud83d\udc0d Script Python >>> calcul ( 7 ) [ 7 , 22 , 11 , 34 , 17 , 52 , 26 , 13 , 40 , 20 , 10 , 5 , 16 , 8 , 4 , 2 , 1 ] {{ correction(True, \" \" ) }} Exercice 29.2 \u2693\ufe0e Exercice 29.2 \u00c9nonc\u00e9 Correction {{ correction(True, \" \" ) }} Exercice 30.1 \u25a1 \u2693\ufe0e Exercice 30.1 \u00c9nonc\u00e9 Correction Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : \ud83d\udc0d Script Python >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 {{ correction(True, \" \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat \" ) }} Exercice 30.2 \u2693\ufe0e Exercice 30.2 \u00c9nonc\u00e9 Correction {{ correction(True, \" \" ) }}","title":"\u00c9preuve pratique \ud83d\udcbb"},{"location":"divers/ep/#epreuve-pratique","text":"Rappel des conditions de passation sur cette page Pdf de l'int\u00e9gralit\u00e9 des exercices","title":"\u00c9preuve pratique \ud83d\udcbb"},{"location":"diviserregner/TD20_Diviser_pour_Regner/","text":"Th\u00e8me 5 : Algorithmique 20 TD : Diviser pour r\u00e9gner I. Le principe \u2693\ufe0e Diviser pour r\u00e9gner La strat\u00e9gie \u00ab diviser pour r\u00e9gner \u00bb consiste \u00e0 Diviser : D\u00e9composer un probl\u00e8me en un ou plusieurs sous-probl\u00e8mes de m\u00eame nature mais plus petits. R\u00e9gner : R\u00e9soudre les sous-probl\u00e8mes, g\u00e9n\u00e9ralement de mani\u00e8re r\u00e9cursive, jusqu'\u00e0 ce qu'on arrive aux cas d'arr\u00eat : des sous-probl\u00e8mes que l'on sait r\u00e9soudre imm\u00e9diatement. Combiner : Construire la solution au probl\u00e8me initial \u00e0 partir des solutions des sous-probl\u00e8mes. II. Diviser pour r\u00e9gner : Palindromes \u2693\ufe0e Palindromes Une cha\u00eene est un palindrome si elle peut se lire de la m\u00eame mani\u00e8re dans les deux sens, de gauche \u00e0 droite et de droite \u00e0 gauche. Par exemple : \"ressasser, \"radar\", \"12321\" sont des palindromes ; \"nsi\", \"toto\" n\u2019en sont pas. On se propose d\u2019\u00e9crire une fonction r\u00e9cursive est_palindrome(ch) qui renvoie Vrai si la chaine ch pass\u00e9e en argument est un palindrome et Faux sinon. Partie A \u2693\ufe0e Une premi\u00e8re version utilisant le slicing On consid\u00e8re la cha\u00eene suivante. \ud83d\udc0d Script Python ch = \"ressasser\" Question 1. Quels slices permettent d\u2019acc\u00e9der : au premier caract\u00e8re de ch ? au dernier caract\u00e8re de ch ? \u00e0 une cha\u00eene priv\u00e9e du premier et du dernier caract\u00e8res de ch. Question 2. En utilisant les slices, compl\u00e9tez la fonction suivante. \ud83d\udc0d Script Python def est_palindrome ( ch ): if len ( ch ) <= 1 : return ... else : return ... Question 3. Au moyen du mot cl\u00e9 assert, \u00e9crivez un bon jeu de tests pour cette fonction. V\u00e9rifiez que les tests passent avec succ\u00e8s. Question 4. Expliquez pourquoi cet algorithme est un exemple de la m\u00e9thode diviser pour r\u00e9gner. Question 5. Utiliser Python tutor, ex\u00e9cutez en mode pas \u00e0 pas le d\u00e9roulement des appels r\u00e9cursifs de cette fonction pour la cha\u00eene \"ressasser\". Si la cha\u00eene de d\u00e9part est un palindrome de longueur n, combien de comparaisons sont effectu\u00e9es ? En d\u00e9duite le co\u00fbt en temps de cet algorithme (sa complexit\u00e9) dans le pire des cas. Question 6. Le slicing a un co\u00fbt en m\u00e9moire cach\u00e9. En effet, chaque appel ch[1:-1] induit la cr\u00e9ation d\u2019une nouvelle cha\u00eene qu\u2019il faut stocker en m\u00e9moire. On peut le voir facilement avec Python tutor. Dans le pire cas, pour une cha\u00eene de longueur n au d\u00e9part, combien de cha\u00eenes doivent \u00eatre cr\u00e9\u00e9es pour r\u00e9pondre au probl\u00e8me ? Partie B \u2693\ufe0e Une deuxi\u00e8me version am\u00e9lior\u00e9e \u2693\ufe0e En r\u00e9alit\u00e9, on peut se passer de la cr\u00e9ation de toutes ces cha\u00eenes interm\u00e9diaires en utilisant et en faisant varier (comme pour la recherche dichotomique) les indices g (pour gauche) et d (pour droite) des caract\u00e8res restants. Voici une fonction palindrome(ch, g, d) qui renvoie True si la chaine ch[g..d] (c\u2019est-\u00e0-dire la cha\u00eene ch limit\u00e9e \u00e0 ses caract\u00e8res entre les positions g et d) est un palindrome et False sinon. \ud83d\udc0d Script Python def palindrome ( ch , g , d ): if d - g < 1 : return True else : return ch [ g ] == ch [ d ] and palindrome ( ch , g + 1 , d - 1 ) Question 7. Quel appel \u00e0 cette fonction faut-il faire pour tester si mot est un palindrome ? \ud83d\udc0d Script Python mot = \"ressasser\" # \u00e0 compl\u00e9ter par le bon appel : Pour \u00e9viter cette \u00e9criture un peu lourde, il suffit de cr\u00e9er une autre fonction est_palindrome2(ch) qui est charg\u00e9e de lancer le premier appel \u00e0 la fonction r\u00e9cursive palindrome. Compl\u00e9tez le code de la fonction est_palindrome2(ch) . Question 8. \ud83d\udc0d Script Python def est_palindrome2 ( ch ): # \u00e0 compl\u00e9ter pass La fonction est_palindrome2 est appel\u00e9e une fonction d\u2019interface qui permet d\u2019ajouter des arguments \u00e0 une fonction sans que l\u2019utilisateur ait \u00e0 s\u2019en pr\u00e9occuper. Question 9. V\u00e9rifiez avec Python tutor qu\u2019avec cette version, il n\u2019y a qu\u2019une cha\u00eene ch \u00e0 m\u00e9moriser (celle de d\u00e9part). On obtient un algorithme avec un co\u00fbt m\u00e9moire inf\u00e9rieur \u00e0 la premi\u00e8re version. III. Les tris : tri par s\u00e9lection et tri par insertion - Tri fusion \u2693\ufe0e Tri par s\u00e9lection \u2693\ufe0e Tri par s\u00e9lection Voici l\u2019algorithme du tri par s\u00e9lection \u00e9crit en fran\u00e7ais : Rechercher le plus petit \u00e9l\u00e9ment du tableau, et l\u2019\u00e9changer avec l\u2019\u00e9l\u00e9ment d\u2019indice 0 ; Rechercher le second plus petit \u00e9l\u00e9ment du tableau, et l\u2019\u00e9changer avec l\u2019\u00e9l\u00e9ment d\u2019indice 1 ; Continuer de cette fa\u00e7on jusqu\u2019\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9 Le tri par s\u00e9lection parcourt ainsi le tableau de la gauche vers la droite, en maintenant sur la gauche une partie d\u00e9j\u00e0 tri\u00e9e et \u00e0 sa place d\u00e9finitive. Animation explicative du tri par s\u00e9lection Exercice Question 1 Appliquez l\u2019algorithme de tri par s\u00e9lection sur le tableau suivant. Vous \u00e9crirez l\u2019\u00e9tat du tableau \u00e0 l\u2019issue de chaque it\u00e9ration. T = [8, 3, 11, 7, 9, 2] Question 2. D\u00e9terminer la complexit\u00e9 de cette algorithme : Combien de comparaisons sont n\u00e9cessaires pour trier par s\u00e9lection un tableau de taille n dans le pire des cas ? Exercice Question 1. \u00c9crivez une fonction echange(T, i, j) qui \u00e9change les \u00e9l\u00e9ments d\u2019indices T[i] et T[j] dans le tableau T . Question 2. \u00c9crivez une fonction tri_par_selection(T) , utilisant la fonction echange , qui trie par s\u00e9lection le tableau T dans l\u2019ordre croissant. Tri par insertion (rappels) \u2693\ufe0e Tri par insertion Voici l\u2019algorithme du tri par insertion \u00e9crit en fran\u00e7ais : Prendre le deuxi\u00e8me \u00e9l\u00e9ment du tableau et l\u2019ins\u00e9rer \u00e0 sa place parmi les \u00e9l\u00e9ments qui le pr\u00e9c\u00e8de Prendre le troisi\u00e8me \u00e9l\u00e9ment du tableau et l\u2019ins\u00e9rer \u00e0 sa place parmi les \u00e9l\u00e9ments qui le pr\u00e9c\u00e8de Continuer de cette fa\u00e7on jusqu\u2019\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Le tri par s\u00e9lection parcourt donc \u00e9galement le tableau de la gauche vers la droite, en maintenant une partie d\u00e9j\u00e0 tri\u00e9e sur la gauche. Au lieu de chercher la plus petite valeur dans la partie de droite, le tri par insertion va ins\u00e9rer la premi\u00e8re valeur non encore tri\u00e9e au bon endroit dans la partie de gauche d\u00e9j\u00e0 tri\u00e9e. Exercice : Question 1. Appliquez l\u2019algorithme de tri par insertion sur le tableau suivant. Vous \u00e9crirez l\u2019\u00e9tat du tableau \u00e0 l\u2019issue de chaque it\u00e9ration. T = [8, 3, 11, 7, 9, 2] Question 2. Combien de comparaisons et d\u2019\u00e9changes sont n\u00e9cessaires pour trier par insertion un tableau de taille n dans le pire des cas ? Exercice : \u00c9crivez une fonction tri_par_insertion(T) qui trie par insertion le tableau T dans l\u2019ordre croissant. Tri fusion \u2693\ufe0e Principe \u2693\ufe0e Voici un deuxi\u00e8me exemple d'application de cette strat\u00e9gie : le tri fusion . On doit cet algorithme \u00e0 John Von Neumann . On dispose d'une liste d'entiers que l'on veut trier dans l'ordre croissant. On scinde cette liste en deux listes de longueurs \u00ab \u00e0 peu pr\u00e8s \u00e9gales \u00bb. On trie ces listes en utilisant... le tri fusion. (on tri donc le mani\u00e8re r\u00e9cursive) On fusionne les deux listes tri\u00e9es par ordre croissant pour ne plus en obtenir qu'une. Un exemple Une chor\u00e9graphie du tri fusion Code correspondant \u2693\ufe0e Voici comment coder le tri fusion : On a tout d'abord besoin d'une fonction scinde qui renvoie la premi\u00e8re moiti\u00e9 et la deuxi\u00e8me moiti\u00e9 de la liste qu'on lui passe en argument. \ud83d\udc0d Script Python def scinde ( L ): \"\"\"prend une liste L et renvoie un couple de deux listes de taille identique (\u00e0 l'unit\u00e9 pr\u00e8s) de sorte que leur r\u00e9union soit la liste L de d\u00e9part \"\"\" lg = len ( L ) if lg < 2 : return L , [] else : p = lg // 2 q = lg - p L1 , L2 = [ 0 ] * q , [ 0 ] * p for i in range ( lg ): if i < q : L1 [ i ] = L [ i ] else : L2 [ i - q ] = L [ i ] return L1 , L2 Version aevc slice \ud83d\udc0d Script Python def scinde ( lst : list ) -> tuple : return lst [: len ( lst ) // 2 ], lst [ len ( lst ) // 2 :] Ensuite, on a besoin d'une fonction fusion qui, \u00e9tant donn\u00e9e deux listes tri\u00e9es, les fusionne. \ud83d\udc0d Script Python def fusion ( L1 , L2 ): '''r\u00e9alise la fusion de deux listes tri\u00e9es, le r\u00e9sultat est une liste tri\u00e9e''' n1 , n2 = len ( L1 ), len ( L2 ) n = n1 + n2 L = [ 0 ] * n i , i1 , i2 = 0 , 0 , 0 while i1 < n1 and i2 < n2 : if L1 [ i1 ] < L2 [ i2 ]: L [ i ] = L1 [ i1 ] i1 += 1 else : L [ i ] = L2 [ i2 ] i2 += 1 i += 1 # ici on a vid\u00e9 l'une ou l'autre des deux listes # s'il faut encore vider L1 while i1 < n1 : L [ i ] = L1 [ i1 ] i1 += 1 i += 1 # s'il faut encore vider L2 while i2 < n2 : L [ i ] = L2 [ i2 ] i2 += 1 i += 1 return L Enfin, la fonction tri_fusion . \ud83d\udc0d Script Python def tri_fusion ( L ): if len ( L ) < 2 : return L else : L1 , L2 = scinde ( L ) return fusion ( tri_fusion ( L1 ), tri_fusion ( L2 )) Complexit\u00e9 du tri fusion \u2693\ufe0e \u27a1 La partie \u201cdiviser\u201d est de complexit\u00e9 constante. Pour pouvoir majorer le nombre maximum d\u2019it\u00e9rations, si le tableau contient P valeurs, et si on a un entier \\(n\\) tel que \\(P \\leq 2^n\\) , alors puisque qu\u2019\u00e0 chaque it\u00e9ration, on s\u00e9lectionne une moiti\u00e9 de ce qui reste : au bout d\u2019une it\u00e9ration, une moiti\u00e9 de tableau aura au plus \\(\\dfrac{2^n}{2} = 2^{n\u22121}\\) \u00e9l\u00e9ments, un quart aura au plus \\(2^{n\u22122}\\) et au bout de \\(k\\) it\u00e9rations, la taille de ce qui reste \u00e0 \u00e9tudier est de taille au plus \\(2^{n\u2212k}\\) . En particulier, si l\u2019on fait \\(n\\) it\u00e9rations, il reste au plus \\(2^{n\u2212n} = 1\\) valeur du tableau \u00e0 examiner. On est s\u00fbr de s\u2019arr\u00eater cette fois-ci On a donc montr\u00e9 que si l\u2019entier \\(n\\) v\u00e9rifie \\(P \\leq 2^n\\) , alors l\u2019algorithme va effectuer au plus \\(n\\) it\u00e9rations. La plus petite valeur est obtenue pour \\(n = log_2 P\\) . Ainsi, la complexit\u00e9 de la fonction est de l\u2019ordre du logarithme de la longueur de la liste ( \\(O(log_2(n))\\) ). \\(log_2(n)\\) . Exemple Pour un tableau de taille n = 64 il faut : 64/2=32,32/2=16,16/2=8,8/2=4,4/2=2,2/2=1 : 6 \u00e9tapes. \\(2^6=64\\) . Comme toujours quand on peut s\u00e9parer le tableau en deux, la m\u00e9thode diviser pour r\u00e9gner permet de ne r\u00e9aliser que \\(log_2 n\\) \u00e9tapes. Mais\u2026 \u27a1 Complexit\u00e9 fusion La partie fusion utilise une boucle qui parcourt plusieurs tableaux en m\u00eame temps. On r\u00e9alise \u00e0 chaque \u00e9tape la m\u00eame chose : lire deux valeurs, comparer, ranger la plus petite. La complexit\u00e9 est lin\u00e9aire. Notons \\(n\\) la taille de la liste \u00e0 trier et consid\u00e9rons comme seule op\u00e9ration \u00e9l\u00e9mentaire le fait d'acc\u00e9der \u00e0 un \u00e9l\u00e9ment d'une liste. Complexit\u00e9 du tri fusion Le nombre d'op\u00e9rations \u00e9l\u00e9mentaires n\u00e9cessaires pour trier une liste de taille \\(n\\) par la m\u00e9thode du tri fusion est de l'ordre de \\(n\\times\\log_2 n\\) . IV. Application : Exercices de l'Epreuve Pratique \u2693\ufe0e Sujet 23 - Exercice 2 La fonction fusion prend deux listes L1, L2 d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e L12 qu\u2019elle renvoie. Le code Python de la fonction est \ud83d\udc0d Script Python def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = ... i1 = ... else : L12 [ i ] = L2 [ i2 ] i2 = ... i += 1 while i1 < n1 : L12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : L12 [ i ] = ... i2 = i2 + 1 i = ... return L12 Compl\u00e9ter le code. Exemple : \ud83d\udc0d Script Python >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] Recherche dichotomique \u2693\ufe0e EX : Recherche dichotomique Enonc\u00e9 Solution Expliquer pourquoi la recherche dichotomique d'un \u00e9l\u00e9ment dans une liste d'entiers tri\u00e9s dans l'ordre croissant peut \u00eatre vue comme un exemple de strat\u00e9gie \u00ab diviser pour r\u00e9gner \u00bb. Programmer la recherche dichotomique de mani\u00e8re r\u00e9cursive. Pour savoir si un \u00e9l\u00e9ment appartient \u00e0 la liste, on regarde celui qui est \u00ab\u00e0 peu pr\u00e8s au milieu\u00bb. Si c'est le bon c'est termin\u00e9, sinon on fait de m\u00eame avec la sous-liste des \u00e9l\u00e9ments pr\u00e9c\u00e9dents et avec celle des \u00e9l\u00e9ments suivants. \ud83d\udc0d Script Python def rech_dicho ( lst , elt ): n = len ( lst ) if n < 2 : return elt in lst elif lst [ n // 2 ] == elt : return True else : return rech_dicho ( lst [: n // 2 ], elt ) if lst [ n // 2 ] > elt else rech_dicho ( lst [ n // 2 + 1 :], elt ) V. Exercices BAC Sujet n\u00b01 : France 2021 Cet exercice porte sur l\u2019algorithme de tri fusion, qui s\u2019appuie sur la m\u00e9thode dite de \u00ab diviser pour r\u00e9gner \u00bb. Question 1 a. Quel est l\u2019ordre de grandeur du co\u00fbt, en nombre de comparaisons, de l\u2019algorithme de tri fusion pour une liste de longueur ? b. Citer le nom d\u2019un autre algorithme de tri. Donner l\u2019ordre de grandeur de son co\u00fbt, en nombre de comparaisons, pour une liste de longueur . Comparer ce co\u00fbt \u00e0 celui du tri fusion. Aucune justification n\u2019est attendue. L\u2019algorithme de tri fusion utilise deux fonctions moitie_gauche et moitie_droite qui prennent en argument une liste L et renvoient respectivement : la sous-liste de L form\u00e9e des \u00e9l\u00e9ments d\u2019indice strictement inf\u00e9rieur \u00e0 len(L)//2 ; la sous-liste de L form\u00e9e des \u00e9l\u00e9ments d\u2019indice sup\u00e9rieur ou \u00e9gal \u00e0 len(L)//2 . On rappelle que la syntaxe a//b d\u00e9signe la division enti\u00e8re de a par b. Par exemple, \ud83d\udc0d Script Python >>> L = [ 3 , 5 , 2 , 7 , 1 , 9 , 0 ] >>> moitie_gauche ( L ) [ 3 , 5 , 2 ] >>> moitie_droite ( L ) [ 7 , 1 , 9 , 0 ] >>> M = [ 4 , 1 , 11 , 7 ] >>> moitie_gauche ( M ) [ 4 , 1 ] >>> moitie_droite ( M ) [ 11 , 7 ] L\u2019algorithme utilise aussi une fonction fusion qui prend en argument deux listes tri\u00e9es L1 et L2 et renvoie une liste L tri\u00e9e et compos\u00e9e des \u00e9l\u00e9ments de L1 et L2. On donne ci-dessous le code python d\u2019une fonction r\u00e9cursive tri_fusion qui prend en argument une liste L et renvoie une nouvelle liste tri\u00e9e form\u00e9e des \u00e9l\u00e9ments de L. \ud83d\udc0d Script Python def tri_fusion ( L ): n = len ( L ) if n <= 1 : return L print ( L ) mg = moitie_gauche ( L ) md = moitie_droite ( L ) L1 = tri_fusion ( mg ) L2 = tri_fusion ( md ) return fusion ( L1 , L2 ) Question 2 Donner la liste des affichages produits par l\u2019appel suivant. \ud83d\udc0d Script Python tri_fusion ([ 7 , 4 , 2 , 1 , 8 , 5 , 6 , 3 ]) On s\u2019int\u00e9resse d\u00e9sormais \u00e0 diff\u00e9rentes fonctions appel\u00e9es par tri_fusion , \u00e0 savoir moitie_droite et fusion. Question 3 \u00c9crire la fonction moitie_droite . Question 4 On donne ci-dessous une version incompl\u00e8te de la fonction fusion. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def fusion ( L1 , L2 ): L = [] n1 = len ( L1 ) n2 = len ( L2 ) i1 = 0 i2 = 0 while i1 < n1 or i2 < n2 : if i1 >= n1 : L . append ( L2 [ i2 ]) i2 = i2 + 1 elif i2 >= n2 : L . append ( L1 [ i1 ]) i1 = i1 + 1 else : e1 = L1 [ i1 ] e2 = L2 [ i2 ] return L Dans cette fonction, les entiers i1 et i2 repr\u00e9sentent respectivement les indices des \u00e9l\u00e9ments des listes L1 et L2 que l\u2019on souhaite comparer : Si aucun des deux indices n\u2019est valide, la boucle while est interrompue ; Si i1 n\u2019est plus un indice valide, on va ajouter \u00e0 L les \u00e9l\u00e9ments de L2 \u00e0 partir de l\u2019indice i2 ; Si i2 n\u2019est plus un indice valide, on va ajouter \u00e0 L les \u00e9l\u00e9ments de L1 \u00e0 partir de l\u2019indice i1 ; Sinon, le plus petit \u00e9l\u00e9ment non encore trait\u00e9 est ajout\u00e9 \u00e0 L et on d\u00e9cale l\u2019indice correspondant. \u00c9crire sur la copie les instructions manquantes des lignes 17 \u00e0 22 permettant d\u2019ins\u00e9rer dans la liste L les \u00e9l\u00e9ments des listes L1 et L2 par ordre croissant. Sujet n\u00b02 : BAC Polyn\u00e9sie 2021 Cet exercice traite principalement du th\u00e8me \u00ab algorithmique, langages et programmation \u00bb. Le but est de comparer le tri par insertion (l'un des algorithmes \u00e9tudi\u00e9s en 1\u00e8re NSI pour trier un tableau) avec le tri fusion (un algorithme qui applique le principe de \u00ab diviser pour r\u00e9gner \u00bb). Partie A : Manipulation d\u2019une liste en Python \u2693\ufe0e !! fabquestion \"Question A.1\" Donner les affichages obtenus apr\u00e8s l\u2019ex\u00e9cution du code Python suivant. \ud83d\udc0d Script Python notes = [ 8 , 7 , 18 , 14 , 12 , 9 , 17 , 3 ] notes [ 3 ] = 16 print ( len ( notes )) print ( notes ) `!!! fabquestion \"Question A.2\" \u00c9crire un code Python permettant d'afficher les \u00e9l\u00e9ments d'indice 2 \u00e0 4 de la liste notes. Partie B : Tri par insertion \u2693\ufe0e Le tri par insertion est un algorithme efficace qui s'inspire de la fa\u00e7on dont on peut trier une poign\u00e9e de cartes. On commence avec une seule carte dans la main gauche (les autres cartes sont en tas sur la table) puis on pioche la carte suivante et on l'ins\u00e8re au bon endroit dans la main gauche. Question B.1 Voici une impl\u00e9mentation en Python de cet algorithme. Recopier et compl\u00e9ter les lignes 6 et 7 surlign\u00e9es (uniquement celles-ci). \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def tri_insertion ( liste ): \"\"\" trie par insertion la liste en param\u00e8tre \"\"\" for indice_courant in range ( 1 , len ( liste )): element_a_inserer = liste [ indice_courant ] i = indice_courant - 1 while i >= 0 and liste [ i ] > ................................ : liste [ ........... ] = liste [ ........... ] i = i - 1 liste [ i + 1 ] = element_a_inserer On a \u00e9crit dans la console les instructions suivantes : \ud83d\udc0d Script Python notes = [ 8 , 7 , 18 , 14 , 12 , 9 , 17 , 3 ] tri_insertion ( notes ) print ( notes ) On a obtenu l'affichage suivant : \ud83d\udc0d Script Python [ 3 , 7 , 8 , 9 , 12 , 14 , 17 , 18 ] On s'interroge sur ce qui s\u2019est pass\u00e9 lors de l\u2019ex\u00e9cution de tri_insertion(notes) . Question B.2 Donner le contenu de la liste notes apr\u00e8s le premier passage dans la boucle for. Question B.3 Donner le contenu de la liste notes apr\u00e8s le troisi\u00e8me passage dans la boucle for. Partie C : Tri fusion \u2693\ufe0e L'algorithme de tri fusion suit le principe de \u00ab diviser pour r\u00e9gner \u00bb. (1) Si le tableau \u00e0 trier n\u2019a qu\u2019un \u00e9l\u00e9ment, il est d\u00e9j\u00e0 tri\u00e9. (2) Sinon, s\u00e9parer le tableau en deux parties \u00e0 peu pr\u00e8s \u00e9gales. (3) Trier les deux parties avec l\u2019algorithme de tri fusion. (4) Fusionner les deux tableaux tri\u00e9s en un seul tableau. source : Wikipedia Question C.1 Cet algorithme est-il it\u00e9ratif ou r\u00e9cursif ? Justifier en une phrase. Question C.2\" Expliquer en trois lignes comment faire pour rassembler dans une main deux tas d\u00e9j\u00e0 tri\u00e9s de cartes, la carte en haut d'un tas \u00e9tant la plus petite de ce m\u00eame tas ; la deuxi\u00e8me carte d'un tas n'\u00e9tant visible qu'apr\u00e8s avoir retir\u00e9 la premi\u00e8re carte de ce tas. \u00c0 la fin du proc\u00e9d\u00e9, les cartes en main doivent \u00eatre tri\u00e9es par ordre croissant. Une fonction fusionner a \u00e9t\u00e9 impl\u00e9ment\u00e9e en Python en s'inspirant du proc\u00e9d\u00e9 de la question pr\u00e9c\u00e9dente. Elle prend quatre arguments : la liste qui est en train d'\u00eatre tri\u00e9e, l'indice o\u00f9 commence la sous-liste de gauche \u00e0 fusionner, l'indice o\u00f9 termine cette sousliste, et l'indice o\u00f9 se termine la sous-liste de droite. Question C.3 Voici une impl\u00e9mentation de l\u2019algorithme de tri fusion. Recopier et compl\u00e9ter les lignes 8, 9 et 10 surlign\u00e9es (uniquement celles-ci). \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 from math import floor def tri_fusion ( liste , i_debut , i_fin ): \"\"\" trie par fusion la liste en param\u00e8tre depuis i_debut jusqu\u2019\u00e0 i_fin \"\"\" if i_debut < i_fin : i_partage = floor (( i_debut + i_fin ) / 2 ) tri_fusion ( liste , i_debut , .............................. ) tri_fusion ( liste , ................................... , i_fin ) fusionner ( liste , ......................... , ......................... , ...................... ) Remarque : la fonction floor renvoie la partie enti\u00e8re du nombre pass\u00e9 en param\u00e8tre. Question C.4 Expliquer le r\u00f4le de la premi\u00e8re ligne du code de la question 3. Partie D : Comparaison du tri par insertion et du tri fusion \u2693\ufe0e Voici une illustration des \u00e9tapes d\u2019un tri effectu\u00e9 sur la liste [3, 41, 52, 26, 38, 57, 9, 49] . [:.center}] Question D.1 Quel algorithme a \u00e9t\u00e9 utilis\u00e9 : le tri par insertion ou le tri fusion ? Justifier. Question D.2 Identifier le tri qui a une complexit\u00e9, dans le pire des cas, en \\(O(n^2)\\) et identifier le tri qui a une complexit\u00e9, dans le pire des cas, en \\(O(n log2 n)\\) . Remarque : \\(n\\) repr\u00e9sente la longueur de la liste \u00e0 trier. Question D.3 Justifier bri\u00e8vement ces deux complexit\u00e9s. Sujet n\u00b03 : FRANCE CANDIDAT LIBRE SUJET 1 Cet exercice traite de manipulation de tableaux, de r\u00e9cursivit\u00e9 et du paradigme \u00ab diviser pour r\u00e9gner \u00bb. Dans un tableau Python d'entiers tab, on dit que le couple d\u2019indices (\u0745,\u0746) forme une inversion lorsque \u0745 < \u0746 et tab[i] > tab[j] . On donne ci-dessous quelques exemples. Dans le tableau [1, 5, 3, 7], le couple d\u2019indices (1,2) forme une inversion car 5> 3. Par contre, le couple (1,3) ne forme pas d'inversion car 5<7. Il n\u2019y a qu\u2019une inversion dans ce tableau. Il y a trois inversions dans le tableau [1, 6, 2, 7, 3], \u00e0 savoir les couples d'indices (1, 2), (1, 4) et (3, 4). On peut compter six inversions dans le tableau [7, 6, 5, 3] : les couples d'indices (0, 1), (0, 2), (0, 3), (1, 2), (1, 3) et (2, 3). On se propose dans cet exercice de d\u00e9terminer le nombre d\u2019inversions dans un tableau quelconque. Questions pr\u00e9liminaires Question 1 Expliquer pourquoi le couple (1, 3) est une inversion dans le tableau [4, 8, 3, 7]. Question2 Justifier que le couple (2, 3) n\u2019en est pas une. Partie A : M\u00e9thode it\u00e9rative \u2693\ufe0e Le but de cette partie est d\u2019\u00e9crire une fonction it\u00e9rative nombre_inversion qui renvoie le nombre d\u2019inversions dans un tableau. Pour cela, on commence par \u00e9crire une fonction fonction1 qui sera ensuite utilis\u00e9e pour \u00e9crire la fonction nombre_inversion . Question A.1 On donne la fonction suivante. \ud83d\udc0d Script Python def fonction1 ( tab , i ): nb_elem = len ( tab ) cpt = 0 for j in range ( i + 1 , nb_elem ): if tab [ j ] < tab [ i ]: cpt += 1 return cpt a. Indiquer ce que renvoie la fonction1(tab, i) dans les cas suivants. Cas n\u00b01 : tab = [1, 5, 3, 7] et i = 0. Cas n\u00b02 : tab = [1, 5, 3, 7] et i = 1. Cas n\u00b03 : tab = [1, 5, 2, 6, 4] et i = 1. b. Expliquer ce que permet de d\u00e9terminer cette fonction. Question A.2 En utilisant la fonction pr\u00e9c\u00e9dente, \u00e9crire une fonction nombre_inversion(tab) qui prend en argument un tableau et renvoie le nombre d\u2019inversions dans ce tableau. On donne ci-dessous les r\u00e9sultats attendus pour certains appels. \ud83d\udc0d Script Python >>> nombre_inversions ([ 1 , 5 , 7 ]) 0 >>> nombre_inversions ([ 1 , 6 , 2 , 7 , 3 ]) 3 >>> nombre_inversions ([ 7 , 6 , 5 , 3 ]) 6 Question A.3 Quelle est l\u2019ordre de grandeur de la complexit\u00e9 en temps de l'algorithme obtenu ? Aucune justification n'est attendue. Partie B : M\u00e9thode r\u00e9cursive \u2693\ufe0e Le but de cette partie est de concevoir une version r\u00e9cursive de la fonction nombre_inversion . On d\u00e9finit pour cela des fonctions auxiliaires. Question B.1 Donner le nom d\u2019un algorithme de tri ayant une complexit\u00e9 meilleure que quadratique. Dans la suite de cet exercice, on suppose qu\u2019on dispose d'une fonction tri(tab) qui prend en argument un tableau et renvoie un tableau contenant les m\u00eames \u00e9l\u00e9ments rang\u00e9s dans l'ordre croissant. Question B.2 \u00c9crire une fonction moitie_gauche(tab) qui prend en argument un tableau tab et renvoie un nouveau tableau contenant la moiti\u00e9 gauche de tab. Si le nombre d'\u00e9l\u00e9ments de tab est impair, l'\u00e9l\u00e9ment du centre se trouve dans cette partie gauche. On donne ci-dessous les r\u00e9sultats attendus pour certains appels. \ud83d\udc0d Script Python >>> moitie_gauche ([]) [] >>> moitie_gauche ([ 4 , 8 , 3 ]) [ 4 , 8 ] >>> moitie_gauche ([ 4 , 8 , 3 , 7 ]) [ 4 , 8 ] Dans la suite, on suppose qu\u2019on dispose de la fonction moitie_droite(tab) qui renvoie la moiti\u00e9 droite sans l\u2019\u00e9l\u00e9ment du milieu. Question B.3 On suppose qu\u2019une fonction nb_inv_tab(tab1, tab2) a \u00e9t\u00e9 \u00e9crite. Cette fonction renvoie le nombre d\u2019inversions du tableau obtenu en mettant bout \u00e0 bout les tableaux tab1 et tab2 , \u00e0 condition que tab1 et tab2 soient tri\u00e9s dans l\u2019ordre croissant. On donne ci-dessous deux exemples d\u2019appel de cette fonction : \ud83d\udc0d Script Python >>> nb_inv_tab ([ 3 , 7 , 9 ], [ 2 , 10 ]) 3 >>> nb_inv_tab ([ 7 , 9 , 13 ], [ 7 , 10 , 14 ]) 3 En utilisant la fonction nb_inv_tab et les questions pr\u00e9c\u00e9dentes, \u00e9crire une fonction r\u00e9cursive nb_inversions_rec(tab) qui permet de calculer le nombre d'inversions dans un tableau. Cette fonction renverra le m\u00eame nombre que nombre_inversions(tab) de la partie A. On proc\u00e9dera de la fa\u00e7on suivante : S\u00e9parer le tableau en deux tableaux de tailles \u00e9gales (\u00e0 une unit\u00e9 pr\u00e8s). Appeler r\u00e9cursivement la fonction nb_inversions_rec pour compter le nombre d\u2019inversions dans chacun des deux tableaux. Trier les deux tableaux (on rappelle qu'une fonction de tri est d\u00e9j\u00e0 d\u00e9finie). Ajouter au nombre d'inversions pr\u00e9c\u00e9demment compt\u00e9es le nombre renvoy\u00e9 par la fonction nb_inv_tab avec pour arguments les deux tableaux tri\u00e9s.","title":"TD n\u00b020 - Diviser pour r\u00e9gner"},{"location":"diviserregner/TD20_Diviser_pour_Regner/#iii-les-tris-tri-par-selection-et-tri-par-insertion-tri-fusion","text":"","title":"III. Les tris : tri par s\u00e9lection et tri par insertion - Tri fusion"},{"location":"diviserregner/TD20_Diviser_pour_Regner/#partie-a-methode-iterative","text":"Le but de cette partie est d\u2019\u00e9crire une fonction it\u00e9rative nombre_inversion qui renvoie le nombre d\u2019inversions dans un tableau. Pour cela, on commence par \u00e9crire une fonction fonction1 qui sera ensuite utilis\u00e9e pour \u00e9crire la fonction nombre_inversion . Question A.1 On donne la fonction suivante. \ud83d\udc0d Script Python def fonction1 ( tab , i ): nb_elem = len ( tab ) cpt = 0 for j in range ( i + 1 , nb_elem ): if tab [ j ] < tab [ i ]: cpt += 1 return cpt a. Indiquer ce que renvoie la fonction1(tab, i) dans les cas suivants. Cas n\u00b01 : tab = [1, 5, 3, 7] et i = 0. Cas n\u00b02 : tab = [1, 5, 3, 7] et i = 1. Cas n\u00b03 : tab = [1, 5, 2, 6, 4] et i = 1. b. Expliquer ce que permet de d\u00e9terminer cette fonction. Question A.2 En utilisant la fonction pr\u00e9c\u00e9dente, \u00e9crire une fonction nombre_inversion(tab) qui prend en argument un tableau et renvoie le nombre d\u2019inversions dans ce tableau. On donne ci-dessous les r\u00e9sultats attendus pour certains appels. \ud83d\udc0d Script Python >>> nombre_inversions ([ 1 , 5 , 7 ]) 0 >>> nombre_inversions ([ 1 , 6 , 2 , 7 , 3 ]) 3 >>> nombre_inversions ([ 7 , 6 , 5 , 3 ]) 6 Question A.3 Quelle est l\u2019ordre de grandeur de la complexit\u00e9 en temps de l'algorithme obtenu ? Aucune justification n'est attendue.","title":"Partie A : M\u00e9thode it\u00e9rative"},{"location":"diviserregner/TD20_Diviser_pour_Regner/#partie-b-methode-recursive","text":"Le but de cette partie est de concevoir une version r\u00e9cursive de la fonction nombre_inversion . On d\u00e9finit pour cela des fonctions auxiliaires. Question B.1 Donner le nom d\u2019un algorithme de tri ayant une complexit\u00e9 meilleure que quadratique. Dans la suite de cet exercice, on suppose qu\u2019on dispose d'une fonction tri(tab) qui prend en argument un tableau et renvoie un tableau contenant les m\u00eames \u00e9l\u00e9ments rang\u00e9s dans l'ordre croissant. Question B.2 \u00c9crire une fonction moitie_gauche(tab) qui prend en argument un tableau tab et renvoie un nouveau tableau contenant la moiti\u00e9 gauche de tab. Si le nombre d'\u00e9l\u00e9ments de tab est impair, l'\u00e9l\u00e9ment du centre se trouve dans cette partie gauche. On donne ci-dessous les r\u00e9sultats attendus pour certains appels. \ud83d\udc0d Script Python >>> moitie_gauche ([]) [] >>> moitie_gauche ([ 4 , 8 , 3 ]) [ 4 , 8 ] >>> moitie_gauche ([ 4 , 8 , 3 , 7 ]) [ 4 , 8 ] Dans la suite, on suppose qu\u2019on dispose de la fonction moitie_droite(tab) qui renvoie la moiti\u00e9 droite sans l\u2019\u00e9l\u00e9ment du milieu. Question B.3 On suppose qu\u2019une fonction nb_inv_tab(tab1, tab2) a \u00e9t\u00e9 \u00e9crite. Cette fonction renvoie le nombre d\u2019inversions du tableau obtenu en mettant bout \u00e0 bout les tableaux tab1 et tab2 , \u00e0 condition que tab1 et tab2 soient tri\u00e9s dans l\u2019ordre croissant. On donne ci-dessous deux exemples d\u2019appel de cette fonction : \ud83d\udc0d Script Python >>> nb_inv_tab ([ 3 , 7 , 9 ], [ 2 , 10 ]) 3 >>> nb_inv_tab ([ 7 , 9 , 13 ], [ 7 , 10 , 14 ]) 3 En utilisant la fonction nb_inv_tab et les questions pr\u00e9c\u00e9dentes, \u00e9crire une fonction r\u00e9cursive nb_inversions_rec(tab) qui permet de calculer le nombre d'inversions dans un tableau. Cette fonction renverra le m\u00eame nombre que nombre_inversions(tab) de la partie A. On proc\u00e9dera de la fa\u00e7on suivante : S\u00e9parer le tableau en deux tableaux de tailles \u00e9gales (\u00e0 une unit\u00e9 pr\u00e8s). Appeler r\u00e9cursivement la fonction nb_inversions_rec pour compter le nombre d\u2019inversions dans chacun des deux tableaux. Trier les deux tableaux (on rappelle qu'une fonction de tri est d\u00e9j\u00e0 d\u00e9finie). Ajouter au nombre d'inversions pr\u00e9c\u00e9demment compt\u00e9es le nombre renvoy\u00e9 par la fonction nb_inv_tab avec pour arguments les deux tableaux tri\u00e9s.","title":"Partie B : M\u00e9thode r\u00e9cursive"},{"location":"diviserregner/TD20_Diviser_pour_Regner_Correction/","text":"Th\u00e8me 5 : Algorithmique 20 Diviser pour r\u00e9gner Le principe \u2693\ufe0e Diviser pour r\u00e9gner La strat\u00e9gie \u00ab diviser pour r\u00e9gner \u00bb consiste \u00e0 Diviser : D\u00e9composer un probl\u00e8me en un ou plusieurs sous-probl\u00e8mes de m\u00eame nature mais plus petits. R\u00e9gner : R\u00e9soudre les sous-probl\u00e8mes, g\u00e9n\u00e9ralement de mani\u00e8re r\u00e9cursive, jusqu'\u00e0 ce qu'on arrive aux cas d'arr\u00eat : des sous-probl\u00e8mes que l'on sait r\u00e9soudre imm\u00e9diatement. Combiner : Construire la solution au probl\u00e8me initial \u00e0 partir des solutions des sous-probl\u00e8mes. Diviser pour r\u00e9gner : Palindromes \u2693\ufe0e Palindromes Une cha\u00eene est un palindrome si elle peut se lire de la m\u00eame mani\u00e8re dans les deux sens, de gauche \u00e0 droite et de droite \u00e0 gauche. Par exemple : \"ressasser, \"radar\", \"12321\" sont des palindromes ; \"nsi\", \"toto\" n\u2019en sont pas. On se propose d\u2019\u00e9crire une fonction r\u00e9cursive est_palindrome(ch) qui renvoie Vrai si la chaine ch pass\u00e9e en argument est un palindrome et Faux sinon. Partie A \u2693\ufe0e Une premi\u00e8re version utilisant le slicing On consid\u00e8re la cha\u00eene suivante. \ud83d\udc0d Script Python ch = \"ressasser\" Question 1. Quels slices permettent d\u2019acc\u00e9der : au premier caract\u00e8re de ch ? au dernier caract\u00e8re de ch ? \u00e0 une cha\u00eene priv\u00e9e du premier et du dernier caract\u00e8res de ch. Question 2. En utilisant les slices, compl\u00e9tez la fonction suivante. \ud83d\udc0d Script Python def est_palindrome ( ch ): if len ( ch ) <= 1 : return ... else : return ... Question 3. Au moyen du mot cl\u00e9 assert, \u00e9crivez un bon jeu de tests pour cette fonction. V\u00e9rifiez que les tests passent avec succ\u00e8s. Question 4. Expliquez pourquoi cet algorithme est un exemple de la m\u00e9thode diviser pour r\u00e9gner. Question 5. Utiliser Python tutor, ex\u00e9cutez en mode pas \u00e0 pas le d\u00e9roulement des appels r\u00e9cursifs de cette fonction pour la cha\u00eene \"ressasser\". Si la cha\u00eene de d\u00e9part est un palindrome de longueur n, combien de comparaisons sont effectu\u00e9es ? En d\u00e9duite le co\u00fbt en temps de cet algorithme (sa complexit\u00e9) dans le pire des cas. Question 6. Le slicing a un co\u00fbt en m\u00e9moire cach\u00e9. En effet, chaque appel ch[1:-1] induit la cr\u00e9ation d\u2019une nouvelle cha\u00eene qu\u2019il faut stocker en m\u00e9moire. On peut le voir facilement avec Python tutor. Dans le pire cas, pour une cha\u00eene de longueur n au d\u00e9part, combien de cha\u00eenes doivent \u00eatre cr\u00e9\u00e9es pour r\u00e9pondre au probl\u00e8me ? Partie B \u2693\ufe0e Une deuxi\u00e8me version am\u00e9lior\u00e9e \u2693\ufe0e En r\u00e9alit\u00e9, on peut se passer de la cr\u00e9ation de toutes ces cha\u00eenes interm\u00e9diaires en utilisant et en faisant varier (comme pour la recherche dichotomique) les indices g (pour gauche) et d (pour droite) des caract\u00e8res restants. Voici une fonction palindrome(ch, g, d) qui renvoie True si la chaine ch[g..d] (c\u2019est-\u00e0-dire la cha\u00eene ch limit\u00e9e \u00e0 ses caract\u00e8res entre les positions g et d) est un palindrome et False sinon. \ud83d\udc0d Script Python def palindrome ( ch , g , d ): if d - g < 1 : return True else : return ch [ g ] == ch [ d ] and palindrome ( ch , g + 1 , d - 1 ) Question 7. Quel appel \u00e0 cette fonction faut-il faire pour tester si mot est un palindrome ? \ud83d\udc0d Script Python mot = \"ressasser\" # \u00e0 compl\u00e9ter par le bon appel : Pour \u00e9viter cette \u00e9criture un peu lourde, il suffit de cr\u00e9er une autre fonction est_palindrome2(ch) qui est charg\u00e9e de lancer le premier appel \u00e0 la fonction r\u00e9cursive palindrome. Compl\u00e9tez le code de la fonction est_palindrome2(ch) . Question 8. \ud83d\udc0d Script Python def est_palindrome2 ( ch ): # \u00e0 compl\u00e9ter pass La fonction est_palindrome2 est appel\u00e9e une fonction d\u2019interface qui permet d\u2019ajouter des arguments \u00e0 une fonction sans que l\u2019utilisateur ait \u00e0 s\u2019en pr\u00e9occuper. Question 9. V\u00e9rifiez avec Python tutor qu\u2019avec cette version, il n\u2019y a qu\u2019une cha\u00eene ch \u00e0 m\u00e9moriser (celle de d\u00e9part). On obtient un algorithme avec un co\u00fbt m\u00e9moire inf\u00e9rieur \u00e0 la premi\u00e8re version. Le tri fusion \u2693\ufe0e Principe \u2693\ufe0e Voici un deuxi\u00e8me exemple d'application de cette strat\u00e9gie : le tri fusion . On doit cet algorithme \u00e0 John Von Neumann . On dispose d'une liste d'entiers que l'on veut trier dans l'ordre croissant. On scinde cette liste en deux listes de longueurs \u00ab \u00e0 peu pr\u00e8s \u00e9gales \u00bb. On trie ces listes en utilisant... le tri fusion. (on tri donc le mani\u00e8re r\u00e9cursive) On fusionne les deux listes tri\u00e9es par ordre croissant pour ne plus en obtenir qu'une. Un exemple Une chor\u00e9graphie du tri fusion Code correspondant \u2693\ufe0e Voici comment coder le tri fusion : On a tout d'abord besoin d'une fonction scinde qui renvoie la premi\u00e8re moiti\u00e9 et la deuxi\u00e8me moiti\u00e9 de la liste qu'on lui passe en argument. \ud83d\udc0d Script Python def scinde ( lst : list ) -> tuple : return lst [: len ( lst ) // 2 ], lst [ len ( lst ) // 2 :] Ensuite, on a besoin d'une fonction fusion qui, \u00e9tant donn\u00e9e deux listes tri\u00e9es, les fusionne. \ud83d\udc0d Script Python def fusion ( lst1 : list , lst2 : list ) -> list : if not lst1 or not lst2 : # si l'une des listes est vide return lst1 or lst2 # alors on renvoie l'autre else : a , b = lst1 [ 0 ], lst2 [ 0 ] if a < b : # sinon on compare leurs premiers \u00e9l\u00e9ments return [ a ] + fusion ( lst1 [ 1 :], lst2 ) # on place le plus petit en t\u00eate et on fusionne le reste elif b > a : return [ b ] + fusion ( lst1 , lst2 [ 1 :]) else : # dans le cas o\u00f9 les 2 \u00e9l\u00e9ments sont \u00e9gaux on peut les placer tous les deux return [ a , b ] + fusion ( lst1 [ 1 :], lst2 [ 1 :]) Enfin, la fonction tri_fusion . \ud83d\udc0d Script Python def tri_fusion ( lst : list ) -> list : if len ( lst ) < 2 : # cas d'arr\u00eat return lst lst1 , lst2 = scinde ( lst ) # sinon on scinde return fusion ( tri_fusion ( lst1 ), tri_fusion ( lst2 )) # et on fusionne les sous-listes tri\u00e9es Complexit\u00e9 du tri fusion \u2693\ufe0e \u27a1 La partie \u201cdiviser\u201d est de complexit\u00e9 constante. Pour pouvoir majorer le nombre maximum d\u2019it\u00e9rations, si le tableau contient P valeurs, et si on a un entier \\(n\\) tel que \\(P \\leq 2^n\\) , alors puisque qu\u2019\u00e0 chaque it\u00e9ration, on s\u00e9lectionne une moiti\u00e9 de ce qui reste : au bout d\u2019une it\u00e9ration, une moiti\u00e9 de tableau aura au plus \\(\\dfrac{2^n}{2} = 2^{n\u22121}\\) \u00e9l\u00e9ments, un quart aura au plus \\(2^{n\u22122}\\) et au bout de \\(k\\) it\u00e9rations, la taille de ce qui reste \u00e0 \u00e9tudier est de taille au plus \\(2^{n\u2212k}\\) . En particulier, si l\u2019on fait \\(n\\) it\u00e9rations, il reste au plus \\(2^{n\u2212n} = 1\\) valeur du tableau \u00e0 examiner. On est s\u00fbr de s\u2019arr\u00eater cette fois-ci On a donc montr\u00e9 que si l\u2019entier \\(n\\) v\u00e9rifie \\(P \\leq 2^n\\) , alors l\u2019algorithme va effectuer au plus \\(n\\) it\u00e9rations. La plus petite valeur est obtenue pour \\(n = log_2 P\\) . Ainsi, la complexit\u00e9 de la fonction est de l\u2019ordre du logarithme de la longueur de la liste ( \\(O(log_2(n))\\) ). \\(log_2(n)\\) . Exemple Pour un tableau de taille n = 64 il faut : 64/2=32,32/2=16,16/2=8,8/2=4,4/2=2,2/2=1 : 6 \u00e9tapes. \\(2^6=64\\) . Comme toujours quand on peut s\u00e9parer le tableau en deux, la m\u00e9thode diviser pour r\u00e9gner permet de ne r\u00e9aliser que \\(log_2 n\\) \u00e9tapes. Mais\u2026 \u27a1 Complexit\u00e9 fusion La partie fusion utilise une boucle qui parcourt plusieurs tableaux en m\u00eame temps. On r\u00e9alise \u00e0 chaque \u00e9tape la m\u00eame chose : lire deux valeurs, comparer, ranger la plus petite. La complexit\u00e9 est lin\u00e9aire. Notons \\(n\\) la taille de la liste \u00e0 trier et consid\u00e9rons comme seule op\u00e9ration \u00e9l\u00e9mentaire le fait d'acc\u00e9der \u00e0 un \u00e9l\u00e9ment d'une liste. Complexit\u00e9 du tri fusion Le nombre d'op\u00e9rations \u00e9l\u00e9mentaires n\u00e9cessaires pour trier une liste de taille \\(n\\) par la m\u00e9thode du tri fusion est de l'ordre de \\(n\\times\\log_2 n\\) . Application : Exercices de l'Epreuve Pratique \u2693\ufe0e Sujet 23 - Exercice 2 La fonction fusion prend deux listes L1, L2 d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e L12 qu\u2019elle renvoie. Le code Python de la fonction est \ud83d\udc0d Script Python def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = ... i1 = ... else : L12 [ i ] = L2 [ i2 ] i2 = ... i += 1 while i1 < n1 : L12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : L12 [ i ] = ... i2 = i2 + 1 i = ... return L12 Compl\u00e9ter le code. Exemple : \ud83d\udc0d Script Python >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] Recherche dichotomique \u2693\ufe0e EX : Recherche dichotomique Enonc\u00e9 Solution Expliquer pourquoi la recherche dichotomique d'un \u00e9l\u00e9ment dans une liste d'entiers tri\u00e9s dans l'ordre croissant peut \u00eatre vue comme un exemple de strat\u00e9gie \u00ab diviser pour r\u00e9gner \u00bb. Programmer la recherche dichotomique de mani\u00e8re r\u00e9cursive. Pour savoir si un \u00e9l\u00e9ment appartient \u00e0 la liste, on regarde celui qui est \u00ab\u00e0 peu pr\u00e8s au milieu\u00bb. Si c'est le bon c'est termin\u00e9, sinon on fait de m\u00eame avec la sous-liste des \u00e9l\u00e9ments pr\u00e9c\u00e9dents et avec celle des \u00e9l\u00e9ments suivants. \ud83d\udc0d Script Python def rech_dicho ( lst , elt ): n = len ( lst ) if n < 2 : return elt in lst elif lst [ n // 2 ] == elt : return True else : return rech_dicho ( lst [: n // 2 ], elt ) if lst [ n // 2 ] > elt else rech_dicho ( lst [ n // 2 + 1 :], elt ) Exercices BAC \u2693\ufe0e Sujet n\u00b01 : France 2021 Cet exercice porte sur l\u2019algorithme de tri fusion, qui s\u2019appuie sur la m\u00e9thode dite de \u00ab diviser pour r\u00e9gner \u00bb. Question 1 Enonc\u00e9 Solution a. Quel est l\u2019ordre de grandeur du co\u00fbt, en nombre de comparaisons, de l\u2019algorithme de tri fusion pour une liste de longueur ? b. Citer le nom d\u2019un autre algorithme de tri. Donner l\u2019ordre de grandeur de son co\u00fbt, en nombre de comparaisons, pour une liste de longueur . Comparer ce co\u00fbt \u00e0 celui du tri fusion. Aucune justification n\u2019est attendue. a. \\(O(nlog_2(n))\\) b. L\u2019algorithme de tri par insertion a une complexit\u00e9 en temps dans le pire des cas en O(n2). L\u2019algorithme du tri par insertion est moins efficace que l\u2019algorithme de tri fusion. L\u2019algorithme de tri fusion utilise deux fonctions moitie_gauche et moitie_droite qui prennent en argument une liste L et renvoient respectivement : la sous-liste de L form\u00e9e des \u00e9l\u00e9ments d\u2019indice strictement inf\u00e9rieur \u00e0 len(L)//2 ; la sous-liste de L form\u00e9e des \u00e9l\u00e9ments d\u2019indice sup\u00e9rieur ou \u00e9gal \u00e0 len(L)//2. On rappelle que la syntaxe a//b d\u00e9signe la division enti\u00e8re de a par b. Par exemple, \ud83d\udc0d Script Python >>> L = [ 3 , 5 , 2 , 7 , 1 , 9 , 0 ] >>> moitie_gauche ( L ) [ 3 , 5 , 2 ] >>> moitie_droite ( L ) [ 7 , 1 , 9 , 0 ] >>> M = [ 4 , 1 , 11 , 7 ] >>> moitie_gauche ( M ) [ 4 , 1 ] >>> moitie_droite ( M ) [ 11 , 7 ] L\u2019algorithme utilise aussi une fonction fusion qui prend en argument deux listes tri\u00e9es L1 et L2 et renvoie une liste L tri\u00e9e et compos\u00e9e des \u00e9l\u00e9ments de L1 et L2. On donne ci-dessous le code python d\u2019une fonction r\u00e9cursive tri_fusion qui prend en argument une liste L et renvoie une nouvelle liste tri\u00e9e form\u00e9e des \u00e9l\u00e9ments de L. \ud83d\udc0d Script Python def tri_fusion ( L ): n = len ( L ) if n <= 1 : return L print ( L ) mg = moitie_gauche ( L ) md = moitie_droite ( L ) L1 = tri_fusion ( mg ) L2 = tri_fusion ( md ) return fusion ( L1 , L2 ) Question 2 Enonc\u00e9 Solution Donner la liste des affichages produits par l\u2019appel suivant. \ud83d\udc0d Script Python tri_fusion ([ 7 , 4 , 2 , 1 , 8 , 5 , 6 , 3 ]) Voici l\u2019affichage obtenu : \ud83d\udc0d Script Python [ 7 , 4 , 2 , 1 , 8 , 5 , 6 , 3 ] [ 7 , 4 , 2 , 1 ] [ 7 , 4 ] [ 2 , 1 ] [ 8 , 5 , 6 , 3 ] [ 8 , 5 ] [ 6 , 3 ] r\u00e9sultat renvoy\u00e9 par la fonction : [1, 2, 3, 4, 5, 6, 7, 8] On s\u2019int\u00e9resse d\u00e9sormais \u00e0 diff\u00e9rentes fonctions appel\u00e9es par tri_fusion, \u00e0 savoir moitie_droite et fusion. Question 3 Enonc\u00e9 Solution Ecrire la fonction moitie_droite. \ud83d\udc0d Script Python def moitie_droite ( L ): n = len ( L ) deb = n // 2 tab = [] for i in range ( deb , n ): tab . append ( L [ i ]) return tab Question 4 Enonc\u00e9 Solution On donne ci-dessous une version incompl\u00e8te de la fonction fusion. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def fusion ( L1 , L2 ): L = [] n1 = len ( L1 ) n2 = len ( L2 ) i1 = 0 i2 = 0 while i1 < n1 or i2 < n2 : if i1 >= n1 : L . append ( L2 [ i2 ]) i2 = i2 + 1 elif i2 >= n2 : L . append ( L1 [ i1 ]) i1 = i1 + 1 else : e1 = L1 [ i1 ] e2 = L2 [ i2 ] return L Dans cette fonction, les entiers i1 et i2 repr\u00e9sentent respectivement les indices des \u00e9l\u00e9ments des listes L1 et L2 que l\u2019on souhaite comparer : Si aucun des deux indices n\u2019est valide, la boucle while est interrompue ; Si i1 n\u2019est plus un indice valide, on va ajouter \u00e0 L les \u00e9l\u00e9ments de L2 \u00e0 partir de l\u2019indice i2 ; Si i2 n\u2019est plus un indice valide, on va ajouter \u00e0 L les \u00e9l\u00e9ments de L1 \u00e0 partir de l\u2019indice i1 ; Sinon, le plus petit \u00e9l\u00e9ment non encore trait\u00e9 est ajout\u00e9 \u00e0 L et on d\u00e9cale l\u2019indice correspondant. \u00c9crire sur la copie les instructions manquantes des lignes 17 \u00e0 22 permettant d\u2019ins\u00e9rer dans la liste L les \u00e9l\u00e9ments des listes L1 et L2 par ordre croissant. \ud83d\udc0d Script Python def fusion ( L1 , L2 ): L = [] n1 = len ( L1 ) n2 = len ( L2 ) i1 = 0 i2 = 0 while i1 < n1 or i2 < n2 : if i1 >= n1 : L . append ( L2 [ i2 ]) i2 = i2 + 1 elif i2 >= n2 : L . append ( L1 [ i1 ]) i1 = i1 + 1 else : e1 = L1 [ i1 ] e2 = L2 [ i2 ] if e1 > e2 : L . append ( e2 ) i2 = i2 + 1 else : L . append ( e1 ) i1 = i1 + 1 return L Sujet n\u00b02 : BAC Polyn\u00e9sie 2021 Cet exercice traite principalement du th\u00e8me \u00ab algorithmique, langages et programmation \u00bb. Le but est de comparer le tri par insertion (l'un des algorithmes \u00e9tudi\u00e9s en 1\u00e8re NSI pour trier un tableau) avec le tri fusion (un algorithme qui applique le principe de \u00ab diviser pour r\u00e9gner \u00bb). Partie A : Manipulation d\u2019une liste en Python \u2693\ufe0e Question A.1 Enonc\u00e9e Solution Donner les affichages obtenus apr\u00e8s l\u2019ex\u00e9cution du code Python suivant. \ud83d\udc0d Script Python notes = [ 8 , 7 , 18 , 14 , 12 , 9 , 17 , 3 ] notes [ 3 ] = 16 print ( len ( notes )) print ( notes ) \ud83d\udc0d Script Python >>> 8 >>> [ 8 , 7 , 18 , 16 , 12 , 9 , 17 , 3 ] `!!! fabquestion \"Question A.2\" === \"Enonc\u00e9\" \u00c9crire un code Python permettant d'afficher les \u00e9l\u00e9ments d'indice 2 \u00e0 4 de la liste notes. \ud83d\udccb Texte === \"Solution\" ```python for i in range(2,5): print(notes[i]) ``` Partie B : Tri par insertion \u2693\ufe0e Le tri par insertion est un algorithme efficace qui s'inspire de la fa\u00e7on dont on peut trier une poign\u00e9e de cartes. On commence avec une seule carte dans la main gauche (les autres cartes sont en tas sur la table) puis on pioche la carte suivante et on l'ins\u00e8re au bon endroit dans la main gauche. Question B.1 Enonc\u00e9 Solution Voici une impl\u00e9mentation en Python de cet algorithme. Recopier et compl\u00e9ter les lignes 6 et 7 surlign\u00e9es (uniquement celles-ci). \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def tri_insertion ( liste ): \"\"\" trie par insertion la liste en param\u00e8tre \"\"\" for indice_courant in range ( 1 , len ( liste )): element_a_inserer = liste [ indice_courant ] i = indice_courant - 1 while i >= 0 and liste [ i ] > ................................ : liste [ ........... ] = liste [ ........... ] i = i - 1 liste [ i + 1 ] = element_a_inserer \ud83d\udc0d Script Python def tri_insertion ( liste ): \"\"\" trie par insertion la liste en param\u00e8tre \"\"\" for indice_courant in range ( 1 , len ( liste )): element_a_inserer = liste [ indice_courant ] i = indice_courant - 1 while i >= 0 and liste [ i ] > element_a_inserer : liste [ i + 1 ] = liste [ i ] i = i - 1 liste [ i + 1 ] = element_a_inserer On a \u00e9crit dans la console les instructions suivantes : \ud83d\udc0d Script Python notes = [ 8 , 7 , 18 , 14 , 12 , 9 , 17 , 3 ] tri_insertion ( notes ) print ( notes ) On a obtenu l'affichage suivant : \ud83d\udc0d Script Python [ 3 , 7 , 8 , 9 , 12 , 14 , 17 , 18 ] On s'interroge sur ce qui s\u2019est pass\u00e9 lors de l\u2019ex\u00e9cution de tri_insertion(notes). Question B.2 Enonc\u00e9 Solution Donner le contenu de la liste notes apr\u00e8s le premier passage dans la boucle for. \ud83d\udc0d Script Python >>> [ 7 , 8 , 18 , 14 , 12 , 9 , 17 , 3 ] Question B.3 Enonc\u00e9 Solution Donner le contenu de la liste notes apr\u00e8s le troisi\u00e8me passage dans la boucle for. \ud83d\udc0d Script Python >>> [ 7 , 8 , 14 , 18 , 12 , 9 , 17 , 3 ] Partie C : Tri fusion \u2693\ufe0e L'algorithme de tri fusion suit le principe de \u00ab diviser pour r\u00e9gner \u00bb. (1) Si le tableau \u00e0 trier n\u2019a qu\u2019un \u00e9l\u00e9ment, il est d\u00e9j\u00e0 tri\u00e9. (2) Sinon, s\u00e9parer le tableau en deux parties \u00e0 peu pr\u00e8s \u00e9gales. (3) Trier les deux parties avec l\u2019algorithme de tri fusion. (4) Fusionner les deux tableaux tri\u00e9s en un seul tableau. source : Wikipedia Question C.1 Enonc\u00e9 Cet algorithme est-il it\u00e9ratif ou r\u00e9cursif ? Justifier en une phrase. Solution r\u00e9cursif : \u00e0 l\u2019\u00e9tape (3) l\u2019algorithme de tri fusion s\u2019appelle lui-m\u00eame. Question C.2 Enonc\u00e9 Solution Expliquer en trois lignes comment faire pour rassembler dans une main deux tas d\u00e9j\u00e0 tri\u00e9s de cartes, la carte en haut d'un tas \u00e9tant la plus petite de ce m\u00eame tas ; la deuxi\u00e8me carte d'un tas n'\u00e9tant visible qu'apr\u00e8s avoir retir\u00e9 la premi\u00e8re carte de ce tas. Comparer les cartes du haut des 2 tas. Placer la carte de valeur plus faible dans la main. Recommencer l\u2019\u00e9tape 1 jusqu\u2019\u00e0 \u00e9puisement des tas. \u00c0 la fin du proc\u00e9d\u00e9, les cartes en main doivent \u00eatre tri\u00e9es par ordre croissant. Une fonction fusionner a \u00e9t\u00e9 impl\u00e9ment\u00e9e en Python en s'inspirant du proc\u00e9d\u00e9 de la question pr\u00e9c\u00e9dente. Elle prend quatre arguments : la liste qui est en train d'\u00eatre tri\u00e9e, l'indice o\u00f9 commence la sous-liste de gauche \u00e0 fusionner, l'indice o\u00f9 termine cette sousliste, et l'indice o\u00f9 se termine la sous-liste de droite. Question C.3 Enonc\u00e9 Solution Voici une impl\u00e9mentation de l\u2019algorithme de tri fusion. Recopier et compl\u00e9ter les lignes 8, 9 et 10 surlign\u00e9es (uniquement celles-ci). \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 from math import floor def tri_fusion ( liste , i_debut , i_fin ): \"\"\" trie par fusion la liste en param\u00e8tre depuis i_debut jusqu\u2019\u00e0 i_fin \"\"\" if i_debut < i_fin : i_partage = floor (( i_debut + i_fin ) / 2 ) tri_fusion ( liste , i_debut , .............................. ) tri_fusion ( liste , ................................... , i_fin ) fusionner ( liste , ......................... , ......................... , ...................... ) Remarque : la fonction floor renvoie la partie enti\u00e8re du nombre pass\u00e9 en param\u00e8tre. \ud83d\udc0d Script Python from math import floor def tri_fusion ( liste , i_debut , i_fin ): \"\"\" trie par fusion la liste en param\u00e8tre depuis i_debut jusqu\u2019\u00e0 i_fin \"\"\" if i_debut < i_fin : i_partage = floor (( i_debut + i_fin ) / 2 ) # milieu pour diviser le tableau en deux moiti\u00e9s tri_fusion ( liste , i_debut , i_partage ) # Appel tri_fusion pour 1\u00e8re moiti\u00e9 du tableau tri_fusion ( liste , i_partage + 1 , i_fin ) # Appel tri_fusion pour 2\u00e8me moiti\u00e9 du tableau fusionner ( liste , i_debut , i_fin , i_partage ) # Fusion des deux moiti\u00e9s tri\u00e9es Question C.4 Enonc\u00e9 Solution Expliquer le r\u00f4le de la premi\u00e8re ligne du code de la question 3. permet d\u2019importer la fonction floor() du module math utilis\u00e9e \u00e0 la ligne 7 Partie D : Comparaison du tri par insertion et du tri fusion \u2693\ufe0e Voici une illustration des \u00e9tapes d\u2019un tri effectu\u00e9 sur la liste [3, 41, 52, 26, 38, 57, 9, 49] . [:.center}] Question D.1 Enonc\u00e9 Solution Quel algorithme a \u00e9t\u00e9 utilis\u00e9 : le tri par insertion ou le tri fusion ? Justifier. tri par fusion : \u00e0 chaque \u00e9tape, le tri se fait par fusion de 2 tas d\u00e9j\u00e0 tri\u00e9s Question D.2 Enonc\u00e9 Solution Identifier le tri qui a une complexit\u00e9, dans le pire des cas, en O(n2) et identifier le tri qui a une complexit\u00e9, dans le pire des cas, en O(n log2 n). Remarque : n repr\u00e9sente la longueur de la liste \u00e0 trier. tri par insertion : \\(O(n^2)\\) tri par fusion : \\(O(n.log_2 n)\\) Question D.3 Enonc\u00e9 Solution Justifier bri\u00e8vement ces deux complexit\u00e9s. Le tri par insertion utilise 2 boucles imbriqu\u00e9es, soit dans le pire des cas ~ \\(1/2n(n+1)\\) op\u00e9rations. Le tri par fusion, divise la liste \u00e0 trier par 2 pour chaque it\u00e9rations, soit ~ \\(log_2 n\\) op\u00e9rations. Sujet n\u00b03 : FRANCE CANDIDAT LIBRE SUJET 1 Cet exercice traite de manipulation de tableaux, de r\u00e9cursivit\u00e9 et du paradigme \u00ab diviser pour r\u00e9gner \u00bb. Dans un tableau Python d'entiers tab, on dit que le couple d\u2019indices (\u0745,\u0746) forme une inversion lorsque \u0745 < \u0746 et tab[i] > tab[j]. On donne ci-dessous quelques exemples. Dans le tableau [1, 5, 3, 7], le couple d\u2019indices (1,2) forme une inversion car 5> 3. Par contre, le couple (1,3) ne forme pas d'inversion car 5<7. Il n\u2019y a qu\u2019une inversion dans ce tableau. Il y a trois inversions dans le tableau [1, 6, 2, 7, 3], \u00e0 savoir les couples d'indices (1, 2), (1, 4) et (3, 4). On peut compter six inversions dans le tableau [7, 6, 5, 3] : les couples d'indices (0, 1), (0, 2), (0, 3), (1, 2), (1, 3) et (2, 3). On se propose dans cet exercice de d\u00e9terminer le nombre d\u2019inversions dans un tableau quelconque. Questions pr\u00e9liminaires Question 1 Enonc\u00e9 Solution Expliquer pourquoi le couple (1, 3) est une inversion dans le tableau [4, 8, 3, 7]. \u00c0 l\u2019indice 1 du tableau on trouve 8, \u00e0 l\u2019indice 3 on trouve 7. Nous avons 1 < 3 alors que 8 > 7, nous avons donc bien une inversion Question2 Enonc\u00e9 Solution Justifier que le couple (2, 3) n\u2019en est pas une. \u00c0 l\u2019indice 2 du tableau on trouve 3, \u00e0 l\u2019indice 3 on trouve 7. Nous avons 2 < 3 et 3 < 7, nous n\u2019avons donc pas d\u2019inversion Partie A : M\u00e9thode it\u00e9rative \u2693\ufe0e Le but de cette partie est d\u2019\u00e9crire une fonction it\u00e9rative nombre_inversion qui renvoie le nombre d\u2019inversions dans un tableau. Pour cela, on commence par \u00e9crire une fonction fonction1 qui sera ensuite utilis\u00e9e pour \u00e9crire la fonction nombre_inversion. Question A.1 Enonc\u00e9 Solution On donne la fonction suivante. \ud83d\udc0d Script Python def fonction1 ( tab , i ): nb_elem = len ( tab ) cpt = 0 for j in range ( i + 1 , nb_elem ): if tab [ j ] < tab [ i ]: cpt += 1 return cpt a. Indiquer ce que renvoie la fonction1(tab, i) dans les cas suivants. Cas n\u00b01 : tab = [1, 5, 3, 7] et i = 0. Cas n\u00b02 : tab = [1, 5, 3, 7] et i = 1. Cas n\u00b03 : tab = [1, 5, 2, 6, 4] et i = 1. b. Expliquer ce que permet de d\u00e9terminer cette fonction. a. cas n\u00b01 : 0 cas n\u00b02 : 1 cas n\u00b03 : 2 b. Question A.2 Enonc\u00e9 Solution En utilisant la fonction pr\u00e9c\u00e9dente, \u00e9crire une fonction nombre_inversion(tab) qui prend en argument un tableau et renvoie le nombre d\u2019inversions dans ce tableau. On donne ci-dessous les r\u00e9sultats attendus pour certains appels. \ud83d\udccb Texte >>> nombre_inversions([1, 5, 7]) 0 >>> nombre_inversions([1, 6, 2, 7, 3]) 3 >>> nombre_inversions([7, 6, 5, 3]) 6 \ud83d\udc0d Script Python def nombre_inversions ( tab ): nb_inv = 0 n = len ( tab ) for i in range ( n - 1 ): nb_inv = nb_inv + fonction1 ( tab , i ) return nb_inv Question A.3 Enonc\u00e9 Solution Quelle est l\u2019ordre de grandeur de la complexit\u00e9 en temps de l'algorithme obtenu ? Aucune justification n'est attendue. L\u2019ordre de grandeur de la complexit\u00e9 en temps de l\u2019algorithme est \\(O(n^2)\\) Partie B : M\u00e9thode r\u00e9cursive \u2693\ufe0e Le but de cette partie est de concevoir une version r\u00e9cursive de la fonction nombre_inversion. On d\u00e9finit pour cela des fonctions auxiliaires. Question B.1 Enonc\u00e9 Solution Donner le nom d\u2019un algorithme de tri ayant une complexit\u00e9 meilleure que quadratique. Dans la suite de cet exercice, on suppose qu\u2019on dispose d'une fonction tri(tab) qui prend en argument un tableau et renvoie un tableau contenant les m\u00eames \u00e9l\u00e9ments rang\u00e9s dans l'ordre croissant. Le tri fusion a une complexit\u00e9 en \\(O(n.log_2 (n))\\) Question B.2 Enonc\u00e9 Solution \u00c9crire une fonction moitie_gauche(tab) qui prend en argument un tableau tab et renvoie un nouveau tableau contenant la moiti\u00e9 gauche de tab. Si le nombre d'\u00e9l\u00e9ments de tab est impair, l'\u00e9l\u00e9ment du centre se trouve dans cette partie gauche. On donne ci-dessous les r\u00e9sultats attendus pour certains appels. \ud83d\udc0d Script Python >>> moitie_gauche ([]) [] >>> moitie_gauche ([ 4 , 8 , 3 ]) [ 4 , 8 ] >>> moitie_gauche ([ 4 , 8 , 3 , 7 ]) [ 4 , 8 ] \ud83d\udc0d Script Python def moitie_gauche ( tab ): n = len ( tab ) nvx_tab = [] if n == 0 : return [] mil = n // 2 if n % 2 == 0 : lim = mil else : lim = mil + 1 for i in range ( lim ): nvx_tab . append ( tab [ i ]) return nvx_tab une autre possibilit\u00e9 un peu plus concise : \ud83d\udc0d Script Python def moitie_gauche ( tab ): return [ tab [ i ] for i in range ( len ( tab ) // 2 + len ( tab ) % 2 )] Dans la suite, on suppose qu\u2019on dispose de la fonction moitie_droite(tab) qui renvoie la moiti\u00e9 droite sans l\u2019\u00e9l\u00e9ment du milieu. Question B.3 Enonc\u00e9 Solution On suppose qu\u2019une fonction nb_inv_tab(tab1, tab2)a \u00e9t\u00e9 \u00e9crite. Cette fonction renvoie le nombre d\u2019inversions du tableau obtenu en mettant bout \u00e0 bout les tableaux tab1 et tab2, \u00e0 condition que tab1 et tab2 soient tri\u00e9s dans l\u2019ordre croissant. On donne ci-dessous deux exemples d\u2019appel de cette fonction : \ud83d\udc0d Script Python >>> nb_inv_tab ([ 3 , 7 , 9 ], [ 2 , 10 ]) 3 >>> nb_inv_tab ([ 7 , 9 , 13 ], [ 7 , 10 , 14 ]) 3 En utilisant la fonction nb_inv_tab et les questions pr\u00e9c\u00e9dentes, \u00e9crire une fonction r\u00e9cursive nb_inversions_rec(tab) qui permet de calculer le nombre d'inversions dans un tableau. * Cette fonction renverra le m\u00eame nombre que nombre_inversions(tab) de la partie A. On proc\u00e9dera de la fa\u00e7on suivante : S\u00e9parer le tableau en deux tableaux de tailles \u00e9gales (\u00e0 une unit\u00e9 pr\u00e8s). Appeler r\u00e9cursivement la fonction nb_inversions_rec pour compter le nombre d\u2019inversions dans chacun des deux tableaux. Trier les deux tableaux (on rappelle qu'une fonction de tri est d\u00e9j\u00e0 d\u00e9finie). Ajouter au nombre d'inversions pr\u00e9c\u00e9demment compt\u00e9es le nombre renvoy\u00e9 par la fonction nb_inv_tab avec pour arguments les deux tableaux tri\u00e9s. \ud83d\udc0d Script Python def nb_inversions_rec ( tab ): if len ( tab ) > 1 : tab_g = moitie_gauche ( tab ) tab_d = moitie_droite ( tab ) return nb_inv_tab ( tri ( tab_g ), tri ( tab_d )) nb_inversions_rec ( tab_g ) + nb_inversions_rec ( tab_d ) else : return 0 ou \ud83d\udc0d Script Python def nb_inversions_rec ( tab : list , n : int = 0 ) -> int : \"\"\" renvoie le m\u00eame nombre que nombre_inversions(tab) de la partie A. \"\"\" if len ( tab ) <= 1 : return 0 else : #S\u00e9parer le tableau en deux tableaux de tailles \u00e9gales (\u00e0 une unit\u00e9 pr\u00e8s). gauche = moitie_gauche ( tab ) droite = moitie_droite ( tab ) #Compter le nombre d\u2019inversions dans chacun des deux tableaux. n = nb_inv_tab ( sorted ( gauche ), sorted ( droite )) #Appeler r\u00e9cursivement la fonction nb_inversions_rec return n + nb_inversions_rec ( gauche , n ) + nb_inversions_rec ( droite , n )","title":"TD n\u00b020 - Diviser pour r\u00e9gner"},{"location":"diviserregner/TD20_Diviser_pour_Regner_Diapo/","text":":root { --color-background: #101010 !important; --color-foreground: #FFFFFF !important; font-size: 1.25rem; } blockquote { background: #C3B091; border-left: 15px solid #CC0000; margin: 1.5em 10px; color: black; padding: 0.5em 10px; } # TD 20 : Diviser pour r\u00e9gner I. Le principe \u2693\ufe0e Diviser pour r\u00e9gner La strat\u00e9gie \u00ab diviser pour r\u00e9gner \u00bb consiste \u00e0 1. Diviser : D\u00e9composer un probl\u00e8me en un ou plusieurs sous-probl\u00e8mes de m\u00eame nature mais plus petits. 2. R\u00e9gner : R\u00e9soudre les sous-probl\u00e8mes, g\u00e9n\u00e9ralement de mani\u00e8re r\u00e9cursive, jusqu'\u00e0 ce qu'on arrive aux cas d'arr\u00eat : des sous-probl\u00e8mes que l'on sait r\u00e9soudre imm\u00e9diatement. 3. Combiner : Construire la solution au probl\u00e8me initial \u00e0 partir des solutions des sous-probl\u00e8mes. II. Diviser pour r\u00e9gner : Palindromes \u2693\ufe0e Palindromes Une cha\u00eene est un palindrome si elle peut se lire de la m\u00eame mani\u00e8re dans les deux sens, de gauche \u00e0 droite et de droite \u00e0 gauche. Par exemple : - \"ressasser, \"radar\", \"12321\" sont des palindromes ; - \"nsi\", \"toto\" n\u2019en sont pas. On se propose d\u2019\u00e9crire une fonction r\u00e9cursive est_palindrome(ch) qui renvoie Vrai si la chaine ch pass\u00e9e en argument est un palindrome et Faux sinon. Partie A \u2693\ufe0e Une premi\u00e8re version utilisant le slicing On consid\u00e8re la cha\u00eene suivante. \ud83d\udc0d Script Python ch = \"ressasser\" Question 1. Quels slices permettent d\u2019acc\u00e9der : au premier caract\u00e8re de ch ? au dernier caract\u00e8re de ch ? \u00e0 une cha\u00eene priv\u00e9e du premier et du dernier caract\u00e8res de ch. Question 2. En utilisant les slices, compl\u00e9tez la fonction suivante. \ud83d\udc0d Script Python def est_palindrome ( ch ): if len ( ch ) <= 1 : return ... else : return ... Question 3. Au moyen du mot cl\u00e9 assert, \u00e9crivez un bon jeu de tests pour cette fonction. V\u00e9rifiez que les tests passent avec succ\u00e8s. Question 4. Expliquez pourquoi cet algorithme est un exemple de la m\u00e9thode diviser pour r\u00e9gner. Question 5. Utiliser Python tutor, ex\u00e9cutez en mode pas \u00e0 pas le d\u00e9roulement des appels r\u00e9cursifs de cette fonction pour la cha\u00eene \"ressasser\". Si la cha\u00eene de d\u00e9part est un palindrome de longueur n, combien de comparaisons sont effectu\u00e9es ? En d\u00e9duite le co\u00fbt en temps de cet algorithme (sa complexit\u00e9) dans le pire des cas. Question 6. Le slicing a un co\u00fbt en m\u00e9moire cach\u00e9. En effet, chaque appel ch[1:-1] induit la cr\u00e9ation d\u2019une nouvelle cha\u00eene qu\u2019il faut stocker en m\u00e9moire. On peut le voir facilement avec Python tutor. Dans le pire cas, pour une cha\u00eene de longueur n au d\u00e9part, combien de cha\u00eenes doivent \u00eatre cr\u00e9\u00e9es pour r\u00e9pondre au probl\u00e8me ? Partie B \u2693\ufe0e Une deuxi\u00e8me version am\u00e9lior\u00e9e \u2693\ufe0e En r\u00e9alit\u00e9, on peut se passer de la cr\u00e9ation de toutes ces cha\u00eenes interm\u00e9diaires en utilisant et en faisant varier (comme pour la recherche dichotomique) les indices g (pour gauche) et d (pour droite) des caract\u00e8res restants. Voici une fonction palindrome(ch, g, d) qui renvoie True si la chaine ch[g..d] (c\u2019est-\u00e0-dire la cha\u00eene ch limit\u00e9e \u00e0 ses caract\u00e8res entre les positions g et d) est un palindrome et False sinon. \ud83d\udc0d Script Python def palindrome ( ch , g , d ): if d - g < 1 : return True else : return ch [ g ] == ch [ d ] and palindrome ( ch , g + 1 , d - 1 ) Question 7. Quel appel \u00e0 cette fonction faut-il faire pour tester si mot est un palindrome ? \ud83d\udc0d Script Python mot = \"ressasser\" # \u00e0 compl\u00e9ter par le bon appel : \u2693\ufe0e Pour \u00e9viter cette \u00e9criture un peu lourde, il suffit de cr\u00e9er une autre fonction est_palindrome2(ch) qui est charg\u00e9e de lancer le premier appel \u00e0 la fonction r\u00e9cursive palindrome. Compl\u00e9tez le code de la fonction est_palindrome2(ch) . Question 8. \ud83d\udc0d Script Python def est_palindrome2 ( ch ): # \u00e0 compl\u00e9ter pass La fonction est_palindrome2 est appel\u00e9e une fonction d\u2019interface qui permet d\u2019ajouter des arguments \u00e0 une fonction sans que l\u2019utilisateur ait \u00e0 s\u2019en pr\u00e9occuper. Question 9. V\u00e9rifiez avec Python tutor qu\u2019avec cette version, il n\u2019y a qu\u2019une cha\u00eene ch \u00e0 m\u00e9moriser (celle de d\u00e9part). On obtient un algorithme avec un co\u00fbt m\u00e9moire inf\u00e9rieur \u00e0 la premi\u00e8re version. III. Les tris : tri par s\u00e9lection et tri par insertion - Tri fusion \u2693\ufe0e Tri par s\u00e9lection \u2693\ufe0e Tri par s\u00e9lection Voici l\u2019algorithme du tri par s\u00e9lection \u00e9crit en fran\u00e7ais : - Rechercher le plus petit \u00e9l\u00e9ment du tableau, et l\u2019\u00e9changer avec l\u2019\u00e9l\u00e9ment d\u2019indice 0 ; - Rechercher le second plus petit \u00e9l\u00e9ment du tableau, et l\u2019\u00e9changer avec l\u2019\u00e9l\u00e9ment d\u2019indice 1 ; - Continuer de cette fa\u00e7on jusqu\u2019\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9 Le tri par s\u00e9lection parcourt ainsi le tableau de la gauche vers la droite, en maintenant sur la gauche une partie d\u00e9j\u00e0 tri\u00e9e et \u00e0 sa place d\u00e9finitive. Animation explicative du tri par s\u00e9lection Exercice Question 1 Appliquez l\u2019algorithme de tri par s\u00e9lection sur le tableau suivant. Vous \u00e9crirez l\u2019\u00e9tat du tableau \u00e0 l\u2019issue de chaque it\u00e9ration. T = [8, 3, 11, 7, 9, 2] Question 2. D\u00e9terminer la complexit\u00e9 de cette algorithme : Combien de comparaisons sont n\u00e9cessaires pour trier par s\u00e9lection un tableau de taille n dans le pire des cas ? Exercice Question 1. \u00c9crivez une fonction echange(T, i, j) qui \u00e9change les \u00e9l\u00e9ments d\u2019indices T[i] et T[j] dans le tableau T . Question 2. \u00c9crivez une fonction tri_par_selection(T) , utilisant la fonction echange , qui trie par s\u00e9lection le tableau T dans l\u2019ordre croissant. Tri par insertion (rappels) \u2693\ufe0e Tri par insertion Voici l\u2019algorithme du tri par insertion \u00e9crit en fran\u00e7ais : - Prendre le deuxi\u00e8me \u00e9l\u00e9ment du tableau et l\u2019ins\u00e9rer \u00e0 sa place parmi les \u00e9l\u00e9ments qui le pr\u00e9c\u00e8de - Prendre le troisi\u00e8me \u00e9l\u00e9ment du tableau et l\u2019ins\u00e9rer \u00e0 sa place parmi les \u00e9l\u00e9ments qui le pr\u00e9c\u00e8de - Continuer de cette fa\u00e7on jusqu\u2019\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Le tri par s\u00e9lection parcourt donc \u00e9galement le tableau de la gauche vers la droite, en maintenant une partie d\u00e9j\u00e0 tri\u00e9e sur la gauche. Au lieu de chercher la plus petite valeur dans la partie de droite, le tri par insertion va ins\u00e9rer la premi\u00e8re valeur non encore tri\u00e9e au bon endroit dans la partie de gauche d\u00e9j\u00e0 tri\u00e9e. Exercice : Question 1. Appliquez l\u2019algorithme de tri par insertion sur le tableau suivant. Vous \u00e9crirez l\u2019\u00e9tat du tableau \u00e0 l\u2019issue de chaque it\u00e9ration. T = [8, 3, 11, 7, 9, 2] Question 2. Combien de comparaisons et d\u2019\u00e9changes sont n\u00e9cessaires pour trier par insertion un tableau de taille n dans le pire des cas ? Exercice : \u00c9crivez une fonction tri_par_insertion(T) qui trie par insertion le tableau T dans l\u2019ordre croissant. Tri fusion \u2693\ufe0e Principe \u2693\ufe0e Voici un deuxi\u00e8me exemple d'application de cette strat\u00e9gie : le tri fusion . On doit cet algorithme \u00e0 John Von Neumann . On dispose d'une liste d'entiers que l'on veut trier dans l'ordre croissant. On scinde cette liste en deux listes de longueurs \u00ab \u00e0 peu pr\u00e8s \u00e9gales \u00bb. On trie ces listes en utilisant... le tri fusion. (on tri donc le mani\u00e8re r\u00e9cursive) 3. On fusionne les deux listes tri\u00e9es par ordre croissant pour ne plus en obtenir qu'une. \u2693\ufe0e Un exemple lien video Une chor\u00e9graphie du tri fusion Code correspondant \u2693\ufe0e Voici comment coder le tri fusion : On a tout d'abord besoin d'une fonction scinde qui renvoie la premi\u00e8re moiti\u00e9 et la deuxi\u00e8me moiti\u00e9 de la liste qu'on lui passe en argument. \ud83d\udc0d Script Python def scinde ( L ): \"\"\"prend une liste L et renvoie un couple de deux listes de taille identique (\u00e0 l'unit\u00e9 pr\u00e8s) de sorte que leur r\u00e9union soit la liste L de d\u00e9part \"\"\" lg = len ( L ) if lg < 2 : return L , [] else : p = lg // 2 q = lg - p L1 , L2 = [ 0 ] * q , [ 0 ] * p for i in range ( lg ): if i < q : L1 [ i ] = L [ i ] else : L2 [ i - q ] = L [ i ] return L1 , L2 Version avec slice \ud83d\udc0d Script Python def scinde ( lst : list ) -> tuple : return lst [: len ( lst ) // 2 ], lst [ len ( lst ) // 2 :] Ensuite, on a besoin d'une fonction fusion qui, \u00e9tant donn\u00e9e deux listes tri\u00e9es, les fusionne. \ud83d\udc0d Script Python def fusion ( L1 , L2 ): '''r\u00e9alise la fusion de deux listes tri\u00e9es, le r\u00e9sultat est une liste tri\u00e9e''' n1 , n2 = len ( L1 ), len ( L2 ) n = n1 + n2 L = [ 0 ] * n i , i1 , i2 = 0 , 0 , 0 while i1 < n1 and i2 < n2 : if L1 [ i1 ] < L2 [ i2 ]: L [ i ] = L1 [ i1 ] i1 += 1 else : L [ i ] = L2 [ i2 ] i2 += 1 i += 1 # ici on a vid\u00e9 l'une ou l'autre des deux listes # s'il faut encore vider L1 while i1 < n1 : L [ i ] = L1 [ i1 ] i1 += 1 i += 1 # s'il faut encore vider L2 while i2 < n2 : L [ i ] = L2 [ i2 ] i2 += 1 i += 1 return L Enfin, la fonction tri_fusion . \ud83d\udc0d Script Python def tri_fusion ( L ): if len ( L ) < 2 : return L else : L1 , L2 = scinde ( L ) return fusion ( tri_fusion ( L1 ), tri_fusion ( L2 )) Complexit\u00e9 du tri fusion \u2693\ufe0e \u27a1 La partie \u201cdiviser\u201d est de complexit\u00e9 constante. Pour pouvoir majorer le nombre maximum d\u2019it\u00e9rations, si le tableau contient P valeurs, et si on a un entier \\(n\\) tel que \\(P \\leq 2^n\\) , alors puisque qu\u2019\u00e0 chaque it\u00e9ration, on s\u00e9lectionne une moiti\u00e9 de ce qui reste : au bout d\u2019une it\u00e9ration, une moiti\u00e9 de tableau aura au plus \\(\\dfrac{2^n}{2} = 2^{n\u22121}\\) \u00e9l\u00e9ments, un quart aura au plus \\(2^{n\u22122}\\) et au bout de \\(k\\) it\u00e9rations, la taille de ce qui reste \u00e0 \u00e9tudier est de taille au plus \\(2^{n\u2212k}\\) . En particulier, si l\u2019on fait \\(n\\) it\u00e9rations, il reste au plus \\(2^{n\u2212n} = 1\\) valeur du tableau \u00e0 examiner. On est s\u00fbr de s\u2019arr\u00eater cette fois-ci On a donc montr\u00e9 que si l\u2019entier \\(n\\) v\u00e9rifie \\(P \\leq 2^n\\) , alors l\u2019algorithme va effectuer au plus \\(n\\) it\u00e9rations. La plus petite valeur est obtenue pour \\(n = log_2 P\\) . Ainsi, la complexit\u00e9 de la fonction est de l\u2019ordre du logarithme de la longueur de la liste ( \\(O(log_2(n))\\) ). \\(log_2(n)\\) . Exemple Pour un tableau de taille n = 64 il faut : 64/2=32,32/2=16,16/2=8,8/2=4,4/2=2,2/2=1 : 6 \u00e9tapes. \\(2^6=64\\) . Comme toujours quand on peut s\u00e9parer le tableau en deux, la m\u00e9thode diviser pour r\u00e9gner permet de ne r\u00e9aliser que \\(log_2 n\\) \u00e9tapes. Mais\u2026 \u27a1 Complexit\u00e9 fusion La partie fusion utilise une boucle qui parcourt plusieurs tableaux en m\u00eame temps. On r\u00e9alise \u00e0 chaque \u00e9tape la m\u00eame chose : lire deux valeurs, comparer, ranger la plus petite. La complexit\u00e9 est lin\u00e9aire. Notons \\(n\\) la taille de la liste \u00e0 trier et consid\u00e9rons comme seule op\u00e9ration \u00e9l\u00e9mentaire le fait d'acc\u00e9der \u00e0 un \u00e9l\u00e9ment d'une liste. Complexit\u00e9 du tri fusion Le nombre d'op\u00e9rations \u00e9l\u00e9mentaires n\u00e9cessaires pour trier une liste de taille \\(n\\) par la m\u00e9thode du tri fusion est de l'ordre de \\(n\\times\\log_2 n\\) . IV. Application : Exercices de l'Epreuve Pratique \u2693\ufe0e Sujet 23 - Exercice 2 La fonction fusion prend deux listes L1, L2 d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e L12 qu\u2019elle renvoie. Le code Python de la fonction est \ud83d\udc0d Script Python def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = ... i1 = ... else : L12 [ i ] = L2 [ i2 ] i2 = ... i += 1 while i1 < n1 : L12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : L12 [ i ] = ... i2 = i2 + 1 i = ... return L12 \u2693\ufe0e Compl\u00e9ter le code. Exemple : \ud83d\udc0d Script Python >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] Recherche dichotomique \u2693\ufe0e EX : Recherche dichotomique Expliquer pourquoi la recherche dichotomique d'un \u00e9l\u00e9ment dans une liste d'entiers tri\u00e9s dans l'ordre croissant peut \u00eatre vue comme un exemple de strat\u00e9gie \u00ab diviser pour r\u00e9gner \u00bb. Programmer la recherche dichotomique de mani\u00e8re r\u00e9cursive. V. Exercices BAC \u2693\ufe0e Sujet n\u00b01 : France 2021 \u2693\ufe0e Cet exercice porte sur l\u2019algorithme de tri fusion, qui s\u2019appuie sur la m\u00e9thode dite de \u00ab diviser pour r\u00e9gner \u00bb. Question 1 a. Quel est l\u2019ordre de grandeur du co\u00fbt, en nombre de comparaisons, de l\u2019algorithme de tri fusion pour une liste de longueur ? b. Citer le nom d\u2019un autre algorithme de tri. Donner l\u2019ordre de grandeur de son co\u00fbt, en nombre de comparaisons, pour une liste de longueur . Comparer ce co\u00fbt \u00e0 celui du tri fusion. Aucune justification n\u2019est attendue. L\u2019algorithme de tri fusion utilise deux fonctions moitie_gauche et moitie_droite qui prennent en argument une liste L et renvoient respectivement : - la sous-liste de L form\u00e9e des \u00e9l\u00e9ments d\u2019indice strictement inf\u00e9rieur \u00e0 len(L)//2 ; - la sous-liste de L form\u00e9e des \u00e9l\u00e9ments d\u2019indice sup\u00e9rieur ou \u00e9gal \u00e0 len(L)//2 . On rappelle que la syntaxe a//b d\u00e9signe la division enti\u00e8re de a par b. Par exemple, \ud83d\udc0d Script Python >>> L = [ 3 , 5 , 2 , 7 , 1 , 9 , 0 ] >>> moitie_gauche ( L ) [ 3 , 5 , 2 ] >>> moitie_droite ( L ) [ 7 , 1 , 9 , 0 ] >>> M = [ 4 , 1 , 11 , 7 ] >>> moitie_gauche ( M ) [ 4 , 1 ] >>> moitie_droite ( M ) [ 11 , 7 ] L\u2019algorithme utilise aussi une fonction fusion qui prend en argument deux listes tri\u00e9es L1 et L2 et renvoie une liste L tri\u00e9e et compos\u00e9e des \u00e9l\u00e9ments de L1 et L2. On donne ci-dessous le code python d\u2019une fonction r\u00e9cursive tri_fusion qui prend en argument une liste L et renvoie une nouvelle liste tri\u00e9e form\u00e9e des \u00e9l\u00e9ments de L. \ud83d\udc0d Script Python def tri_fusion ( L ): n = len ( L ) if n <= 1 : return L print ( L ) mg = moitie_gauche ( L ) md = moitie_droite ( L ) L1 = tri_fusion ( mg ) L2 = tri_fusion ( md ) return fusion ( L1 , L2 ) Question 2 Donner la liste des affichages produits par l\u2019appel suivant. \ud83d\udc0d Script Python tri_fusion ([ 7 , 4 , 2 , 1 , 8 , 5 , 6 , 3 ]) On s\u2019int\u00e9resse d\u00e9sormais \u00e0 diff\u00e9rentes fonctions appel\u00e9es par tri_fusion , \u00e0 savoir moitie_droite et fusion. Question 3 \u00c9crire la fonction moitie_droite . Question 4 On donne ci-dessous une version incompl\u00e8te de la fonction fusion. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def fusion ( L1 , L2 ): L = [] n1 = len ( L1 ) n2 = len ( L2 ) i1 = 0 i2 = 0 while i1 < n1 or i2 < n2 : if i1 >= n1 : L . append ( L2 [ i2 ]) i2 = i2 + 1 elif i2 >= n2 : L . append ( L1 [ i1 ]) i1 = i1 + 1 else : e1 = L1 [ i1 ] e2 = L2 [ i2 ] return L Dans cette fonction, les entiers i1 et i2 repr\u00e9sentent respectivement les indices des \u00e9l\u00e9ments des listes L1 et L2 que l\u2019on souhaite comparer : Si aucun des deux indices n\u2019est valide, la boucle while est interrompue ; Si i1 n\u2019est plus un indice valide, on va ajouter \u00e0 L les \u00e9l\u00e9ments de L2 \u00e0 partir de l\u2019indice i2 ; Si i2 n\u2019est plus un indice valide, on va ajouter \u00e0 L les \u00e9l\u00e9ments de L1 \u00e0 partir de l\u2019indice i1 ; Sinon, le plus petit \u00e9l\u00e9ment non encore trait\u00e9 est ajout\u00e9 \u00e0 L et on d\u00e9cale l\u2019indice correspondant. \u00c9crire sur la copie les instructions manquantes des lignes 17 \u00e0 22 permettant d\u2019ins\u00e9rer dans la liste L les \u00e9l\u00e9ments des listes L1 et L2 par ordre croissant. Sujet n\u00b02 : BAC Polyn\u00e9sie 2021 \u2693\ufe0e Cet exercice traite principalement du th\u00e8me \u00ab algorithmique, langages et programmation \u00bb. Le but est de comparer le tri par insertion (l'un des algorithmes \u00e9tudi\u00e9s en 1\u00e8re NSI pour trier un tableau) avec le tri fusion (un algorithme qui applique le principe de \u00ab diviser pour r\u00e9gner \u00bb). Partie A : Manipulation d\u2019une liste en Python \u2693\ufe0e Question A.1 Donner les affichages obtenus apr\u00e8s l\u2019ex\u00e9cution du code Python suivant. \ud83d\udc0d Script Python notes = [ 8 , 7 , 18 , 14 , 12 , 9 , 17 , 3 ] notes [ 3 ] = 16 print ( len ( notes )) print ( notes ) Question A.2 \u00c9crire un code Python permettant d'afficher les \u00e9l\u00e9ments d'indice 2 \u00e0 4 de la liste notes. Partie B : Tri par insertion \u2693\ufe0e Le tri par insertion est un algorithme efficace qui s'inspire de la fa\u00e7on dont on peut trier une poign\u00e9e de cartes. On commence avec une seule carte dans la main gauche (les autres cartes sont en tas sur la table) puis on pioche la carte suivante et on l'ins\u00e8re au bon endroit dans la main gauche. Question B.1 Voici une impl\u00e9mentation en Python de cet algorithme. Recopier et compl\u00e9ter les lignes 6 et 7 surlign\u00e9es (uniquement celles-ci). \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def tri_insertion ( liste ): \"\"\" trie par insertion la liste en param\u00e8tre \"\"\" for indice_courant in range ( 1 , len ( liste )): element_a_inserer = liste [ indice_courant ] i = indice_courant - 1 while i >= 0 and liste [ i ] > ................................ : liste [ ........... ] = liste [ ........... ] i = i - 1 liste [ i + 1 ] = element_a_inserer On a \u00e9crit dans la console les instructions suivantes : \ud83d\udc0d Script Python notes = [ 8 , 7 , 18 , 14 , 12 , 9 , 17 , 3 ] tri_insertion ( notes ) print ( notes ) On a obtenu l'affichage suivant : \ud83d\udc0d Script Python [ 3 , 7 , 8 , 9 , 12 , 14 , 17 , 18 ] On s'interroge sur ce qui s\u2019est pass\u00e9 lors de l\u2019ex\u00e9cution de tri_insertion(notes) . \u2693\ufe0e Question B.2 Donner le contenu de la liste notes apr\u00e8s le premier passage dans la boucle for. Question B.3 Donner le contenu de la liste notes apr\u00e8s le troisi\u00e8me passage dans la boucle for. Partie C : Tri fusion \u2693\ufe0e L'algorithme de tri fusion suit le principe de \u00ab diviser pour r\u00e9gner \u00bb. (1) Si le tableau \u00e0 trier n\u2019a qu\u2019un \u00e9l\u00e9ment, il est d\u00e9j\u00e0 tri\u00e9. (2) Sinon, s\u00e9parer le tableau en deux parties \u00e0 peu pr\u00e8s \u00e9gales. (3) Trier les deux parties avec l\u2019algorithme de tri fusion. (4) Fusionner les deux tableaux tri\u00e9s en un seul tableau. source : Wikipedia Question C.1 Cet algorithme est-il it\u00e9ratif ou r\u00e9cursif ? Justifier en une phrase. Question C.2 Expliquer en trois lignes comment faire pour rassembler dans une main deux tas d\u00e9j\u00e0 tri\u00e9s de cartes, la carte en haut d'un tas \u00e9tant la plus petite de ce m\u00eame tas ; la deuxi\u00e8me carte d'un tas n'\u00e9tant visible qu'apr\u00e8s avoir retir\u00e9 la premi\u00e8re carte de ce tas. \u00c0 la fin du proc\u00e9d\u00e9, les cartes en main doivent \u00eatre tri\u00e9es par ordre croissant. Une fonction fusionner a \u00e9t\u00e9 impl\u00e9ment\u00e9e en Python en s'inspirant du proc\u00e9d\u00e9 de la question pr\u00e9c\u00e9dente. Elle prend quatre arguments : la liste qui est en train d'\u00eatre tri\u00e9e, l'indice o\u00f9 commence la sous-liste de gauche \u00e0 fusionner, l'indice o\u00f9 termine cette sousliste, et l'indice o\u00f9 se termine la sous-liste de droite. Question C.3 Voici une impl\u00e9mentation de l\u2019algorithme de tri fusion. Recopier et compl\u00e9ter les lignes 8, 9 et 10 surlign\u00e9es (uniquement celles-ci). \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 from math import floor def tri_fusion ( liste , i_debut , i_fin ): \"\"\" trie par fusion la liste en param\u00e8tre depuis i_debut jusqu\u2019\u00e0 i_fin \"\"\" if i_debut < i_fin : i_partage = floor (( i_debut + i_fin ) / 2 ) tri_fusion ( liste , i_debut , .............................. ) tri_fusion ( liste , ................................... , i_fin ) fusionner ( liste , ......................... , ......................... , ...................... ) Remarque : la fonction floor renvoie la partie enti\u00e8re du nombre pass\u00e9 en param\u00e8tre. Question C.4 Expliquer le r\u00f4le de la premi\u00e8re ligne du code de la question 3. Partie D : Comparaison du tri par insertion et du tri fusion \u2693\ufe0e Voici une illustration des \u00e9tapes d\u2019un tri effectu\u00e9 sur la liste [3, 41, 52, 26, 38, 57, 9, 49] . Question D.1 Quel algorithme a \u00e9t\u00e9 utilis\u00e9 : le tri par insertion ou le tri fusion ? Justifier. Question D.2 Identifier le tri qui a une complexit\u00e9, dans le pire des cas, en \\(O(n^2)\\) et identifier le tri qui a une complexit\u00e9, dans le pire des cas, en \\(O(n log2 n)\\) . Remarque : \\(n\\) repr\u00e9sente la longueur de la liste \u00e0 trier. Question D.3 Justifier bri\u00e8vement ces deux complexit\u00e9s. Sujet n\u00b03 : FRANCE CANDIDAT LIBRE SUJET 1 \u2693\ufe0e Cet exercice traite de manipulation de tableaux, de r\u00e9cursivit\u00e9 et du paradigme \u00ab diviser pour r\u00e9gner \u00bb. Dans un tableau Python d'entiers tab, on dit que le couple d\u2019indices (\u0745,\u0746) forme une inversion lorsque \u0745 < \u0746 et tab[i] > tab[j] . On donne ci-dessous quelques exemples. Dans le tableau [1, 5, 3, 7], le couple d\u2019indices (1,2) forme une inversion car 5> 3. Par contre, le couple (1,3) ne forme pas d'inversion car 5<7. Il n\u2019y a qu\u2019une inversion dans ce tableau. Il y a trois inversions dans le tableau [1, 6, 2, 7, 3], \u00e0 savoir les couples d'indices (1, 2), (1, 4) et (3, 4). On peut compter six inversions dans le tableau [7, 6, 5, 3] : les couples d'indices (0, 1), (0, 2), (0, 3), (1, 2), (1, 3) et (2, 3). On se propose dans cet exercice de d\u00e9terminer le nombre d\u2019inversions dans un tableau quelconque. Questions pr\u00e9liminaires Question 1 Expliquer pourquoi le couple (1, 3) est une inversion dans le tableau [4, 8, 3, 7]. Question 2 Justifier que le couple (2, 3) n\u2019en est pas une. Partie A : M\u00e9thode it\u00e9rative \u2693\ufe0e Le but de cette partie est d\u2019\u00e9crire une fonction it\u00e9rative nombre_inversion qui renvoie le nombre d\u2019inversions dans un tableau. Pour cela, on commence par \u00e9crire une fonction fonction1 qui sera ensuite utilis\u00e9e pour \u00e9crire la fonction nombre_inversion . Question A.1 On donne la fonction suivante. \ud83d\udc0d Script Python def fonction1 ( tab , i ): nb_elem = len ( tab ) cpt = 0 for j in range ( i + 1 , nb_elem ): if tab [ j ] < tab [ i ]: cpt += 1 return cpt a. Indiquer ce que renvoie la fonction1(tab, i) dans les cas suivants. Cas n\u00b01 : tab = [1, 5, 3, 7] et i = 0. Cas n\u00b02 : tab = [1, 5, 3, 7] et i = 1. Cas n\u00b03 : tab = [1, 5, 2, 6, 4] et i = 1. b. Expliquer ce que permet de d\u00e9terminer cette fonction. Question A.2 En utilisant la fonction pr\u00e9c\u00e9dente, \u00e9crire une fonction nombre_inversion(tab) qui prend en argument un tableau et renvoie le nombre d\u2019inversions dans ce tableau. On donne ci-dessous les r\u00e9sultats attendus pour certains appels. \ud83d\udc0d Script Python >>> nombre_inversions ([ 1 , 5 , 7 ]) 0 >>> nombre_inversions ([ 1 , 6 , 2 , 7 , 3 ]) 3 >>> nombre_inversions ([ 7 , 6 , 5 , 3 ]) 6 Question A.3 Quelle est l\u2019ordre de grandeur de la complexit\u00e9 en temps de l'algorithme obtenu ? Aucune justification n'est attendue. Partie B : M\u00e9thode r\u00e9cursive \u2693\ufe0e Le but de cette partie est de concevoir une version r\u00e9cursive de la fonction nombre_inversion . On d\u00e9finit pour cela des fonctions auxiliaires. Question B.1 Donner le nom d\u2019un algorithme de tri ayant une complexit\u00e9 meilleure que quadratique. Dans la suite de cet exercice, on suppose qu\u2019on dispose d'une fonction tri(tab) qui prend en argument un tableau et renvoie un tableau contenant les m\u00eames \u00e9l\u00e9ments rang\u00e9s dans l'ordre croissant. Question B.2 \u00c9crire une fonction moitie_gauche(tab) qui prend en argument un tableau tab et renvoie un nouveau tableau contenant la moiti\u00e9 gauche de tab. Si le nombre d'\u00e9l\u00e9ments de tab est impair, l'\u00e9l\u00e9ment du centre se trouve dans cette partie gauche. On donne ci-dessous les r\u00e9sultats attendus pour certains appels. \ud83d\udc0d Script Python >>> moitie_gauche ([]) [] >>> moitie_gauche ([ 4 , 8 , 3 ]) [ 4 , 8 ] >>> moitie_gauche ([ 4 , 8 , 3 , 7 ]) [ 4 , 8 ] Dans la suite, on suppose qu\u2019on dispose de la fonction moitie_droite(tab) qui renvoie la moiti\u00e9 droite sans l\u2019\u00e9l\u00e9ment du milieu. Question B.3 On suppose qu\u2019une fonction nb_inv_tab(tab1, tab2) a \u00e9t\u00e9 \u00e9crite. Cette fonction renvoie le nombre d\u2019inversions du tableau obtenu en mettant bout \u00e0 bout les tableaux tab1 et tab2 , \u00e0 condition que tab1 et tab2 soient tri\u00e9s dans l\u2019ordre croissant. On donne ci-dessous deux exemples d\u2019appel de cette fonction : \ud83d\udc0d Script Python >>> nb_inv_tab ([ 3 , 7 , 9 ], [ 2 , 10 ]) 3 >>> nb_inv_tab ([ 7 , 9 , 13 ], [ 7 , 10 , 14 ]) 3 En utilisant la fonction nb_inv_tab et les questions pr\u00e9c\u00e9dentes, \u00e9crire une fonction r\u00e9cursive nb_inversions_rec(tab) qui permet de calculer le nombre d'inversions dans un tableau. Cette fonction renverra le m\u00eame nombre que nombre_inversions(tab) de la partie A. On proc\u00e9dera de la fa\u00e7on suivante : S\u00e9parer le tableau en deux tableaux de tailles \u00e9gales (\u00e0 une unit\u00e9 pr\u00e8s). Appeler r\u00e9cursivement la fonction nb_inversions_rec pour compter le nombre d\u2019inversions dans chacun des deux tableaux. Trier les deux tableaux (on rappelle qu'une fonction de tri est d\u00e9j\u00e0 d\u00e9finie). Ajouter au nombre d'inversions pr\u00e9c\u00e9demment compt\u00e9es le nombre renvoy\u00e9 par la fonction nb_inv_tab avec pour arguments les deux tableaux tri\u00e9s. Question 2. En utilisant les slices, compl\u00e9tez la fonction suivante. \ud83d\udc0d Script Python def est_palindrome ( ch ): if len ( ch ) <= 1 : return ... else : return ... Question 3. Au moyen du mot cl\u00e9 assert, \u00e9crivez un bon jeu de tests pour cette fonction. V\u00e9rifiez que les tests passent avec succ\u00e8s. Question 4. Expliquez pourquoi cet algorithme est un exemple de la m\u00e9thode diviser pour r\u00e9gner. Question 5. Utiliser Python tutor, ex\u00e9cutez en mode pas \u00e0 pas le d\u00e9roulement des appels r\u00e9cursifs de cette fonction pour la cha\u00eene \"ressasser\". Si la cha\u00eene de d\u00e9part est un palindrome de longueur n, combien de comparaisons sont effectu\u00e9es ? En d\u00e9duite le co\u00fbt en temps de cet algorithme (sa complexit\u00e9) dans le pire des cas. Question 6. Le slicing a un co\u00fbt en m\u00e9moire cach\u00e9. En effet, chaque appel ch[1:-1] induit la cr\u00e9ation d\u2019une nouvelle cha\u00eene qu\u2019il faut stocker en m\u00e9moire. On peut le voir facilement avec Python tutor. Dans le pire cas, pour une cha\u00eene de longueur n au d\u00e9part, combien de cha\u00eenes doivent \u00eatre cr\u00e9\u00e9es pour r\u00e9pondre au probl\u00e8me ? Partie B \u2693\ufe0e Une deuxi\u00e8me version am\u00e9lior\u00e9e \u2693\ufe0e En r\u00e9alit\u00e9, on peut se passer de la cr\u00e9ation de toutes ces cha\u00eenes interm\u00e9diaires en utilisant et en faisant varier (comme pour la recherche dichotomique) les indices g (pour gauche) et d (pour droite) des caract\u00e8res restants. Voici une fonction palindrome(ch, g, d) qui renvoie True si la chaine ch[g..d] (c\u2019est-\u00e0-dire la cha\u00eene ch limit\u00e9e \u00e0 ses caract\u00e8res entre les positions g et d) est un palindrome et False sinon. \ud83d\udc0d Script Python def palindrome ( ch , g , d ): if d - g < 1 : return True else : return ch [ g ] == ch [ d ] and palindrome ( ch , g + 1 , d - 1 ) **Question 7. Quel appel \u00e0 cette fonction faut-il faire pour tester si mot est un palindrome ? \ud83d\udc0d Script Python mot = \"ressasser\" # \u00e0 compl\u00e9ter par le bon appel : \u2693\ufe0e Pour \u00e9viter cette \u00e9criture un peu lourde, il suffit de cr\u00e9er une autre fonction est_palindrome2(ch) qui est charg\u00e9e de lancer le premier appel \u00e0 la fonction r\u00e9cursive palindrome. Compl\u00e9tez le code de la fonction est_palindrome2(ch) . Question 8. \ud83d\udc0d Script Python def est_palindrome2 ( ch ): # \u00e0 compl\u00e9ter pass La fonction est_palindrome2 est appel\u00e9e une fonction d\u2019interface qui permet d\u2019ajouter des arguments \u00e0 une fonction sans que l\u2019utilisateur ait \u00e0 s\u2019en pr\u00e9occuper. Question 9. V\u00e9rifiez avec Python tutor qu\u2019avec cette version, il n\u2019y a qu\u2019une cha\u00eene ch \u00e0 m\u00e9moriser (celle de d\u00e9part). On obtient un algorithme avec un co\u00fbt m\u00e9moire inf\u00e9rieur \u00e0 la premi\u00e8re version. III. Les tris : tri par s\u00e9lection et tri par insertion - Tri fusion \u2693\ufe0e Tri par s\u00e9lection \u2693\ufe0e Tri par s\u00e9lection Voici l\u2019algorithme du tri par s\u00e9lection \u00e9crit en fran\u00e7ais : - Rechercher le plus petit \u00e9l\u00e9ment du tableau, et l\u2019\u00e9changer avec l\u2019\u00e9l\u00e9ment d\u2019indice 0 ; - Rechercher le second plus petit \u00e9l\u00e9ment du tableau, et l\u2019\u00e9changer avec l\u2019\u00e9l\u00e9ment d\u2019indice 1 ; - Continuer de cette fa\u00e7on jusqu\u2019\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9 Le tri par s\u00e9lection parcourt ainsi le tableau de la gauche vers la droite, en maintenant sur la gauche une partie d\u00e9j\u00e0 tri\u00e9e et \u00e0 sa place d\u00e9finitive. ---$ Animation explicative du tri par s\u00e9lection Exercice Question 1 Appliquez l\u2019algorithme de tri par s\u00e9lection sur le tableau suivant. Vous \u00e9crirez l\u2019\u00e9tat du tableau \u00e0 l\u2019issue de chaque it\u00e9ration. T = [8, 3, 11, 7, 9, 2] Question 2. D\u00e9terminer la complexit\u00e9 de cette algorithme : Combien de comparaisons sont n\u00e9cessaires pour trier par s\u00e9lection un tableau de taille n dans le pire des cas ? Exercice Question 1. \u00c9crivez une fonction echange(T, i, j) qui \u00e9change les \u00e9l\u00e9ments d\u2019indices T[i] et T[j] dans le tableau T . Question 2. \u00c9crivez une fonction tri_par_selection(T) , utilisant la fonction echange , qui trie par s\u00e9lection le tableau T dans l\u2019ordre croissant. Tri par insertion (rappels) \u2693\ufe0e Tri par insertion Voici l\u2019algorithme du tri par insertion \u00e9crit en fran\u00e7ais : - Prendre le deuxi\u00e8me \u00e9l\u00e9ment du tableau et l\u2019ins\u00e9rer \u00e0 sa place parmi les \u00e9l\u00e9ments qui le pr\u00e9c\u00e8de - Prendre le troisi\u00e8me \u00e9l\u00e9ment du tableau et l\u2019ins\u00e9rer \u00e0 sa place parmi les \u00e9l\u00e9ments qui le pr\u00e9c\u00e8de - Continuer de cette fa\u00e7on jusqu\u2019\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Le tri par s\u00e9lection parcourt donc \u00e9galement le tableau de la gauche vers la droite, en maintenant une partie d\u00e9j\u00e0 tri\u00e9e sur la gauche. Au lieu de chercher la plus petite valeur dans la partie de droite, le tri par insertion va ins\u00e9rer la premi\u00e8re valeur non encore tri\u00e9e au bon endroit dans la partie de gauche d\u00e9j\u00e0 tri\u00e9e. Exercice : Question 1. Appliquez l\u2019algorithme de tri par insertion sur le tableau suivant. Vous \u00e9crirez l\u2019\u00e9tat du tableau \u00e0 l\u2019issue de chaque it\u00e9ration. T = [8, 3, 11, 7, 9, 2] Question 2. Combien de comparaisons et d\u2019\u00e9changes sont n\u00e9cessaires pour trier par insertion un tableau de taille n dans le pire des cas ? Exercice : \u00c9crivez une fonction tri_par_insertion(T) qui trie par insertion le tableau T dans l\u2019ordre croissant. Tri fusion \u2693\ufe0e Principe \u2693\ufe0e Voici un deuxi\u00e8me exemple d'application de cette strat\u00e9gie : le tri fusion . On doit cet algorithme \u00e0 John Von Neumann . On dispose d'une liste d'entiers que l'on veut trier dans l'ordre croissant. On scinde cette liste en deux listes de longueurs \u00ab \u00e0 peu pr\u00e8s \u00e9gales \u00bb. On trie ces listes en utilisant... le tri fusion. (on tri donc le mani\u00e8re r\u00e9cursive) 3. On fusionne les deux listes tri\u00e9es par ordre croissant pour ne plus en obtenir qu'une. \u2693\ufe0e Un exemple lien video Une chor\u00e9graphie du tri fusion Code correspondant \u2693\ufe0e Voici comment coder le tri fusion : On a tout d'abord besoin d'une fonction scinde qui renvoie la premi\u00e8re moiti\u00e9 et la deuxi\u00e8me moiti\u00e9 de la liste qu'on lui passe en argument. \ud83d\udc0d Script Python def scinde ( L ): \"\"\"prend une liste L et renvoie un couple de deux listes de taille identique (\u00e0 l'unit\u00e9 pr\u00e8s) de sorte que leur r\u00e9union soit la liste L de d\u00e9part \"\"\" lg = len ( L ) if lg < 2 : return L , [] else : p = lg // 2 q = lg - p L1 , L2 = [ 0 ] * q , [ 0 ] * p for i in range ( lg ): if i < q : L1 [ i ] = L [ i ] else : L2 [ i - q ] = L [ i ] return L1 , L2 Version aevc slice \ud83d\udc0d Script Python def scinde ( lst : list ) -> tuple : return lst [: len ( lst ) // 2 ], lst [ len ( lst ) // 2 :] Ensuite, on a besoin d'une fonction fusion qui, \u00e9tant donn\u00e9e deux listes tri\u00e9es, les fusionne. \ud83d\udc0d Script Python def fusion ( L1 , L2 ): '''r\u00e9alise la fusion de deux listes tri\u00e9es, le r\u00e9sultat est une liste tri\u00e9e''' n1 , n2 = len ( L1 ), len ( L2 ) n = n1 + n2 L = [ 0 ] * n i , i1 , i2 = 0 , 0 , 0 while i1 < n1 and i2 < n2 : if L1 [ i1 ] < L2 [ i2 ]: L [ i ] = L1 [ i1 ] i1 += 1 else : L [ i ] = L2 [ i2 ] i2 += 1 i += 1 # ici on a vid\u00e9 l'une ou l'autre des deux listes # s'il faut encore vider L1 while i1 < n1 : L [ i ] = L1 [ i1 ] i1 += 1 i += 1 # s'il faut encore vider L2 while i2 < n2 : L [ i ] = L2 [ i2 ] i2 += 1 i += 1 return L Enfin, la fonction tri_fusion . \ud83d\udc0d Script Python def tri_fusion ( L ): if len ( L ) < 2 : return L else : L1 , L2 = scinde ( L ) return fusion ( tri_fusion ( L1 ), tri_fusion ( L2 )) Complexit\u00e9 du tri fusion \u2693\ufe0e \u27a1 La partie \u201cdiviser\u201d est de complexit\u00e9 constante. Pour pouvoir majorer le nombre maximum d\u2019it\u00e9rations, si le tableau contient P valeurs, et si on a un entier \\(n\\) tel que \\(P \\leq 2^n\\) , alors puisque qu\u2019\u00e0 chaque it\u00e9ration, on s\u00e9lectionne une moiti\u00e9 de ce qui reste : au bout d\u2019une it\u00e9ration, une moiti\u00e9 de tableau aura au plus \\(\\dfrac{2^n}{2} = 2^{n\u22121}\\) \u00e9l\u00e9ments, un quart aura au plus \\(2^{n\u22122}\\) et au bout de \\(k\\) it\u00e9rations, la taille de ce qui reste \u00e0 \u00e9tudier est de taille au plus \\(2^{n\u2212k}\\) . En particulier, si l\u2019on fait \\(n\\) it\u00e9rations, il reste au plus \\(2^{n\u2212n} = 1\\) valeur du tableau \u00e0 examiner. On est s\u00fbr de s\u2019arr\u00eater cette fois-ci On a donc montr\u00e9 que si l\u2019entier \\(n\\) v\u00e9rifie \\(P \\leq 2^n\\) , alors l\u2019algorithme va effectuer au plus \\(n\\) it\u00e9rations. La plus petite valeur est obtenue pour \\(n = log_2 P\\) . Ainsi, la complexit\u00e9 de la fonction est de l\u2019ordre du logarithme de la longueur de la liste ( \\(O(log_2(n))\\) ). \\(log_2(n)\\) . Exemple Pour un tableau de taille n = 64 il faut : 64/2=32,32/2=16,16/2=8,8/2=4,4/2=2,2/2=1 : 6 \u00e9tapes. \\(2^6=64\\) . Comme toujours quand on peut s\u00e9parer le tableau en deux, la m\u00e9thode diviser pour r\u00e9gner permet de ne r\u00e9aliser que \\(log_2 n\\) \u00e9tapes. Mais\u2026 \u27a1 Complexit\u00e9 fusion La partie fusion utilise une boucle qui parcourt plusieurs tableaux en m\u00eame temps. On r\u00e9alise \u00e0 chaque \u00e9tape la m\u00eame chose : lire deux valeurs, comparer, ranger la plus petite. La complexit\u00e9 est lin\u00e9aire. Notons \\(n\\) la taille de la liste \u00e0 trier et consid\u00e9rons comme seule op\u00e9ration \u00e9l\u00e9mentaire le fait d'acc\u00e9der \u00e0 un \u00e9l\u00e9ment d'une liste. Complexit\u00e9 du tri fusion Le nombre d'op\u00e9rations \u00e9l\u00e9mentaires n\u00e9cessaires pour trier une liste de taille \\(n\\) par la m\u00e9thode du tri fusion est de l'ordre de \\(n\\times\\log_2 n\\) . IV. Application : Exercices de l'Epreuve Pratique \u2693\ufe0e Sujet 23 - Exercice 2 La fonction fusion prend deux listes L1, L2 d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e L12 qu\u2019elle renvoie. Le code Python de la fonction est \ud83d\udc0d Script Python def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = ... i1 = ... else : L12 [ i ] = L2 [ i2 ] i2 = ... i += 1 while i1 < n1 : L12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : L12 [ i ] = ... i2 = i2 + 1 i = ... return L12 \u2693\ufe0e Compl\u00e9ter le code. Exemple : \ud83d\udc0d Script Python >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] Recherche dichotomique \u2693\ufe0e EX : Recherche dichotomique Expliquer pourquoi la recherche dichotomique d'un \u00e9l\u00e9ment dans une liste d'entiers tri\u00e9s dans l'ordre croissant peut \u00eatre vue comme un exemple de strat\u00e9gie \u00ab diviser pour r\u00e9gner \u00bb. Programmer la recherche dichotomique de mani\u00e8re r\u00e9cursive. V. Exercices BAC \u2693\ufe0e Sujet n\u00b01 : France 2021 \u2693\ufe0e Cet exercice porte sur l\u2019algorithme de tri fusion, qui s\u2019appuie sur la m\u00e9thode dite de \u00ab diviser pour r\u00e9gner \u00bb. Question 1 a. Quel est l\u2019ordre de grandeur du co\u00fbt, en nombre de comparaisons, de l\u2019algorithme de tri fusion pour une liste de longueur ? b. Citer le nom d\u2019un autre algorithme de tri. Donner l\u2019ordre de grandeur de son co\u00fbt, en nombre de comparaisons, pour une liste de longueur . Comparer ce co\u00fbt \u00e0 celui du tri fusion. Aucune justification n\u2019est attendue. L\u2019algorithme de tri fusion utilise deux fonctions moitie_gauche et moitie_droite qui prennent en argument une liste L et renvoient respectivement : - la sous-liste de L form\u00e9e des \u00e9l\u00e9ments d\u2019indice strictement inf\u00e9rieur \u00e0 len(L)//2 ; - la sous-liste de L form\u00e9e des \u00e9l\u00e9ments d\u2019indice sup\u00e9rieur ou \u00e9gal \u00e0 len(L)//2 . On rappelle que la syntaxe a//b d\u00e9signe la division enti\u00e8re de a par b. Par exemple, \ud83d\udc0d Script Python >>> L = [ 3 , 5 , 2 , 7 , 1 , 9 , 0 ] >>> moitie_gauche ( L ) [ 3 , 5 , 2 ] >>> moitie_droite ( L ) [ 7 , 1 , 9 , 0 ] >>> M = [ 4 , 1 , 11 , 7 ] >>> moitie_gauche ( M ) [ 4 , 1 ] >>> moitie_droite ( M ) [ 11 , 7 ] L\u2019algorithme utilise aussi une fonction fusion qui prend en argument deux listes tri\u00e9es L1 et L2 et renvoie une liste L tri\u00e9e et compos\u00e9e des \u00e9l\u00e9ments de L1 et L2. On donne ci-dessous le code python d\u2019une fonction r\u00e9cursive tri_fusion qui prend en argument une liste L et renvoie une nouvelle liste tri\u00e9e form\u00e9e des \u00e9l\u00e9ments de L. \ud83d\udc0d Script Python def tri_fusion ( L ): n = len ( L ) if n <= 1 : return L print ( L ) mg = moitie_gauche ( L ) md = moitie_droite ( L ) L1 = tri_fusion ( mg ) L2 = tri_fusion ( md ) return fusion ( L1 , L2 ) Question 2 Donner la liste des affichages produits par l\u2019appel suivant. \ud83d\udc0d Script Python tri_fusion ([ 7 , 4 , 2 , 1 , 8 , 5 , 6 , 3 ]) On s\u2019int\u00e9resse d\u00e9sormais \u00e0 diff\u00e9rentes fonctions appel\u00e9es par tri_fusion , \u00e0 savoir moitie_droite et fusion. Question 3 \u00c9crire la fonction moitie_droite . Question 4 On donne ci-dessous une version incompl\u00e8te de la fonction fusion. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def fusion ( L1 , L2 ): L = [] n1 = len ( L1 ) n2 = len ( L2 ) i1 = 0 i2 = 0 while i1 < n1 or i2 < n2 : if i1 >= n1 : L . append ( L2 [ i2 ]) i2 = i2 + 1 elif i2 >= n2 : L . append ( L1 [ i1 ]) i1 = i1 + 1 else : e1 = L1 [ i1 ] e2 = L2 [ i2 ] return L Dans cette fonction, les entiers i1 et i2 repr\u00e9sentent respectivement les indices des \u00e9l\u00e9ments des listes L1 et L2 que l\u2019on souhaite comparer : Si aucun des deux indices n\u2019est valide, la boucle while est interrompue ; Si i1 n\u2019est plus un indice valide, on va ajouter \u00e0 L les \u00e9l\u00e9ments de L2 \u00e0 partir de l\u2019indice i2 ; Si i2 n\u2019est plus un indice valide, on va ajouter \u00e0 L les \u00e9l\u00e9ments de L1 \u00e0 partir de l\u2019indice i1 ; Sinon, le plus petit \u00e9l\u00e9ment non encore trait\u00e9 est ajout\u00e9 \u00e0 L et on d\u00e9cale l\u2019indice correspondant. \u00c9crire sur la copie les instructions manquantes des lignes 17 \u00e0 22 permettant d\u2019ins\u00e9rer dans la liste L les \u00e9l\u00e9ments des listes L1 et L2 par ordre croissant. Sujet n\u00b02 : BAC Polyn\u00e9sie 2021 \u2693\ufe0e Cet exercice traite principalement du th\u00e8me \u00ab algorithmique, langages et programmation \u00bb. Le but est de comparer le tri par insertion (l'un des algorithmes \u00e9tudi\u00e9s en 1\u00e8re NSI pour trier un tableau) avec le tri fusion (un algorithme qui applique le principe de \u00ab diviser pour r\u00e9gner \u00bb). Partie A : Manipulation d\u2019une liste en Python \u2693\ufe0e Question A.1 Donner les affichages obtenus apr\u00e8s l\u2019ex\u00e9cution du code Python suivant. \ud83d\udc0d Script Python notes = [ 8 , 7 , 18 , 14 , 12 , 9 , 17 , 3 ] notes [ 3 ] = 16 print ( len ( notes )) print ( notes ) Question A.2 \u00c9crire un code Python permettant d'afficher les \u00e9l\u00e9ments d'indice 2 \u00e0 4 de la liste notes. Partie B : Tri par insertion \u2693\ufe0e Le tri par insertion est un algorithme efficace qui s'inspire de la fa\u00e7on dont on peut trier une poign\u00e9e de cartes. On commence avec une seule carte dans la main gauche (les autres cartes sont en tas sur la table) puis on pioche la carte suivante et on l'ins\u00e8re au bon endroit dans la main gauche. Question B.1 Voici une impl\u00e9mentation en Python de cet algorithme. Recopier et compl\u00e9ter les lignes 6 et 7 surlign\u00e9es (uniquement celles-ci). \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def tri_insertion ( liste ): \"\"\" trie par insertion la liste en param\u00e8tre \"\"\" for indice_courant in range ( 1 , len ( liste )): element_a_inserer = liste [ indice_courant ] i = indice_courant - 1 while i >= 0 and liste [ i ] > ................................ : liste [ ........... ] = liste [ ........... ] i = i - 1 liste [ i + 1 ] = element_a_inserer On a \u00e9crit dans la console les instructions suivantes : \ud83d\udc0d Script Python notes = [ 8 , 7 , 18 , 14 , 12 , 9 , 17 , 3 ] tri_insertion ( notes ) print ( notes ) On a obtenu l'affichage suivant : \ud83d\udc0d Script Python [ 3 , 7 , 8 , 9 , 12 , 14 , 17 , 18 ] On s'interroge sur ce qui s\u2019est pass\u00e9 lors de l\u2019ex\u00e9cution de tri_insertion(notes) . \u2693\ufe0e Question B.2 Donner le contenu de la liste notes apr\u00e8s le premier passage dans la boucle for. Question B.3 Donner le contenu de la liste notes apr\u00e8s le troisi\u00e8me passage dans la boucle for. Partie C : Tri fusion \u2693\ufe0e L'algorithme de tri fusion suit le principe de \u00ab diviser pour r\u00e9gner \u00bb. (1) Si le tableau \u00e0 trier n\u2019a qu\u2019un \u00e9l\u00e9ment, il est d\u00e9j\u00e0 tri\u00e9. (2) Sinon, s\u00e9parer le tableau en deux parties \u00e0 peu pr\u00e8s \u00e9gales. (3) Trier les deux parties avec l\u2019algorithme de tri fusion. (4) Fusionner les deux tableaux tri\u00e9s en un seul tableau. source : Wikipedia Question C.1 Cet algorithme est-il it\u00e9ratif ou r\u00e9cursif ? Justifier en une phrase. Question C.2 Expliquer en trois lignes comment faire pour rassembler dans une main deux tas d\u00e9j\u00e0 tri\u00e9s de cartes, la carte en haut d'un tas \u00e9tant la plus petite de ce m\u00eame tas ; la deuxi\u00e8me carte d'un tas n'\u00e9tant visible qu'apr\u00e8s avoir retir\u00e9 la premi\u00e8re carte de ce tas. \u00c0 la fin du proc\u00e9d\u00e9, les cartes en main doivent \u00eatre tri\u00e9es par ordre croissant. Une fonction fusionner a \u00e9t\u00e9 impl\u00e9ment\u00e9e en Python en s'inspirant du proc\u00e9d\u00e9 de la question pr\u00e9c\u00e9dente. Elle prend quatre arguments : la liste qui est en train d'\u00eatre tri\u00e9e, l'indice o\u00f9 commence la sous-liste de gauche \u00e0 fusionner, l'indice o\u00f9 termine cette sousliste, et l'indice o\u00f9 se termine la sous-liste de droite. Question C.3 Voici une impl\u00e9mentation de l\u2019algorithme de tri fusion. Recopier et compl\u00e9ter les lignes 8, 9 et 10 surlign\u00e9es (uniquement celles-ci). \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 from math import floor def tri_fusion ( liste , i_debut , i_fin ): \"\"\" trie par fusion la liste en param\u00e8tre depuis i_debut jusqu\u2019\u00e0 i_fin \"\"\" if i_debut < i_fin : i_partage = floor (( i_debut + i_fin ) / 2 ) tri_fusion ( liste , i_debut , .............................. ) tri_fusion ( liste , ................................... , i_fin ) fusionner ( liste , ......................... , ......................... , ...................... ) Remarque : la fonction floor renvoie la partie enti\u00e8re du nombre pass\u00e9 en param\u00e8tre. Question C.4 Expliquer le r\u00f4le de la premi\u00e8re ligne du code de la question 3. Partie D : Comparaison du tri par insertion et du tri fusion \u2693\ufe0e Voici une illustration des \u00e9tapes d\u2019un tri effectu\u00e9 sur la liste [3, 41, 52, 26, 38, 57, 9, 49] . Question D.1 Quel algorithme a \u00e9t\u00e9 utilis\u00e9 : le tri par insertion ou le tri fusion ? Justifier. Question D.2 Identifier le tri qui a une complexit\u00e9, dans le pire des cas, en \\(O(n^2)\\) et identifier le tri qui a une complexit\u00e9, dans le pire des cas, en \\(O(n log2 n)\\) . Remarque : \\(n\\) repr\u00e9sente la longueur de la liste \u00e0 trier. Question D.3 Justifier bri\u00e8vement ces deux complexit\u00e9s. Sujet n\u00b03 : FRANCE CANDIDAT LIBRE SUJET 1 \u2693\ufe0e Cet exercice traite de manipulation de tableaux, de r\u00e9cursivit\u00e9 et du paradigme \u00ab diviser pour r\u00e9gner \u00bb. Dans un tableau Python d'entiers tab, on dit que le couple d\u2019indices (\u0745,\u0746) forme une inversion lorsque \u0745 < \u0746 et tab[i] > tab[j] . On donne ci-dessous quelques exemples. Dans le tableau [1, 5, 3, 7], le couple d\u2019indices (1,2) forme une inversion car 5> 3. Par contre, le couple (1,3) ne forme pas d'inversion car 5<7. Il n\u2019y a qu\u2019une inversion dans ce tableau. Il y a trois inversions dans le tableau [1, 6, 2, 7, 3], \u00e0 savoir les couples d'indices (1, 2), (1, 4) et (3, 4). On peut compter six inversions dans le tableau [7, 6, 5, 3] : les couples d'indices (0, 1), (0, 2), (0, 3), (1, 2), (1, 3) et (2, 3). On se propose dans cet exercice de d\u00e9terminer le nombre d\u2019inversions dans un tableau quelconque. Questions pr\u00e9liminaires Question 1 Expliquer pourquoi le couple (1, 3) est une inversion dans le tableau [4, 8, 3, 7]. Question 2 Justifier que le couple (2, 3) n\u2019en est pas une. Partie A : M\u00e9thode it\u00e9rative \u2693\ufe0e Le but de cette partie est d\u2019\u00e9crire une fonction it\u00e9rative nombre_inversion qui renvoie le nombre d\u2019inversions dans un tableau. Pour cela, on commence par \u00e9crire une fonction fonction1 qui sera ensuite utilis\u00e9e pour \u00e9crire la fonction nombre_inversion . Question A.1 On donne la fonction suivante. \ud83d\udc0d Script Python def fonction1 ( tab , i ): nb_elem = len ( tab ) cpt = 0 for j in range ( i + 1 , nb_elem ): if tab [ j ] < tab [ i ]: cpt += 1 return cpt a. Indiquer ce que renvoie la fonction1(tab, i) dans les cas suivants. Cas n\u00b01 : tab = [1, 5, 3, 7] et i = 0. Cas n\u00b02 : tab = [1, 5, 3, 7] et i = 1. Cas n\u00b03 : tab = [1, 5, 2, 6, 4] et i = 1. b. Expliquer ce que permet de d\u00e9terminer cette fonction. Question A.2 En utilisant la fonction pr\u00e9c\u00e9dente, \u00e9crire une fonction nombre_inversion(tab) qui prend en argument un tableau et renvoie le nombre d\u2019inversions dans ce tableau. On donne ci-dessous les r\u00e9sultats attendus pour certains appels. \ud83d\udc0d Script Python >>> nombre_inversions ([ 1 , 5 , 7 ]) 0 >>> nombre_inversions ([ 1 , 6 , 2 , 7 , 3 ]) 3 >>> nombre_inversions ([ 7 , 6 , 5 , 3 ]) 6 Question A.3 Quelle est l\u2019ordre de grandeur de la complexit\u00e9 en temps de l'algorithme obtenu ? Aucune justification n'est attendue. Partie B : M\u00e9thode r\u00e9cursive \u2693\ufe0e Le but de cette partie est de concevoir une version r\u00e9cursive de la fonction nombre_inversion . On d\u00e9finit pour cela des fonctions auxiliaires. Question B.1 Donner le nom d\u2019un algorithme de tri ayant une complexit\u00e9 meilleure que quadratique. Dans la suite de cet exercice, on suppose qu\u2019on dispose d'une fonction tri(tab) qui prend en argument un tableau et renvoie un tableau contenant les m\u00eames \u00e9l\u00e9ments rang\u00e9s dans l'ordre croissant. Question B.2 \u00c9crire une fonction moitie_gauche(tab) qui prend en argument un tableau tab et renvoie un nouveau tableau contenant la moiti\u00e9 gauche de tab. Si le nombre d'\u00e9l\u00e9ments de tab est impair, l'\u00e9l\u00e9ment du centre se trouve dans cette partie gauche. On donne ci-dessous les r\u00e9sultats attendus pour certains appels. \ud83d\udc0d Script Python >>> moitie_gauche ([]) [] >>> moitie_gauche ([ 4 , 8 , 3 ]) [ 4 , 8 ] >>> moitie_gauche ([ 4 , 8 , 3 , 7 ]) [ 4 , 8 ] Dans la suite, on suppose qu\u2019on dispose de la fonction moitie_droite(tab) qui renvoie la moiti\u00e9 droite sans l\u2019\u00e9l\u00e9ment du milieu. Question B.3 On suppose qu\u2019une fonction nb_inv_tab(tab1, tab2) a \u00e9t\u00e9 \u00e9crite. Cette fonction renvoie le nombre d\u2019inversions du tableau obtenu en mettant bout \u00e0 bout les tableaux tab1 et tab2 , \u00e0 condition que tab1 et tab2 soient tri\u00e9s dans l\u2019ordre croissant. On donne ci-dessous deux exemples d\u2019appel de cette fonction : \ud83d\udc0d Script Python >>> nb_inv_tab ([ 3 , 7 , 9 ], [ 2 , 10 ]) 3 >>> nb_inv_tab ([ 7 , 9 , 13 ], [ 7 , 10 , 14 ]) 3 /media/michael/TRAVAIL/2.NSI/siteGithub/TermNSI/docs/diviserregner/TD20_Diviser_pour_Regner_Diapo.pdf En utilisant la fonction nb_inv_tab et les questions pr\u00e9c\u00e9dentes, \u00e9crire une fonction r\u00e9cursive nb_inversions_rec(tab) qui permet de calculer le nombre d'inversions dans un tableau. Cette fonction renverra le m\u00eame nombre que nombre_inversions(tab) de la partie A. On proc\u00e9dera de la fa\u00e7on suivante : S\u00e9parer le tableau en deux tableaux de tailles \u00e9gales (\u00e0 une unit\u00e9 pr\u00e8s). Appeler r\u00e9cursivement la fonction nb_inversions_rec pour compter le nombre d\u2019inversions dans chacun des deux tableaux. Trier les deux tableaux (on rappelle qu'une fonction de tri est d\u00e9j\u00e0 d\u00e9finie). Ajouter au nombre d'inversions pr\u00e9c\u00e9demment compt\u00e9es le nombre renvoy\u00e9 par la fonction nb_inv_tab avec pour arguments les deux tableaux tri\u00e9s.","title":"TD20 Diviser pour Regner Diapo"},{"location":"diviserregner/TD20_Diviser_pour_Regner_Diapo/#i-le-principe","text":"Diviser pour r\u00e9gner La strat\u00e9gie \u00ab diviser pour r\u00e9gner \u00bb consiste \u00e0 1. Diviser : D\u00e9composer un probl\u00e8me en un ou plusieurs sous-probl\u00e8mes de m\u00eame nature mais plus petits. 2. R\u00e9gner : R\u00e9soudre les sous-probl\u00e8mes, g\u00e9n\u00e9ralement de mani\u00e8re r\u00e9cursive, jusqu'\u00e0 ce qu'on arrive aux cas d'arr\u00eat : des sous-probl\u00e8mes que l'on sait r\u00e9soudre imm\u00e9diatement. 3. Combiner : Construire la solution au probl\u00e8me initial \u00e0 partir des solutions des sous-probl\u00e8mes.","title":"I. Le principe"},{"location":"diviserregner/TD20_Diviser_pour_Regner_Diapo/#ii-diviser-pour-regner-palindromes","text":"Palindromes Une cha\u00eene est un palindrome si elle peut se lire de la m\u00eame mani\u00e8re dans les deux sens, de gauche \u00e0 droite et de droite \u00e0 gauche. Par exemple : - \"ressasser, \"radar\", \"12321\" sont des palindromes ; - \"nsi\", \"toto\" n\u2019en sont pas. On se propose d\u2019\u00e9crire une fonction r\u00e9cursive est_palindrome(ch) qui renvoie Vrai si la chaine ch pass\u00e9e en argument est un palindrome et Faux sinon.","title":"II. Diviser pour r\u00e9gner : Palindromes"},{"location":"diviserregner/TD20_Diviser_pour_Regner_Diapo/#iii-les-tris-tri-par-selection-et-tri-par-insertion-tri-fusion","text":"","title":"III. Les tris : tri par s\u00e9lection et tri par insertion - Tri fusion"},{"location":"diviserregner/TD20_Diviser_pour_Regner_Diapo/#partie-a-methode-iterative","text":"Le but de cette partie est d\u2019\u00e9crire une fonction it\u00e9rative nombre_inversion qui renvoie le nombre d\u2019inversions dans un tableau. Pour cela, on commence par \u00e9crire une fonction fonction1 qui sera ensuite utilis\u00e9e pour \u00e9crire la fonction nombre_inversion . Question A.1 On donne la fonction suivante. \ud83d\udc0d Script Python def fonction1 ( tab , i ): nb_elem = len ( tab ) cpt = 0 for j in range ( i + 1 , nb_elem ): if tab [ j ] < tab [ i ]: cpt += 1 return cpt a. Indiquer ce que renvoie la fonction1(tab, i) dans les cas suivants. Cas n\u00b01 : tab = [1, 5, 3, 7] et i = 0. Cas n\u00b02 : tab = [1, 5, 3, 7] et i = 1. Cas n\u00b03 : tab = [1, 5, 2, 6, 4] et i = 1. b. Expliquer ce que permet de d\u00e9terminer cette fonction. Question A.2 En utilisant la fonction pr\u00e9c\u00e9dente, \u00e9crire une fonction nombre_inversion(tab) qui prend en argument un tableau et renvoie le nombre d\u2019inversions dans ce tableau. On donne ci-dessous les r\u00e9sultats attendus pour certains appels. \ud83d\udc0d Script Python >>> nombre_inversions ([ 1 , 5 , 7 ]) 0 >>> nombre_inversions ([ 1 , 6 , 2 , 7 , 3 ]) 3 >>> nombre_inversions ([ 7 , 6 , 5 , 3 ]) 6 Question A.3 Quelle est l\u2019ordre de grandeur de la complexit\u00e9 en temps de l'algorithme obtenu ? Aucune justification n'est attendue.","title":"Partie A : M\u00e9thode it\u00e9rative"},{"location":"diviserregner/TD20_Diviser_pour_Regner_Diapo/#partie-b-methode-recursive","text":"Le but de cette partie est de concevoir une version r\u00e9cursive de la fonction nombre_inversion . On d\u00e9finit pour cela des fonctions auxiliaires. Question B.1 Donner le nom d\u2019un algorithme de tri ayant une complexit\u00e9 meilleure que quadratique. Dans la suite de cet exercice, on suppose qu\u2019on dispose d'une fonction tri(tab) qui prend en argument un tableau et renvoie un tableau contenant les m\u00eames \u00e9l\u00e9ments rang\u00e9s dans l'ordre croissant. Question B.2 \u00c9crire une fonction moitie_gauche(tab) qui prend en argument un tableau tab et renvoie un nouveau tableau contenant la moiti\u00e9 gauche de tab. Si le nombre d'\u00e9l\u00e9ments de tab est impair, l'\u00e9l\u00e9ment du centre se trouve dans cette partie gauche. On donne ci-dessous les r\u00e9sultats attendus pour certains appels. \ud83d\udc0d Script Python >>> moitie_gauche ([]) [] >>> moitie_gauche ([ 4 , 8 , 3 ]) [ 4 , 8 ] >>> moitie_gauche ([ 4 , 8 , 3 , 7 ]) [ 4 , 8 ] Dans la suite, on suppose qu\u2019on dispose de la fonction moitie_droite(tab) qui renvoie la moiti\u00e9 droite sans l\u2019\u00e9l\u00e9ment du milieu. Question B.3 On suppose qu\u2019une fonction nb_inv_tab(tab1, tab2) a \u00e9t\u00e9 \u00e9crite. Cette fonction renvoie le nombre d\u2019inversions du tableau obtenu en mettant bout \u00e0 bout les tableaux tab1 et tab2 , \u00e0 condition que tab1 et tab2 soient tri\u00e9s dans l\u2019ordre croissant. On donne ci-dessous deux exemples d\u2019appel de cette fonction : \ud83d\udc0d Script Python >>> nb_inv_tab ([ 3 , 7 , 9 ], [ 2 , 10 ]) 3 >>> nb_inv_tab ([ 7 , 9 , 13 ], [ 7 , 10 , 14 ]) 3 En utilisant la fonction nb_inv_tab et les questions pr\u00e9c\u00e9dentes, \u00e9crire une fonction r\u00e9cursive nb_inversions_rec(tab) qui permet de calculer le nombre d'inversions dans un tableau. Cette fonction renverra le m\u00eame nombre que nombre_inversions(tab) de la partie A. On proc\u00e9dera de la fa\u00e7on suivante : S\u00e9parer le tableau en deux tableaux de tailles \u00e9gales (\u00e0 une unit\u00e9 pr\u00e8s). Appeler r\u00e9cursivement la fonction nb_inversions_rec pour compter le nombre d\u2019inversions dans chacun des deux tableaux. Trier les deux tableaux (on rappelle qu'une fonction de tri est d\u00e9j\u00e0 d\u00e9finie). Ajouter au nombre d'inversions pr\u00e9c\u00e9demment compt\u00e9es le nombre renvoy\u00e9 par la fonction nb_inv_tab avec pour arguments les deux tableaux tri\u00e9s. Question 2. En utilisant les slices, compl\u00e9tez la fonction suivante. \ud83d\udc0d Script Python def est_palindrome ( ch ): if len ( ch ) <= 1 : return ... else : return ... Question 3. Au moyen du mot cl\u00e9 assert, \u00e9crivez un bon jeu de tests pour cette fonction. V\u00e9rifiez que les tests passent avec succ\u00e8s. Question 4. Expliquez pourquoi cet algorithme est un exemple de la m\u00e9thode diviser pour r\u00e9gner. Question 5. Utiliser Python tutor, ex\u00e9cutez en mode pas \u00e0 pas le d\u00e9roulement des appels r\u00e9cursifs de cette fonction pour la cha\u00eene \"ressasser\". Si la cha\u00eene de d\u00e9part est un palindrome de longueur n, combien de comparaisons sont effectu\u00e9es ? En d\u00e9duite le co\u00fbt en temps de cet algorithme (sa complexit\u00e9) dans le pire des cas. Question 6. Le slicing a un co\u00fbt en m\u00e9moire cach\u00e9. En effet, chaque appel ch[1:-1] induit la cr\u00e9ation d\u2019une nouvelle cha\u00eene qu\u2019il faut stocker en m\u00e9moire. On peut le voir facilement avec Python tutor. Dans le pire cas, pour une cha\u00eene de longueur n au d\u00e9part, combien de cha\u00eenes doivent \u00eatre cr\u00e9\u00e9es pour r\u00e9pondre au probl\u00e8me ?","title":"Partie B : M\u00e9thode r\u00e9cursive"},{"location":"diviserregner/TD20_Diviser_pour_Regner_Diapo/#iii-les-tris-tri-par-selection-et-tri-par-insertion-tri-fusion_1","text":"","title":"III. Les tris : tri par s\u00e9lection et tri par insertion - Tri fusion"},{"location":"diviserregner/TD20_Diviser_pour_Regner_Diapo/#partie-a-methode-iterative_1","text":"Le but de cette partie est d\u2019\u00e9crire une fonction it\u00e9rative nombre_inversion qui renvoie le nombre d\u2019inversions dans un tableau. Pour cela, on commence par \u00e9crire une fonction fonction1 qui sera ensuite utilis\u00e9e pour \u00e9crire la fonction nombre_inversion . Question A.1 On donne la fonction suivante. \ud83d\udc0d Script Python def fonction1 ( tab , i ): nb_elem = len ( tab ) cpt = 0 for j in range ( i + 1 , nb_elem ): if tab [ j ] < tab [ i ]: cpt += 1 return cpt a. Indiquer ce que renvoie la fonction1(tab, i) dans les cas suivants. Cas n\u00b01 : tab = [1, 5, 3, 7] et i = 0. Cas n\u00b02 : tab = [1, 5, 3, 7] et i = 1. Cas n\u00b03 : tab = [1, 5, 2, 6, 4] et i = 1. b. Expliquer ce que permet de d\u00e9terminer cette fonction. Question A.2 En utilisant la fonction pr\u00e9c\u00e9dente, \u00e9crire une fonction nombre_inversion(tab) qui prend en argument un tableau et renvoie le nombre d\u2019inversions dans ce tableau. On donne ci-dessous les r\u00e9sultats attendus pour certains appels. \ud83d\udc0d Script Python >>> nombre_inversions ([ 1 , 5 , 7 ]) 0 >>> nombre_inversions ([ 1 , 6 , 2 , 7 , 3 ]) 3 >>> nombre_inversions ([ 7 , 6 , 5 , 3 ]) 6 Question A.3 Quelle est l\u2019ordre de grandeur de la complexit\u00e9 en temps de l'algorithme obtenu ? Aucune justification n'est attendue.","title":"Partie A : M\u00e9thode it\u00e9rative"},{"location":"diviserregner/TD20_Diviser_pour_Regner_Diapo/#partie-b-methode-recursive_1","text":"Le but de cette partie est de concevoir une version r\u00e9cursive de la fonction nombre_inversion . On d\u00e9finit pour cela des fonctions auxiliaires. Question B.1 Donner le nom d\u2019un algorithme de tri ayant une complexit\u00e9 meilleure que quadratique. Dans la suite de cet exercice, on suppose qu\u2019on dispose d'une fonction tri(tab) qui prend en argument un tableau et renvoie un tableau contenant les m\u00eames \u00e9l\u00e9ments rang\u00e9s dans l'ordre croissant. Question B.2 \u00c9crire une fonction moitie_gauche(tab) qui prend en argument un tableau tab et renvoie un nouveau tableau contenant la moiti\u00e9 gauche de tab. Si le nombre d'\u00e9l\u00e9ments de tab est impair, l'\u00e9l\u00e9ment du centre se trouve dans cette partie gauche. On donne ci-dessous les r\u00e9sultats attendus pour certains appels. \ud83d\udc0d Script Python >>> moitie_gauche ([]) [] >>> moitie_gauche ([ 4 , 8 , 3 ]) [ 4 , 8 ] >>> moitie_gauche ([ 4 , 8 , 3 , 7 ]) [ 4 , 8 ] Dans la suite, on suppose qu\u2019on dispose de la fonction moitie_droite(tab) qui renvoie la moiti\u00e9 droite sans l\u2019\u00e9l\u00e9ment du milieu. Question B.3 On suppose qu\u2019une fonction nb_inv_tab(tab1, tab2) a \u00e9t\u00e9 \u00e9crite. Cette fonction renvoie le nombre d\u2019inversions du tableau obtenu en mettant bout \u00e0 bout les tableaux tab1 et tab2 , \u00e0 condition que tab1 et tab2 soient tri\u00e9s dans l\u2019ordre croissant. On donne ci-dessous deux exemples d\u2019appel de cette fonction : \ud83d\udc0d Script Python >>> nb_inv_tab ([ 3 , 7 , 9 ], [ 2 , 10 ]) 3 >>> nb_inv_tab ([ 7 , 9 , 13 ], [ 7 , 10 , 14 ]) 3 /media/michael/TRAVAIL/2.NSI/siteGithub/TermNSI/docs/diviserregner/TD20_Diviser_pour_Regner_Diapo.pdf En utilisant la fonction nb_inv_tab et les questions pr\u00e9c\u00e9dentes, \u00e9crire une fonction r\u00e9cursive nb_inversions_rec(tab) qui permet de calculer le nombre d'inversions dans un tableau. Cette fonction renverra le m\u00eame nombre que nombre_inversions(tab) de la partie A. On proc\u00e9dera de la fa\u00e7on suivante : S\u00e9parer le tableau en deux tableaux de tailles \u00e9gales (\u00e0 une unit\u00e9 pr\u00e8s). Appeler r\u00e9cursivement la fonction nb_inversions_rec pour compter le nombre d\u2019inversions dans chacun des deux tableaux. Trier les deux tableaux (on rappelle qu'une fonction de tri est d\u00e9j\u00e0 d\u00e9finie). Ajouter au nombre d'inversions pr\u00e9c\u00e9demment compt\u00e9es le nombre renvoy\u00e9 par la fonction nb_inv_tab avec pour arguments les deux tableaux tri\u00e9s.","title":"Partie B : M\u00e9thode r\u00e9cursive"}]}